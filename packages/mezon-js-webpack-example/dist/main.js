/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js":
/*!**********************************************************!*\
  !*** ../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// ../../node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"../../node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"../../node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"../../node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"../../node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\")\n        (function() {\n          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n          function writeFloat_f32_cpy(val, buf, pos) {\n            f32[0] = val;\n            buf[pos] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n          }\n          function writeFloat_f32_rev(val, buf, pos) {\n            f32[0] = val;\n            buf[pos] = f8b[3];\n            buf[pos + 1] = f8b[2];\n            buf[pos + 2] = f8b[1];\n            buf[pos + 3] = f8b[0];\n          }\n          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n          function readFloat_f32_cpy(buf, pos) {\n            f8b[0] = buf[pos];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            return f32[0];\n          }\n          function readFloat_f32_rev(buf, pos) {\n            f8b[3] = buf[pos];\n            f8b[2] = buf[pos + 1];\n            f8b[1] = buf[pos + 2];\n            f8b[0] = buf[pos + 3];\n            return f32[0];\n          }\n          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n        })();\n      else\n        (function() {\n          function writeFloat_ieee754(writeUint, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n              val = -val;\n            if (val === 0)\n              writeUint(1 / val > 0 ? (\n                /* positive */\n                0\n              ) : (\n                /* negative 0 */\n                2147483648\n              ), buf, pos);\n            else if (isNaN(val))\n              writeUint(2143289344, buf, pos);\n            else if (val > 34028234663852886e22)\n              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n            else if (val < 11754943508222875e-54)\n              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n            else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n            }\n          }\n          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n          function readFloat_ieee754(readUint, buf, pos) {\n            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n          }\n          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n        })();\n      if (typeof Float64Array !== \"undefined\")\n        (function() {\n          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n          function writeDouble_f64_cpy(val, buf, pos) {\n            f64[0] = val;\n            buf[pos] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n            buf[pos + 4] = f8b[4];\n            buf[pos + 5] = f8b[5];\n            buf[pos + 6] = f8b[6];\n            buf[pos + 7] = f8b[7];\n          }\n          function writeDouble_f64_rev(val, buf, pos) {\n            f64[0] = val;\n            buf[pos] = f8b[7];\n            buf[pos + 1] = f8b[6];\n            buf[pos + 2] = f8b[5];\n            buf[pos + 3] = f8b[4];\n            buf[pos + 4] = f8b[3];\n            buf[pos + 5] = f8b[2];\n            buf[pos + 6] = f8b[1];\n            buf[pos + 7] = f8b[0];\n          }\n          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n          function readDouble_f64_cpy(buf, pos) {\n            f8b[0] = buf[pos];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            f8b[4] = buf[pos + 4];\n            f8b[5] = buf[pos + 5];\n            f8b[6] = buf[pos + 6];\n            f8b[7] = buf[pos + 7];\n            return f64[0];\n          }\n          function readDouble_f64_rev(buf, pos) {\n            f8b[7] = buf[pos];\n            f8b[6] = buf[pos + 1];\n            f8b[5] = buf[pos + 2];\n            f8b[4] = buf[pos + 3];\n            f8b[3] = buf[pos + 4];\n            f8b[2] = buf[pos + 5];\n            f8b[1] = buf[pos + 6];\n            f8b[0] = buf[pos + 7];\n            return f64[0];\n          }\n          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n        })();\n      else\n        (function() {\n          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n              val = -val;\n            if (val === 0) {\n              writeUint(0, buf, pos + off0);\n              writeUint(1 / val > 0 ? (\n                /* positive */\n                0\n              ) : (\n                /* negative 0 */\n                2147483648\n              ), buf, pos + off1);\n            } else if (isNaN(val)) {\n              writeUint(0, buf, pos + off0);\n              writeUint(2146959360, buf, pos + off1);\n            } else if (val > 17976931348623157e292) {\n              writeUint(0, buf, pos + off0);\n              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n            } else {\n              var mantissa;\n              if (val < 22250738585072014e-324) {\n                mantissa = val / 5e-324;\n                writeUint(mantissa >>> 0, buf, pos + off0);\n                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n              } else {\n                var exponent = Math.floor(Math.log(val) / Math.LN2);\n                if (exponent === 1024)\n                  exponent = 1023;\n                mantissa = val * Math.pow(2, -exponent);\n                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n              }\n            }\n          }\n          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n          function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n          }\n          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n        })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"../../node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"../../node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"../../node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// ../../node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"../../node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"../../node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject2(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet5(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n      Object.defineProperty(CustomError.prototype, \"name\", { get: function() {\n        return name;\n      } });\n      CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n      };\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"../../node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"../../node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else\n          for (var i = 0; i < val.length; )\n            buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// ../../node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"../../node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"../../node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// ../../node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"../../node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"../../node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// ../../node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"../../node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// ../../node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"../../node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// ../../node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"../../node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// ../../node_modules/long/src/long.js\nvar require_long = __commonJS({\n  \"../../node_modules/long/src/long.js\"(exports2, module2) {\n    module2.exports = Long4;\n    var wasm = null;\n    try {\n      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n      ])), {}).exports;\n    } catch (e) {\n    }\n    function Long4(low, high, unsigned) {\n      this.low = low | 0;\n      this.high = high | 0;\n      this.unsigned = !!unsigned;\n    }\n    Long4.prototype.__isLong__;\n    Object.defineProperty(Long4.prototype, \"__isLong__\", { value: true });\n    function isLong(obj) {\n      return (obj && obj[\"__isLong__\"]) === true;\n    }\n    Long4.isLong = isLong;\n    var INT_CACHE = {};\n    var UINT_CACHE = {};\n    function fromInt(value, unsigned) {\n      var obj, cachedObj, cache;\n      if (unsigned) {\n        value >>>= 0;\n        if (cache = 0 <= value && value < 256) {\n          cachedObj = UINT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n          UINT_CACHE[value] = obj;\n        return obj;\n      } else {\n        value |= 0;\n        if (cache = -128 <= value && value < 128) {\n          cachedObj = INT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n          INT_CACHE[value] = obj;\n        return obj;\n      }\n    }\n    Long4.fromInt = fromInt;\n    function fromNumber(value, unsigned) {\n      if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n      if (unsigned) {\n        if (value < 0)\n          return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n          return MAX_UNSIGNED_VALUE;\n      } else {\n        if (value <= -TWO_PWR_63_DBL)\n          return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n          return MAX_VALUE;\n      }\n      if (value < 0)\n        return fromNumber(-value, unsigned).neg();\n      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    Long4.fromNumber = fromNumber;\n    function fromBits(lowBits, highBits, unsigned) {\n      return new Long4(lowBits, highBits, unsigned);\n    }\n    Long4.fromBits = fromBits;\n    var pow_dbl = Math.pow;\n    function fromString(str, unsigned, radix) {\n      if (str.length === 0)\n        throw Error(\"empty string\");\n      if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n      if (typeof unsigned === \"number\") {\n        radix = unsigned, unsigned = false;\n      } else {\n        unsigned = !!unsigned;\n      }\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      var p;\n      if ((p = str.indexOf(\"-\")) > 0)\n        throw Error(\"interior hyphen\");\n      else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 8));\n      var result = ZERO;\n      for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n          var power = fromNumber(pow_dbl(radix, size));\n          result = result.mul(power).add(fromNumber(value));\n        } else {\n          result = result.mul(radixToPower);\n          result = result.add(fromNumber(value));\n        }\n      }\n      result.unsigned = unsigned;\n      return result;\n    }\n    Long4.fromString = fromString;\n    function fromValue(val, unsigned) {\n      if (typeof val === \"number\")\n        return fromNumber(val, unsigned);\n      if (typeof val === \"string\")\n        return fromString(val, unsigned);\n      return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    Long4.fromValue = fromValue;\n    var TWO_PWR_16_DBL = 1 << 16;\n    var TWO_PWR_24_DBL = 1 << 24;\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    var ZERO = fromInt(0);\n    Long4.ZERO = ZERO;\n    var UZERO = fromInt(0, true);\n    Long4.UZERO = UZERO;\n    var ONE = fromInt(1);\n    Long4.ONE = ONE;\n    var UONE = fromInt(1, true);\n    Long4.UONE = UONE;\n    var NEG_ONE = fromInt(-1);\n    Long4.NEG_ONE = NEG_ONE;\n    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);\n    Long4.MAX_VALUE = MAX_VALUE;\n    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);\n    Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);\n    Long4.MIN_VALUE = MIN_VALUE;\n    var LongPrototype = Long4.prototype;\n    LongPrototype.toInt = function toInt() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    LongPrototype.toNumber = function toNumber() {\n      if (this.unsigned)\n        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    LongPrototype.toString = function toString(radix) {\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      if (this.isZero())\n        return \"0\";\n      if (this.isNegative()) {\n        if (this.eq(MIN_VALUE)) {\n          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n          return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n          return \"-\" + this.neg().toString(radix);\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n      var result = \"\";\n      while (true) {\n        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero())\n          return digits + result;\n        else {\n          while (digits.length < 6)\n            digits = \"0\" + digits;\n          result = \"\" + digits + result;\n        }\n      }\n    };\n    LongPrototype.getHighBits = function getHighBits() {\n      return this.high;\n    };\n    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n      return this.high >>> 0;\n    };\n    LongPrototype.getLowBits = function getLowBits() {\n      return this.low;\n    };\n    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n      return this.low >>> 0;\n    };\n    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n      if (this.isNegative())\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n      var val = this.high != 0 ? this.high : this.low;\n      for (var bit = 31; bit > 0; bit--)\n        if ((val & 1 << bit) != 0)\n          break;\n      return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    LongPrototype.isZero = function isZero() {\n      return this.high === 0 && this.low === 0;\n    };\n    LongPrototype.eqz = LongPrototype.isZero;\n    LongPrototype.isNegative = function isNegative() {\n      return !this.unsigned && this.high < 0;\n    };\n    LongPrototype.isPositive = function isPositive() {\n      return this.unsigned || this.high >= 0;\n    };\n    LongPrototype.isOdd = function isOdd() {\n      return (this.low & 1) === 1;\n    };\n    LongPrototype.isEven = function isEven() {\n      return (this.low & 1) === 0;\n    };\n    LongPrototype.equals = function equals(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n        return false;\n      return this.high === other.high && this.low === other.low;\n    };\n    LongPrototype.eq = LongPrototype.equals;\n    LongPrototype.notEquals = function notEquals(other) {\n      return !this.eq(\n        /* validates */\n        other\n      );\n    };\n    LongPrototype.neq = LongPrototype.notEquals;\n    LongPrototype.ne = LongPrototype.notEquals;\n    LongPrototype.lessThan = function lessThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) < 0;\n    };\n    LongPrototype.lt = LongPrototype.lessThan;\n    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) <= 0;\n    };\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    LongPrototype.le = LongPrototype.lessThanOrEqual;\n    LongPrototype.greaterThan = function greaterThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) > 0;\n    };\n    LongPrototype.gt = LongPrototype.greaterThan;\n    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) >= 0;\n    };\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    LongPrototype.compare = function compare(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      if (this.eq(other))\n        return 0;\n      var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n      if (thisNeg && !otherNeg)\n        return -1;\n      if (!thisNeg && otherNeg)\n        return 1;\n      if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    LongPrototype.comp = LongPrototype.compare;\n    LongPrototype.negate = function negate() {\n      if (!this.unsigned && this.eq(MIN_VALUE))\n        return MIN_VALUE;\n      return this.not().add(ONE);\n    };\n    LongPrototype.neg = LongPrototype.negate;\n    LongPrototype.add = function add(addend) {\n      if (!isLong(addend))\n        addend = fromValue(addend);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 65535;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    LongPrototype.subtract = function subtract(subtrahend) {\n      if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n      return this.add(subtrahend.neg());\n    };\n    LongPrototype.sub = LongPrototype.subtract;\n    LongPrototype.multiply = function multiply(multiplier) {\n      if (this.isZero())\n        return ZERO;\n      if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n      if (wasm) {\n        var low = wasm.mul(\n          this.low,\n          this.high,\n          multiplier.low,\n          multiplier.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (multiplier.isZero())\n        return ZERO;\n      if (this.eq(MIN_VALUE))\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\n      if (multiplier.eq(MIN_VALUE))\n        return this.isOdd() ? MIN_VALUE : ZERO;\n      if (this.isNegative()) {\n        if (multiplier.isNegative())\n          return this.neg().mul(multiplier.neg());\n        else\n          return this.neg().mul(multiplier).neg();\n      } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 65535;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    LongPrototype.mul = LongPrototype.multiply;\n    LongPrototype.divide = function divide(divisor) {\n      if (!isLong(divisor))\n        divisor = fromValue(divisor);\n      if (divisor.isZero())\n        throw Error(\"division by zero\");\n      if (wasm) {\n        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n          return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (this.isZero())\n        return this.unsigned ? UZERO : ZERO;\n      var approx, rem, res;\n      if (!this.unsigned) {\n        if (this.eq(MIN_VALUE)) {\n          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n            return MIN_VALUE;\n          else if (divisor.eq(MIN_VALUE))\n            return ONE;\n          else {\n            var halfThis = this.shr(1);\n            approx = halfThis.div(divisor).shl(1);\n            if (approx.eq(ZERO)) {\n              return divisor.isNegative() ? ONE : NEG_ONE;\n            } else {\n              rem = this.sub(divisor.mul(approx));\n              res = approx.add(rem.div(divisor));\n              return res;\n            }\n          }\n        } else if (divisor.eq(MIN_VALUE))\n          return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n          if (divisor.isNegative())\n            return this.neg().div(divisor.neg());\n          return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n          return this.div(divisor.neg()).neg();\n        res = ZERO;\n      } else {\n        if (!divisor.unsigned)\n          divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n          return UZERO;\n        if (divisor.gt(this.shru(1)))\n          return UONE;\n        res = UZERO;\n      }\n      rem = this;\n      while (rem.gte(divisor)) {\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n          approx -= delta;\n          approxRes = fromNumber(approx, this.unsigned);\n          approxRem = approxRes.mul(divisor);\n        }\n        if (approxRes.isZero())\n          approxRes = ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n      }\n      return res;\n    };\n    LongPrototype.div = LongPrototype.divide;\n    LongPrototype.modulo = function modulo(divisor) {\n      if (!isLong(divisor))\n        divisor = fromValue(divisor);\n      if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(divisor).mul(divisor));\n    };\n    LongPrototype.mod = LongPrototype.modulo;\n    LongPrototype.rem = LongPrototype.modulo;\n    LongPrototype.not = function not() {\n      return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    LongPrototype.and = function and(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    LongPrototype.or = function or(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    LongPrototype.xor = function xor(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    LongPrototype.shiftLeft = function shiftLeft(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n      else\n        return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    LongPrototype.shl = LongPrototype.shiftLeft;\n    LongPrototype.shiftRight = function shiftRight(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n      else\n        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    LongPrototype.shr = LongPrototype.shiftRight;\n    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      numBits &= 63;\n      if (numBits === 0)\n        return this;\n      else {\n        var high = this.high;\n        if (numBits < 32) {\n          var low = this.low;\n          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n        } else if (numBits === 32)\n          return fromBits(high, 0, this.unsigned);\n        else\n          return fromBits(high >>> numBits - 32, 0, this.unsigned);\n      }\n    };\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    LongPrototype.toSigned = function toSigned() {\n      if (!this.unsigned)\n        return this;\n      return fromBits(this.low, this.high, false);\n    };\n    LongPrototype.toUnsigned = function toUnsigned() {\n      if (this.unsigned)\n        return this;\n      return fromBits(this.low, this.high, true);\n    };\n    LongPrototype.toBytes = function toBytes(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    LongPrototype.toBytesLE = function toBytesLE() {\n      var hi = this.high, lo = this.low;\n      return [\n        lo & 255,\n        lo >>> 8 & 255,\n        lo >>> 16 & 255,\n        lo >>> 24,\n        hi & 255,\n        hi >>> 8 & 255,\n        hi >>> 16 & 255,\n        hi >>> 24\n      ];\n    };\n    LongPrototype.toBytesBE = function toBytesBE() {\n      var hi = this.high, lo = this.low;\n      return [\n        hi >>> 24,\n        hi >>> 16 & 255,\n        hi >>> 8 & 255,\n        hi & 255,\n        lo >>> 24,\n        lo >>> 16 & 255,\n        lo >>> 8 & 255,\n        lo & 255\n      ];\n    };\n    Long4.fromBytes = function fromBytes(bytes, unsigned, le) {\n      return le ? Long4.fromBytesLE(bytes, unsigned) : Long4.fromBytesBE(bytes, unsigned);\n    };\n    Long4.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n      return new Long4(\n        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,\n        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,\n        unsigned\n      );\n    };\n    Long4.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n      return new Long4(\n        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],\n        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],\n        unsigned\n      );\n    };\n  }\n});\n\n// index.ts\nvar mezon_js_protobuf_exports = {};\n__export(mezon_js_protobuf_exports, {\n  WebSocketAdapterPb: () => WebSocketAdapterPb\n});\nmodule.exports = __toCommonJS(mezon_js_protobuf_exports);\n\n// rtapi/realtime.ts\nvar import_minimal4 = __toESM(require_minimal2());\n\n// api/api.ts\nvar import_long3 = __toESM(require_long());\nvar import_minimal3 = __toESM(require_minimal2());\n\n// google/protobuf/timestamp.ts\nvar import_long = __toESM(require_long());\nvar import_minimal = __toESM(require_minimal2());\nfunction createBaseTimestamp() {\n  return { seconds: 0, nanos: 0 };\n}\nvar Timestamp = {\n  encode(message, writer = import_minimal.default.Writer.create()) {\n    if (message.seconds !== 0) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal.default.Reader ? input : new import_minimal.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.seconds = longToNumber(reader.int64());\n          break;\n        case 2:\n          message.nanos = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      seconds: isSet(object.seconds) ? Number(object.seconds) : 0,\n      nanos: isSet(object.nanos) ? Number(object.nanos) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.seconds !== void 0 && (obj.seconds = Math.round(message.seconds));\n    message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));\n    return obj;\n  },\n  create(base) {\n    return Timestamp.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseTimestamp();\n    message.seconds = (_a = object.seconds) != null ? _a : 0;\n    message.nanos = (_b = object.nanos) != null ? _b : 0;\n    return message;\n  }\n};\nvar tsProtoGlobalThis = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  throw \"Unable to locate global object\";\n})();\nfunction longToNumber(long) {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new tsProtoGlobalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\nif (import_minimal.default.util.Long !== import_long.default) {\n  import_minimal.default.util.Long = import_long.default;\n  import_minimal.default.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== void 0;\n}\n\n// google/protobuf/wrappers.ts\nvar import_long2 = __toESM(require_long());\nvar import_minimal2 = __toESM(require_minimal2());\nfunction createBaseInt32Value() {\n  return { value: 0 };\n}\nvar Int32Value = {\n  encode(message, writer = import_minimal2.default.Writer.create()) {\n    if (message.value !== 0) {\n      writer.uint32(8).int32(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseInt32Value();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? Number(object.value) : 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.value !== void 0 && (obj.value = Math.round(message.value));\n    return obj;\n  },\n  create(base) {\n    return Int32Value.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseInt32Value();\n    message.value = (_a = object.value) != null ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseBoolValue() {\n  return { value: false };\n}\nvar BoolValue = {\n  encode(message, writer = import_minimal2.default.Writer.create()) {\n    if (message.value === true) {\n      writer.uint32(8).bool(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseBoolValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? Boolean(object.value) : false };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.value !== void 0 && (obj.value = message.value);\n    return obj;\n  },\n  create(base) {\n    return BoolValue.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseBoolValue();\n    message.value = (_a = object.value) != null ? _a : false;\n    return message;\n  }\n};\nfunction createBaseStringValue() {\n  return { value: \"\" };\n}\nvar StringValue = {\n  encode(message, writer = import_minimal2.default.Writer.create()) {\n    if (message.value !== \"\") {\n      writer.uint32(10).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal2.default.Reader ? input : new import_minimal2.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStringValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? String(object.value) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.value !== void 0 && (obj.value = message.value);\n    return obj;\n  },\n  create(base) {\n    return StringValue.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStringValue();\n    message.value = (_a = object.value) != null ? _a : \"\";\n    return message;\n  }\n};\nvar tsProtoGlobalThis2 = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  throw \"Unable to locate global object\";\n})();\nif (import_minimal2.default.util.Long !== import_long2.default) {\n  import_minimal2.default.util.Long = import_long2.default;\n  import_minimal2.default.configure();\n}\nfunction isSet2(value) {\n  return value !== null && value !== void 0;\n}\n\n// api/api.ts\nfunction createBaseChannelMessage() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    code: void 0,\n    sender_id: \"\",\n    username: \"\",\n    avatar: \"\",\n    content: \"\",\n    create_time: void 0,\n    update_time: void 0,\n    channel_label: \"\",\n    clan_logo: \"\",\n    category_name: \"\",\n    display_name: \"\",\n    clan_nick: \"\",\n    clan_avatar: \"\",\n    reactions: \"\",\n    mentions: \"\",\n    attachments: \"\",\n    references: \"\",\n    referenced_message: \"\",\n    create_time_ms: 0,\n    update_time_ms: 0,\n    mode: 0,\n    hide_editted: false\n  };\n}\nvar ChannelMessage = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.code !== void 0) {\n      Int32Value.encode({ value: message.code }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(42).string(message.sender_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(50).string(message.username);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(58).string(message.avatar);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(66).string(message.content);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(74).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(82).fork()).ldelim();\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(90).string(message.channel_label);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(98).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(106).string(message.category_name);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(114).string(message.display_name);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(122).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(130).string(message.clan_avatar);\n    }\n    if (message.reactions !== \"\") {\n      writer.uint32(138).string(message.reactions);\n    }\n    if (message.mentions !== \"\") {\n      writer.uint32(146).string(message.mentions);\n    }\n    if (message.attachments !== \"\") {\n      writer.uint32(154).string(message.attachments);\n    }\n    if (message.references !== \"\") {\n      writer.uint32(162).string(message.references);\n    }\n    if (message.referenced_message !== \"\") {\n      writer.uint32(170).string(message.referenced_message);\n    }\n    if (message.create_time_ms !== 0) {\n      writer.uint32(176).uint32(message.create_time_ms);\n    }\n    if (message.update_time_ms !== 0) {\n      writer.uint32(184).uint32(message.update_time_ms);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(192).int32(message.mode);\n    }\n    if (message.hide_editted === true) {\n      writer.uint32(200).bool(message.hide_editted);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.message_id = reader.string();\n          break;\n        case 4:\n          message.code = Int32Value.decode(reader, reader.uint32()).value;\n          break;\n        case 5:\n          message.sender_id = reader.string();\n          break;\n        case 6:\n          message.username = reader.string();\n          break;\n        case 7:\n          message.avatar = reader.string();\n          break;\n        case 8:\n          message.content = reader.string();\n          break;\n        case 9:\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 10:\n          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 11:\n          message.channel_label = reader.string();\n          break;\n        case 12:\n          message.clan_logo = reader.string();\n          break;\n        case 13:\n          message.category_name = reader.string();\n          break;\n        case 14:\n          message.display_name = reader.string();\n          break;\n        case 15:\n          message.clan_nick = reader.string();\n          break;\n        case 16:\n          message.clan_avatar = reader.string();\n          break;\n        case 17:\n          message.reactions = reader.string();\n          break;\n        case 18:\n          message.mentions = reader.string();\n          break;\n        case 19:\n          message.attachments = reader.string();\n          break;\n        case 20:\n          message.references = reader.string();\n          break;\n        case 21:\n          message.referenced_message = reader.string();\n          break;\n        case 22:\n          message.create_time_ms = reader.uint32();\n          break;\n        case 23:\n          message.update_time_ms = reader.uint32();\n          break;\n        case 24:\n          message.mode = reader.int32();\n          break;\n        case 25:\n          message.hide_editted = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? String(object.message_id) : \"\",\n      code: isSet3(object.code) ? Number(object.code) : void 0,\n      sender_id: isSet3(object.sender_id) ? String(object.sender_id) : \"\",\n      username: isSet3(object.username) ? String(object.username) : \"\",\n      avatar: isSet3(object.avatar) ? String(object.avatar) : \"\",\n      content: isSet3(object.content) ? String(object.content) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      update_time: isSet3(object.update_time) ? fromJsonTimestamp(object.update_time) : void 0,\n      channel_label: isSet3(object.channel_label) ? String(object.channel_label) : \"\",\n      clan_logo: isSet3(object.clan_logo) ? String(object.clan_logo) : \"\",\n      category_name: isSet3(object.category_name) ? String(object.category_name) : \"\",\n      display_name: isSet3(object.display_name) ? String(object.display_name) : \"\",\n      clan_nick: isSet3(object.clan_nick) ? String(object.clan_nick) : \"\",\n      clan_avatar: isSet3(object.clan_avatar) ? String(object.clan_avatar) : \"\",\n      reactions: isSet3(object.reactions) ? String(object.reactions) : \"\",\n      mentions: isSet3(object.mentions) ? String(object.mentions) : \"\",\n      attachments: isSet3(object.attachments) ? String(object.attachments) : \"\",\n      references: isSet3(object.references) ? String(object.references) : \"\",\n      referenced_message: isSet3(object.referenced_message) ? String(object.referenced_message) : \"\",\n      create_time_ms: isSet3(object.create_time_ms) ? Number(object.create_time_ms) : 0,\n      update_time_ms: isSet3(object.update_time_ms) ? Number(object.update_time_ms) : 0,\n      mode: isSet3(object.mode) ? Number(object.mode) : 0,\n      hide_editted: isSet3(object.hide_editted) ? Boolean(object.hide_editted) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.code !== void 0 && (obj.code = message.code);\n    message.sender_id !== void 0 && (obj.sender_id = message.sender_id);\n    message.username !== void 0 && (obj.username = message.username);\n    message.avatar !== void 0 && (obj.avatar = message.avatar);\n    message.content !== void 0 && (obj.content = message.content);\n    message.create_time !== void 0 && (obj.create_time = message.create_time.toISOString());\n    message.update_time !== void 0 && (obj.update_time = message.update_time.toISOString());\n    message.channel_label !== void 0 && (obj.channel_label = message.channel_label);\n    message.clan_logo !== void 0 && (obj.clan_logo = message.clan_logo);\n    message.category_name !== void 0 && (obj.category_name = message.category_name);\n    message.display_name !== void 0 && (obj.display_name = message.display_name);\n    message.clan_nick !== void 0 && (obj.clan_nick = message.clan_nick);\n    message.clan_avatar !== void 0 && (obj.clan_avatar = message.clan_avatar);\n    message.reactions !== void 0 && (obj.reactions = message.reactions);\n    message.mentions !== void 0 && (obj.mentions = message.mentions);\n    message.attachments !== void 0 && (obj.attachments = message.attachments);\n    message.references !== void 0 && (obj.references = message.references);\n    message.referenced_message !== void 0 && (obj.referenced_message = message.referenced_message);\n    message.create_time_ms !== void 0 && (obj.create_time_ms = Math.round(message.create_time_ms));\n    message.update_time_ms !== void 0 && (obj.update_time_ms = Math.round(message.update_time_ms));\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.hide_editted !== void 0 && (obj.hide_editted = message.hide_editted);\n    return obj;\n  },\n  create(base) {\n    return ChannelMessage.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;\n    const message = createBaseChannelMessage();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.code = (_d = object.code) != null ? _d : void 0;\n    message.sender_id = (_e = object.sender_id) != null ? _e : \"\";\n    message.username = (_f = object.username) != null ? _f : \"\";\n    message.avatar = (_g = object.avatar) != null ? _g : \"\";\n    message.content = (_h = object.content) != null ? _h : \"\";\n    message.create_time = (_i = object.create_time) != null ? _i : void 0;\n    message.update_time = (_j = object.update_time) != null ? _j : void 0;\n    message.channel_label = (_k = object.channel_label) != null ? _k : \"\";\n    message.clan_logo = (_l = object.clan_logo) != null ? _l : \"\";\n    message.category_name = (_m = object.category_name) != null ? _m : \"\";\n    message.display_name = (_n = object.display_name) != null ? _n : \"\";\n    message.clan_nick = (_o = object.clan_nick) != null ? _o : \"\";\n    message.clan_avatar = (_p = object.clan_avatar) != null ? _p : \"\";\n    message.reactions = (_q = object.reactions) != null ? _q : \"\";\n    message.mentions = (_r = object.mentions) != null ? _r : \"\";\n    message.attachments = (_s = object.attachments) != null ? _s : \"\";\n    message.references = (_t = object.references) != null ? _t : \"\";\n    message.referenced_message = (_u = object.referenced_message) != null ? _u : \"\";\n    message.create_time_ms = (_v = object.create_time_ms) != null ? _v : 0;\n    message.update_time_ms = (_w = object.update_time_ms) != null ? _w : 0;\n    message.mode = (_x = object.mode) != null ? _x : 0;\n    message.hide_editted = (_y = object.hide_editted) != null ? _y : false;\n    return message;\n  }\n};\nfunction createBaseMessageMention() {\n  return { id: \"\", user_id: \"\", username: \"\", role_id: \"\", rolename: \"\", create_time: void 0, s: 0, e: 0 };\n}\nvar MessageMention = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.role_id !== \"\") {\n      writer.uint32(34).string(message.role_id);\n    }\n    if (message.rolename !== \"\") {\n      writer.uint32(42).string(message.rolename);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.s !== 0) {\n      writer.uint32(56).int32(message.s);\n    }\n    if (message.e !== 0) {\n      writer.uint32(64).int32(message.e);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageMention();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.user_id = reader.string();\n          break;\n        case 3:\n          message.username = reader.string();\n          break;\n        case 4:\n          message.role_id = reader.string();\n          break;\n        case 5:\n          message.rolename = reader.string();\n          break;\n        case 6:\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.s = reader.int32();\n          break;\n        case 8:\n          message.e = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? String(object.id) : \"\",\n      user_id: isSet3(object.user_id) ? String(object.user_id) : \"\",\n      username: isSet3(object.username) ? String(object.username) : \"\",\n      role_id: isSet3(object.role_id) ? String(object.role_id) : \"\",\n      rolename: isSet3(object.rolename) ? String(object.rolename) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      s: isSet3(object.s) ? Number(object.s) : 0,\n      e: isSet3(object.e) ? Number(object.e) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.username !== void 0 && (obj.username = message.username);\n    message.role_id !== void 0 && (obj.role_id = message.role_id);\n    message.rolename !== void 0 && (obj.rolename = message.rolename);\n    message.create_time !== void 0 && (obj.create_time = message.create_time.toISOString());\n    message.s !== void 0 && (obj.s = Math.round(message.s));\n    message.e !== void 0 && (obj.e = Math.round(message.e));\n    return obj;\n  },\n  create(base) {\n    return MessageMention.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseMessageMention();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.role_id = (_d = object.role_id) != null ? _d : \"\";\n    message.rolename = (_e = object.rolename) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.s = (_g = object.s) != null ? _g : 0;\n    message.e = (_h = object.e) != null ? _h : 0;\n    return message;\n  }\n};\nfunction createBaseMessageReaction() {\n  return {\n    id: \"\",\n    emoji_id: \"\",\n    emoji: \"\",\n    sender_id: \"\",\n    sender_name: \"\",\n    sender_avatar: \"\",\n    action: false,\n    count: 0,\n    channel_id: \"\",\n    message_id: \"\",\n    clan_id: \"\",\n    mode: 0,\n    message_sender_id: \"\"\n  };\n}\nvar MessageReaction = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.emoji_id !== \"\") {\n      writer.uint32(18).string(message.emoji_id);\n    }\n    if (message.emoji !== \"\") {\n      writer.uint32(26).string(message.emoji);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(34).string(message.sender_id);\n    }\n    if (message.sender_name !== \"\") {\n      writer.uint32(42).string(message.sender_name);\n    }\n    if (message.sender_avatar !== \"\") {\n      writer.uint32(50).string(message.sender_avatar);\n    }\n    if (message.action === true) {\n      writer.uint32(56).bool(message.action);\n    }\n    if (message.count !== 0) {\n      writer.uint32(64).int32(message.count);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(74).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(82).string(message.message_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(90).string(message.clan_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(96).int32(message.mode);\n    }\n    if (message.message_sender_id !== \"\") {\n      writer.uint32(106).string(message.message_sender_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageReaction();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.emoji_id = reader.string();\n          break;\n        case 3:\n          message.emoji = reader.string();\n          break;\n        case 4:\n          message.sender_id = reader.string();\n          break;\n        case 5:\n          message.sender_name = reader.string();\n          break;\n        case 6:\n          message.sender_avatar = reader.string();\n          break;\n        case 7:\n          message.action = reader.bool();\n          break;\n        case 8:\n          message.count = reader.int32();\n          break;\n        case 9:\n          message.channel_id = reader.string();\n          break;\n        case 10:\n          message.message_id = reader.string();\n          break;\n        case 11:\n          message.clan_id = reader.string();\n          break;\n        case 12:\n          message.mode = reader.int32();\n          break;\n        case 13:\n          message.message_sender_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? String(object.id) : \"\",\n      emoji_id: isSet3(object.emoji_id) ? String(object.emoji_id) : \"\",\n      emoji: isSet3(object.emoji) ? String(object.emoji) : \"\",\n      sender_id: isSet3(object.sender_id) ? String(object.sender_id) : \"\",\n      sender_name: isSet3(object.sender_name) ? String(object.sender_name) : \"\",\n      sender_avatar: isSet3(object.sender_avatar) ? String(object.sender_avatar) : \"\",\n      action: isSet3(object.action) ? Boolean(object.action) : false,\n      count: isSet3(object.count) ? Number(object.count) : 0,\n      channel_id: isSet3(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? String(object.message_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? String(object.clan_id) : \"\",\n      mode: isSet3(object.mode) ? Number(object.mode) : 0,\n      message_sender_id: isSet3(object.message_sender_id) ? String(object.message_sender_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.emoji_id !== void 0 && (obj.emoji_id = message.emoji_id);\n    message.emoji !== void 0 && (obj.emoji = message.emoji);\n    message.sender_id !== void 0 && (obj.sender_id = message.sender_id);\n    message.sender_name !== void 0 && (obj.sender_name = message.sender_name);\n    message.sender_avatar !== void 0 && (obj.sender_avatar = message.sender_avatar);\n    message.action !== void 0 && (obj.action = message.action);\n    message.count !== void 0 && (obj.count = Math.round(message.count));\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.message_sender_id !== void 0 && (obj.message_sender_id = message.message_sender_id);\n    return obj;\n  },\n  create(base) {\n    return MessageReaction.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;\n    const message = createBaseMessageReaction();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.emoji_id = (_b = object.emoji_id) != null ? _b : \"\";\n    message.emoji = (_c = object.emoji) != null ? _c : \"\";\n    message.sender_id = (_d = object.sender_id) != null ? _d : \"\";\n    message.sender_name = (_e = object.sender_name) != null ? _e : \"\";\n    message.sender_avatar = (_f = object.sender_avatar) != null ? _f : \"\";\n    message.action = (_g = object.action) != null ? _g : false;\n    message.count = (_h = object.count) != null ? _h : 0;\n    message.channel_id = (_i = object.channel_id) != null ? _i : \"\";\n    message.message_id = (_j = object.message_id) != null ? _j : \"\";\n    message.clan_id = (_k = object.clan_id) != null ? _k : \"\";\n    message.mode = (_l = object.mode) != null ? _l : 0;\n    message.message_sender_id = (_m = object.message_sender_id) != null ? _m : \"\";\n    return message;\n  }\n};\nfunction createBaseMessageAttachment() {\n  return { filename: \"\", size: 0, url: \"\", filetype: \"\", width: 0, height: 0 };\n}\nvar MessageAttachment = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.filename !== \"\") {\n      writer.uint32(10).string(message.filename);\n    }\n    if (message.size !== 0) {\n      writer.uint32(16).int64(message.size);\n    }\n    if (message.url !== \"\") {\n      writer.uint32(26).string(message.url);\n    }\n    if (message.filetype !== \"\") {\n      writer.uint32(34).string(message.filetype);\n    }\n    if (message.width !== 0) {\n      writer.uint32(40).int32(message.width);\n    }\n    if (message.height !== 0) {\n      writer.uint32(48).int32(message.height);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageAttachment();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.filename = reader.string();\n          break;\n        case 2:\n          message.size = longToNumber2(reader.int64());\n          break;\n        case 3:\n          message.url = reader.string();\n          break;\n        case 4:\n          message.filetype = reader.string();\n          break;\n        case 5:\n          message.width = reader.int32();\n          break;\n        case 6:\n          message.height = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      filename: isSet3(object.filename) ? String(object.filename) : \"\",\n      size: isSet3(object.size) ? Number(object.size) : 0,\n      url: isSet3(object.url) ? String(object.url) : \"\",\n      filetype: isSet3(object.filetype) ? String(object.filetype) : \"\",\n      width: isSet3(object.width) ? Number(object.width) : 0,\n      height: isSet3(object.height) ? Number(object.height) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.filename !== void 0 && (obj.filename = message.filename);\n    message.size !== void 0 && (obj.size = Math.round(message.size));\n    message.url !== void 0 && (obj.url = message.url);\n    message.filetype !== void 0 && (obj.filetype = message.filetype);\n    message.width !== void 0 && (obj.width = Math.round(message.width));\n    message.height !== void 0 && (obj.height = Math.round(message.height));\n    return obj;\n  },\n  create(base) {\n    return MessageAttachment.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseMessageAttachment();\n    message.filename = (_a = object.filename) != null ? _a : \"\";\n    message.size = (_b = object.size) != null ? _b : 0;\n    message.url = (_c = object.url) != null ? _c : \"\";\n    message.filetype = (_d = object.filetype) != null ? _d : \"\";\n    message.width = (_e = object.width) != null ? _e : 0;\n    message.height = (_f = object.height) != null ? _f : 0;\n    return message;\n  }\n};\nfunction createBaseMessageRef() {\n  return {\n    message_id: \"\",\n    message_ref_id: \"\",\n    content: \"\",\n    has_attachment: false,\n    ref_type: 0,\n    message_sender_id: \"\",\n    message_sender_username: \"\",\n    mesages_sender_avatar: \"\",\n    message_sender_clan_nick: \"\",\n    message_sender_display_name: \"\"\n  };\n}\nvar MessageRef = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.message_id !== \"\") {\n      writer.uint32(10).string(message.message_id);\n    }\n    if (message.message_ref_id !== \"\") {\n      writer.uint32(18).string(message.message_ref_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.has_attachment === true) {\n      writer.uint32(32).bool(message.has_attachment);\n    }\n    if (message.ref_type !== 0) {\n      writer.uint32(40).int32(message.ref_type);\n    }\n    if (message.message_sender_id !== \"\") {\n      writer.uint32(50).string(message.message_sender_id);\n    }\n    if (message.message_sender_username !== \"\") {\n      writer.uint32(58).string(message.message_sender_username);\n    }\n    if (message.mesages_sender_avatar !== \"\") {\n      writer.uint32(66).string(message.mesages_sender_avatar);\n    }\n    if (message.message_sender_clan_nick !== \"\") {\n      writer.uint32(74).string(message.message_sender_clan_nick);\n    }\n    if (message.message_sender_display_name !== \"\") {\n      writer.uint32(82).string(message.message_sender_display_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageRef();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.message_id = reader.string();\n          break;\n        case 2:\n          message.message_ref_id = reader.string();\n          break;\n        case 3:\n          message.content = reader.string();\n          break;\n        case 4:\n          message.has_attachment = reader.bool();\n          break;\n        case 5:\n          message.ref_type = reader.int32();\n          break;\n        case 6:\n          message.message_sender_id = reader.string();\n          break;\n        case 7:\n          message.message_sender_username = reader.string();\n          break;\n        case 8:\n          message.mesages_sender_avatar = reader.string();\n          break;\n        case 9:\n          message.message_sender_clan_nick = reader.string();\n          break;\n        case 10:\n          message.message_sender_display_name = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message_id: isSet3(object.message_id) ? String(object.message_id) : \"\",\n      message_ref_id: isSet3(object.message_ref_id) ? String(object.message_ref_id) : \"\",\n      content: isSet3(object.content) ? String(object.content) : \"\",\n      has_attachment: isSet3(object.has_attachment) ? Boolean(object.has_attachment) : false,\n      ref_type: isSet3(object.ref_type) ? Number(object.ref_type) : 0,\n      message_sender_id: isSet3(object.message_sender_id) ? String(object.message_sender_id) : \"\",\n      message_sender_username: isSet3(object.message_sender_username) ? String(object.message_sender_username) : \"\",\n      mesages_sender_avatar: isSet3(object.mesages_sender_avatar) ? String(object.mesages_sender_avatar) : \"\",\n      message_sender_clan_nick: isSet3(object.message_sender_clan_nick) ? String(object.message_sender_clan_nick) : \"\",\n      message_sender_display_name: isSet3(object.message_sender_display_name) ? String(object.message_sender_display_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.message_ref_id !== void 0 && (obj.message_ref_id = message.message_ref_id);\n    message.content !== void 0 && (obj.content = message.content);\n    message.has_attachment !== void 0 && (obj.has_attachment = message.has_attachment);\n    message.ref_type !== void 0 && (obj.ref_type = Math.round(message.ref_type));\n    message.message_sender_id !== void 0 && (obj.message_sender_id = message.message_sender_id);\n    message.message_sender_username !== void 0 && (obj.message_sender_username = message.message_sender_username);\n    message.mesages_sender_avatar !== void 0 && (obj.mesages_sender_avatar = message.mesages_sender_avatar);\n    message.message_sender_clan_nick !== void 0 && (obj.message_sender_clan_nick = message.message_sender_clan_nick);\n    message.message_sender_display_name !== void 0 && (obj.message_sender_display_name = message.message_sender_display_name);\n    return obj;\n  },\n  create(base) {\n    return MessageRef.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseMessageRef();\n    message.message_id = (_a = object.message_id) != null ? _a : \"\";\n    message.message_ref_id = (_b = object.message_ref_id) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.has_attachment = (_d = object.has_attachment) != null ? _d : false;\n    message.ref_type = (_e = object.ref_type) != null ? _e : 0;\n    message.message_sender_id = (_f = object.message_sender_id) != null ? _f : \"\";\n    message.message_sender_username = (_g = object.message_sender_username) != null ? _g : \"\";\n    message.mesages_sender_avatar = (_h = object.mesages_sender_avatar) != null ? _h : \"\";\n    message.message_sender_clan_nick = (_i = object.message_sender_clan_nick) != null ? _i : \"\";\n    message.message_sender_display_name = (_j = object.message_sender_display_name) != null ? _j : \"\";\n    return message;\n  }\n};\nfunction createBaseNotification() {\n  return {\n    id: \"\",\n    subject: \"\",\n    content: \"\",\n    code: 0,\n    sender_id: \"\",\n    create_time: void 0,\n    persistent: false,\n    clan_id: \"\",\n    channel_id: \"\",\n    channel_type: 0,\n    avatar_url: \"\"\n  };\n}\nvar Notification = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.subject !== \"\") {\n      writer.uint32(18).string(message.subject);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.code !== 0) {\n      writer.uint32(32).int32(message.code);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(42).string(message.sender_id);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.persistent === true) {\n      writer.uint32(56).bool(message.persistent);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(66).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(74).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(80).int32(message.channel_type);\n    }\n    if (message.avatar_url !== \"\") {\n      writer.uint32(90).string(message.avatar_url);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotification();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.subject = reader.string();\n          break;\n        case 3:\n          message.content = reader.string();\n          break;\n        case 4:\n          message.code = reader.int32();\n          break;\n        case 5:\n          message.sender_id = reader.string();\n          break;\n        case 6:\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.persistent = reader.bool();\n          break;\n        case 8:\n          message.clan_id = reader.string();\n          break;\n        case 9:\n          message.channel_id = reader.string();\n          break;\n        case 10:\n          message.channel_type = reader.int32();\n          break;\n        case 11:\n          message.avatar_url = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? String(object.id) : \"\",\n      subject: isSet3(object.subject) ? String(object.subject) : \"\",\n      content: isSet3(object.content) ? String(object.content) : \"\",\n      code: isSet3(object.code) ? Number(object.code) : 0,\n      sender_id: isSet3(object.sender_id) ? String(object.sender_id) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      persistent: isSet3(object.persistent) ? Boolean(object.persistent) : false,\n      clan_id: isSet3(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? String(object.channel_id) : \"\",\n      channel_type: isSet3(object.channel_type) ? Number(object.channel_type) : 0,\n      avatar_url: isSet3(object.avatar_url) ? String(object.avatar_url) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.subject !== void 0 && (obj.subject = message.subject);\n    message.content !== void 0 && (obj.content = message.content);\n    message.code !== void 0 && (obj.code = Math.round(message.code));\n    message.sender_id !== void 0 && (obj.sender_id = message.sender_id);\n    message.create_time !== void 0 && (obj.create_time = message.create_time.toISOString());\n    message.persistent !== void 0 && (obj.persistent = message.persistent);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.channel_type !== void 0 && (obj.channel_type = Math.round(message.channel_type));\n    message.avatar_url !== void 0 && (obj.avatar_url = message.avatar_url);\n    return obj;\n  },\n  create(base) {\n    return Notification.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseNotification();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.subject = (_b = object.subject) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.code = (_d = object.code) != null ? _d : 0;\n    message.sender_id = (_e = object.sender_id) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.persistent = (_g = object.persistent) != null ? _g : false;\n    message.clan_id = (_h = object.clan_id) != null ? _h : \"\";\n    message.channel_id = (_i = object.channel_id) != null ? _i : \"\";\n    message.channel_type = (_j = object.channel_type) != null ? _j : 0;\n    message.avatar_url = (_k = object.avatar_url) != null ? _k : \"\";\n    return message;\n  }\n};\nfunction createBaseRpc() {\n  return { id: \"\", payload: \"\", http_key: \"\" };\n}\nvar Rpc = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.payload !== \"\") {\n      writer.uint32(18).string(message.payload);\n    }\n    if (message.http_key !== \"\") {\n      writer.uint32(26).string(message.http_key);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : new import_minimal3.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRpc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.payload = reader.string();\n          break;\n        case 3:\n          message.http_key = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? String(object.id) : \"\",\n      payload: isSet3(object.payload) ? String(object.payload) : \"\",\n      http_key: isSet3(object.http_key) ? String(object.http_key) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.payload !== void 0 && (obj.payload = message.payload);\n    message.http_key !== void 0 && (obj.http_key = message.http_key);\n    return obj;\n  },\n  create(base) {\n    return Rpc.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseRpc();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.payload = (_b = object.payload) != null ? _b : \"\";\n    message.http_key = (_c = object.http_key) != null ? _c : \"\";\n    return message;\n  }\n};\nvar tsProtoGlobalThis3 = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof __webpack_require__.g !== \"undefined\") {\n    return __webpack_require__.g;\n  }\n  throw \"Unable to locate global object\";\n})();\nfunction toTimestamp(date) {\n  const seconds = date.getTime() / 1e3;\n  const nanos = date.getTime() % 1e3 * 1e6;\n  return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n  let millis = t.seconds * 1e3;\n  millis += t.nanos / 1e6;\n  return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\nfunction longToNumber2(long) {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new tsProtoGlobalThis3.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\nif (import_minimal3.default.util.Long !== import_long3.default) {\n  import_minimal3.default.util.Long = import_long3.default;\n  import_minimal3.default.configure();\n}\nfunction isSet3(value) {\n  return value !== null && value !== void 0;\n}\n\n// rtapi/realtime.ts\nfunction createBaseEnvelope() {\n  return {\n    cid: \"\",\n    channel: void 0,\n    clan_join: void 0,\n    channel_join: void 0,\n    channel_leave: void 0,\n    channel_message: void 0,\n    channel_message_ack: void 0,\n    channel_message_send: void 0,\n    channel_message_update: void 0,\n    channel_message_remove: void 0,\n    channel_presence_event: void 0,\n    error: void 0,\n    notifications: void 0,\n    rpc: void 0,\n    status: void 0,\n    status_follow: void 0,\n    status_presence_event: void 0,\n    status_unfollow: void 0,\n    status_update: void 0,\n    stream_data: void 0,\n    stream_presence_event: void 0,\n    ping: void 0,\n    pong: void 0,\n    message_typing_event: void 0,\n    last_seen_message_event: void 0,\n    message_reaction_event: void 0,\n    voice_joined_event: void 0,\n    voice_leaved_event: void 0,\n    voice_started_event: void 0,\n    voice_ended_event: void 0,\n    channel_created_event: void 0,\n    channel_deleted_event: void 0,\n    channel_updated_event: void 0,\n    last_pin_message_event: void 0,\n    custom_status_event: void 0,\n    user_channel_added_event: void 0,\n    user_channel_removed_event: void 0,\n    user_clan_removed_event: void 0,\n    clan_updated_event: void 0,\n    clan_profile_updated_event: void 0,\n    clan_name_existed_event: void 0,\n    user_profile_updated_event: void 0,\n    emojis_listed_event: void 0,\n    sticker_listed_event: void 0,\n    channel_desc_list_event: void 0,\n    hashtag_dm_list_event: void 0,\n    notification_channel_setting_event: void 0,\n    notification_category_setting_event: void 0,\n    notification_clan_setting_event: void 0,\n    notifi_react_message_event: void 0,\n    permission_role_channel_list_event: void 0\n  };\n}\nvar Envelope = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.cid !== \"\") {\n      writer.uint32(10).string(message.cid);\n    }\n    if (message.channel !== void 0) {\n      Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.clan_join !== void 0) {\n      ClanJoin.encode(message.clan_join, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.channel_join !== void 0) {\n      ChannelJoin.encode(message.channel_join, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.channel_leave !== void 0) {\n      ChannelLeave.encode(message.channel_leave, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.channel_message !== void 0) {\n      ChannelMessage.encode(message.channel_message, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.channel_message_ack !== void 0) {\n      ChannelMessageAck.encode(message.channel_message_ack, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.channel_message_send !== void 0) {\n      ChannelMessageSend.encode(message.channel_message_send, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.channel_message_update !== void 0) {\n      ChannelMessageUpdate.encode(message.channel_message_update, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.channel_message_remove !== void 0) {\n      ChannelMessageRemove.encode(message.channel_message_remove, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.channel_presence_event !== void 0) {\n      ChannelPresenceEvent.encode(message.channel_presence_event, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.error !== void 0) {\n      Error2.encode(message.error, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.notifications !== void 0) {\n      Notifications.encode(message.notifications, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.rpc !== void 0) {\n      Rpc.encode(message.rpc, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.status !== void 0) {\n      Status.encode(message.status, writer.uint32(122).fork()).ldelim();\n    }\n    if (message.status_follow !== void 0) {\n      StatusFollow.encode(message.status_follow, writer.uint32(130).fork()).ldelim();\n    }\n    if (message.status_presence_event !== void 0) {\n      StatusPresenceEvent.encode(message.status_presence_event, writer.uint32(138).fork()).ldelim();\n    }\n    if (message.status_unfollow !== void 0) {\n      StatusUnfollow.encode(message.status_unfollow, writer.uint32(146).fork()).ldelim();\n    }\n    if (message.status_update !== void 0) {\n      StatusUpdate.encode(message.status_update, writer.uint32(154).fork()).ldelim();\n    }\n    if (message.stream_data !== void 0) {\n      StreamData.encode(message.stream_data, writer.uint32(162).fork()).ldelim();\n    }\n    if (message.stream_presence_event !== void 0) {\n      StreamPresenceEvent.encode(message.stream_presence_event, writer.uint32(170).fork()).ldelim();\n    }\n    if (message.ping !== void 0) {\n      Ping.encode(message.ping, writer.uint32(178).fork()).ldelim();\n    }\n    if (message.pong !== void 0) {\n      Pong.encode(message.pong, writer.uint32(186).fork()).ldelim();\n    }\n    if (message.message_typing_event !== void 0) {\n      MessageTypingEvent.encode(message.message_typing_event, writer.uint32(194).fork()).ldelim();\n    }\n    if (message.last_seen_message_event !== void 0) {\n      LastSeenMessageEvent.encode(message.last_seen_message_event, writer.uint32(202).fork()).ldelim();\n    }\n    if (message.message_reaction_event !== void 0) {\n      MessageReaction.encode(message.message_reaction_event, writer.uint32(210).fork()).ldelim();\n    }\n    if (message.voice_joined_event !== void 0) {\n      VoiceJoinedEvent.encode(message.voice_joined_event, writer.uint32(218).fork()).ldelim();\n    }\n    if (message.voice_leaved_event !== void 0) {\n      VoiceLeavedEvent.encode(message.voice_leaved_event, writer.uint32(226).fork()).ldelim();\n    }\n    if (message.voice_started_event !== void 0) {\n      VoiceStartedEvent.encode(message.voice_started_event, writer.uint32(234).fork()).ldelim();\n    }\n    if (message.voice_ended_event !== void 0) {\n      VoiceEndedEvent.encode(message.voice_ended_event, writer.uint32(242).fork()).ldelim();\n    }\n    if (message.channel_created_event !== void 0) {\n      ChannelCreatedEvent.encode(message.channel_created_event, writer.uint32(250).fork()).ldelim();\n    }\n    if (message.channel_deleted_event !== void 0) {\n      ChannelDeletedEvent.encode(message.channel_deleted_event, writer.uint32(258).fork()).ldelim();\n    }\n    if (message.channel_updated_event !== void 0) {\n      ChannelUpdatedEvent.encode(message.channel_updated_event, writer.uint32(266).fork()).ldelim();\n    }\n    if (message.last_pin_message_event !== void 0) {\n      LastPinMessageEvent.encode(message.last_pin_message_event, writer.uint32(274).fork()).ldelim();\n    }\n    if (message.custom_status_event !== void 0) {\n      CustomStatusEvent.encode(message.custom_status_event, writer.uint32(282).fork()).ldelim();\n    }\n    if (message.user_channel_added_event !== void 0) {\n      UserChannelAdded.encode(message.user_channel_added_event, writer.uint32(290).fork()).ldelim();\n    }\n    if (message.user_channel_removed_event !== void 0) {\n      UserChannelRemoved.encode(message.user_channel_removed_event, writer.uint32(298).fork()).ldelim();\n    }\n    if (message.user_clan_removed_event !== void 0) {\n      UserClanRemoved.encode(message.user_clan_removed_event, writer.uint32(306).fork()).ldelim();\n    }\n    if (message.clan_updated_event !== void 0) {\n      ClanUpdatedEvent.encode(message.clan_updated_event, writer.uint32(314).fork()).ldelim();\n    }\n    if (message.clan_profile_updated_event !== void 0) {\n      ClanProfileUpdatedEvent.encode(message.clan_profile_updated_event, writer.uint32(322).fork()).ldelim();\n    }\n    if (message.clan_name_existed_event !== void 0) {\n      ClanNameExistedEvent.encode(message.clan_name_existed_event, writer.uint32(330).fork()).ldelim();\n    }\n    if (message.user_profile_updated_event !== void 0) {\n      UserProfileUpdatedEvent.encode(message.user_profile_updated_event, writer.uint32(338).fork()).ldelim();\n    }\n    if (message.emojis_listed_event !== void 0) {\n      EmojiListedEvent.encode(message.emojis_listed_event, writer.uint32(346).fork()).ldelim();\n    }\n    if (message.sticker_listed_event !== void 0) {\n      StrickerListedEvent.encode(message.sticker_listed_event, writer.uint32(354).fork()).ldelim();\n    }\n    if (message.channel_desc_list_event !== void 0) {\n      ChannelDescListEvent.encode(message.channel_desc_list_event, writer.uint32(362).fork()).ldelim();\n    }\n    if (message.hashtag_dm_list_event !== void 0) {\n      HashtagDmListEvent.encode(message.hashtag_dm_list_event, writer.uint32(370).fork()).ldelim();\n    }\n    if (message.notification_channel_setting_event !== void 0) {\n      NotificationChannelSettingEvent.encode(message.notification_channel_setting_event, writer.uint32(378).fork()).ldelim();\n    }\n    if (message.notification_category_setting_event !== void 0) {\n      NotificationCategorySettingEvent.encode(message.notification_category_setting_event, writer.uint32(386).fork()).ldelim();\n    }\n    if (message.notification_clan_setting_event !== void 0) {\n      NotificationClanSettingEvent.encode(message.notification_clan_setting_event, writer.uint32(394).fork()).ldelim();\n    }\n    if (message.notifi_react_message_event !== void 0) {\n      NotifiReactMessageEvent.encode(message.notifi_react_message_event, writer.uint32(402).fork()).ldelim();\n    }\n    if (message.permission_role_channel_list_event !== void 0) {\n      PermissionRoleChannelListEvent.encode(message.permission_role_channel_list_event, writer.uint32(410).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEnvelope();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.cid = reader.string();\n          break;\n        case 2:\n          message.channel = Channel.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.clan_join = ClanJoin.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.channel_join = ChannelJoin.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.channel_leave = ChannelLeave.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.channel_message = ChannelMessage.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.channel_message_ack = ChannelMessageAck.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.channel_message_send = ChannelMessageSend.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.channel_message_update = ChannelMessageUpdate.decode(reader, reader.uint32());\n          break;\n        case 10:\n          message.channel_message_remove = ChannelMessageRemove.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.channel_presence_event = ChannelPresenceEvent.decode(reader, reader.uint32());\n          break;\n        case 12:\n          message.error = Error2.decode(reader, reader.uint32());\n          break;\n        case 13:\n          message.notifications = Notifications.decode(reader, reader.uint32());\n          break;\n        case 14:\n          message.rpc = Rpc.decode(reader, reader.uint32());\n          break;\n        case 15:\n          message.status = Status.decode(reader, reader.uint32());\n          break;\n        case 16:\n          message.status_follow = StatusFollow.decode(reader, reader.uint32());\n          break;\n        case 17:\n          message.status_presence_event = StatusPresenceEvent.decode(reader, reader.uint32());\n          break;\n        case 18:\n          message.status_unfollow = StatusUnfollow.decode(reader, reader.uint32());\n          break;\n        case 19:\n          message.status_update = StatusUpdate.decode(reader, reader.uint32());\n          break;\n        case 20:\n          message.stream_data = StreamData.decode(reader, reader.uint32());\n          break;\n        case 21:\n          message.stream_presence_event = StreamPresenceEvent.decode(reader, reader.uint32());\n          break;\n        case 22:\n          message.ping = Ping.decode(reader, reader.uint32());\n          break;\n        case 23:\n          message.pong = Pong.decode(reader, reader.uint32());\n          break;\n        case 24:\n          message.message_typing_event = MessageTypingEvent.decode(reader, reader.uint32());\n          break;\n        case 25:\n          message.last_seen_message_event = LastSeenMessageEvent.decode(reader, reader.uint32());\n          break;\n        case 26:\n          message.message_reaction_event = MessageReaction.decode(reader, reader.uint32());\n          break;\n        case 27:\n          message.voice_joined_event = VoiceJoinedEvent.decode(reader, reader.uint32());\n          break;\n        case 28:\n          message.voice_leaved_event = VoiceLeavedEvent.decode(reader, reader.uint32());\n          break;\n        case 29:\n          message.voice_started_event = VoiceStartedEvent.decode(reader, reader.uint32());\n          break;\n        case 30:\n          message.voice_ended_event = VoiceEndedEvent.decode(reader, reader.uint32());\n          break;\n        case 31:\n          message.channel_created_event = ChannelCreatedEvent.decode(reader, reader.uint32());\n          break;\n        case 32:\n          message.channel_deleted_event = ChannelDeletedEvent.decode(reader, reader.uint32());\n          break;\n        case 33:\n          message.channel_updated_event = ChannelUpdatedEvent.decode(reader, reader.uint32());\n          break;\n        case 34:\n          message.last_pin_message_event = LastPinMessageEvent.decode(reader, reader.uint32());\n          break;\n        case 35:\n          message.custom_status_event = CustomStatusEvent.decode(reader, reader.uint32());\n          break;\n        case 36:\n          message.user_channel_added_event = UserChannelAdded.decode(reader, reader.uint32());\n          break;\n        case 37:\n          message.user_channel_removed_event = UserChannelRemoved.decode(reader, reader.uint32());\n          break;\n        case 38:\n          message.user_clan_removed_event = UserClanRemoved.decode(reader, reader.uint32());\n          break;\n        case 39:\n          message.clan_updated_event = ClanUpdatedEvent.decode(reader, reader.uint32());\n          break;\n        case 40:\n          message.clan_profile_updated_event = ClanProfileUpdatedEvent.decode(reader, reader.uint32());\n          break;\n        case 41:\n          message.clan_name_existed_event = ClanNameExistedEvent.decode(reader, reader.uint32());\n          break;\n        case 42:\n          message.user_profile_updated_event = UserProfileUpdatedEvent.decode(reader, reader.uint32());\n          break;\n        case 43:\n          message.emojis_listed_event = EmojiListedEvent.decode(reader, reader.uint32());\n          break;\n        case 44:\n          message.sticker_listed_event = StrickerListedEvent.decode(reader, reader.uint32());\n          break;\n        case 45:\n          message.channel_desc_list_event = ChannelDescListEvent.decode(reader, reader.uint32());\n          break;\n        case 46:\n          message.hashtag_dm_list_event = HashtagDmListEvent.decode(reader, reader.uint32());\n          break;\n        case 47:\n          message.notification_channel_setting_event = NotificationChannelSettingEvent.decode(reader, reader.uint32());\n          break;\n        case 48:\n          message.notification_category_setting_event = NotificationCategorySettingEvent.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        case 49:\n          message.notification_clan_setting_event = NotificationClanSettingEvent.decode(reader, reader.uint32());\n          break;\n        case 50:\n          message.notifi_react_message_event = NotifiReactMessageEvent.decode(reader, reader.uint32());\n          break;\n        case 51:\n          message.permission_role_channel_list_event = PermissionRoleChannelListEvent.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet4(object.cid) ? String(object.cid) : \"\",\n      channel: isSet4(object.channel) ? Channel.fromJSON(object.channel) : void 0,\n      clan_join: isSet4(object.clan_join) ? ClanJoin.fromJSON(object.clan_join) : void 0,\n      channel_join: isSet4(object.channel_join) ? ChannelJoin.fromJSON(object.channel_join) : void 0,\n      channel_leave: isSet4(object.channel_leave) ? ChannelLeave.fromJSON(object.channel_leave) : void 0,\n      channel_message: isSet4(object.channel_message) ? ChannelMessage.fromJSON(object.channel_message) : void 0,\n      channel_message_ack: isSet4(object.channel_message_ack) ? ChannelMessageAck.fromJSON(object.channel_message_ack) : void 0,\n      channel_message_send: isSet4(object.channel_message_send) ? ChannelMessageSend.fromJSON(object.channel_message_send) : void 0,\n      channel_message_update: isSet4(object.channel_message_update) ? ChannelMessageUpdate.fromJSON(object.channel_message_update) : void 0,\n      channel_message_remove: isSet4(object.channel_message_remove) ? ChannelMessageRemove.fromJSON(object.channel_message_remove) : void 0,\n      channel_presence_event: isSet4(object.channel_presence_event) ? ChannelPresenceEvent.fromJSON(object.channel_presence_event) : void 0,\n      error: isSet4(object.error) ? Error2.fromJSON(object.error) : void 0,\n      notifications: isSet4(object.notifications) ? Notifications.fromJSON(object.notifications) : void 0,\n      rpc: isSet4(object.rpc) ? Rpc.fromJSON(object.rpc) : void 0,\n      status: isSet4(object.status) ? Status.fromJSON(object.status) : void 0,\n      status_follow: isSet4(object.status_follow) ? StatusFollow.fromJSON(object.status_follow) : void 0,\n      status_presence_event: isSet4(object.status_presence_event) ? StatusPresenceEvent.fromJSON(object.status_presence_event) : void 0,\n      status_unfollow: isSet4(object.status_unfollow) ? StatusUnfollow.fromJSON(object.status_unfollow) : void 0,\n      status_update: isSet4(object.status_update) ? StatusUpdate.fromJSON(object.status_update) : void 0,\n      stream_data: isSet4(object.stream_data) ? StreamData.fromJSON(object.stream_data) : void 0,\n      stream_presence_event: isSet4(object.stream_presence_event) ? StreamPresenceEvent.fromJSON(object.stream_presence_event) : void 0,\n      ping: isSet4(object.ping) ? Ping.fromJSON(object.ping) : void 0,\n      pong: isSet4(object.pong) ? Pong.fromJSON(object.pong) : void 0,\n      message_typing_event: isSet4(object.message_typing_event) ? MessageTypingEvent.fromJSON(object.message_typing_event) : void 0,\n      last_seen_message_event: isSet4(object.last_seen_message_event) ? LastSeenMessageEvent.fromJSON(object.last_seen_message_event) : void 0,\n      message_reaction_event: isSet4(object.message_reaction_event) ? MessageReaction.fromJSON(object.message_reaction_event) : void 0,\n      voice_joined_event: isSet4(object.voice_joined_event) ? VoiceJoinedEvent.fromJSON(object.voice_joined_event) : void 0,\n      voice_leaved_event: isSet4(object.voice_leaved_event) ? VoiceLeavedEvent.fromJSON(object.voice_leaved_event) : void 0,\n      voice_started_event: isSet4(object.voice_started_event) ? VoiceStartedEvent.fromJSON(object.voice_started_event) : void 0,\n      voice_ended_event: isSet4(object.voice_ended_event) ? VoiceEndedEvent.fromJSON(object.voice_ended_event) : void 0,\n      channel_created_event: isSet4(object.channel_created_event) ? ChannelCreatedEvent.fromJSON(object.channel_created_event) : void 0,\n      channel_deleted_event: isSet4(object.channel_deleted_event) ? ChannelDeletedEvent.fromJSON(object.channel_deleted_event) : void 0,\n      channel_updated_event: isSet4(object.channel_updated_event) ? ChannelUpdatedEvent.fromJSON(object.channel_updated_event) : void 0,\n      last_pin_message_event: isSet4(object.last_pin_message_event) ? LastPinMessageEvent.fromJSON(object.last_pin_message_event) : void 0,\n      custom_status_event: isSet4(object.custom_status_event) ? CustomStatusEvent.fromJSON(object.custom_status_event) : void 0,\n      user_channel_added_event: isSet4(object.user_channel_added_event) ? UserChannelAdded.fromJSON(object.user_channel_added_event) : void 0,\n      user_channel_removed_event: isSet4(object.user_channel_removed_event) ? UserChannelRemoved.fromJSON(object.user_channel_removed_event) : void 0,\n      user_clan_removed_event: isSet4(object.user_clan_removed_event) ? UserClanRemoved.fromJSON(object.user_clan_removed_event) : void 0,\n      clan_updated_event: isSet4(object.clan_updated_event) ? ClanUpdatedEvent.fromJSON(object.clan_updated_event) : void 0,\n      clan_profile_updated_event: isSet4(object.clan_profile_updated_event) ? ClanProfileUpdatedEvent.fromJSON(object.clan_profile_updated_event) : void 0,\n      clan_name_existed_event: isSet4(object.clan_name_existed_event) ? ClanNameExistedEvent.fromJSON(object.clan_name_existed_event) : void 0,\n      user_profile_updated_event: isSet4(object.user_profile_updated_event) ? UserProfileUpdatedEvent.fromJSON(object.user_profile_updated_event) : void 0,\n      emojis_listed_event: isSet4(object.emojis_listed_event) ? EmojiListedEvent.fromJSON(object.emojis_listed_event) : void 0,\n      sticker_listed_event: isSet4(object.sticker_listed_event) ? StrickerListedEvent.fromJSON(object.sticker_listed_event) : void 0,\n      channel_desc_list_event: isSet4(object.channel_desc_list_event) ? ChannelDescListEvent.fromJSON(object.channel_desc_list_event) : void 0,\n      hashtag_dm_list_event: isSet4(object.hashtag_dm_list_event) ? HashtagDmListEvent.fromJSON(object.hashtag_dm_list_event) : void 0,\n      notification_channel_setting_event: isSet4(object.notification_channel_setting_event) ? NotificationChannelSettingEvent.fromJSON(object.notification_channel_setting_event) : void 0,\n      notification_category_setting_event: isSet4(object.notification_category_setting_event) ? NotificationCategorySettingEvent.fromJSON(object.notification_category_setting_event) : void 0,\n      notification_clan_setting_event: isSet4(object.notification_clan_setting_event) ? NotificationClanSettingEvent.fromJSON(object.notification_clan_setting_event) : void 0,\n      notifi_react_message_event: isSet4(object.notifi_react_message_event) ? NotifiReactMessageEvent.fromJSON(object.notifi_react_message_event) : void 0,\n      permission_role_channel_list_event: isSet4(object.permission_role_channel_list_event) ? PermissionRoleChannelListEvent.fromJSON(object.permission_role_channel_list_event) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.cid !== void 0 && (obj.cid = message.cid);\n    message.channel !== void 0 && (obj.channel = message.channel ? Channel.toJSON(message.channel) : void 0);\n    message.clan_join !== void 0 && (obj.clan_join = message.clan_join ? ClanJoin.toJSON(message.clan_join) : void 0);\n    message.channel_join !== void 0 && (obj.channel_join = message.channel_join ? ChannelJoin.toJSON(message.channel_join) : void 0);\n    message.channel_leave !== void 0 && (obj.channel_leave = message.channel_leave ? ChannelLeave.toJSON(message.channel_leave) : void 0);\n    message.channel_message !== void 0 && (obj.channel_message = message.channel_message ? ChannelMessage.toJSON(message.channel_message) : void 0);\n    message.channel_message_ack !== void 0 && (obj.channel_message_ack = message.channel_message_ack ? ChannelMessageAck.toJSON(message.channel_message_ack) : void 0);\n    message.channel_message_send !== void 0 && (obj.channel_message_send = message.channel_message_send ? ChannelMessageSend.toJSON(message.channel_message_send) : void 0);\n    message.channel_message_update !== void 0 && (obj.channel_message_update = message.channel_message_update ? ChannelMessageUpdate.toJSON(message.channel_message_update) : void 0);\n    message.channel_message_remove !== void 0 && (obj.channel_message_remove = message.channel_message_remove ? ChannelMessageRemove.toJSON(message.channel_message_remove) : void 0);\n    message.channel_presence_event !== void 0 && (obj.channel_presence_event = message.channel_presence_event ? ChannelPresenceEvent.toJSON(message.channel_presence_event) : void 0);\n    message.error !== void 0 && (obj.error = message.error ? Error2.toJSON(message.error) : void 0);\n    message.notifications !== void 0 && (obj.notifications = message.notifications ? Notifications.toJSON(message.notifications) : void 0);\n    message.rpc !== void 0 && (obj.rpc = message.rpc ? Rpc.toJSON(message.rpc) : void 0);\n    message.status !== void 0 && (obj.status = message.status ? Status.toJSON(message.status) : void 0);\n    message.status_follow !== void 0 && (obj.status_follow = message.status_follow ? StatusFollow.toJSON(message.status_follow) : void 0);\n    message.status_presence_event !== void 0 && (obj.status_presence_event = message.status_presence_event ? StatusPresenceEvent.toJSON(message.status_presence_event) : void 0);\n    message.status_unfollow !== void 0 && (obj.status_unfollow = message.status_unfollow ? StatusUnfollow.toJSON(message.status_unfollow) : void 0);\n    message.status_update !== void 0 && (obj.status_update = message.status_update ? StatusUpdate.toJSON(message.status_update) : void 0);\n    message.stream_data !== void 0 && (obj.stream_data = message.stream_data ? StreamData.toJSON(message.stream_data) : void 0);\n    message.stream_presence_event !== void 0 && (obj.stream_presence_event = message.stream_presence_event ? StreamPresenceEvent.toJSON(message.stream_presence_event) : void 0);\n    message.ping !== void 0 && (obj.ping = message.ping ? Ping.toJSON(message.ping) : void 0);\n    message.pong !== void 0 && (obj.pong = message.pong ? Pong.toJSON(message.pong) : void 0);\n    message.message_typing_event !== void 0 && (obj.message_typing_event = message.message_typing_event ? MessageTypingEvent.toJSON(message.message_typing_event) : void 0);\n    message.last_seen_message_event !== void 0 && (obj.last_seen_message_event = message.last_seen_message_event ? LastSeenMessageEvent.toJSON(message.last_seen_message_event) : void 0);\n    message.message_reaction_event !== void 0 && (obj.message_reaction_event = message.message_reaction_event ? MessageReaction.toJSON(message.message_reaction_event) : void 0);\n    message.voice_joined_event !== void 0 && (obj.voice_joined_event = message.voice_joined_event ? VoiceJoinedEvent.toJSON(message.voice_joined_event) : void 0);\n    message.voice_leaved_event !== void 0 && (obj.voice_leaved_event = message.voice_leaved_event ? VoiceLeavedEvent.toJSON(message.voice_leaved_event) : void 0);\n    message.voice_started_event !== void 0 && (obj.voice_started_event = message.voice_started_event ? VoiceStartedEvent.toJSON(message.voice_started_event) : void 0);\n    message.voice_ended_event !== void 0 && (obj.voice_ended_event = message.voice_ended_event ? VoiceEndedEvent.toJSON(message.voice_ended_event) : void 0);\n    message.channel_created_event !== void 0 && (obj.channel_created_event = message.channel_created_event ? ChannelCreatedEvent.toJSON(message.channel_created_event) : void 0);\n    message.channel_deleted_event !== void 0 && (obj.channel_deleted_event = message.channel_deleted_event ? ChannelDeletedEvent.toJSON(message.channel_deleted_event) : void 0);\n    message.channel_updated_event !== void 0 && (obj.channel_updated_event = message.channel_updated_event ? ChannelUpdatedEvent.toJSON(message.channel_updated_event) : void 0);\n    message.last_pin_message_event !== void 0 && (obj.last_pin_message_event = message.last_pin_message_event ? LastPinMessageEvent.toJSON(message.last_pin_message_event) : void 0);\n    message.custom_status_event !== void 0 && (obj.custom_status_event = message.custom_status_event ? CustomStatusEvent.toJSON(message.custom_status_event) : void 0);\n    message.user_channel_added_event !== void 0 && (obj.user_channel_added_event = message.user_channel_added_event ? UserChannelAdded.toJSON(message.user_channel_added_event) : void 0);\n    message.user_channel_removed_event !== void 0 && (obj.user_channel_removed_event = message.user_channel_removed_event ? UserChannelRemoved.toJSON(message.user_channel_removed_event) : void 0);\n    message.user_clan_removed_event !== void 0 && (obj.user_clan_removed_event = message.user_clan_removed_event ? UserClanRemoved.toJSON(message.user_clan_removed_event) : void 0);\n    message.clan_updated_event !== void 0 && (obj.clan_updated_event = message.clan_updated_event ? ClanUpdatedEvent.toJSON(message.clan_updated_event) : void 0);\n    message.clan_profile_updated_event !== void 0 && (obj.clan_profile_updated_event = message.clan_profile_updated_event ? ClanProfileUpdatedEvent.toJSON(message.clan_profile_updated_event) : void 0);\n    message.clan_name_existed_event !== void 0 && (obj.clan_name_existed_event = message.clan_name_existed_event ? ClanNameExistedEvent.toJSON(message.clan_name_existed_event) : void 0);\n    message.user_profile_updated_event !== void 0 && (obj.user_profile_updated_event = message.user_profile_updated_event ? UserProfileUpdatedEvent.toJSON(message.user_profile_updated_event) : void 0);\n    message.emojis_listed_event !== void 0 && (obj.emojis_listed_event = message.emojis_listed_event ? EmojiListedEvent.toJSON(message.emojis_listed_event) : void 0);\n    message.sticker_listed_event !== void 0 && (obj.sticker_listed_event = message.sticker_listed_event ? StrickerListedEvent.toJSON(message.sticker_listed_event) : void 0);\n    message.channel_desc_list_event !== void 0 && (obj.channel_desc_list_event = message.channel_desc_list_event ? ChannelDescListEvent.toJSON(message.channel_desc_list_event) : void 0);\n    message.hashtag_dm_list_event !== void 0 && (obj.hashtag_dm_list_event = message.hashtag_dm_list_event ? HashtagDmListEvent.toJSON(message.hashtag_dm_list_event) : void 0);\n    message.notification_channel_setting_event !== void 0 && (obj.notification_channel_setting_event = message.notification_channel_setting_event ? NotificationChannelSettingEvent.toJSON(message.notification_channel_setting_event) : void 0);\n    message.notification_category_setting_event !== void 0 && (obj.notification_category_setting_event = message.notification_category_setting_event ? NotificationCategorySettingEvent.toJSON(message.notification_category_setting_event) : void 0);\n    message.notification_clan_setting_event !== void 0 && (obj.notification_clan_setting_event = message.notification_clan_setting_event ? NotificationClanSettingEvent.toJSON(message.notification_clan_setting_event) : void 0);\n    message.notifi_react_message_event !== void 0 && (obj.notifi_react_message_event = message.notifi_react_message_event ? NotifiReactMessageEvent.toJSON(message.notifi_react_message_event) : void 0);\n    message.permission_role_channel_list_event !== void 0 && (obj.permission_role_channel_list_event = message.permission_role_channel_list_event ? PermissionRoleChannelListEvent.toJSON(message.permission_role_channel_list_event) : void 0);\n    return obj;\n  },\n  create(base) {\n    return Envelope.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseEnvelope();\n    message.cid = (_a = object.cid) != null ? _a : \"\";\n    message.channel = object.channel !== void 0 && object.channel !== null ? Channel.fromPartial(object.channel) : void 0;\n    message.clan_join = object.clan_join !== void 0 && object.clan_join !== null ? ClanJoin.fromPartial(object.clan_join) : void 0;\n    message.channel_join = object.channel_join !== void 0 && object.channel_join !== null ? ChannelJoin.fromPartial(object.channel_join) : void 0;\n    message.channel_leave = object.channel_leave !== void 0 && object.channel_leave !== null ? ChannelLeave.fromPartial(object.channel_leave) : void 0;\n    message.channel_message = object.channel_message !== void 0 && object.channel_message !== null ? ChannelMessage.fromPartial(object.channel_message) : void 0;\n    message.channel_message_ack = object.channel_message_ack !== void 0 && object.channel_message_ack !== null ? ChannelMessageAck.fromPartial(object.channel_message_ack) : void 0;\n    message.channel_message_send = object.channel_message_send !== void 0 && object.channel_message_send !== null ? ChannelMessageSend.fromPartial(object.channel_message_send) : void 0;\n    message.channel_message_update = object.channel_message_update !== void 0 && object.channel_message_update !== null ? ChannelMessageUpdate.fromPartial(object.channel_message_update) : void 0;\n    message.channel_message_remove = object.channel_message_remove !== void 0 && object.channel_message_remove !== null ? ChannelMessageRemove.fromPartial(object.channel_message_remove) : void 0;\n    message.channel_presence_event = object.channel_presence_event !== void 0 && object.channel_presence_event !== null ? ChannelPresenceEvent.fromPartial(object.channel_presence_event) : void 0;\n    message.error = object.error !== void 0 && object.error !== null ? Error2.fromPartial(object.error) : void 0;\n    message.notifications = object.notifications !== void 0 && object.notifications !== null ? Notifications.fromPartial(object.notifications) : void 0;\n    message.rpc = object.rpc !== void 0 && object.rpc !== null ? Rpc.fromPartial(object.rpc) : void 0;\n    message.status = object.status !== void 0 && object.status !== null ? Status.fromPartial(object.status) : void 0;\n    message.status_follow = object.status_follow !== void 0 && object.status_follow !== null ? StatusFollow.fromPartial(object.status_follow) : void 0;\n    message.status_presence_event = object.status_presence_event !== void 0 && object.status_presence_event !== null ? StatusPresenceEvent.fromPartial(object.status_presence_event) : void 0;\n    message.status_unfollow = object.status_unfollow !== void 0 && object.status_unfollow !== null ? StatusUnfollow.fromPartial(object.status_unfollow) : void 0;\n    message.status_update = object.status_update !== void 0 && object.status_update !== null ? StatusUpdate.fromPartial(object.status_update) : void 0;\n    message.stream_data = object.stream_data !== void 0 && object.stream_data !== null ? StreamData.fromPartial(object.stream_data) : void 0;\n    message.stream_presence_event = object.stream_presence_event !== void 0 && object.stream_presence_event !== null ? StreamPresenceEvent.fromPartial(object.stream_presence_event) : void 0;\n    message.ping = object.ping !== void 0 && object.ping !== null ? Ping.fromPartial(object.ping) : void 0;\n    message.pong = object.pong !== void 0 && object.pong !== null ? Pong.fromPartial(object.pong) : void 0;\n    message.message_typing_event = object.message_typing_event !== void 0 && object.message_typing_event !== null ? MessageTypingEvent.fromPartial(object.message_typing_event) : void 0;\n    message.last_seen_message_event = object.last_seen_message_event !== void 0 && object.last_seen_message_event !== null ? LastSeenMessageEvent.fromPartial(object.last_seen_message_event) : void 0;\n    message.message_reaction_event = object.message_reaction_event !== void 0 && object.message_reaction_event !== null ? MessageReaction.fromPartial(object.message_reaction_event) : void 0;\n    message.voice_joined_event = object.voice_joined_event !== void 0 && object.voice_joined_event !== null ? VoiceJoinedEvent.fromPartial(object.voice_joined_event) : void 0;\n    message.voice_leaved_event = object.voice_leaved_event !== void 0 && object.voice_leaved_event !== null ? VoiceLeavedEvent.fromPartial(object.voice_leaved_event) : void 0;\n    message.voice_started_event = object.voice_started_event !== void 0 && object.voice_started_event !== null ? VoiceStartedEvent.fromPartial(object.voice_started_event) : void 0;\n    message.voice_ended_event = object.voice_ended_event !== void 0 && object.voice_ended_event !== null ? VoiceEndedEvent.fromPartial(object.voice_ended_event) : void 0;\n    message.channel_created_event = object.channel_created_event !== void 0 && object.channel_created_event !== null ? ChannelCreatedEvent.fromPartial(object.channel_created_event) : void 0;\n    message.channel_deleted_event = object.channel_deleted_event !== void 0 && object.channel_deleted_event !== null ? ChannelDeletedEvent.fromPartial(object.channel_deleted_event) : void 0;\n    message.channel_updated_event = object.channel_updated_event !== void 0 && object.channel_updated_event !== null ? ChannelUpdatedEvent.fromPartial(object.channel_updated_event) : void 0;\n    message.last_pin_message_event = object.last_pin_message_event !== void 0 && object.last_pin_message_event !== null ? LastPinMessageEvent.fromPartial(object.last_pin_message_event) : void 0;\n    message.custom_status_event = object.custom_status_event !== void 0 && object.custom_status_event !== null ? CustomStatusEvent.fromPartial(object.custom_status_event) : void 0;\n    message.user_channel_added_event = object.user_channel_added_event !== void 0 && object.user_channel_added_event !== null ? UserChannelAdded.fromPartial(object.user_channel_added_event) : void 0;\n    message.user_channel_removed_event = object.user_channel_removed_event !== void 0 && object.user_channel_removed_event !== null ? UserChannelRemoved.fromPartial(object.user_channel_removed_event) : void 0;\n    message.user_clan_removed_event = object.user_clan_removed_event !== void 0 && object.user_clan_removed_event !== null ? UserClanRemoved.fromPartial(object.user_clan_removed_event) : void 0;\n    message.clan_updated_event = object.clan_updated_event !== void 0 && object.clan_updated_event !== null ? ClanUpdatedEvent.fromPartial(object.clan_updated_event) : void 0;\n    message.clan_profile_updated_event = object.clan_profile_updated_event !== void 0 && object.clan_profile_updated_event !== null ? ClanProfileUpdatedEvent.fromPartial(object.clan_profile_updated_event) : void 0;\n    message.clan_name_existed_event = object.clan_name_existed_event !== void 0 && object.clan_name_existed_event !== null ? ClanNameExistedEvent.fromPartial(object.clan_name_existed_event) : void 0;\n    message.user_profile_updated_event = object.user_profile_updated_event !== void 0 && object.user_profile_updated_event !== null ? UserProfileUpdatedEvent.fromPartial(object.user_profile_updated_event) : void 0;\n    message.emojis_listed_event = object.emojis_listed_event !== void 0 && object.emojis_listed_event !== null ? EmojiListedEvent.fromPartial(object.emojis_listed_event) : void 0;\n    message.sticker_listed_event = object.sticker_listed_event !== void 0 && object.sticker_listed_event !== null ? StrickerListedEvent.fromPartial(object.sticker_listed_event) : void 0;\n    message.channel_desc_list_event = object.channel_desc_list_event !== void 0 && object.channel_desc_list_event !== null ? ChannelDescListEvent.fromPartial(object.channel_desc_list_event) : void 0;\n    message.hashtag_dm_list_event = object.hashtag_dm_list_event !== void 0 && object.hashtag_dm_list_event !== null ? HashtagDmListEvent.fromPartial(object.hashtag_dm_list_event) : void 0;\n    message.notification_channel_setting_event = object.notification_channel_setting_event !== void 0 && object.notification_channel_setting_event !== null ? NotificationChannelSettingEvent.fromPartial(object.notification_channel_setting_event) : void 0;\n    message.notification_category_setting_event = object.notification_category_setting_event !== void 0 && object.notification_category_setting_event !== null ? NotificationCategorySettingEvent.fromPartial(object.notification_category_setting_event) : void 0;\n    message.notification_clan_setting_event = object.notification_clan_setting_event !== void 0 && object.notification_clan_setting_event !== null ? NotificationClanSettingEvent.fromPartial(object.notification_clan_setting_event) : void 0;\n    message.notifi_react_message_event = object.notifi_react_message_event !== void 0 && object.notifi_react_message_event !== null ? NotifiReactMessageEvent.fromPartial(object.notifi_react_message_event) : void 0;\n    message.permission_role_channel_list_event = object.permission_role_channel_list_event !== void 0 && object.permission_role_channel_list_event !== null ? PermissionRoleChannelListEvent.fromPartial(object.permission_role_channel_list_event) : void 0;\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannelListEvent() {\n  return { role_id: \"\", channel_id: \"\", permission_role_channel: [] };\n}\nvar PermissionRoleChannelListEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.role_id !== \"\") {\n      writer.uint32(10).string(message.role_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    for (const v of message.permission_role_channel) {\n      PermissionRoleChannel.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannelListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.role_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.permission_role_channel.push(PermissionRoleChannel.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_id: isSet4(object.role_id) ? String(object.role_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      permission_role_channel: Array.isArray(object == null ? void 0 : object.permission_role_channel) ? object.permission_role_channel.map((e) => PermissionRoleChannel.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.role_id !== void 0 && (obj.role_id = message.role_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    if (message.permission_role_channel) {\n      obj.permission_role_channel = message.permission_role_channel.map(\n        (e) => e ? PermissionRoleChannel.toJSON(e) : void 0\n      );\n    } else {\n      obj.permission_role_channel = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannelListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBasePermissionRoleChannelListEvent();\n    message.role_id = (_a = object.role_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.permission_role_channel = ((_c = object.permission_role_channel) == null ? void 0 : _c.map((e) => PermissionRoleChannel.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannel() {\n  return { permission_id: \"\", active: false };\n}\nvar PermissionRoleChannel = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.permission_id !== \"\") {\n      writer.uint32(10).string(message.permission_id);\n    }\n    if (message.active === true) {\n      writer.uint32(16).bool(message.active);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.permission_id = reader.string();\n          break;\n        case 2:\n          message.active = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      permission_id: isSet4(object.permission_id) ? String(object.permission_id) : \"\",\n      active: isSet4(object.active) ? Boolean(object.active) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.permission_id !== void 0 && (obj.permission_id = message.permission_id);\n    message.active !== void 0 && (obj.active = message.active);\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePermissionRoleChannel();\n    message.permission_id = (_a = object.permission_id) != null ? _a : \"\";\n    message.active = (_b = object.active) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBaseHashtagDmListEvent() {\n  return { user_id: [], limit: void 0, hashtag_dm: [] };\n}\nvar HashtagDmListEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.user_id) {\n      writer.uint32(10).string(v);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.hashtag_dm) {\n      HashtagDm.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDmListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_id.push(reader.string());\n          break;\n        case 2:\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          break;\n        case 3:\n          message.hashtag_dm.push(HashtagDm.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: Array.isArray(object == null ? void 0 : object.user_id) ? object.user_id.map((e) => String(e)) : [],\n      limit: isSet4(object.limit) ? Number(object.limit) : void 0,\n      hashtag_dm: Array.isArray(object == null ? void 0 : object.hashtag_dm) ? object.hashtag_dm.map((e) => HashtagDm.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id) {\n      obj.user_id = message.user_id.map((e) => e);\n    } else {\n      obj.user_id = [];\n    }\n    message.limit !== void 0 && (obj.limit = message.limit);\n    if (message.hashtag_dm) {\n      obj.hashtag_dm = message.hashtag_dm.map((e) => e ? HashtagDm.toJSON(e) : void 0);\n    } else {\n      obj.hashtag_dm = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDmListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseHashtagDmListEvent();\n    message.user_id = ((_a = object.user_id) == null ? void 0 : _a.map((e) => e)) || [];\n    message.limit = (_b = object.limit) != null ? _b : void 0;\n    message.hashtag_dm = ((_c = object.hashtag_dm) == null ? void 0 : _c.map((e) => HashtagDm.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseHashtagDm() {\n  return {\n    channel_id: \"\",\n    channel_label: \"\",\n    clan_id: \"\",\n    clan_name: \"\",\n    meeting_code: \"\",\n    type: 0,\n    channel_private: 0,\n    parrent_id: \"\"\n  };\n}\nvar HashtagDm = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(18).string(message.channel_label);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(34).string(message.clan_name);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(42).string(message.meeting_code);\n    }\n    if (message.type !== 0) {\n      writer.uint32(48).int32(message.type);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(66).string(message.parrent_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDm();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.channel_label = reader.string();\n          break;\n        case 3:\n          message.clan_id = reader.string();\n          break;\n        case 4:\n          message.clan_name = reader.string();\n          break;\n        case 5:\n          message.meeting_code = reader.string();\n          break;\n        case 6:\n          message.type = reader.int32();\n          break;\n        case 7:\n          message.channel_private = reader.int32();\n          break;\n        case 8:\n          message.parrent_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? String(object.channel_label) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? String(object.clan_name) : \"\",\n      meeting_code: isSet4(object.meeting_code) ? String(object.meeting_code) : \"\",\n      type: isSet4(object.type) ? Number(object.type) : 0,\n      channel_private: isSet4(object.channel_private) ? Number(object.channel_private) : 0,\n      parrent_id: isSet4(object.parrent_id) ? String(object.parrent_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.channel_label !== void 0 && (obj.channel_label = message.channel_label);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.clan_name !== void 0 && (obj.clan_name = message.clan_name);\n    message.meeting_code !== void 0 && (obj.meeting_code = message.meeting_code);\n    message.type !== void 0 && (obj.type = Math.round(message.type));\n    message.channel_private !== void 0 && (obj.channel_private = Math.round(message.channel_private));\n    message.parrent_id !== void 0 && (obj.parrent_id = message.parrent_id);\n    return obj;\n  },\n  create(base) {\n    return HashtagDm.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseHashtagDm();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.channel_label = (_b = object.channel_label) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.clan_name = (_d = object.clan_name) != null ? _d : \"\";\n    message.meeting_code = (_e = object.meeting_code) != null ? _e : \"\";\n    message.type = (_f = object.type) != null ? _f : 0;\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.parrent_id = (_h = object.parrent_id) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelDescListEvent() {\n  return { channeldesc: [] };\n}\nvar ChannelDescListEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.channeldesc) {\n      ChannelDescription.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channeldesc: Array.isArray(object == null ? void 0 : object.channeldesc) ? object.channeldesc.map((e) => ChannelDescription.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channeldesc) {\n      obj.channeldesc = message.channeldesc.map((e) => e ? ChannelDescription.toJSON(e) : void 0);\n    } else {\n      obj.channeldesc = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDescListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseChannelDescListEvent();\n    message.channeldesc = ((_a = object.channeldesc) == null ? void 0 : _a.map((e) => ChannelDescription.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseChannelDescription() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    type: void 0,\n    channel_label: \"\",\n    channel_private: 0,\n    meeting_code: \"\",\n    clan_name: \"\",\n    parrent_id: \"\"\n  };\n}\nvar ChannelDescription = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.type !== void 0) {\n      Int32Value.encode({ value: message.type }, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(34).string(message.channel_label);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(40).int32(message.channel_private);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(50).string(message.meeting_code);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(58).string(message.clan_name);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(66).string(message.parrent_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescription();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.type = Int32Value.decode(reader, reader.uint32()).value;\n          break;\n        case 4:\n          message.channel_label = reader.string();\n          break;\n        case 5:\n          message.channel_private = reader.int32();\n          break;\n        case 6:\n          message.meeting_code = reader.string();\n          break;\n        case 7:\n          message.clan_name = reader.string();\n          break;\n        case 8:\n          message.parrent_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      type: isSet4(object.type) ? Number(object.type) : void 0,\n      channel_label: isSet4(object.channel_label) ? String(object.channel_label) : \"\",\n      channel_private: isSet4(object.channel_private) ? Number(object.channel_private) : 0,\n      meeting_code: isSet4(object.meeting_code) ? String(object.meeting_code) : \"\",\n      clan_name: isSet4(object.clan_name) ? String(object.clan_name) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? String(object.parrent_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.type !== void 0 && (obj.type = message.type);\n    message.channel_label !== void 0 && (obj.channel_label = message.channel_label);\n    message.channel_private !== void 0 && (obj.channel_private = Math.round(message.channel_private));\n    message.meeting_code !== void 0 && (obj.meeting_code = message.meeting_code);\n    message.clan_name !== void 0 && (obj.clan_name = message.clan_name);\n    message.parrent_id !== void 0 && (obj.parrent_id = message.parrent_id);\n    return obj;\n  },\n  create(base) {\n    return ChannelDescription.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseChannelDescription();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.type = (_c = object.type) != null ? _c : void 0;\n    message.channel_label = (_d = object.channel_label) != null ? _d : \"\";\n    message.channel_private = (_e = object.channel_private) != null ? _e : 0;\n    message.meeting_code = (_f = object.meeting_code) != null ? _f : \"\";\n    message.clan_name = (_g = object.clan_name) != null ? _g : \"\";\n    message.parrent_id = (_h = object.parrent_id) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseStrickerListedEvent() {\n  return { clan_id: \"\", stickers: [] };\n}\nvar StrickerListedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    for (const v of message.stickers) {\n      ClanSticker.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStrickerListedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.stickers.push(ClanSticker.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      stickers: Array.isArray(object == null ? void 0 : object.stickers) ? object.stickers.map((e) => ClanSticker.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    if (message.stickers) {\n      obj.stickers = message.stickers.map((e) => e ? ClanSticker.toJSON(e) : void 0);\n    } else {\n      obj.stickers = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StrickerListedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStrickerListedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.stickers = ((_b = object.stickers) == null ? void 0 : _b.map((e) => ClanSticker.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseClanSticker() {\n  return { id: \"\", source: \"\", shortname: \"\", category: \"\", creator_id: \"\", create_time: void 0, clan_id: \"\" };\n}\nvar ClanSticker = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(18).string(message.source);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(58).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanSticker();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.source = reader.string();\n          break;\n        case 3:\n          message.shortname = reader.string();\n          break;\n        case 4:\n          message.category = reader.string();\n          break;\n        case 5:\n          message.creator_id = reader.string();\n          break;\n        case 6:\n          message.create_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.clan_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      source: isSet4(object.source) ? String(object.source) : \"\",\n      shortname: isSet4(object.shortname) ? String(object.shortname) : \"\",\n      category: isSet4(object.category) ? String(object.category) : \"\",\n      creator_id: isSet4(object.creator_id) ? String(object.creator_id) : \"\",\n      create_time: isSet4(object.create_time) ? fromJsonTimestamp2(object.create_time) : void 0,\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.source !== void 0 && (obj.source = message.source);\n    message.shortname !== void 0 && (obj.shortname = message.shortname);\n    message.category !== void 0 && (obj.category = message.category);\n    message.creator_id !== void 0 && (obj.creator_id = message.creator_id);\n    message.create_time !== void 0 && (obj.create_time = message.create_time.toISOString());\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    return obj;\n  },\n  create(base) {\n    return ClanSticker.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseClanSticker();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.source = (_b = object.source) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.clan_id = (_g = object.clan_id) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseClanEmoji() {\n  return { id: \"\", src: \"\", shortname: \"\", category: \"\", creator_id: \"\" };\n}\nvar ClanEmoji = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.src !== \"\") {\n      writer.uint32(18).string(message.src);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanEmoji();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.src = reader.string();\n          break;\n        case 3:\n          message.shortname = reader.string();\n          break;\n        case 4:\n          message.category = reader.string();\n          break;\n        case 5:\n          message.creator_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      src: isSet4(object.src) ? String(object.src) : \"\",\n      shortname: isSet4(object.shortname) ? String(object.shortname) : \"\",\n      category: isSet4(object.category) ? String(object.category) : \"\",\n      creator_id: isSet4(object.creator_id) ? String(object.creator_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.src !== void 0 && (obj.src = message.src);\n    message.shortname !== void 0 && (obj.shortname = message.shortname);\n    message.category !== void 0 && (obj.category = message.category);\n    message.creator_id !== void 0 && (obj.creator_id = message.creator_id);\n    return obj;\n  },\n  create(base) {\n    return ClanEmoji.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseClanEmoji();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.src = (_b = object.src) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseEmojiListedEvent() {\n  return { clan_id: \"\", emoji_list: [] };\n}\nvar EmojiListedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    for (const v of message.emoji_list) {\n      ClanEmoji.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEmojiListedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.emoji_list.push(ClanEmoji.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      emoji_list: Array.isArray(object == null ? void 0 : object.emoji_list) ? object.emoji_list.map((e) => ClanEmoji.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    if (message.emoji_list) {\n      obj.emoji_list = message.emoji_list.map((e) => e ? ClanEmoji.toJSON(e) : void 0);\n    } else {\n      obj.emoji_list = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return EmojiListedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseEmojiListedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.emoji_list = ((_b = object.emoji_list) == null ? void 0 : _b.map((e) => ClanEmoji.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseChannel() {\n  return { id: \"\", presences: [], self: void 0, chanel_label: \"\", clan_logo: \"\", category_name: \"\" };\n}\nvar Channel = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    for (const v of message.presences) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.self !== void 0) {\n      UserPresence.encode(message.self, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.chanel_label !== \"\") {\n      writer.uint32(34).string(message.chanel_label);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(42).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(50).string(message.category_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.presences.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.self = UserPresence.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.chanel_label = reader.string();\n          break;\n        case 5:\n          message.clan_logo = reader.string();\n          break;\n        case 6:\n          message.category_name = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      presences: Array.isArray(object == null ? void 0 : object.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : [],\n      self: isSet4(object.self) ? UserPresence.fromJSON(object.self) : void 0,\n      chanel_label: isSet4(object.chanel_label) ? String(object.chanel_label) : \"\",\n      clan_logo: isSet4(object.clan_logo) ? String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? String(object.category_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    if (message.presences) {\n      obj.presences = message.presences.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.presences = [];\n    }\n    message.self !== void 0 && (obj.self = message.self ? UserPresence.toJSON(message.self) : void 0);\n    message.chanel_label !== void 0 && (obj.chanel_label = message.chanel_label);\n    message.clan_logo !== void 0 && (obj.clan_logo = message.clan_logo);\n    message.category_name !== void 0 && (obj.category_name = message.category_name);\n    return obj;\n  },\n  create(base) {\n    return Channel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannel();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.presences = ((_b = object.presences) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    message.self = object.self !== void 0 && object.self !== null ? UserPresence.fromPartial(object.self) : void 0;\n    message.chanel_label = (_c = object.chanel_label) != null ? _c : \"\";\n    message.clan_logo = (_d = object.clan_logo) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseClanJoin() {\n  return { clan_id: \"\" };\n}\nvar ClanJoin = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanJoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    return obj;\n  },\n  create(base) {\n    return ClanJoin.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseClanJoin();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelJoin() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0 };\n}\nvar ChannelJoin = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelJoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.channel_type = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.channel_type !== void 0 && (obj.channel_type = Math.round(message.channel_type));\n    return obj;\n  },\n  create(base) {\n    return ChannelJoin.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseChannelJoin();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseChannelLeave() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0 };\n}\nvar ChannelLeave = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelLeave();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.channel_type = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.channel_type !== void 0 && (obj.channel_type = Math.round(message.channel_type));\n    return obj;\n  },\n  create(base) {\n    return ChannelLeave.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseChannelLeave();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseChannelMessageAck() {\n  return {\n    channel_id: \"\",\n    message_id: \"\",\n    code: void 0,\n    username: \"\",\n    create_time: void 0,\n    update_time: void 0,\n    persistent: void 0,\n    clan_logo: \"\",\n    category_name: \"\"\n  };\n}\nvar ChannelMessageAck = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(18).string(message.message_id);\n    }\n    if (message.code !== void 0) {\n      Int32Value.encode({ value: message.code }, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.username !== \"\") {\n      writer.uint32(34).string(message.username);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.create_time), writer.uint32(42).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.update_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.persistent !== void 0) {\n      BoolValue.encode({ value: message.persistent }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(66).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(74).string(message.category_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageAck();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.message_id = reader.string();\n          break;\n        case 3:\n          message.code = Int32Value.decode(reader, reader.uint32()).value;\n          break;\n        case 4:\n          message.username = reader.string();\n          break;\n        case 5:\n          message.create_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.update_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.persistent = BoolValue.decode(reader, reader.uint32()).value;\n          break;\n        case 8:\n          message.clan_logo = reader.string();\n          break;\n        case 9:\n          message.category_name = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? String(object.message_id) : \"\",\n      code: isSet4(object.code) ? Number(object.code) : void 0,\n      username: isSet4(object.username) ? String(object.username) : \"\",\n      create_time: isSet4(object.create_time) ? fromJsonTimestamp2(object.create_time) : void 0,\n      update_time: isSet4(object.update_time) ? fromJsonTimestamp2(object.update_time) : void 0,\n      persistent: isSet4(object.persistent) ? Boolean(object.persistent) : void 0,\n      clan_logo: isSet4(object.clan_logo) ? String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? String(object.category_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.code !== void 0 && (obj.code = message.code);\n    message.username !== void 0 && (obj.username = message.username);\n    message.create_time !== void 0 && (obj.create_time = message.create_time.toISOString());\n    message.update_time !== void 0 && (obj.update_time = message.update_time.toISOString());\n    message.persistent !== void 0 && (obj.persistent = message.persistent);\n    message.clan_logo !== void 0 && (obj.clan_logo = message.clan_logo);\n    message.category_name !== void 0 && (obj.category_name = message.category_name);\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageAck.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseChannelMessageAck();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.message_id = (_b = object.message_id) != null ? _b : \"\";\n    message.code = (_c = object.code) != null ? _c : void 0;\n    message.username = (_d = object.username) != null ? _d : \"\";\n    message.create_time = (_e = object.create_time) != null ? _e : void 0;\n    message.update_time = (_f = object.update_time) != null ? _f : void 0;\n    message.persistent = (_g = object.persistent) != null ? _g : void 0;\n    message.clan_logo = (_h = object.clan_logo) != null ? _h : \"\";\n    message.category_name = (_i = object.category_name) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelMessageSend() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    content: \"\",\n    mentions: [],\n    attachments: [],\n    references: [],\n    mode: 0,\n    anonymous_message: false,\n    mention_everyone: false,\n    avatar: \"\"\n  };\n}\nvar ChannelMessageSend = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    for (const v of message.mentions) {\n      MessageMention.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    for (const v of message.attachments) {\n      MessageAttachment.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    for (const v of message.references) {\n      MessageRef.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.mode !== 0) {\n      writer.uint32(56).int32(message.mode);\n    }\n    if (message.anonymous_message === true) {\n      writer.uint32(64).bool(message.anonymous_message);\n    }\n    if (message.mention_everyone === true) {\n      writer.uint32(72).bool(message.mention_everyone);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(82).string(message.avatar);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.content = reader.string();\n          break;\n        case 4:\n          message.mentions.push(MessageMention.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.references.push(MessageRef.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.mode = reader.int32();\n          break;\n        case 8:\n          message.anonymous_message = reader.bool();\n          break;\n        case 9:\n          message.mention_everyone = reader.bool();\n          break;\n        case 10:\n          message.avatar = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      content: isSet4(object.content) ? String(object.content) : \"\",\n      mentions: Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => MessageMention.fromJSON(e)) : [],\n      attachments: Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => MessageAttachment.fromJSON(e)) : [],\n      references: Array.isArray(object == null ? void 0 : object.references) ? object.references.map((e) => MessageRef.fromJSON(e)) : [],\n      mode: isSet4(object.mode) ? Number(object.mode) : 0,\n      anonymous_message: isSet4(object.anonymous_message) ? Boolean(object.anonymous_message) : false,\n      mention_everyone: isSet4(object.mention_everyone) ? Boolean(object.mention_everyone) : false,\n      avatar: isSet4(object.avatar) ? String(object.avatar) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.content !== void 0 && (obj.content = message.content);\n    if (message.mentions) {\n      obj.mentions = message.mentions.map((e) => e ? MessageMention.toJSON(e) : void 0);\n    } else {\n      obj.mentions = [];\n    }\n    if (message.attachments) {\n      obj.attachments = message.attachments.map((e) => e ? MessageAttachment.toJSON(e) : void 0);\n    } else {\n      obj.attachments = [];\n    }\n    if (message.references) {\n      obj.references = message.references.map((e) => e ? MessageRef.toJSON(e) : void 0);\n    } else {\n      obj.references = [];\n    }\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.anonymous_message !== void 0 && (obj.anonymous_message = message.anonymous_message);\n    message.mention_everyone !== void 0 && (obj.mention_everyone = message.mention_everyone);\n    message.avatar !== void 0 && (obj.avatar = message.avatar);\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageSend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseChannelMessageSend();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.mentions = ((_d = object.mentions) == null ? void 0 : _d.map((e) => MessageMention.fromPartial(e))) || [];\n    message.attachments = ((_e = object.attachments) == null ? void 0 : _e.map((e) => MessageAttachment.fromPartial(e))) || [];\n    message.references = ((_f = object.references) == null ? void 0 : _f.map((e) => MessageRef.fromPartial(e))) || [];\n    message.mode = (_g = object.mode) != null ? _g : 0;\n    message.anonymous_message = (_h = object.anonymous_message) != null ? _h : false;\n    message.mention_everyone = (_i = object.mention_everyone) != null ? _i : false;\n    message.avatar = (_j = object.avatar) != null ? _j : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelMessageUpdate() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    content: \"\",\n    mentions: [],\n    attachments: [],\n    mode: 0,\n    hide_editted: false\n  };\n}\nvar ChannelMessageUpdate = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(34).string(message.content);\n    }\n    for (const v of message.mentions) {\n      MessageMention.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    for (const v of message.attachments) {\n      MessageAttachment.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.mode !== 0) {\n      writer.uint32(56).int32(message.mode);\n    }\n    if (message.hide_editted === true) {\n      writer.uint32(64).bool(message.hide_editted);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.message_id = reader.string();\n          break;\n        case 4:\n          message.content = reader.string();\n          break;\n        case 5:\n          message.mentions.push(MessageMention.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));\n          break;\n        case 7:\n          message.mode = reader.int32();\n          break;\n        case 8:\n          message.hide_editted = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? String(object.message_id) : \"\",\n      content: isSet4(object.content) ? String(object.content) : \"\",\n      mentions: Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => MessageMention.fromJSON(e)) : [],\n      attachments: Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => MessageAttachment.fromJSON(e)) : [],\n      mode: isSet4(object.mode) ? Number(object.mode) : 0,\n      hide_editted: isSet4(object.hide_editted) ? Boolean(object.hide_editted) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.content !== void 0 && (obj.content = message.content);\n    if (message.mentions) {\n      obj.mentions = message.mentions.map((e) => e ? MessageMention.toJSON(e) : void 0);\n    } else {\n      obj.mentions = [];\n    }\n    if (message.attachments) {\n      obj.attachments = message.attachments.map((e) => e ? MessageAttachment.toJSON(e) : void 0);\n    } else {\n      obj.attachments = [];\n    }\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.hide_editted !== void 0 && (obj.hide_editted = message.hide_editted);\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseChannelMessageUpdate();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.content = (_d = object.content) != null ? _d : \"\";\n    message.mentions = ((_e = object.mentions) == null ? void 0 : _e.map((e) => MessageMention.fromPartial(e))) || [];\n    message.attachments = ((_f = object.attachments) == null ? void 0 : _f.map((e) => MessageAttachment.fromPartial(e))) || [];\n    message.mode = (_g = object.mode) != null ? _g : 0;\n    message.hide_editted = (_h = object.hide_editted) != null ? _h : false;\n    return message;\n  }\n};\nfunction createBaseChannelMessageRemove() {\n  return { clan_id: \"\", channel_id: \"\", message_id: \"\", mode: 0 };\n}\nvar ChannelMessageRemove = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageRemove();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.message_id = reader.string();\n          break;\n        case 4:\n          message.mode = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? Number(object.mode) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageRemove.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseChannelMessageRemove();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseChannelPresenceEvent() {\n  return { channel_id: \"\", joins: [], leaves: [], clan_logo: \"\", category_name: \"\", mode: 0 };\n}\nvar ChannelPresenceEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(34).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(42).string(message.category_name);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(48).int32(message.mode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.clan_logo = reader.string();\n          break;\n        case 5:\n          message.category_name = reader.string();\n          break;\n        case 6:\n          message.mode = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      joins: Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : [],\n      clan_logo: isSet4(object.clan_logo) ? String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? String(object.category_name) : \"\",\n      mode: isSet4(object.mode) ? Number(object.mode) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    if (message.joins) {\n      obj.joins = message.joins.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.joins = [];\n    }\n    if (message.leaves) {\n      obj.leaves = message.leaves.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.leaves = [];\n    }\n    message.clan_logo !== void 0 && (obj.clan_logo = message.clan_logo);\n    message.category_name !== void 0 && (obj.category_name = message.category_name);\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    return obj;\n  },\n  create(base) {\n    return ChannelPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseChannelPresenceEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.joins = ((_b = object.joins) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_c = object.leaves) == null ? void 0 : _c.map((e) => UserPresence.fromPartial(e))) || [];\n    message.clan_logo = (_d = object.clan_logo) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    message.mode = (_f = object.mode) != null ? _f : 0;\n    return message;\n  }\n};\nfunction createBaseError() {\n  return { code: 0, message: \"\", context: {} };\n}\nvar Error2 = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).int32(message.code);\n    }\n    if (message.message !== \"\") {\n      writer.uint32(18).string(message.message);\n    }\n    Object.entries(message.context).forEach(([key, value]) => {\n      Error_ContextEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();\n    });\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseError();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.int32();\n          break;\n        case 2:\n          message.message = reader.string();\n          break;\n        case 3:\n          const entry3 = Error_ContextEntry.decode(reader, reader.uint32());\n          if (entry3.value !== void 0) {\n            message.context[entry3.key] = entry3.value;\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      code: isSet4(object.code) ? Number(object.code) : 0,\n      message: isSet4(object.message) ? String(object.message) : \"\",\n      context: isObject(object.context) ? Object.entries(object.context).reduce((acc, [key, value]) => {\n        acc[key] = String(value);\n        return acc;\n      }, {}) : {}\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.code !== void 0 && (obj.code = Math.round(message.code));\n    message.message !== void 0 && (obj.message = message.message);\n    obj.context = {};\n    if (message.context) {\n      Object.entries(message.context).forEach(([k, v]) => {\n        obj.context[k] = v;\n      });\n    }\n    return obj;\n  },\n  create(base) {\n    return Error2.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseError();\n    message.code = (_a = object.code) != null ? _a : 0;\n    message.message = (_b = object.message) != null ? _b : \"\";\n    message.context = Object.entries((_c = object.context) != null ? _c : {}).reduce((acc, [key, value]) => {\n      if (value !== void 0) {\n        acc[key] = String(value);\n      }\n      return acc;\n    }, {});\n    return message;\n  }\n};\nfunction createBaseError_ContextEntry() {\n  return { key: \"\", value: \"\" };\n}\nvar Error_ContextEntry = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseError_ContextEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.value = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { key: isSet4(object.key) ? String(object.key) : \"\", value: isSet4(object.value) ? String(object.value) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== void 0 && (obj.key = message.key);\n    message.value !== void 0 && (obj.value = message.value);\n    return obj;\n  },\n  create(base) {\n    return Error_ContextEntry.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseError_ContextEntry();\n    message.key = (_a = object.key) != null ? _a : \"\";\n    message.value = (_b = object.value) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseNotifications() {\n  return { notifications: [] };\n}\nvar Notifications = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.notifications) {\n      Notification.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifications();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.notifications.push(Notification.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      notifications: Array.isArray(object == null ? void 0 : object.notifications) ? object.notifications.map((e) => Notification.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.notifications) {\n      obj.notifications = message.notifications.map((e) => e ? Notification.toJSON(e) : void 0);\n    } else {\n      obj.notifications = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return Notifications.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotifications();\n    message.notifications = ((_a = object.notifications) == null ? void 0 : _a.map((e) => Notification.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBasePing() {\n  return {};\n}\nvar Ping = {\n  encode(_, writer = import_minimal4.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePing();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return Ping.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBasePing();\n    return message;\n  }\n};\nfunction createBasePong() {\n  return {};\n}\nvar Pong = {\n  encode(_, writer = import_minimal4.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePong();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return Pong.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBasePong();\n    return message;\n  }\n};\nfunction createBaseStatus() {\n  return { presences: [] };\n}\nvar Status = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.presences) {\n      UserPresence.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatus();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.presences.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      presences: Array.isArray(object == null ? void 0 : object.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.presences) {\n      obj.presences = message.presences.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.presences = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return Status.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatus();\n    message.presences = ((_a = object.presences) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseStatusFollow() {\n  return { user_ids: [], usernames: [] };\n}\nvar StatusFollow = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.user_ids) {\n      writer.uint32(10).string(v);\n    }\n    for (const v of message.usernames) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusFollow();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_ids.push(reader.string());\n          break;\n        case 2:\n          message.usernames.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_ids: Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => String(e)) : [],\n      usernames: Array.isArray(object == null ? void 0 : object.usernames) ? object.usernames.map((e) => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_ids) {\n      obj.user_ids = message.user_ids.map((e) => e);\n    } else {\n      obj.user_ids = [];\n    }\n    if (message.usernames) {\n      obj.usernames = message.usernames.map((e) => e);\n    } else {\n      obj.usernames = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusFollow.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStatusFollow();\n    message.user_ids = ((_a = object.user_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    message.usernames = ((_b = object.usernames) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseStatusPresenceEvent() {\n  return { joins: [], leaves: [] };\n}\nvar StatusPresenceEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      joins: Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.joins) {\n      obj.joins = message.joins.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.joins = [];\n    }\n    if (message.leaves) {\n      obj.leaves = message.leaves.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.leaves = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStatusPresenceEvent();\n    message.joins = ((_a = object.joins) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_b = object.leaves) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseLastPinMessageEvent() {\n  return { clan_id: \"\", channel_id: \"\", message_id: \"\", mode: 0, user_id: \"\", timestamp: \"\", operation: 0 };\n}\nvar LastPinMessageEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.timestamp !== \"\") {\n      writer.uint32(50).string(message.timestamp);\n    }\n    if (message.operation !== 0) {\n      writer.uint32(56).int32(message.operation);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseLastPinMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.message_id = reader.string();\n          break;\n        case 4:\n          message.mode = reader.int32();\n          break;\n        case 5:\n          message.user_id = reader.string();\n          break;\n        case 6:\n          message.timestamp = reader.string();\n          break;\n        case 7:\n          message.operation = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? Number(object.mode) : 0,\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      timestamp: isSet4(object.timestamp) ? String(object.timestamp) : \"\",\n      operation: isSet4(object.operation) ? Number(object.operation) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.timestamp !== void 0 && (obj.timestamp = message.timestamp);\n    message.operation !== void 0 && (obj.operation = Math.round(message.operation));\n    return obj;\n  },\n  create(base) {\n    return LastPinMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseLastPinMessageEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.timestamp = (_f = object.timestamp) != null ? _f : \"\";\n    message.operation = (_g = object.operation) != null ? _g : 0;\n    return message;\n  }\n};\nfunction createBaseLastSeenMessageEvent() {\n  return { channel_id: \"\", message_id: \"\", mode: 0, timestamp: \"\" };\n}\nvar LastSeenMessageEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(18).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(24).int32(message.mode);\n    }\n    if (message.timestamp !== \"\") {\n      writer.uint32(34).string(message.timestamp);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseLastSeenMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.message_id = reader.string();\n          break;\n        case 3:\n          message.mode = reader.int32();\n          break;\n        case 4:\n          message.timestamp = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? Number(object.mode) : 0,\n      timestamp: isSet4(object.timestamp) ? String(object.timestamp) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.message_id !== void 0 && (obj.message_id = message.message_id);\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.timestamp !== void 0 && (obj.timestamp = message.timestamp);\n    return obj;\n  },\n  create(base) {\n    return LastSeenMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseLastSeenMessageEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.message_id = (_b = object.message_id) != null ? _b : \"\";\n    message.mode = (_c = object.mode) != null ? _c : 0;\n    message.timestamp = (_d = object.timestamp) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseMessageTypingEvent() {\n  return { clan_id: \"\", channel_id: \"\", sender_id: \"\", mode: 0 };\n}\nvar MessageTypingEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(26).string(message.sender_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageTypingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.sender_id = reader.string();\n          break;\n        case 4:\n          message.mode = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      sender_id: isSet4(object.sender_id) ? String(object.sender_id) : \"\",\n      mode: isSet4(object.mode) ? Number(object.mode) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.sender_id !== void 0 && (obj.sender_id = message.sender_id);\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    return obj;\n  },\n  create(base) {\n    return MessageTypingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseMessageTypingEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.sender_id = (_c = object.sender_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseVoiceLeavedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\", voice_user_id: \"\" };\n}\nvar VoiceLeavedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    if (message.voice_user_id !== \"\") {\n      writer.uint32(34).string(message.voice_user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceLeavedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.clan_id = reader.string();\n          break;\n        case 3:\n          message.voice_channel_id = reader.string();\n          break;\n        case 4:\n          message.voice_user_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? String(object.voice_channel_id) : \"\",\n      voice_user_id: isSet4(object.voice_user_id) ? String(object.voice_user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.voice_channel_id !== void 0 && (obj.voice_channel_id = message.voice_channel_id);\n    message.voice_user_id !== void 0 && (obj.voice_user_id = message.voice_user_id);\n    return obj;\n  },\n  create(base) {\n    return VoiceLeavedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseVoiceLeavedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    message.voice_user_id = (_d = object.voice_user_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceJoinedEvent() {\n  return {\n    clan_id: \"\",\n    clan_name: \"\",\n    id: \"\",\n    participant: \"\",\n    user_id: \"\",\n    voice_channel_label: \"\",\n    voice_channel_id: \"\",\n    last_screenshot: \"\"\n  };\n}\nvar VoiceJoinedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.participant !== \"\") {\n      writer.uint32(34).string(message.participant);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.voice_channel_label !== \"\") {\n      writer.uint32(50).string(message.voice_channel_label);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(58).string(message.voice_channel_id);\n    }\n    if (message.last_screenshot !== \"\") {\n      writer.uint32(66).string(message.last_screenshot);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceJoinedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.clan_name = reader.string();\n          break;\n        case 3:\n          message.id = reader.string();\n          break;\n        case 4:\n          message.participant = reader.string();\n          break;\n        case 5:\n          message.user_id = reader.string();\n          break;\n        case 6:\n          message.voice_channel_label = reader.string();\n          break;\n        case 7:\n          message.voice_channel_id = reader.string();\n          break;\n        case 8:\n          message.last_screenshot = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? String(object.clan_name) : \"\",\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      participant: isSet4(object.participant) ? String(object.participant) : \"\",\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      voice_channel_label: isSet4(object.voice_channel_label) ? String(object.voice_channel_label) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? String(object.voice_channel_id) : \"\",\n      last_screenshot: isSet4(object.last_screenshot) ? String(object.last_screenshot) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.clan_name !== void 0 && (obj.clan_name = message.clan_name);\n    message.id !== void 0 && (obj.id = message.id);\n    message.participant !== void 0 && (obj.participant = message.participant);\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.voice_channel_label !== void 0 && (obj.voice_channel_label = message.voice_channel_label);\n    message.voice_channel_id !== void 0 && (obj.voice_channel_id = message.voice_channel_id);\n    message.last_screenshot !== void 0 && (obj.last_screenshot = message.last_screenshot);\n    return obj;\n  },\n  create(base) {\n    return VoiceJoinedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseVoiceJoinedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.id = (_c = object.id) != null ? _c : \"\";\n    message.participant = (_d = object.participant) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.voice_channel_label = (_f = object.voice_channel_label) != null ? _f : \"\";\n    message.voice_channel_id = (_g = object.voice_channel_id) != null ? _g : \"\";\n    message.last_screenshot = (_h = object.last_screenshot) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceStartedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\n}\nvar VoiceStartedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.clan_id = reader.string();\n          break;\n        case 3:\n          message.voice_channel_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? String(object.voice_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.voice_channel_id !== void 0 && (obj.voice_channel_id = message.voice_channel_id);\n    return obj;\n  },\n  create(base) {\n    return VoiceStartedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseVoiceStartedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceEndedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\n}\nvar VoiceEndedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceEndedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.clan_id = reader.string();\n          break;\n        case 3:\n          message.voice_channel_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? String(object.voice_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.voice_channel_id !== void 0 && (obj.voice_channel_id = message.voice_channel_id);\n    return obj;\n  },\n  create(base) {\n    return VoiceEndedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseVoiceEndedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelCreatedEvent() {\n  return {\n    clan_id: \"\",\n    category_id: \"\",\n    creator_id: \"\",\n    parrent_id: \"\",\n    channel_id: \"\",\n    channel_label: \"\",\n    channel_private: 0,\n    channel_type: void 0,\n    status: 0\n  };\n}\nvar ChannelCreatedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(26).string(message.creator_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(34).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(50).string(message.channel_label);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.channel_type !== void 0) {\n      Int32Value.encode({ value: message.channel_type }, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(72).int32(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelCreatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.category_id = reader.string();\n          break;\n        case 3:\n          message.creator_id = reader.string();\n          break;\n        case 4:\n          message.parrent_id = reader.string();\n          break;\n        case 5:\n          message.channel_id = reader.string();\n          break;\n        case 6:\n          message.channel_label = reader.string();\n          break;\n        case 7:\n          message.channel_private = reader.int32();\n          break;\n        case 8:\n          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;\n          break;\n        case 9:\n          message.status = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? String(object.category_id) : \"\",\n      creator_id: isSet4(object.creator_id) ? String(object.creator_id) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? String(object.parrent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? String(object.channel_label) : \"\",\n      channel_private: isSet4(object.channel_private) ? Number(object.channel_private) : 0,\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : void 0,\n      status: isSet4(object.status) ? Number(object.status) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.category_id !== void 0 && (obj.category_id = message.category_id);\n    message.creator_id !== void 0 && (obj.creator_id = message.creator_id);\n    message.parrent_id !== void 0 && (obj.parrent_id = message.parrent_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.channel_label !== void 0 && (obj.channel_label = message.channel_label);\n    message.channel_private !== void 0 && (obj.channel_private = Math.round(message.channel_private));\n    message.channel_type !== void 0 && (obj.channel_type = message.channel_type);\n    message.status !== void 0 && (obj.status = Math.round(message.status));\n    return obj;\n  },\n  create(base) {\n    return ChannelCreatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseChannelCreatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.creator_id = (_c = object.creator_id) != null ? _c : \"\";\n    message.parrent_id = (_d = object.parrent_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.channel_label = (_f = object.channel_label) != null ? _f : \"\";\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.channel_type = (_h = object.channel_type) != null ? _h : void 0;\n    message.status = (_i = object.status) != null ? _i : 0;\n    return message;\n  }\n};\nfunction createBaseChannelDeletedEvent() {\n  return { clan_id: \"\", category_id: \"\", parrent_id: \"\", channel_id: \"\", deletor: \"\" };\n}\nvar ChannelDeletedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(26).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.deletor !== \"\") {\n      writer.uint32(42).string(message.deletor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDeletedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.category_id = reader.string();\n          break;\n        case 3:\n          message.parrent_id = reader.string();\n          break;\n        case 4:\n          message.channel_id = reader.string();\n          break;\n        case 5:\n          message.deletor = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? String(object.category_id) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? String(object.parrent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      deletor: isSet4(object.deletor) ? String(object.deletor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.category_id !== void 0 && (obj.category_id = message.category_id);\n    message.parrent_id !== void 0 && (obj.parrent_id = message.parrent_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.deletor !== void 0 && (obj.deletor = message.deletor);\n    return obj;\n  },\n  create(base) {\n    return ChannelDeletedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannelDeletedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.parrent_id = (_c = object.parrent_id) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.deletor = (_e = object.deletor) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelUpdatedEvent() {\n  return {\n    clan_id: \"\",\n    category_id: \"\",\n    creator_id: \"\",\n    parrent_id: \"\",\n    channel_id: \"\",\n    channel_label: \"\",\n    channel_type: void 0,\n    status: 0\n  };\n}\nvar ChannelUpdatedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(26).string(message.creator_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(34).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(50).string(message.channel_label);\n    }\n    if (message.channel_type !== void 0) {\n      Int32Value.encode({ value: message.channel_type }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(64).int32(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.category_id = reader.string();\n          break;\n        case 3:\n          message.creator_id = reader.string();\n          break;\n        case 4:\n          message.parrent_id = reader.string();\n          break;\n        case 5:\n          message.channel_id = reader.string();\n          break;\n        case 6:\n          message.channel_label = reader.string();\n          break;\n        case 7:\n          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;\n          break;\n        case 8:\n          message.status = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? String(object.category_id) : \"\",\n      creator_id: isSet4(object.creator_id) ? String(object.creator_id) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? String(object.parrent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? String(object.channel_label) : \"\",\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : void 0,\n      status: isSet4(object.status) ? Number(object.status) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.category_id !== void 0 && (obj.category_id = message.category_id);\n    message.creator_id !== void 0 && (obj.creator_id = message.creator_id);\n    message.parrent_id !== void 0 && (obj.parrent_id = message.parrent_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.channel_label !== void 0 && (obj.channel_label = message.channel_label);\n    message.channel_type !== void 0 && (obj.channel_type = message.channel_type);\n    message.status !== void 0 && (obj.status = Math.round(message.status));\n    return obj;\n  },\n  create(base) {\n    return ChannelUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseChannelUpdatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.creator_id = (_c = object.creator_id) != null ? _c : \"\";\n    message.parrent_id = (_d = object.parrent_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.channel_label = (_f = object.channel_label) != null ? _f : \"\";\n    message.channel_type = (_g = object.channel_type) != null ? _g : void 0;\n    message.status = (_h = object.status) != null ? _h : 0;\n    return message;\n  }\n};\nfunction createBaseStatusUnfollow() {\n  return { user_ids: [] };\n}\nvar StatusUnfollow = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.user_ids) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusUnfollow();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_ids.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { user_ids: Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => String(e)) : [] };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_ids) {\n      obj.user_ids = message.user_ids.map((e) => e);\n    } else {\n      obj.user_ids = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusUnfollow.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatusUnfollow();\n    message.user_ids = ((_a = object.user_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseStatusUpdate() {\n  return { status: void 0 };\n}\nvar StatusUpdate = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.status !== void 0) {\n      StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.status = StringValue.decode(reader, reader.uint32()).value;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { status: isSet4(object.status) ? String(object.status) : void 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.status !== void 0 && (obj.status = message.status);\n    return obj;\n  },\n  create(base) {\n    return StatusUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatusUpdate();\n    message.status = (_a = object.status) != null ? _a : void 0;\n    return message;\n  }\n};\nfunction createBaseStream() {\n  return { mode: 0, channel_id: \"\", clan_id: \"\", label: \"\" };\n}\nvar Stream = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(34).string(message.label);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStream();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.mode = reader.int32();\n          break;\n        case 2:\n          message.channel_id = reader.string();\n          break;\n        case 3:\n          message.clan_id = reader.string();\n          break;\n        case 4:\n          message.label = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mode: isSet4(object.mode) ? Number(object.mode) : 0,\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      label: isSet4(object.label) ? String(object.label) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.mode !== void 0 && (obj.mode = Math.round(message.mode));\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.label !== void 0 && (obj.label = message.label);\n    return obj;\n  },\n  create(base) {\n    return Stream.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStream();\n    message.mode = (_a = object.mode) != null ? _a : 0;\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.label = (_d = object.label) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamData() {\n  return { stream: void 0, sender: void 0, data: \"\", reliable: false };\n}\nvar StreamData = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.stream !== void 0) {\n      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.sender !== void 0) {\n      UserPresence.encode(message.sender, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.data !== \"\") {\n      writer.uint32(26).string(message.data);\n    }\n    if (message.reliable === true) {\n      writer.uint32(32).bool(message.reliable);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.stream = Stream.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.sender = UserPresence.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.data = reader.string();\n          break;\n        case 4:\n          message.reliable = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stream: isSet4(object.stream) ? Stream.fromJSON(object.stream) : void 0,\n      sender: isSet4(object.sender) ? UserPresence.fromJSON(object.sender) : void 0,\n      data: isSet4(object.data) ? String(object.data) : \"\",\n      reliable: isSet4(object.reliable) ? Boolean(object.reliable) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.stream !== void 0 && (obj.stream = message.stream ? Stream.toJSON(message.stream) : void 0);\n    message.sender !== void 0 && (obj.sender = message.sender ? UserPresence.toJSON(message.sender) : void 0);\n    message.data !== void 0 && (obj.data = message.data);\n    message.reliable !== void 0 && (obj.reliable = message.reliable);\n    return obj;\n  },\n  create(base) {\n    return StreamData.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamData();\n    message.stream = object.stream !== void 0 && object.stream !== null ? Stream.fromPartial(object.stream) : void 0;\n    message.sender = object.sender !== void 0 && object.sender !== null ? UserPresence.fromPartial(object.sender) : void 0;\n    message.data = (_a = object.data) != null ? _a : \"\";\n    message.reliable = (_b = object.reliable) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBaseStreamPresenceEvent() {\n  return { stream: void 0, joins: [], leaves: [] };\n}\nvar StreamPresenceEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.stream !== void 0) {\n      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.stream = Stream.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stream: isSet4(object.stream) ? Stream.fromJSON(object.stream) : void 0,\n      joins: Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.stream !== void 0 && (obj.stream = message.stream ? Stream.toJSON(message.stream) : void 0);\n    if (message.joins) {\n      obj.joins = message.joins.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.joins = [];\n    }\n    if (message.leaves) {\n      obj.leaves = message.leaves.map((e) => e ? UserPresence.toJSON(e) : void 0);\n    } else {\n      obj.leaves = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamPresenceEvent();\n    message.stream = object.stream !== void 0 && object.stream !== null ? Stream.fromPartial(object.stream) : void 0;\n    message.joins = ((_a = object.joins) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_b = object.leaves) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUserPresence() {\n  return { user_id: \"\", session_id: \"\", username: \"\", persistence: false, status: void 0 };\n}\nvar UserPresence = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.session_id !== \"\") {\n      writer.uint32(18).string(message.session_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.persistence === true) {\n      writer.uint32(32).bool(message.persistence);\n    }\n    if (message.status !== void 0) {\n      StringValue.encode({ value: message.status }, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserPresence();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_id = reader.string();\n          break;\n        case 2:\n          message.session_id = reader.string();\n          break;\n        case 3:\n          message.username = reader.string();\n          break;\n        case 4:\n          message.persistence = reader.bool();\n          break;\n        case 5:\n          message.status = StringValue.decode(reader, reader.uint32()).value;\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      session_id: isSet4(object.session_id) ? String(object.session_id) : \"\",\n      username: isSet4(object.username) ? String(object.username) : \"\",\n      persistence: isSet4(object.persistence) ? Boolean(object.persistence) : false,\n      status: isSet4(object.status) ? String(object.status) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.session_id !== void 0 && (obj.session_id = message.session_id);\n    message.username !== void 0 && (obj.username = message.username);\n    message.persistence !== void 0 && (obj.persistence = message.persistence);\n    message.status !== void 0 && (obj.status = message.status);\n    return obj;\n  },\n  create(base) {\n    return UserPresence.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseUserPresence();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.session_id = (_b = object.session_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.persistence = (_d = object.persistence) != null ? _d : false;\n    message.status = (_e = object.status) != null ? _e : void 0;\n    return message;\n  }\n};\nfunction createBaseCustomStatusEvent() {\n  return { clan_id: \"\", user_id: \"\", username: \"\", status: \"\" };\n}\nvar CustomStatusEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.status !== \"\") {\n      writer.uint32(34).string(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCustomStatusEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.user_id = reader.string();\n          break;\n        case 3:\n          message.username = reader.string();\n          break;\n        case 4:\n          message.status = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      username: isSet4(object.username) ? String(object.username) : \"\",\n      status: isSet4(object.status) ? String(object.status) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.username !== void 0 && (obj.username = message.username);\n    message.status !== void 0 && (obj.status = message.status);\n    return obj;\n  },\n  create(base) {\n    return CustomStatusEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseCustomStatusEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.status = (_d = object.status) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseAddUsers() {\n  return { user_id: \"\", avatar: \"\", username: \"\" };\n}\nvar AddUsers = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(18).string(message.avatar);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAddUsers();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_id = reader.string();\n          break;\n        case 2:\n          message.avatar = reader.string();\n          break;\n        case 3:\n          message.username = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      avatar: isSet4(object.avatar) ? String(object.avatar) : \"\",\n      username: isSet4(object.username) ? String(object.username) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.avatar !== void 0 && (obj.avatar = message.avatar);\n    message.username !== void 0 && (obj.username = message.username);\n    return obj;\n  },\n  create(base) {\n    return AddUsers.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseAddUsers();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.avatar = (_b = object.avatar) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseUserChannelAdded() {\n  return { channel_id: \"\", users: [], status: \"\", clan_id: \"\", channel_type: 0 };\n}\nvar UserChannelAdded = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.users) {\n      AddUsers.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== \"\") {\n      writer.uint32(26).string(message.status);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(40).int32(message.channel_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserChannelAdded();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.users.push(AddUsers.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.status = reader.string();\n          break;\n        case 4:\n          message.clan_id = reader.string();\n          break;\n        case 5:\n          message.channel_type = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      users: Array.isArray(object == null ? void 0 : object.users) ? object.users.map((e) => AddUsers.fromJSON(e)) : [],\n      status: isSet4(object.status) ? String(object.status) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    if (message.users) {\n      obj.users = message.users.map((e) => e ? AddUsers.toJSON(e) : void 0);\n    } else {\n      obj.users = [];\n    }\n    message.status !== void 0 && (obj.status = message.status);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.channel_type !== void 0 && (obj.channel_type = Math.round(message.channel_type));\n    return obj;\n  },\n  create(base) {\n    return UserChannelAdded.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseUserChannelAdded();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.users = ((_b = object.users) == null ? void 0 : _b.map((e) => AddUsers.fromPartial(e))) || [];\n    message.status = (_c = object.status) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    message.channel_type = (_e = object.channel_type) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseUserChannelRemoved() {\n  return { channel_id: \"\", user_ids: [] };\n}\nvar UserChannelRemoved = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserChannelRemoved();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.user_ids.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      user_ids: Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    if (message.user_ids) {\n      obj.user_ids = message.user_ids.map((e) => e);\n    } else {\n      obj.user_ids = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return UserChannelRemoved.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserChannelRemoved();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseUserClanRemoved() {\n  return { clan_id: \"\", user_ids: [] };\n}\nvar UserClanRemoved = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserClanRemoved();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.user_ids.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      user_ids: Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => String(e)) : []\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    if (message.user_ids) {\n      obj.user_ids = message.user_ids.map((e) => e);\n    } else {\n      obj.user_ids = [];\n    }\n    return obj;\n  },\n  create(base) {\n    return UserClanRemoved.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserClanRemoved();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseClanUpdatedEvent() {\n  return { clan_id: \"\", clan_name: \"\", clan_logo: \"\" };\n}\nvar ClanUpdatedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(26).string(message.clan_logo);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.clan_name = reader.string();\n          break;\n        case 3:\n          message.clan_logo = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? String(object.clan_name) : \"\",\n      clan_logo: isSet4(object.clan_logo) ? String(object.clan_logo) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.clan_name !== void 0 && (obj.clan_name = message.clan_name);\n    message.clan_logo !== void 0 && (obj.clan_logo = message.clan_logo);\n    return obj;\n  },\n  create(base) {\n    return ClanUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseClanUpdatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.clan_logo = (_c = object.clan_logo) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseClanProfileUpdatedEvent() {\n  return { user_id: \"\", clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\n}\nvar ClanProfileUpdatedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(18).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(26).string(message.clan_avatar);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanProfileUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_id = reader.string();\n          break;\n        case 2:\n          message.clan_nick = reader.string();\n          break;\n        case 3:\n          message.clan_avatar = reader.string();\n          break;\n        case 4:\n          message.clan_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      clan_nick: isSet4(object.clan_nick) ? String(object.clan_nick) : \"\",\n      clan_avatar: isSet4(object.clan_avatar) ? String(object.clan_avatar) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.clan_nick !== void 0 && (obj.clan_nick = message.clan_nick);\n    message.clan_avatar !== void 0 && (obj.clan_avatar = message.clan_avatar);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    return obj;\n  },\n  create(base) {\n    return ClanProfileUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseClanProfileUpdatedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.clan_nick = (_b = object.clan_nick) != null ? _b : \"\";\n    message.clan_avatar = (_c = object.clan_avatar) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseUserProfileUpdatedEvent() {\n  return { user_id: \"\", display_name: \"\", avatar: \"\", about_me: \"\", channel_id: \"\", clan_id: \"\" };\n}\nvar UserProfileUpdatedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(18).string(message.display_name);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(26).string(message.avatar);\n    }\n    if (message.about_me !== \"\") {\n      writer.uint32(34).string(message.about_me);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserProfileUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.user_id = reader.string();\n          break;\n        case 2:\n          message.display_name = reader.string();\n          break;\n        case 3:\n          message.avatar = reader.string();\n          break;\n        case 4:\n          message.about_me = reader.string();\n          break;\n        case 5:\n          message.channel_id = reader.string();\n          break;\n        case 6:\n          message.clan_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      display_name: isSet4(object.display_name) ? String(object.display_name) : \"\",\n      avatar: isSet4(object.avatar) ? String(object.avatar) : \"\",\n      about_me: isSet4(object.about_me) ? String(object.about_me) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.display_name !== void 0 && (obj.display_name = message.display_name);\n    message.avatar !== void 0 && (obj.avatar = message.avatar);\n    message.about_me !== void 0 && (obj.about_me = message.about_me);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    return obj;\n  },\n  create(base) {\n    return UserProfileUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseUserProfileUpdatedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.display_name = (_b = object.display_name) != null ? _b : \"\";\n    message.avatar = (_c = object.avatar) != null ? _c : \"\";\n    message.about_me = (_d = object.about_me) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseClanNameExistedEvent() {\n  return { clan_name: \"\", exist: false };\n}\nvar ClanNameExistedEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_name !== \"\") {\n      writer.uint32(10).string(message.clan_name);\n    }\n    if (message.exist === true) {\n      writer.uint32(16).bool(message.exist);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanNameExistedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_name = reader.string();\n          break;\n        case 2:\n          message.exist = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_name: isSet4(object.clan_name) ? String(object.clan_name) : \"\",\n      exist: isSet4(object.exist) ? Boolean(object.exist) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_name !== void 0 && (obj.clan_name = message.clan_name);\n    message.exist !== void 0 && (obj.exist = message.exist);\n    return obj;\n  },\n  create(base) {\n    return ClanNameExistedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseClanNameExistedEvent();\n    message.clan_name = (_a = object.clan_name) != null ? _a : \"\";\n    message.exist = (_b = object.exist) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBaseNotificationChannelSettingEvent() {\n  return { channel_id: \"\", notification_user_channel: void 0 };\n}\nvar NotificationChannelSettingEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.notification_user_channel !== void 0) {\n      NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelSettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      notification_user_channel: isSet4(object.notification_user_channel) ? NotificationUserChannel.fromJSON(object.notification_user_channel) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.notification_user_channel !== void 0 && (obj.notification_user_channel = message.notification_user_channel ? NotificationUserChannel.toJSON(message.notification_user_channel) : void 0);\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelSettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationChannelSettingEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.notification_user_channel = object.notification_user_channel !== void 0 && object.notification_user_channel !== null ? NotificationUserChannel.fromPartial(object.notification_user_channel) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotificationUserChannel() {\n  return { id: \"\", notification_setting_type: 0, time_mute: void 0, active: 0 };\n}\nvar NotificationUserChannel = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(16).int32(message.notification_setting_type);\n    }\n    if (message.time_mute !== void 0) {\n      Timestamp.encode(toTimestamp2(message.time_mute), writer.uint32(26).fork()).ldelim();\n    }\n    if (message.active !== 0) {\n      writer.uint32(32).int32(message.active);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationUserChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.notification_setting_type = reader.int32();\n          break;\n        case 3:\n          message.time_mute = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.active = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      notification_setting_type: isSet4(object.notification_setting_type) ? Number(object.notification_setting_type) : 0,\n      time_mute: isSet4(object.time_mute) ? fromJsonTimestamp2(object.time_mute) : void 0,\n      active: isSet4(object.active) ? Number(object.active) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.notification_setting_type !== void 0 && (obj.notification_setting_type = Math.round(message.notification_setting_type));\n    message.time_mute !== void 0 && (obj.time_mute = message.time_mute.toISOString());\n    message.active !== void 0 && (obj.active = Math.round(message.active));\n    return obj;\n  },\n  create(base) {\n    return NotificationUserChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseNotificationUserChannel();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.notification_setting_type = (_b = object.notification_setting_type) != null ? _b : 0;\n    message.time_mute = (_c = object.time_mute) != null ? _c : void 0;\n    message.active = (_d = object.active) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseNotificationCategorySettingEvent() {\n  return { category_id: \"\", notification_user_channel: void 0 };\n}\nvar NotificationCategorySettingEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.category_id !== \"\") {\n      writer.uint32(10).string(message.category_id);\n    }\n    if (message.notification_user_channel !== void 0) {\n      NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationCategorySettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.category_id = reader.string();\n          break;\n        case 2:\n          message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      category_id: isSet4(object.category_id) ? String(object.category_id) : \"\",\n      notification_user_channel: isSet4(object.notification_user_channel) ? NotificationUserChannel.fromJSON(object.notification_user_channel) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.category_id !== void 0 && (obj.category_id = message.category_id);\n    message.notification_user_channel !== void 0 && (obj.notification_user_channel = message.notification_user_channel ? NotificationUserChannel.toJSON(message.notification_user_channel) : void 0);\n    return obj;\n  },\n  create(base) {\n    return NotificationCategorySettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationCategorySettingEvent();\n    message.category_id = (_a = object.category_id) != null ? _a : \"\";\n    message.notification_user_channel = object.notification_user_channel !== void 0 && object.notification_user_channel !== null ? NotificationUserChannel.fromPartial(object.notification_user_channel) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotificationClanSettingEvent() {\n  return { clan_id: \"\", notification_setting: void 0 };\n}\nvar NotificationClanSettingEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.notification_setting !== void 0) {\n      NotificationSetting.encode(message.notification_setting, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationClanSettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clan_id = reader.string();\n          break;\n        case 2:\n          message.notification_setting = NotificationSetting.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? String(object.clan_id) : \"\",\n      notification_setting: isSet4(object.notification_setting) ? NotificationSetting.fromJSON(object.notification_setting) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clan_id !== void 0 && (obj.clan_id = message.clan_id);\n    message.notification_setting !== void 0 && (obj.notification_setting = message.notification_setting ? NotificationSetting.toJSON(message.notification_setting) : void 0);\n    return obj;\n  },\n  create(base) {\n    return NotificationClanSettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationClanSettingEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.notification_setting = object.notification_setting !== void 0 && object.notification_setting !== null ? NotificationSetting.fromPartial(object.notification_setting) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotificationSetting() {\n  return { id: \"\", notification_setting_type: 0 };\n}\nvar NotificationSetting = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(16).int32(message.notification_setting_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationSetting();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.notification_setting_type = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      notification_setting_type: isSet4(object.notification_setting_type) ? Number(object.notification_setting_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.notification_setting_type !== void 0 && (obj.notification_setting_type = Math.round(message.notification_setting_type));\n    return obj;\n  },\n  create(base) {\n    return NotificationSetting.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseNotificationSetting();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.notification_setting_type = (_b = object.notification_setting_type) != null ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseNotifiReactMessageEvent() {\n  return { channel_id: \"\", notifi_react_message: void 0 };\n}\nvar NotifiReactMessageEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.notifi_react_message !== void 0) {\n      NotifiReactMessage.encode(message.notifi_react_message, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifiReactMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channel_id = reader.string();\n          break;\n        case 2:\n          message.notifi_react_message = NotifiReactMessage.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\",\n      notifi_react_message: isSet4(object.notifi_react_message) ? NotifiReactMessage.fromJSON(object.notifi_react_message) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    message.notifi_react_message !== void 0 && (obj.notifi_react_message = message.notifi_react_message ? NotifiReactMessage.toJSON(message.notifi_react_message) : void 0);\n    return obj;\n  },\n  create(base) {\n    return NotifiReactMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotifiReactMessageEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.notifi_react_message = object.notifi_react_message !== void 0 && object.notifi_react_message !== null ? NotifiReactMessage.fromPartial(object.notifi_react_message) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotifiReactMessage() {\n  return { id: \"\", user_id: \"\", channel_id: \"\" };\n}\nvar NotifiReactMessage = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : new import_minimal4.default.Reader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifiReactMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.user_id = reader.string();\n          break;\n        case 3:\n          message.channel_id = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? String(object.id) : \"\",\n      user_id: isSet4(object.user_id) ? String(object.user_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== void 0 && (obj.id = message.id);\n    message.user_id !== void 0 && (obj.user_id = message.user_id);\n    message.channel_id !== void 0 && (obj.channel_id = message.channel_id);\n    return obj;\n  },\n  create(base) {\n    return NotifiReactMessage.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseNotifiReactMessage();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction toTimestamp2(date) {\n  const seconds = date.getTime() / 1e3;\n  const nanos = date.getTime() % 1e3 * 1e6;\n  return { seconds, nanos };\n}\nfunction fromTimestamp2(t) {\n  let millis = t.seconds * 1e3;\n  millis += t.nanos / 1e6;\n  return new Date(millis);\n}\nfunction fromJsonTimestamp2(o) {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp2(Timestamp.fromJSON(o));\n  }\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction isSet4(value) {\n  return value !== null && value !== void 0;\n}\n\n// web_socket_adapter_pb.ts\nvar WebSocketAdapterPb = class {\n  constructor() {\n  }\n  get onClose() {\n    return this._socket.onclose;\n  }\n  set onClose(value) {\n    this._socket.onclose = value;\n  }\n  get onError() {\n    return this._socket.onerror;\n  }\n  set onError(value) {\n    this._socket.onerror = value;\n  }\n  get onMessage() {\n    return this._socket.onmessage;\n  }\n  set onMessage(value) {\n    if (value) {\n      this._socket.onmessage = (evt) => {\n        const buffer = evt.data;\n        const uintBuffer = new Uint8Array(buffer);\n        const envelope = Envelope.decode(uintBuffer);\n        if (envelope.channel_message) {\n          if (envelope.channel_message.code == void 0) {\n            envelope.channel_message.code = 0;\n          }\n        }\n        value(envelope);\n      };\n    } else {\n      value = null;\n    }\n  }\n  get onOpen() {\n    return this._socket.onopen;\n  }\n  set onOpen(value) {\n    this._socket.onopen = value;\n  }\n  isOpen() {\n    var _a;\n    return ((_a = this._socket) == null ? void 0 : _a.readyState) == WebSocket.OPEN;\n  }\n  close() {\n    this._socket.close();\n    this._socket = void 0;\n  }\n  connect(scheme, host, port, createStatus, token) {\n    const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(createStatus.toString())}&token=${encodeURIComponent(token)}&format=protobuf`;\n    this._socket = new WebSocket(url);\n    this._socket.binaryType = \"arraybuffer\";\n  }\n  send(msg) {\n    if (msg.match_data_send) {\n      let payload = msg.match_data_send.data;\n      if (typeof payload == \"string\") {\n        msg.match_data_send.data = new TextEncoder().encode(payload);\n      }\n    } else if (msg.party_data_send) {\n      let payload = msg.party_data_send.data;\n      if (typeof payload == \"string\") {\n        msg.party_data_send.data = new TextEncoder().encode(payload);\n      }\n    }\n    const envelopeWriter = Envelope.encode(Envelope.fromPartial(msg));\n    const encodedMsg = envelopeWriter.finish();\n    this._socket.send(encodedMsg);\n  }\n};\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js?");

/***/ }),

/***/ "./node_modules/mezon-js/dist/mezon-js.cjs.js":
/*!****************************************************!*\
  !*** ./node_modules/mezon-js/dist/mezon-js.cjs.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// index.ts\nvar mezon_js_exports = {};\n__export(mezon_js_exports, {\n  ChannelStreamMode: () => ChannelStreamMode,\n  ChannelType: () => ChannelType,\n  Client: () => Client,\n  DefaultSocket: () => DefaultSocket,\n  NotificationType: () => NotificationType,\n  Session: () => Session,\n  WebSocketAdapterText: () => WebSocketAdapterText\n});\nmodule.exports = __toCommonJS(mezon_js_exports);\n\n// ../../node_modules/whatwg-fetch/fetch.js\nvar global = typeof globalThis !== \"undefined\" && globalThis || typeof self !== \"undefined\" && self || typeof global !== \"undefined\" && global;\nvar support = {\n  searchParams: \"URLSearchParams\" in global,\n  iterable: \"Symbol\" in global && \"iterator\" in Symbol,\n  blob: \"FileReader\" in global && \"Blob\" in global && function() {\n    try {\n      new Blob();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(),\n  formData: \"FormData\" in global,\n  arrayBuffer: \"ArrayBuffer\" in global\n};\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj);\n}\nif (support.arrayBuffer) {\n  viewClasses = [\n    \"[object Int8Array]\",\n    \"[object Uint8Array]\",\n    \"[object Uint8ClampedArray]\",\n    \"[object Int16Array]\",\n    \"[object Uint16Array]\",\n    \"[object Int32Array]\",\n    \"[object Uint32Array]\",\n    \"[object Float32Array]\",\n    \"[object Float64Array]\"\n  ];\n  isArrayBufferView = ArrayBuffer.isView || function(obj) {\n    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n  };\n}\nvar viewClasses;\nvar isArrayBufferView;\nfunction normalizeName(name) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === \"\") {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"');\n  }\n  return name.toLowerCase();\n}\nfunction normalizeValue(value) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift();\n      return { done: value === void 0, value };\n    }\n  };\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator;\n    };\n  }\n  return iterator;\n}\nfunction Headers(headers) {\n  this.map = {};\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value);\n    }, this);\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1]);\n    }, this);\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name]);\n    }, this);\n  }\n}\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name);\n  value = normalizeValue(value);\n  var oldValue = this.map[name];\n  this.map[name] = oldValue ? oldValue + \", \" + value : value;\n};\nHeaders.prototype[\"delete\"] = function(name) {\n  delete this.map[normalizeName(name)];\n};\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name);\n  return this.has(name) ? this.map[name] : null;\n};\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name));\n};\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value);\n};\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this);\n    }\n  }\n};\nHeaders.prototype.keys = function() {\n  var items = [];\n  this.forEach(function(value, name) {\n    items.push(name);\n  });\n  return iteratorFor(items);\n};\nHeaders.prototype.values = function() {\n  var items = [];\n  this.forEach(function(value) {\n    items.push(value);\n  });\n  return iteratorFor(items);\n};\nHeaders.prototype.entries = function() {\n  var items = [];\n  this.forEach(function(value, name) {\n    items.push([name, value]);\n  });\n  return iteratorFor(items);\n};\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n}\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError(\"Already read\"));\n  }\n  body.bodyUsed = true;\n}\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result);\n    };\n    reader.onerror = function() {\n      reject(reader.error);\n    };\n  });\n}\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  reader.readAsArrayBuffer(blob);\n  return promise;\n}\nfunction readBlobAsText(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  reader.readAsText(blob);\n  return promise;\n}\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf);\n  var chars2 = new Array(view.length);\n  for (var i = 0; i < view.length; i++) {\n    chars2[i] = String.fromCharCode(view[i]);\n  }\n  return chars2.join(\"\");\n}\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0);\n  } else {\n    var view = new Uint8Array(buf.byteLength);\n    view.set(new Uint8Array(buf));\n    return view.buffer;\n  }\n}\nfunction Body() {\n  this.bodyUsed = false;\n  this._initBody = function(body) {\n    this.bodyUsed = this.bodyUsed;\n    this._bodyInit = body;\n    if (!body) {\n      this._bodyText = \"\";\n    } else if (typeof body === \"string\") {\n      this._bodyText = body;\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body;\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body;\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString();\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer);\n      this._bodyInit = new Blob([this._bodyArrayBuffer]);\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body);\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body);\n    }\n    if (!this.headers.get(\"content-type\")) {\n      if (typeof body === \"string\") {\n        this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set(\"content-type\", this._bodyBlob.type);\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n      }\n    }\n  };\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected;\n      }\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob);\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n      } else if (this._bodyFormData) {\n        throw new Error(\"could not read FormData body as blob\");\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]));\n      }\n    };\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this);\n        if (isConsumed) {\n          return isConsumed;\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          );\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer);\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer);\n      }\n    };\n  }\n  this.text = function() {\n    var rejected = consumed(this);\n    if (rejected) {\n      return rejected;\n    }\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob);\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n    } else if (this._bodyFormData) {\n      throw new Error(\"could not read FormData body as text\");\n    } else {\n      return Promise.resolve(this._bodyText);\n    }\n  };\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode);\n    };\n  }\n  this.json = function() {\n    return this.text().then(JSON.parse);\n  };\n  return this;\n}\nvar methods = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"];\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase();\n  return methods.indexOf(upcased) > -1 ? upcased : method;\n}\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n  }\n  options = options || {};\n  var body = options.body;\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError(\"Already read\");\n    }\n    this.url = input.url;\n    this.credentials = input.credentials;\n    if (!options.headers) {\n      this.headers = new Headers(input.headers);\n    }\n    this.method = input.method;\n    this.mode = input.mode;\n    this.signal = input.signal;\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit;\n      input.bodyUsed = true;\n    }\n  } else {\n    this.url = String(input);\n  }\n  this.credentials = options.credentials || this.credentials || \"same-origin\";\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers);\n  }\n  this.method = normalizeMethod(options.method || this.method || \"GET\");\n  this.mode = options.mode || this.mode || null;\n  this.signal = options.signal || this.signal;\n  this.referrer = null;\n  if ((this.method === \"GET\" || this.method === \"HEAD\") && body) {\n    throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n  }\n  this._initBody(body);\n  if (this.method === \"GET\" || this.method === \"HEAD\") {\n    if (options.cache === \"no-store\" || options.cache === \"no-cache\") {\n      var reParamSearch = /([?&])_=[^&]*/;\n      if (reParamSearch.test(this.url)) {\n        this.url = this.url.replace(reParamSearch, \"$1_=\" + (/* @__PURE__ */ new Date()).getTime());\n      } else {\n        var reQueryString = /\\?/;\n        this.url += (reQueryString.test(this.url) ? \"&\" : \"?\") + \"_=\" + (/* @__PURE__ */ new Date()).getTime();\n      }\n    }\n  }\n}\nRequest.prototype.clone = function() {\n  return new Request(this, { body: this._bodyInit });\n};\nfunction decode(body) {\n  var form = new FormData();\n  body.trim().split(\"&\").forEach(function(bytes) {\n    if (bytes) {\n      var split = bytes.split(\"=\");\n      var name = split.shift().replace(/\\+/g, \" \");\n      var value = split.join(\"=\").replace(/\\+/g, \" \");\n      form.append(decodeURIComponent(name), decodeURIComponent(value));\n    }\n  });\n  return form;\n}\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers();\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \" \");\n  preProcessedHeaders.split(\"\\r\").map(function(header) {\n    return header.indexOf(\"\\n\") === 0 ? header.substr(1, header.length) : header;\n  }).forEach(function(line) {\n    var parts = line.split(\":\");\n    var key = parts.shift().trim();\n    if (key) {\n      var value = parts.join(\":\").trim();\n      headers.append(key, value);\n    }\n  });\n  return headers;\n}\nBody.call(Request.prototype);\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n  }\n  if (!options) {\n    options = {};\n  }\n  this.type = \"default\";\n  this.status = options.status === void 0 ? 200 : options.status;\n  this.ok = this.status >= 200 && this.status < 300;\n  this.statusText = options.statusText === void 0 ? \"\" : \"\" + options.statusText;\n  this.headers = new Headers(options.headers);\n  this.url = options.url || \"\";\n  this._initBody(bodyInit);\n}\nBody.call(Response.prototype);\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  });\n};\nResponse.error = function() {\n  var response = new Response(null, { status: 0, statusText: \"\" });\n  response.type = \"error\";\n  return response;\n};\nvar redirectStatuses = [301, 302, 303, 307, 308];\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError(\"Invalid status code\");\n  }\n  return new Response(null, { status, headers: { location: url } });\n};\nvar DOMException = global.DOMException;\ntry {\n  new DOMException();\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message;\n    this.name = name;\n    var error = Error(message);\n    this.stack = error.stack;\n  };\n  DOMException.prototype = Object.create(Error.prototype);\n  DOMException.prototype.constructor = DOMException;\n}\nfunction fetch2(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init);\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException(\"Aborted\", \"AbortError\"));\n    }\n    var xhr = new XMLHttpRequest();\n    function abortXhr() {\n      xhr.abort();\n    }\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || \"\")\n      };\n      options.url = \"responseURL\" in xhr ? xhr.responseURL : options.headers.get(\"X-Request-URL\");\n      var body = \"response\" in xhr ? xhr.response : xhr.responseText;\n      setTimeout(function() {\n        resolve(new Response(body, options));\n      }, 0);\n    };\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError(\"Network request failed\"));\n      }, 0);\n    };\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError(\"Network request failed\"));\n      }, 0);\n    };\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException(\"Aborted\", \"AbortError\"));\n      }, 0);\n    };\n    function fixUrl(url) {\n      try {\n        return url === \"\" && global.location.href ? global.location.href : url;\n      } catch (e) {\n        return url;\n      }\n    }\n    xhr.open(request.method, fixUrl(request.url), true);\n    if (request.credentials === \"include\") {\n      xhr.withCredentials = true;\n    } else if (request.credentials === \"omit\") {\n      xhr.withCredentials = false;\n    }\n    if (\"responseType\" in xhr) {\n      if (support.blob) {\n        xhr.responseType = \"blob\";\n      } else if (support.arrayBuffer && request.headers.get(\"Content-Type\") && request.headers.get(\"Content-Type\").indexOf(\"application/octet-stream\") !== -1) {\n        xhr.responseType = \"arraybuffer\";\n      }\n    }\n    if (init && typeof init.headers === \"object\" && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n      });\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n    }\n    if (request.signal) {\n      request.signal.addEventListener(\"abort\", abortXhr);\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener(\"abort\", abortXhr);\n        }\n      };\n    }\n    xhr.send(typeof request._bodyInit === \"undefined\" ? null : request._bodyInit);\n  });\n}\nfetch2.polyfill = true;\nif (!global.fetch) {\n  global.fetch = fetch2;\n  global.Headers = Headers;\n  global.Request = Request;\n  global.Response = Response;\n}\n\n// ../../node_modules/js-base64/base64.mjs\nvar _hasatob = typeof atob === \"function\";\nvar _hasbtoa = typeof btoa === \"function\";\nvar _hasBuffer = typeof Buffer === \"function\";\nvar _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : void 0;\nvar _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : void 0;\nvar b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar b64chs = Array.prototype.slice.call(b64ch);\nvar b64tab = ((a) => {\n  let tab = {};\n  a.forEach((c, i) => tab[c] = i);\n  return tab;\n})(b64chs);\nvar b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nvar _fromCC = String.fromCharCode.bind(String);\nvar _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\nvar _mkUriSafe = (src) => src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0) => m0 == \"+\" ? \"-\" : \"_\");\nvar _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\nvar btoaPolyfill = (bin) => {\n  let u32, c0, c1, c2, asc = \"\";\n  const pad = bin.length % 3;\n  for (let i = 0; i < bin.length; ) {\n    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)\n      throw new TypeError(\"invalid character found\");\n    u32 = c0 << 16 | c1 << 8 | c2;\n    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n  }\n  return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\nvar _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nvar _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString(\"base64\") : (u8a) => {\n  const maxargs = 4096;\n  let strs = [];\n  for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n  }\n  return _btoa(strs.join(\"\"));\n};\nvar cb_utob = (c) => {\n  if (c.length < 2) {\n    var cc = c.charCodeAt(0);\n    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  } else {\n    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);\n    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  }\n};\nvar re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\nvar utob = (u) => u.replace(re_utob, cb_utob);\nvar _encode = _hasBuffer ? (s) => Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));\nvar encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\nvar atobPolyfill = (asc) => {\n  asc = asc.replace(/\\s+/g, \"\");\n  if (!b64re.test(asc))\n    throw new TypeError(\"malformed base64.\");\n  asc += \"==\".slice(2 - (asc.length & 3));\n  let u24, bin = \"\", r1, r2;\n  for (let i = 0; i < asc.length; ) {\n    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n  }\n  return bin;\n};\nvar _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\n\n// utils.ts\nfunction buildFetchOptions(method, options, bodyJson) {\n  const fetchOptions = __spreadValues(__spreadValues({}, { method }), options);\n  fetchOptions.headers = __spreadValues({}, options.headers);\n  if (typeof XMLHttpRequest !== \"undefined\") {\n    const descriptor = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, \"withCredentials\");\n    if (!(descriptor == null ? void 0 : descriptor.set)) {\n      fetchOptions.credentials = \"cocos-ignore\";\n    }\n  }\n  if (!Object.keys(fetchOptions.headers).includes(\"Accept\")) {\n    fetchOptions.headers[\"Accept\"] = \"application/json\";\n  }\n  if (!Object.keys(fetchOptions.headers).includes(\"Content-Type\")) {\n    fetchOptions.headers[\"Content-Type\"] = \"application/json\";\n  }\n  Object.keys(fetchOptions.headers).forEach((key) => {\n    if (!fetchOptions.headers[key]) {\n      delete fetchOptions.headers[key];\n    }\n  });\n  if (bodyJson) {\n    fetchOptions.body = bodyJson;\n  }\n  return fetchOptions;\n}\n\n// api.gen.ts\nvar MezonApi = class {\n  constructor(serverKey, basePath, timeoutMs) {\n    this.serverKey = serverKey;\n    this.basePath = basePath;\n    this.timeoutMs = timeoutMs;\n  }\n  /** A healthcheck which load balancers can use to check the service. */\n  healthcheck(bearerToken, options = {}) {\n    const urlPath = \"/healthcheck\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete the current user's account. */\n  deleteAccount(bearerToken, options = {}) {\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch the current user's account. */\n  getAccount(bearerToken, options = {}) {\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in the current user's account. */\n  updateAccount(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an Apple ID against the server. */\n  authenticateApple(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/apple\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a custom id against the server. */\n  authenticateCustom(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/custom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a device id against the server. */\n  authenticateDevice(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/device\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an email+password against the server. */\n  authenticateEmail(basicAuthUsername, basicAuthPassword, account, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a Facebook OAuth token against the server. */\n  authenticateFacebook(basicAuthUsername, basicAuthPassword, account, create, username, sync, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    queryParams.set(\"sync\", sync);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a Facebook Instant Game token against the server. */\n  authenticateFacebookInstantGame(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/facebookinstantgame\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Apple's GameCenter against the server. */\n  authenticateGameCenter(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/gamecenter\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Google against the server. */\n  authenticateGoogle(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/google\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Steam against the server. */\n  authenticateSteam(basicAuthUsername, basicAuthPassword, account, create, username, sync, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    queryParams.set(\"sync\", sync);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an Apple ID to the social profiles on the current user's account. */\n  linkApple(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/apple\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a custom ID to the social profiles on the current user's account. */\n  linkCustom(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/custom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a device ID to the social profiles on the current user's account. */\n  linkDevice(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/device\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an email+password to the social profiles on the current user's account. */\n  linkEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Facebook to the social profiles on the current user's account. */\n  linkFacebook(bearerToken, account, sync, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"sync\", sync);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Facebook Instant Game to the social profiles on the current user's account. */\n  linkFacebookInstantGame(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/facebookinstantgame\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Apple's GameCenter to the social profiles on the current user's account. */\n  linkGameCenter(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/gamecenter\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Google to the social profiles on the current user's account. */\n  linkGoogle(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/google\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Steam to the social profiles on the current user's account. */\n  linkSteam(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an email+password against the server. */\n  registrationEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/registry\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\n  sessionRefresh(basicAuthUsername, basicAuthPassword, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/session/refresh\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the Apple ID from the social profiles on the current user's account. */\n  unlinkApple(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/apple\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the custom ID from the social profiles on the current user's account. */\n  unlinkCustom(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/custom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the device ID from the social profiles on the current user's account. */\n  unlinkDevice(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/device\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the email+password from the social profiles on the current user's account. */\n  unlinkEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Facebook from the social profiles on the current user's account. */\n  unlinkFacebook(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Facebook Instant Game profile from the social profiles on the current user's account. */\n  unlinkFacebookInstantGame(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/facebookinstantgame\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Apple's GameCenter from the social profiles on the current user's account. */\n  unlinkGameCenter(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/gamecenter\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Google from the social profiles on the current user's account. */\n  unlinkGoogle(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/google\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Steam from the social profiles on the current user's account. */\n  unlinkSteam(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a new apps. */\n  addApp(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/add\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List (and optionally filter) accounts. */\n  listApps(bearerToken, filter, tombstones, cursor, options = {}) {\n    const urlPath = \"/v2/apps/app\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"filter\", filter);\n    queryParams.set(\"tombstones\", tombstones);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete all information stored for an app. */\n  deleteApp(bearerToken, id, recordDeletion, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"record_deletion\", recordDeletion);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get detailed app information. */\n  getApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update one or more fields on a app. */\n  updateApp(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Ban a app. */\n  banApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}/ban\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Unban an app. */\n  unbanApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}/unban\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  listCategoryDescs(bearerToken, clanId, creatorId, categoryName, categoryId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/categorydesc/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"creator_id\", creatorId);\n    queryParams.set(\"category_name\", categoryName);\n    queryParams.set(\"category_id\", categoryId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List a channel's message history. */\n  listChannelMessages(bearerToken, channelId, messageId, direction, limit, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel/{channelId}\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"message_id\", messageId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"direction\", direction);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  addChannelUsers(bearerToken, channelId, userIds, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel/{channelId}/add\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all attachment that are part of a channel. */\n  listChannelAttachment(bearerToken, channelId, clanId, fileType, limit, state, cursor, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel/{channelId}/attachment\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"file_type\", fileType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Leave a channel the user is a member of. */\n  leaveChannel(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel/{channelId}/leave\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Kick a set of users from a channel. */\n  removeChannelUsers(bearerToken, channelId, userIds, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel/{channelId}/remove\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listChannelUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel/{channelId}/user\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user channels */\n  listChannelDescs(bearerToken, limit, state, cursor, clanId, channelType, options = {}) {\n    const urlPath = \"/v2/channeldesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_type\", channelType);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new channel with the current user as the owner. */\n  createChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channeldesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a channel by ID. */\n  deleteChannelDesc(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given channel. */\n  updateChannelDesc(bearerToken, channelId, body, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listChannelVoiceUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/channelvoice\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List clans */\n  listClanDescs(bearerToken, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/clandesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a clan */\n  createClanDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a clan desc by ID. */\n  deleteClanDesc(bearerToken, clanDescId, options = {}) {\n    if (clanDescId === null || clanDescId === void 0) {\n      throw new Error(\"'clanDescId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandesc/{clanDescId}\".replace(\"{clanDescId}\", encodeURIComponent(String(clanDescId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given clan. */\n  updateClanDesc(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandesc/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Kick a set of users from a clan. */\n  removeClanUsers(bearerToken, clanId, userIds, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandesc/{clanId}/kick\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a clan. */\n  listClanUsers(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandesc/{clanId}/user\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** check duplicate clan name */\n  checkDuplicateClanName(bearerToken, clanName, options = {}) {\n    if (clanName === null || clanName === void 0) {\n      throw new Error(\"'clanName' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandesc/{clanName}\".replace(\"{clanName}\", encodeURIComponent(String(clanName)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get a clan desc profile */\n  getClanDescProfile(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandescprofile/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given clan profile. */\n  updateClanDescProfile(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clandescprofile/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  createCategoryDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/createcategory\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteCategoryDesc(bearerToken, creatorId, options = {}) {\n    if (creatorId === null || creatorId === void 0) {\n      throw new Error(\"'creatorId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/deletecategory/{creatorId}\".replace(\"{creatorId}\", encodeURIComponent(String(creatorId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** regist fcm device token */\n  registFCMDeviceToken(bearerToken, token, deviceId, platform, options = {}) {\n    const urlPath = \"/v2/devicetoken\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"token\", token);\n    queryParams.set(\"device_id\", deviceId);\n    queryParams.set(\"platform\", platform);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** close direct message. */\n  closeDirectMess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/direct/close\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** open direct message. */\n  openDirectMess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/direct/open\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Post clan Emoji  /v2/emoji/create */\n  createClanEmoji(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/emoji/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a emoji by ID. */\n  deleteClanEmojiById(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/emoji/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    const body = { clan_id: clanId };\n    let bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update ClanEmoj By id */\n  updateClanEmojiById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/emoji/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Search message from elasticsearch service. */\n  searchMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/es/search\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Submit an event for processing in the server's registered runtime custom events handler. */\n  event(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/event\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user events */\n  listEvents(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/eventmanagement\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new event for clan. */\n  createEvent(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/eventmanagement/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given event. */\n  updateEventUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/eventmanagement/user\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a event by ID. */\n  deleteEvent(bearerToken, eventId, options = {}) {\n    if (eventId === null || eventId === void 0) {\n      throw new Error(\"'eventId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/eventmanagement/{eventId}\".replace(\"{eventId}\", encodeURIComponent(String(eventId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given event. */\n  updateEvent(bearerToken, eventId, body, options = {}) {\n    if (eventId === null || eventId === void 0) {\n      throw new Error(\"'eventId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/eventmanagement/{eventId}\".replace(\"{eventId}\", encodeURIComponent(String(eventId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete one or more users by ID or username. */\n  deleteFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all friends for the current user. */\n  listFriends(bearerToken, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add friends by ID or username to a user's account. */\n  addFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Block one or more users by ID or username. */\n  blockFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend/block\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Import Facebook friends and add them to a user's account. */\n  importFacebookFriends(bearerToken, account, reset, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/friend/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"reset\", reset);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Import Steam friends and add them to a user's account. */\n  importSteamFriends(bearerToken, account, reset, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/friend/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"reset\", reset);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getUserProfileOnClan(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/getclanprofile/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  createLinkInviteUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/invite\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  getLinkInvite(bearerToken, inviteId, options = {}) {\n    if (inviteId === null || inviteId === void 0) {\n      throw new Error(\"'inviteId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/invite/{inviteId}\".replace(\"{inviteId}\", encodeURIComponent(String(inviteId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  inviteUser(bearerToken, inviteId, options = {}) {\n    if (inviteId === null || inviteId === void 0) {\n      throw new Error(\"'inviteId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/invite/{inviteId}\".replace(\"{inviteId}\", encodeURIComponent(String(inviteId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set mute notification user channel. */\n  setMuteNotificationChannel(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/mutenotificationchannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete one or more notifications for the current user. */\n  deleteNotifications(bearerToken, ids, options = {}) {\n    const urlPath = \"/v2/notification\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch list of notifications. */\n  listNotifications(bearerToken, clanId, limit, cacheableCursor, options = {}) {\n    const urlPath = \"/v2/notification\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"cacheable_cursor\", cacheableCursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationChannelSetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/notificationchannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationClanSetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/notificationclan/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationCategorySetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/notificationucategory/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotificationCategorySetting(bearerToken, categoryId, options = {}) {\n    const urlPath = \"/v2/notificationusercategory/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"category_id\", categoryId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotificationChannel(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/notificationuserchannel/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** notification category, channel selected */\n  getChannelCategoryNotiSettingsList(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/notifichannelcategory/get\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotiReactMessage(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/notifireactmessage/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  setNotificationReactMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/notifireactmessage/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set permission role channel. */\n  setRoleChannelPermission(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/permissionrolechannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get permission list */\n  getListPermission(bearerToken, options = {}) {\n    const urlPath = \"/v2/permissions\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getPermissionOfUserInTheClan(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/permissionuserinclan/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deletePinMessage(bearerToken, messageId, options = {}) {\n    const urlPath = \"/v2/pinmessage/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"message_id\", messageId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getPinMessagesList(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/pinmessage/get\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  createPinMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/pinmessage/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  addRolesChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rolechannel/addrole\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update the category of a channel */\n  changeChannelCategory(bearerToken, newCategoryId, body, options = {}) {\n    if (newCategoryId === null || newCategoryId === void 0) {\n      throw new Error(\"'newCategoryId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rolechannel/category/{newCategoryId}\".replace(\"{newCategoryId}\", encodeURIComponent(String(newCategoryId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a role when Delete a role by ID. */\n  deleteRoleChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rolechannel/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user roles */\n  listRoles(bearerToken, limit, state, cursor, clanId, options = {}) {\n    const urlPath = \"/v2/roles\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new role for clan. */\n  createRole(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/roles\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a role when Delete a role by ID. */\n  updateRoleDelete(bearerToken, roleId, body, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\"'roleId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/roles/delete/{roleId}\".replace(\"{roleId}\", encodeURIComponent(String(roleId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a role by ID. */\n  deleteRole(bearerToken, roleId, channelId, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\"'roleId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/roles/{roleId}\".replace(\"{roleId}\", encodeURIComponent(String(roleId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given role. */\n  updateRole(bearerToken, roleId, body, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\"'roleId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/roles/{roleId}\".replace(\"{roleId}\", encodeURIComponent(String(roleId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List role permissions */\n  listRolePermissions(bearerToken, roleId, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\"'roleId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/roles/{roleId}/permissions\".replace(\"{roleId}\", encodeURIComponent(String(roleId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List role permissions */\n  listRoleUsers(bearerToken, roleId, limit, cursor, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\"'roleId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/roles/{roleId}/users\".replace(\"{roleId}\", encodeURIComponent(String(roleId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Execute a Lua function on the server. */\n  rpcFunc2(bearerToken, basicAuthUsername, basicAuthPassword, id, payload, httpKey, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rpc/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"payload\", payload);\n    queryParams.set(\"http_key\", httpKey);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Execute a Lua function on the server. */\n  rpcFunc(bearerToken, basicAuthUsername, basicAuthPassword, id, payload, httpKey, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (payload === null || payload === void 0) {\n      throw new Error(\"'payload' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rpc/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"http_key\", httpKey);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(payload || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\n  sessionLogout(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/session/logout\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a new sticker */\n  addClanSticker(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/sticker\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a sticker by ID */\n  deleteClanStickerById(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/sticker/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a sticker by ID */\n  updateClanStickerById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/sticker/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given category. */\n  updateCategory(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/updatecategory\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update channel private. */\n  updateChannelPrivate(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/updatechannelprivate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateUserProfileByClan(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\"'clanId' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/updateclanprofile/{clanId}\".replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Upload attachment */\n  uploadAttachmentFile(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/uploadattachmentfile\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch zero or more users by ID and/or username. */\n  getUsers(bearerToken, ids, usernames, facebookIds, options = {}) {\n    const urlPath = \"/v2/user\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    queryParams.set(\"facebook_ids\", facebookIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/user/update\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** create webhook */\n  generateWebhook(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/webhooks/generate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update webhook name by id */\n  updateWebhookById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/webhooks/update/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list webhook belong to the channel */\n  listWebhookByChannelId(bearerToken, channelId, clanId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/webhooks/{channelId}\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** disabled webhook */\n  deleteWebhookById(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/webhooks/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  buildFullUrl(basePath, fragment, queryParams) {\n    let fullPath = basePath + fragment + \"?\";\n    for (let [k, v] of queryParams) {\n      if (v instanceof Array) {\n        fullPath += v.reduce((prev, curr) => {\n          return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\n        }, \"\");\n      } else {\n        if (v != null) {\n          fullPath += encodeURIComponent(k) + \"=\" + encodeURIComponent(v) + \"&\";\n        }\n      }\n    }\n    return fullPath;\n  }\n};\n\n// session.ts\nvar Session = class _Session {\n  constructor(token, refresh_token, created) {\n    this.created = created;\n    this.token = token;\n    this.refresh_token = refresh_token;\n    this.created_at = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);\n    this.update(token, refresh_token);\n  }\n  isexpired(currenttime) {\n    return this.expires_at - currenttime < 0;\n  }\n  isrefreshexpired(currenttime) {\n    return this.refresh_expires_at - currenttime < 0;\n  }\n  update(token, refreshToken) {\n    const tokenParts = token.split(\".\");\n    if (tokenParts.length != 3) {\n      throw \"jwt is not valid.\";\n    }\n    const tokenDecoded = JSON.parse(_atob(tokenParts[1]));\n    const tokenExpiresAt = Math.floor(parseInt(tokenDecoded[\"exp\"]));\n    if (refreshToken) {\n      const refreshTokenParts = refreshToken.split(\".\");\n      if (refreshTokenParts.length != 3) {\n        throw \"refresh jwt is not valid.\";\n      }\n      const refreshTokenDecoded = JSON.parse(_atob(refreshTokenParts[1]));\n      const refreshTokenExpiresAt = Math.floor(parseInt(refreshTokenDecoded[\"exp\"]));\n      this.refresh_expires_at = refreshTokenExpiresAt;\n      this.refresh_token = refreshToken;\n    }\n    this.token = token;\n    this.expires_at = tokenExpiresAt;\n    this.username = tokenDecoded[\"usn\"];\n    this.user_id = tokenDecoded[\"uid\"];\n    this.vars = tokenDecoded[\"vrs\"];\n  }\n  static restore(token, refreshToken) {\n    return new _Session(token, refreshToken, false);\n  }\n};\n\n// ../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\nvar i;\nvar encode2 = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n  for (i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nvar decode2 = function(base64) {\n  var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\n\n// web_socket_adapter.ts\nvar WebSocketAdapterText = class {\n  get onClose() {\n    return this._socket.onclose;\n  }\n  set onClose(value) {\n    this._socket.onclose = value;\n  }\n  get onError() {\n    return this._socket.onerror;\n  }\n  set onError(value) {\n    this._socket.onerror = value;\n  }\n  get onMessage() {\n    return this._socket.onmessage;\n  }\n  set onMessage(value) {\n    if (value) {\n      this._socket.onmessage = (evt) => {\n        const message = JSON.parse(evt.data);\n        if (message.party_data && message.party_data.data) {\n          message.party_data.data = new Uint8Array(decode2(message.party_data.data));\n        }\n        value(message);\n      };\n    } else {\n      value = null;\n    }\n  }\n  get onOpen() {\n    return this._socket.onopen;\n  }\n  set onOpen(value) {\n    this._socket.onopen = value;\n  }\n  isOpen() {\n    var _a;\n    return ((_a = this._socket) == null ? void 0 : _a.readyState) == WebSocket.OPEN;\n  }\n  connect(scheme, host, port, createStatus, token) {\n    const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(createStatus.toString())}&token=${encodeURIComponent(token)}`;\n    this._socket = new WebSocket(url);\n  }\n  close() {\n    this._socket.close();\n    this._socket = void 0;\n  }\n  send(msg) {\n    if (msg.party_data_send) {\n      msg.party_data_send.op_code = msg.party_data_send.op_code.toString();\n      let payload = msg.party_data_send.data;\n      if (payload && payload instanceof Uint8Array) {\n        msg.party_data_send.data = encode2(payload.buffer);\n      } else if (payload) {\n        msg.party_data_send.data = _btoa(payload);\n      }\n    }\n    this._socket.send(JSON.stringify(msg));\n  }\n};\n\n// socket.ts\nvar _DefaultSocket = class _DefaultSocket {\n  constructor(host, port, useSSL = false, verbose = false, adapter = new WebSocketAdapterText(), sendTimeoutMs = _DefaultSocket.DefaultSendTimeoutMs) {\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    this.verbose = verbose;\n    this.adapter = adapter;\n    this.sendTimeoutMs = sendTimeoutMs;\n    this.cIds = {};\n    this.nextCid = 1;\n    this._heartbeatTimeoutMs = _DefaultSocket.DefaultHeartbeatTimeoutMs;\n  }\n  generatecid() {\n    const cid = this.nextCid.toString();\n    ++this.nextCid;\n    return cid;\n  }\n  isOpen() {\n    return this.adapter.isOpen();\n  }\n  connect(session, createStatus = false, connectTimeoutMs = _DefaultSocket.DefaultConnectTimeoutMs) {\n    if (this.adapter.isOpen()) {\n      return Promise.resolve(session);\n    }\n    const scheme = this.useSSL ? \"wss://\" : \"ws://\";\n    this.adapter.connect(scheme, this.host, this.port, createStatus, session.token);\n    this.adapter.onClose = (evt) => {\n      this.ondisconnect(evt);\n    };\n    this.adapter.onError = (evt) => {\n      this.onerror(evt);\n    };\n    this.adapter.onMessage = (message) => {\n      if (this.verbose && window && window.console) {\n        console.log(\"Response: %o\", JSON.stringify(message));\n      }\n      if (!message.cid) {\n        if (message.notifications) {\n          message.notifications.notifications.forEach((n) => {\n            n.content = n.content ? JSON.parse(n.content) : void 0;\n            this.onnotification(n);\n          });\n        } else if (message.voice_started_event) {\n          this.onvoicestarted(message.voice_started_event);\n        } else if (message.voice_ended_event) {\n          this.onvoiceended(message.voice_ended_event);\n        } else if (message.voice_joined_event) {\n          this.onvoicejoined(message.voice_joined_event);\n        } else if (message.voice_leaved_event) {\n          this.onvoiceleaved(message.voice_leaved_event);\n        } else if (message.channel_created_event) {\n          this.onchannelcreated(message.channel_created_event);\n        } else if (message.channel_deleted_event) {\n          this.onchanneldeleted(message.channel_deleted_event);\n        } else if (message.channel_updated_event) {\n          this.onchannelupdated(message.channel_updated_event);\n        } else if (message.clan_profile_updated_event) {\n          this.onclanprofileupdated(message.clan_profile_updated_event);\n        } else if (message.clan_updated_event) {\n          this.onclanupdated(message.clan_updated_event);\n        } else if (message.status_presence_event) {\n          this.onstatuspresence(message.status_presence_event);\n        } else if (message.stream_presence_event) {\n          this.onstreampresence(message.stream_presence_event);\n        } else if (message.stream_data) {\n          this.onstreamdata(message.stream_data);\n        } else if (message.channel_message) {\n          var content, reactions, mentions, attachments, references;\n          try {\n            content = JSON.parse(message.channel_message.content);\n          } catch (e2) {\n          }\n          try {\n            reactions = JSON.parse(message.channel_message.reactions);\n          } catch (e2) {\n          }\n          try {\n            mentions = JSON.parse(message.channel_message.mentions);\n          } catch (e2) {\n          }\n          try {\n            attachments = JSON.parse(message.channel_message.attachments);\n          } catch (e2) {\n          }\n          try {\n            references = JSON.parse(message.channel_message.references);\n          } catch (e2) {\n          }\n          var e = {\n            id: message.id,\n            avatar: message.channel_message.avatar,\n            channel_id: message.channel_message.channel_id,\n            mode: message.channel_message.mode,\n            channel_label: message.channel_message.channel_label,\n            clan_id: message.channel_message.clan_id,\n            code: message.channel_message.code,\n            create_time: message.channel_message.create_time,\n            message_id: message.channel_message.message_id,\n            sender_id: message.channel_message.sender_id,\n            update_time: message.channel_message.update_time,\n            clan_logo: message.channel_message.clan_logo,\n            category_name: message.channel_message.category_name,\n            username: message.channel_message.username,\n            clan_nick: message.channel_message.clan_nick,\n            clan_avatar: message.channel_message.clan_avatar,\n            display_name: message.channel_message.display_name,\n            content,\n            reactions,\n            mentions,\n            attachments,\n            references,\n            hideEditted: message.channel_message.hide_editted\n          };\n          this.onchannelmessage(e);\n        } else if (message.message_typing_event) {\n          this.onmessagetyping(message.message_typing_event);\n        } else if (message.message_reaction_event) {\n          this.onmessagereaction(message.message_reaction_event);\n        } else if (message.channel_presence_event) {\n          this.onchannelpresence(message.channel_presence_event);\n        } else if (message.last_pin_message_event) {\n          this.onpinmessage(message.last_pin_message_event);\n        } else if (message.custom_status_event) {\n          this.oncustomstatus(message.custom_status_event);\n        } else if (message.user_channel_added_event) {\n          this.onuserchanneladded(message.user_channel_added_event);\n        } else if (message.user_channel_added_event) {\n          this.onuserprofileupdate(message.user_profile_updated_event);\n        } else if (message.user_profile_updated_event) {\n          this.onuserchannelremoved(message.user_channel_removed_event);\n        } else if (message.user_clan_removed_event) {\n          this.onuserclanremoved(message.user_clan_removed_event);\n        } else {\n          if (this.verbose && window && window.console) {\n            console.log(\"Unrecognized message received: %o\", message);\n          }\n        }\n      } else {\n        const executor = this.cIds[message.cid];\n        if (!executor) {\n          if (this.verbose && window && window.console) {\n            console.error(\"No promise executor for message: %o\", message);\n          }\n          return;\n        }\n        delete this.cIds[message.cid];\n        if (message.error) {\n          executor.reject(message.error);\n        } else {\n          executor.resolve(message);\n        }\n      }\n    };\n    return new Promise((resolve, reject) => {\n      this.adapter.onOpen = (evt) => {\n        if (this.verbose && window && window.console) {\n          console.log(evt);\n        }\n        this.pingPong();\n        resolve(session);\n      };\n      this.adapter.onError = (evt) => {\n        reject(evt);\n        this.adapter.close();\n      };\n      setTimeout(() => {\n        reject(\"The socket timed out when trying to connect.\");\n      }, connectTimeoutMs);\n    });\n  }\n  disconnect(fireDisconnectEvent = true) {\n    if (this.adapter.isOpen()) {\n      this.adapter.close();\n    }\n    if (fireDisconnectEvent) {\n      this.ondisconnect({});\n    }\n  }\n  setHeartbeatTimeoutMs(ms) {\n    this._heartbeatTimeoutMs = ms;\n  }\n  getHeartbeatTimeoutMs() {\n    return this._heartbeatTimeoutMs;\n  }\n  ondisconnect(evt) {\n    if (this.verbose && window && window.console) {\n      console.log(evt);\n    }\n  }\n  onerror(evt) {\n    if (this.verbose && window && window.console) {\n      console.log(evt);\n    }\n  }\n  onmessagetyping(messagetyping) {\n    if (this.verbose && window && window.console) {\n      console.log(messagetyping);\n    }\n  }\n  onmessagereaction(messagereaction) {\n    if (this.verbose && window && window.console) {\n      console.log(messagereaction);\n    }\n  }\n  onchannelmessage(channelMessage) {\n    if (this.verbose && window && window.console) {\n      console.log(channelMessage);\n    }\n  }\n  onchannelpresence(channelPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(channelPresence);\n    }\n  }\n  onuserchanneladded(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserprofileupdate(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserchannelremoved(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserclanremoved(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onnotification(notification) {\n    if (this.verbose && window && window.console) {\n      console.log(notification);\n    }\n  }\n  onstatuspresence(statusPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(statusPresence);\n    }\n  }\n  onpinmessage(pin) {\n    if (this.verbose && window && window.console) {\n      console.log(pin);\n    }\n  }\n  onvoiceended(voice) {\n    if (this.verbose && window && window.console) {\n      console.log(voice);\n    }\n  }\n  onvoicestarted(voice) {\n    if (this.verbose && window && window.console) {\n      console.log(voice);\n    }\n  }\n  onvoicejoined(voiceParticipant) {\n    if (this.verbose && window && window.console) {\n      console.log(voiceParticipant);\n    }\n  }\n  onvoiceleaved(voiceParticipant) {\n    if (this.verbose && window && window.console) {\n      console.log(voiceParticipant);\n    }\n  }\n  onchannelcreated(channelCreated) {\n    if (this.verbose && window && window.console) {\n      console.log(channelCreated);\n    }\n  }\n  onchanneldeleted(channelDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(channelDeleted);\n    }\n  }\n  onchannelupdated(channelUpdated) {\n    if (this.verbose && window && window.console) {\n      console.log(channelUpdated);\n    }\n  }\n  onclanprofileupdated(clanprofile) {\n    if (this.verbose && window && window.console) {\n      console.log(clanprofile);\n    }\n  }\n  onclanupdated(clan) {\n    if (this.verbose && window && window.console) {\n      console.log(clan);\n    }\n  }\n  onstreampresence(streamPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(streamPresence);\n    }\n  }\n  onstreamdata(streamData) {\n    if (this.verbose && window && window.console) {\n      console.log(streamData);\n    }\n  }\n  onheartbeattimeout() {\n    if (this.verbose && window && window.console) {\n      console.log(\"Heartbeat timeout.\");\n    }\n  }\n  oncustomstatus(statusEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(statusEvent);\n    }\n  }\n  send(message, sendTimeout = _DefaultSocket.DefaultSendTimeoutMs) {\n    const untypedMessage = message;\n    return new Promise((resolve, reject) => {\n      if (!this.adapter.isOpen()) {\n        reject(\"Socket connection has not been established yet.\");\n      } else {\n        if (untypedMessage.channel_message_send) {\n          untypedMessage.channel_message_send.content = JSON.stringify(untypedMessage.channel_message_send.content);\n        } else if (untypedMessage.channel_message_update) {\n          untypedMessage.channel_message_update.content = JSON.stringify(untypedMessage.channel_message_update.content);\n        }\n        const cid = this.generatecid();\n        this.cIds[cid] = { resolve, reject };\n        setTimeout(() => {\n          reject(\"The socket timed out while waiting for a response.\");\n        }, sendTimeout);\n        untypedMessage.cid = cid;\n        this.adapter.send(untypedMessage);\n      }\n    });\n  }\n  followUsers(userIds) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ status_follow: { user_ids: userIds } });\n      return response.status;\n    });\n  }\n  joinClanChat(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        clan_join: {\n          clan_id\n        }\n      });\n      return response.clan_join;\n    });\n  }\n  joinChat(clan_id, channel_id, channel_type) {\n    return __async(this, null, function* () {\n      const response = yield this.send(\n        {\n          channel_join: {\n            clan_id,\n            channel_id,\n            channel_type\n          }\n        }\n      );\n      return response.channel;\n    });\n  }\n  leaveChat(clan_id, channel_id, channel_type) {\n    return this.send({ channel_leave: { clan_id, channel_id, channel_type } });\n  }\n  removeChatMessage(clan_id, channel_id, mode, message_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send(\n        {\n          channel_message_remove: {\n            clan_id,\n            channel_id,\n            mode,\n            message_id\n          }\n        }\n      );\n      return response.channel_message_ack;\n    });\n  }\n  removePartyMember(party_id, member) {\n    return __async(this, null, function* () {\n      return this.send({ party_remove: {\n        party_id,\n        presence: member\n      } });\n    });\n  }\n  rpc(id, payload, http_key) {\n    return __async(this, null, function* () {\n      const response = yield this.send(\n        {\n          rpc: {\n            id,\n            payload,\n            http_key\n          }\n        }\n      );\n      return response.rpc;\n    });\n  }\n  sendPartyData(party_id, op_code, data) {\n    return this.send({ party_data_send: { party_id, op_code, data } });\n  }\n  unfollowUsers(user_ids) {\n    return this.send({ status_unfollow: { user_ids } });\n  }\n  updateChatMessage(clan_id, channel_id, mode, message_id, content, mentions, attachments, hideEditted) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ channel_message_update: { clan_id, channel_id, message_id, content, mentions, attachments, mode, hideEditted } });\n      return response.channel_message_ack;\n    });\n  }\n  updateStatus(status) {\n    return this.send({ status_update: { status } });\n  }\n  writeChatMessage(clan_id, channel_id, mode, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ channel_message_send: { clan_id, channel_id, mode, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar } });\n      return response.channel_message_ack;\n    });\n  }\n  writeMessageReaction(id, clan_id, channel_id, mode, message_id, emoji_id, emoji, count, message_sender_id, action_delete) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ message_reaction_event: { id, clan_id, channel_id, mode, message_id, emoji_id, emoji, count, message_sender_id, action: action_delete } });\n      return response.message_reaction_event;\n    });\n  }\n  writeMessageTyping(clan_id, channel_id, mode) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ message_typing_event: { clan_id, channel_id, mode } });\n      return response.message_typing_event;\n    });\n  }\n  writeLastSeenMessage(clan_id, channel_id, mode, message_id, timestamp) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ last_seen_message_event: { clan_id, channel_id, mode, message_id, timestamp } });\n      return response.last_seen_message_event;\n    });\n  }\n  writeLastPinMessage(clan_id, channel_id, mode, message_id, timestamp, operation) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ last_pin_message_event: { clan_id, channel_id, mode, message_id, timestamp, operation } });\n      return response.last_pin_message_event;\n    });\n  }\n  writeVoiceJoined(id, clanId, clanName, voiceChannelId, voiceChannelLabel, participant, lastScreenshot) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ voice_joined_event: { clan_id: clanId, clan_name: clanName, id, participant, voice_channel_id: voiceChannelId, voice_channel_label: voiceChannelLabel, last_screenshot: lastScreenshot } });\n      return response.voice_joined_event;\n    });\n  }\n  writeVoiceLeaved(id, clanId, voiceChannelId, voiceUserId) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ voice_leaved_event: { id, clan_id: clanId, voice_channel_id: voiceChannelId, voice_user_id: voiceUserId } });\n      return response.voice_leaved_event;\n    });\n  }\n  writeCustomStatus(clan_id, status) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ custom_status_event: { clan_id, status } });\n      return response.custom_status_event;\n    });\n  }\n  checkDuplicateClanName(clan_name) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ clan_name_existed_event: { clan_name } });\n      return response.clan_name_existed_event;\n    });\n  }\n  listClanEmojiByClanId(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ emojis_listed_event: { clan_id } });\n      return response.emojis_listed_event;\n    });\n  }\n  ListChannelByUserId() {\n    return __async(this, null, function* () {\n      const response = yield this.send({ channel_desc_list_event: {} });\n      return response.channel_desc_list_event;\n    });\n  }\n  hashtagDMList(user_id, limit) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ hashtag_dm_list_event: { user_id, limit } });\n      return response.hashtag_dm_list_event;\n    });\n  }\n  GetPermissionByRoleIdChannelId(role_id, channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ permission_role_channel_list_event: { role_id, channel_id } });\n      return response.permission_role_channel_list_event;\n    });\n  }\n  listClanStickersByClanId(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ sticker_listed_event: { clan_id } });\n      return response.sticker_listed_event;\n    });\n  }\n  getNotificationChannelSetting(channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_channel_setting_event: { channel_id } });\n      return response.notification_channel_setting_event;\n    });\n  }\n  getNotificationCategorySetting(category_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_category_setting_event: { category_id } });\n      return response.notification_category_setting_event;\n    });\n  }\n  getNotificationClanSetting(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_clan_setting_event: { clan_id } });\n      return response.notification_clan_setting_event;\n    });\n  }\n  getNotificationReactMessage(channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notifi_react_message_event: { channel_id } });\n      return response.notifi_react_message_event;\n    });\n  }\n  pingPong() {\n    return __async(this, null, function* () {\n      if (!this.adapter.isOpen()) {\n        return;\n      }\n      try {\n        yield this.send({ ping: {} }, this._heartbeatTimeoutMs);\n      } catch (e) {\n        if (this.adapter.isOpen()) {\n          if (window && window.console) {\n            console.error(\"Server unreachable from heartbeat.\");\n          }\n          this.onheartbeattimeout();\n          this.adapter.close();\n        }\n        return;\n      }\n      setTimeout(() => this.pingPong(), this._heartbeatTimeoutMs);\n    });\n  }\n};\n_DefaultSocket.DefaultHeartbeatTimeoutMs = 1e4;\n_DefaultSocket.DefaultSendTimeoutMs = 1e4;\n_DefaultSocket.DefaultConnectTimeoutMs = 3e4;\nvar DefaultSocket = _DefaultSocket;\n\n// client.ts\nvar DEFAULT_HOST = \"127.0.0.1\";\nvar DEFAULT_PORT = \"7350\";\nvar DEFAULT_SERVER_KEY = \"defaultkey\";\nvar DEFAULT_TIMEOUT_MS = 7e3;\nvar DEFAULT_EXPIRED_TIMESPAN_MS = 5 * 60 * 1e3;\nvar ChannelType = /* @__PURE__ */ ((ChannelType2) => {\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_TEXT\"] = 1] = \"CHANNEL_TYPE_TEXT\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_GROUP\"] = 2] = \"CHANNEL_TYPE_GROUP\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_DM\"] = 3] = \"CHANNEL_TYPE_DM\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_VOICE\"] = 4] = \"CHANNEL_TYPE_VOICE\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_FORUM\"] = 5] = \"CHANNEL_TYPE_FORUM\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_ANNOUNCEMENT\"] = 6] = \"CHANNEL_TYPE_ANNOUNCEMENT\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_THREAD\"] = 7] = \"CHANNEL_TYPE_THREAD\";\n  return ChannelType2;\n})(ChannelType || {});\nvar ChannelStreamMode = /* @__PURE__ */ ((ChannelStreamMode2) => {\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_CHANNEL\"] = 2] = \"STREAM_MODE_CHANNEL\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_GROUP\"] = 3] = \"STREAM_MODE_GROUP\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_DM\"] = 4] = \"STREAM_MODE_DM\";\n  return ChannelStreamMode2;\n})(ChannelStreamMode || {});\nvar NotificationType = /* @__PURE__ */ ((NotificationType2) => {\n  NotificationType2[NotificationType2[\"ALL_MESSAGE\"] = 1] = \"ALL_MESSAGE\";\n  NotificationType2[NotificationType2[\"MENTION_MESSAGE\"] = 2] = \"MENTION_MESSAGE\";\n  NotificationType2[NotificationType2[\"NOTHING_MESSAGE\"] = 3] = \"NOTHING_MESSAGE\";\n  return NotificationType2;\n})(NotificationType || {});\nvar Client = class {\n  constructor(serverkey = DEFAULT_SERVER_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = false, timeout = DEFAULT_TIMEOUT_MS, autoRefreshSession = true) {\n    this.serverkey = serverkey;\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    this.timeout = timeout;\n    this.autoRefreshSession = autoRefreshSession;\n    /** The expired timespan used to check session lifetime. */\n    this.expiredTimespanMs = DEFAULT_EXPIRED_TIMESPAN_MS;\n    const scheme = useSSL ? \"https://\" : \"http://\";\n    const basePath = `${scheme}${host}:${port}`;\n    this.apiClient = new MezonApi(serverkey, basePath, timeout);\n  }\n  /** Add users to a channel, or accept their join requests. */\n  addChannelUsers(session, channelId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addChannelUsers(session.token, channelId, ids).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add friends by ID or username to a user's account. */\n  addFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addFriends(session.token, ids, usernames).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Authenticate a user with an Apple ID against the server. */\n  authenticateApple(_0, _1, _2) {\n    return __async(this, arguments, function* (token, create, username, vars = {}, options = {}) {\n      const request = {\n        \"token\": token,\n        \"vars\": vars\n      };\n      return this.apiClient.authenticateApple(this.serverkey, \"\", request, create, username, options).then((apiSession) => {\n        return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n      });\n    });\n  }\n  /** Authenticate a user with a custom id against the server. */\n  authenticateCustom(id, create, username, vars = {}, options = {}) {\n    const request = {\n      \"id\": id,\n      \"vars\": vars\n    };\n    return this.apiClient.authenticateCustom(this.serverkey, \"\", request, create, username, options).then((apiSession) => {\n      return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n    });\n  }\n  /** Authenticate a user with a device id against the server. */\n  authenticateDevice(id, create, username, vars) {\n    const request = {\n      \"id\": id,\n      \"vars\": vars\n    };\n    return this.apiClient.authenticateDevice(this.serverkey, \"\", request, create, username).then((apiSession) => {\n      return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n    });\n  }\n  /** Authenticate a user with an email+password against the server. */\n  authenticateEmail(email, password, username, vars) {\n    const request = {\n      \"email\": email,\n      \"password\": password,\n      \"vars\": vars\n    };\n    return this.apiClient.authenticateEmail(this.serverkey, \"\", request, username).then((apiSession) => {\n      return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n    });\n  }\n  /** Authenticate a user with a Facebook Instant Game token against the server. */\n  authenticateFacebookInstantGame(signedPlayerInfo, create, username, vars, options = {}) {\n    const request = {\n      \"signed_player_info\": signedPlayerInfo,\n      \"vars\": vars\n    };\n    return this.apiClient.authenticateFacebookInstantGame(\n      this.serverkey,\n      \"\",\n      { signed_player_info: request.signed_player_info, vars: request.vars },\n      create,\n      username,\n      options\n    ).then((apiSession) => {\n      return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n    });\n  }\n  /** Authenticate a user with a Facebook OAuth token against the server. */\n  authenticateFacebook(token, create, username, sync, vars, options = {}) {\n    const request = {\n      \"token\": token,\n      \"vars\": vars\n    };\n    return this.apiClient.authenticateFacebook(this.serverkey, \"\", request, create, username, sync, options).then((apiSession) => {\n      return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n    });\n  }\n  /** Authenticate a user with Google against the server. */\n  authenticateGoogle(_0, _1, _2, _3) {\n    return __async(this, arguments, function* (token, create, username, vars, options = {}) {\n      const request = {\n        token,\n        vars\n      };\n      const apiSession = yield this.apiClient.authenticateGoogle(\n        this.serverkey,\n        \"\",\n        request,\n        create,\n        username,\n        options\n      );\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with GameCenter against the server. */\n  authenticateGameCenter(_0, _1, _2, _3, _4, _5, _6, _7, _8) {\n    return __async(this, arguments, function* (bundleId, playerId, publicKeyUrl, salt, signature, timestamp, username, create, vars, options = {}) {\n      const request = {\n        bundle_id: bundleId,\n        player_id: playerId,\n        public_key_url: publicKeyUrl,\n        salt,\n        signature,\n        timestamp_seconds: timestamp,\n        vars\n      };\n      const apiSession = yield this.apiClient.authenticateGameCenter(\n        this.serverkey,\n        \"\",\n        request,\n        create,\n        username,\n        options\n      );\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with Steam against the server. */\n  authenticateSteam(token, create, username, sync, vars) {\n    return __async(this, null, function* () {\n      const request = {\n        \"token\": token,\n        \"vars\": vars,\n        \"sync\": sync\n      };\n      return this.apiClient.authenticateSteam(this.serverkey, \"\", request, create, username).then((apiSession) => {\n        return new Session(apiSession.token || \"\", apiSession.refresh_token || \"\", apiSession.created || false);\n      });\n    });\n  }\n  /** Block one or more users by ID or username. */\n  blockFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.blockFriends(session.token, ids, usernames).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Create a new group with the current user as the creator and superadmin. */\n  uploadAttachmentFile(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.uploadAttachmentFile(session.token, request);\n    });\n  }\n  /** Create a channel within clan */\n  createChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createChannelDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a clan */\n  createClanDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createClanDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /**  */\n  createCategoryDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createCategoryDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a new role for clan. */\n  createRole(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createRole(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a new event for clan. */\n  createEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createEvent(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** add role for channel. */\n  addRolesChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addRolesChannelDesc(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update action role when delete role */\n  deleteRoleChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteRoleChannelDesc(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** A socket created with the client's configuration. */\n  createSocket(useSSL = false, verbose = false, adapter = new WebSocketAdapterText(), sendTimeoutMs = DefaultSocket.DefaultSendTimeoutMs) {\n    return new DefaultSocket(this.host, this.port, useSSL, verbose, adapter, sendTimeoutMs);\n  }\n  /** Delete one or more users by ID or username. */\n  deleteFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteFriends(session.token, ids, usernames).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a channel by ID. */\n  deleteChannelDesc(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteChannelDesc(session.token, channelId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a clan desc by ID. */\n  deleteClanDesc(session, clanDescId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanDesc(session.token, clanDescId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a category by ID. */\n  deleteCategoryDesc(session, creatorId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteCategoryDesc(session.token, creatorId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete one or more notifications */\n  deleteNotifications(session, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotifications(session.token, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Delete a role by ID. */\n  deleteRole(session, roleId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteRole(session.token, roleId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a event by ID. */\n  deleteEvent(session, roleId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteEvent(session.token, roleId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** update user a event by ID. */\n  updateEventUser(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateEventUser(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Submit an event for processing in the server's registered runtime custom events handler. */\n  emitEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.event(session.token, request).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Fetch the current user's account. */\n  getAccount(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getAccount(session.token);\n    });\n  }\n  /** Import Facebook friends and add them to a user's account. */\n  importFacebookFriends(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.importFacebookFriends(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Import Steam friends and add them to a user's account. */\n  importSteamFriends(session, request, reset) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.importSteamFriends(session.token, request, reset).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Fetch zero or more users by ID and/or username. */\n  getUsers(session, ids, usernames, facebookIds) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUsers(session.token, ids, usernames, facebookIds).then((response) => {\n        var result = {\n          users: []\n        };\n        if (response.users == null) {\n          return Promise.resolve(result);\n        }\n        response.users.forEach((u) => {\n          result.users.push({\n            avatar_url: u.avatar_url,\n            create_time: u.create_time,\n            display_name: u.display_name,\n            edge_count: u.edge_count ? Number(u.edge_count) : 0,\n            facebook_id: u.facebook_id,\n            gamecenter_id: u.gamecenter_id,\n            google_id: u.google_id,\n            id: u.id,\n            lang_tag: u.lang_tag,\n            location: u.location,\n            online: u.online,\n            steam_id: u.steam_id,\n            timezone: u.timezone,\n            update_time: u.update_time,\n            username: u.username,\n            metadata: u.metadata ? JSON.parse(u.metadata) : void 0\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Kick a set of users from a clan. */\n  removeClanUsers(session, clanId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeClanUsers(session.token, clanId, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Kick users from a channel, or decline their join requests. */\n  removeChannelUsers(session, channelId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeChannelUsers(session.token, channelId, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** List a channel's message history. */\n  listChannelMessages(session, channelId, messageId, direction, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelMessages(session.token, channelId, messageId, direction, limit).then((response) => {\n        var result = {\n          messages: [],\n          last_seen_message: response.last_seen_message,\n          last_sent_message: response.last_sent_message\n        };\n        if (response.messages == null) {\n          return Promise.resolve(result);\n        }\n        response.messages.forEach((m) => {\n          var content, reactions, mentions, attachments, references;\n          try {\n            content = JSON.parse(m.content);\n          } catch (e) {\n          }\n          try {\n            reactions = JSON.parse(m.reactions || \"[]\");\n          } catch (e) {\n          }\n          try {\n            mentions = JSON.parse(m.mentions || \"[]\");\n          } catch (e) {\n          }\n          try {\n            attachments = JSON.parse(m.attachments || \"[]\");\n          } catch (e) {\n          }\n          try {\n            references = JSON.parse(m.references || \"[]\");\n          } catch (e) {\n          }\n          result.messages.push({\n            channel_id: m.channel_id,\n            code: m.code ? Number(m.code) : 0,\n            create_time: m.create_time || \"\",\n            id: m.message_id,\n            sender_id: m.sender_id,\n            update_time: m.update_time,\n            username: m.username,\n            display_name: m.display_name,\n            avatar: m.avatar,\n            content,\n            channel_label: m.channel_label,\n            clan_logo: m.clan_logo,\n            category_name: m.category_name,\n            clan_nick: m.clan_nick,\n            clan_avatar: m.clan_avatar,\n            attachments,\n            mentions,\n            reactions,\n            references,\n            clan_id: m.clan_id,\n            create_time_ms: m.create_time_ms,\n            update_time_ms: m.update_time_ms\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelVoiceUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelVoiceUsers(session.token, clanId, channelId, channelType, limit, state, cursor).then((response) => {\n        var result = {\n          voice_channel_users: []\n        };\n        if (response.voice_channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.voice_channel_users.forEach((gu) => {\n          result.voice_channel_users.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            user_id: gu.user_id,\n            participant: gu.participant\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelUsers(session.token, clanId, channelId, channelType, limit, state, cursor).then((response) => {\n        var result = {\n          channel_users: [],\n          cursor: response.cursor,\n          channel_id: response.channel_id\n        };\n        if (response.channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.channel_users.forEach((gu) => {\n          var _a;\n          result.channel_users.push({\n            user: {\n              avatar_url: gu.user.avatar_url,\n              create_time: gu.user.create_time,\n              display_name: gu.user.display_name,\n              edge_count: gu.user.edge_count ? Number(gu.user.edge_count) : 0,\n              facebook_id: gu.user.facebook_id,\n              gamecenter_id: gu.user.gamecenter_id,\n              google_id: gu.user.google_id,\n              id: gu.user.id,\n              lang_tag: gu.user.lang_tag,\n              location: gu.user.location,\n              online: gu.user.online,\n              steam_id: gu.user.steam_id,\n              timezone: gu.user.timezone,\n              update_time: gu.user.update_time,\n              username: gu.user.username,\n              about_me: (_a = gu.user) == null ? void 0 : _a.about_me,\n              metadata: gu.user.metadata ? JSON.parse(gu.user.metadata) : void 0\n            },\n            role_id: gu.role_id,\n            thread_id: gu.thread_id,\n            clan_avatar: gu.clan_avatar,\n            clan_nick: gu.clan_nick,\n            id: gu.id,\n            clan_id: gu.clan_id\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's attachment. */\n  listChannelAttachments(session, clanId, channelId, fileType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelAttachment(session.token, clanId, channelId, fileType, limit, state, cursor).then((response) => {\n        var result = {\n          attachments: []\n        };\n        if (response.attachments == null) {\n          return Promise.resolve(result);\n        }\n        response.attachments.forEach((at) => {\n          result.attachments.push({\n            filename: at.filename,\n            filesize: at.filesize,\n            filetype: at.filetype,\n            id: at.id,\n            uploader: at.uploader,\n            url: at.url,\n            create_time: at.create_time\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listClanUsers(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanUsers(session.token, clanId).then((response) => {\n        var result = {\n          clan_users: [],\n          cursor: response.cursor,\n          clan_id: response.clan_id\n        };\n        if (response.clan_users == null) {\n          return Promise.resolve(result);\n        }\n        response.clan_users.forEach((gu) => {\n          result.clan_users.push({\n            user: {\n              avatar_url: gu.user.avatar_url,\n              create_time: gu.user.create_time,\n              display_name: gu.user.display_name,\n              edge_count: gu.user.edge_count ? Number(gu.user.edge_count) : 0,\n              facebook_id: gu.user.facebook_id,\n              gamecenter_id: gu.user.gamecenter_id,\n              google_id: gu.user.google_id,\n              id: gu.user.id,\n              lang_tag: gu.user.lang_tag,\n              location: gu.user.location,\n              online: gu.user.online,\n              steam_id: gu.user.steam_id,\n              timezone: gu.user.timezone,\n              update_time: gu.user.update_time,\n              username: gu.user.username,\n              metadata: gu.user.metadata ? JSON.parse(gu.user.metadata) : void 0\n            },\n            role_id: gu.role_id,\n            clan_nick: gu.clan_nick,\n            clan_avatar: gu.clan_avatar\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List channels. */\n  listChannelDescs(session, limit, state, cursor, clanId, channelType) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelDescs(session.token, limit, state, cursor, clanId, channelType).then((response) => {\n        var result = {\n          channeldesc: [],\n          next_cursor: response.next_cursor,\n          prev_cursor: response.prev_cursor,\n          cacheable_cursor: response.cacheable_cursor\n        };\n        if (response.channeldesc == null) {\n          return Promise.resolve(result);\n        }\n        result.channeldesc = response.channeldesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List clans */\n  listClanDescs(session, limit, state, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanDescs(session.token, limit, state, cursor).then((response) => {\n        var result = {\n          clandesc: []\n        };\n        if (response.clandesc == null) {\n          return Promise.resolve(result);\n        }\n        result.clandesc = response.clandesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List categories. */\n  listCategoryDescs(session, clanId, creatorId, categoryName) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listCategoryDescs(session.token, clanId, creatorId, categoryName).then((response) => {\n        var result = {\n          categorydesc: []\n        };\n        if (response.categorydesc == null) {\n          return Promise.resolve(result);\n        }\n        result.categorydesc = response.categorydesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List user roles */\n  listRoles(session, limit, state, cursor, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRoles(session.token, limit, state, cursor, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List event */\n  listEvents(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listEvents(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List permission */\n  getListPermission(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListPermission(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Update action role when delete role */\n  updateRoleDelete(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateRoleDelete(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** List user roles */\n  listRolePermissions(session, roleId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRolePermissions(session.token, roleId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List user roles */\n  listRoleUsers(session, roleId, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRoleUsers(session.token, roleId, limit, cursor).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  registFCMDeviceToken(session, tokenId, deviceId, platform) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.registFCMDeviceToken(session.token, tokenId, deviceId, platform).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Get a clan desc profile */\n  getClanDescProfile(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getClanDescProfile(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getUserProfileOnClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUserProfileOnClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Add an Apple ID to the social profiles on the current user's account. */\n  linkApple(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkApple(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //\n  closeDirectMess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.closeDirectMess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //\n  openDirectMess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.openDirectMess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add a custom ID to the social profiles on the current user's account. */\n  linkCustom(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkCustom(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add a device ID to the social profiles on the current user's account. */\n  linkDevice(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkDevice(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add an email+password to the social profiles on the current user's account. */\n  linkEmail(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkEmail(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Facebook to the social profiles on the current user's account. */\n  linkFacebook(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkFacebook(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Facebook Instant to the social profiles on the current user's account. */\n  linkFacebookInstantGame(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkFacebookInstantGame(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Google to the social profiles on the current user's account. */\n  linkGoogle(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkGoogle(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add GameCenter to the social profiles on the current user's account. */\n  linkGameCenter(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkGameCenter(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Steam to the social profiles on the current user's account. */\n  linkSteam(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkSteam(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** List all friends for the current user. */\n  listFriends(session, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listFriends(session.token, limit, state, cursor).then((response) => {\n        var result = {\n          friends: [],\n          cursor: response.cursor\n        };\n        if (response.friends == null) {\n          return Promise.resolve(result);\n        }\n        response.friends.forEach((f) => {\n          result.friends.push({\n            user: {\n              avatar_url: f.user.avatar_url,\n              create_time: f.user.create_time,\n              display_name: f.user.display_name,\n              edge_count: f.user.edge_count ? Number(f.user.edge_count) : 0,\n              facebook_id: f.user.facebook_id,\n              gamecenter_id: f.user.gamecenter_id,\n              google_id: f.user.google_id,\n              id: f.user.id,\n              lang_tag: f.user.lang_tag,\n              location: f.user.location,\n              online: f.user.online,\n              steam_id: f.user.steam_id,\n              timezone: f.user.timezone,\n              update_time: f.user.update_time,\n              username: f.user.username,\n              metadata: f.user.metadata ? JSON.parse(f.user.metadata) : void 0\n            },\n            state: f.state\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Fetch list of notifications. */\n  listNotifications(session, clanId, limit, cacheableCursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listNotifications(session.token, clanId, limit, cacheableCursor).then((response) => {\n        var result = {\n          cacheable_cursor: response.cacheable_cursor,\n          notifications: []\n        };\n        if (response.notifications == null) {\n          return Promise.resolve(result);\n        }\n        response.notifications.forEach((n) => {\n          result.notifications.push({\n            code: n.code ? Number(n.code) : 0,\n            create_time: n.create_time,\n            id: n.id,\n            persistent: n.persistent,\n            sender_id: n.sender_id,\n            subject: n.subject,\n            content: n.content ? JSON.parse(n.content) : void 0\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Execute an RPC function on the server. */\n  rpc(session, basicAuthUsername, basicAuthPassword, id, input) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.rpcFunc(session.token, basicAuthUsername, basicAuthPassword, id, JSON.stringify(input)).then((response) => {\n        return Promise.resolve({\n          id: response.id,\n          payload: !response.payload ? void 0 : JSON.parse(response.payload)\n        });\n      });\n    });\n  }\n  /** Execute an RPC function on the server. */\n  rpcHttpKey(httpKey, id, input) {\n    return __async(this, null, function* () {\n      return this.apiClient.rpcFunc2(\"\", id, input && JSON.stringify(input) || \"\", httpKey).then((response) => {\n        return Promise.resolve({\n          id: response.id,\n          payload: !response.payload ? void 0 : JSON.parse(response.payload)\n        });\n      }).catch((err) => {\n        throw err;\n      });\n    });\n  }\n  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\n  sessionLogout(session, token, refreshToken) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.sessionLogout(session.token, { refresh_token: refreshToken, token }).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\n  sessionRefresh(_0) {\n    return __async(this, arguments, function* (session, vars = {}) {\n      if (!session) {\n        console.error(\"Cannot refresh a null session.\");\n        return session;\n      }\n      if (session.created && session.expires_at - session.created_at < 70) {\n        console.warn(\"Session lifetime too short, please set '--session.token_expiry_sec' option. See the documentation for more info: https://mezon.vn/docs/mezon/getting-started/configuration/#session\");\n      }\n      if (session.created && session.refresh_expires_at - session.created_at < 3700) {\n        console.warn(\"Session refresh lifetime too short, please set '--session.refresh_token_expiry_sec' option. See the documentation for more info: https://mezon.vn/docs/mezon/getting-started/configuration/#session\");\n      }\n      const apiSession = yield this.apiClient.sessionRefresh(this.serverkey, \"\", { token: session.refresh_token, vars });\n      session.update(apiSession.token, apiSession.refresh_token);\n      return session;\n    });\n  }\n  /** Remove the Apple ID from the social profiles on the current user's account. */\n  unlinkApple(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkApple(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove custom ID from the social profiles on the current user's account. */\n  unlinkCustom(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkCustom(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove a device ID from the social profiles on the current user's account. */\n  unlinkDevice(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkDevice(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove an email+password from the social profiles on the current user's account. */\n  unlinkEmail(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkEmail(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Facebook from the social profiles on the current user's account. */\n  unlinkFacebook(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkFacebook(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Facebook Instant social profiles from the current user's account. */\n  unlinkFacebookInstantGame(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkFacebookInstantGame(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Google from the social profiles on the current user's account. */\n  unlinkGoogle(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkGoogle(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove GameCenter from the social profiles on the current user's account. */\n  unlinkGameCenter(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkGameCenter(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Steam from the social profiles on the current user's account. */\n  unlinkSteam(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkSteam(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in the current user's account. */\n  updateAccount(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateAccount(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given channel */\n  updateChannelDesc(session, channelId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateChannelDesc(session.token, channelId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan. */\n  updateClanDesc(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanDesc(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given category. */\n  updateCategory(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateCategory(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan profile. */\n  updateClanDescProfile(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanDescProfile(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  updateUserProfileByClan(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateUserProfileByClan(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given role. */\n  updateRole(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateRole(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given event. */\n  updateEvent(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateEvent(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan profile. */\n  createLinkInviteUser(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createLinkInviteUser(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get link invite user */\n  getLinkInvite(session, inviteId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getLinkInvite(session.token, inviteId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get permission of user in the clan */\n  getPermissionOfUserInTheClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPermissionOfUserInTheClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** invite user */\n  inviteUser(session, inviteId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.inviteUser(session.token, inviteId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Set default notification clan*/\n  setNotificationClan(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationClanSetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification channel*/\n  setNotificationChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationChannelSetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification channel*/\n  setMuteNotificationChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setMuteNotificationChannel(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** update channel private*/\n  updateChannelPrivate(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateChannelPrivate(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set default notification category*/\n  setNotificationCategory(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationCategorySetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteNotificationCategory(session, category_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotificationCategorySetting(session.token, category_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  getChannelCategoryNotiSettingsList(session, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getChannelCategoryNotiSettingsList(session.token, clan_id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteNotificationChannel(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotificationChannel(session.token, channel_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** */\n  setNotificationReactMessage(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationReactMessage(session.token, { channel_id }).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //** */\n  deleteNotiReactMessage(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotiReactMessage(session.token, channel_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** query message in elasticsearch */\n  searchMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.searchMessage(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** */\n  createPinMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createPinMessage(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  pinMessagesList(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPinMessagesList(session.token, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //** */\n  deletePinMessage(session, message_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deletePinMessage(session.token, message_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** create clan emoji */\n  createClanEmoji(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createClanEmoji(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**update clan emoji by id */\n  updateClanEmojiById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanEmojiById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**delete clan emoji by id */\n  deleteByIdClanEmoji(session, id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanEmojiById(session.token, id, clan_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**create webhook for chaneel */\n  generateWebhookLink(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.generateWebhook(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list webhook belong to the channel */\n  listWebhookByChannelId(session, channel_id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listWebhookByChannelId(session.token, channel_id, clan_id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**update webhook name by id */\n  updateWebhookById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateWebhookById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**disabled webhook by id */\n  deleteWebhookById(session, id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteWebhookById(session.token, id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**check duplicate clan name */\n  checkDuplicateClanName(session, clan_name) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.checkDuplicateClanName(session.token, clan_name).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**Add a new sticker */\n  addClanSticker(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addClanSticker(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**Delete a sticker by ID*/\n  deleteClanStickerById(session, id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanStickerById(session.token, id, clan_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**Update a sticker by ID*/\n  updateClanStickerById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanStickerById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //** update the category of a channel */\n  changeChannelCategory(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.changeChannelCategory(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** */\n  setRoleChannelPermission(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setRoleChannelPermission(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  addApp(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addApp(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  getApp(session, id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getApp(session.token, id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listApp(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listApps(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n};\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/./node_modules/mezon-js/dist/mezon-js.cjs.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Copyright 2021 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nexports.__esModule = true;\r\nvar mezon_js_1 = __webpack_require__(/*! mezon-js */ \"./node_modules/mezon-js/dist/mezon-js.cjs.js\");\r\nvar mezon_js_protobuf_1 = __webpack_require__(/*! mezon-js-protobuf */ \"../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js\");\r\nvar useSSL = false; // Enable if server is run with an SSL certificate.\r\n//var client = new Client(\"defaultkey\", \"dev-mezon.nccsoft.vn\", \"7305\", useSSL);\r\nvar client = new mezon_js_1.Client(\"defaultkey\", \"127.0.0.1\", \"7350\", useSSL);\r\nclient.authenticateEmail(\"user1@ncc.asia\", \"Aa12345678\").then(function (session) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var socket, session2;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                console.log(\"authenticated.\", session);\r\n                socket = client.createSocket(false, true, new mezon_js_protobuf_1.WebSocketAdapterPb());\r\n                return [4 /*yield*/, socket.connect(session, true)];\r\n            case 1:\r\n                session2 = _a.sent();\r\n                console.log(\"session\", session2);\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}); })[\"catch\"](function (e) {\r\n    console.log(\"error authenticating.\");\r\n});\r\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;