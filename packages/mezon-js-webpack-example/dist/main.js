/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js":
/*!**********************************************************!*\
  !*** ../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// ../../node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"../../node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"../../node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"../../node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"../../node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\")\n        (function() {\n          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n          function writeFloat_f32_cpy(val, buf, pos) {\n            f32[0] = val;\n            buf[pos] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n          }\n          function writeFloat_f32_rev(val, buf, pos) {\n            f32[0] = val;\n            buf[pos] = f8b[3];\n            buf[pos + 1] = f8b[2];\n            buf[pos + 2] = f8b[1];\n            buf[pos + 3] = f8b[0];\n          }\n          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n          function readFloat_f32_cpy(buf, pos) {\n            f8b[0] = buf[pos];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            return f32[0];\n          }\n          function readFloat_f32_rev(buf, pos) {\n            f8b[3] = buf[pos];\n            f8b[2] = buf[pos + 1];\n            f8b[1] = buf[pos + 2];\n            f8b[0] = buf[pos + 3];\n            return f32[0];\n          }\n          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n        })();\n      else\n        (function() {\n          function writeFloat_ieee754(writeUint, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n              val = -val;\n            if (val === 0)\n              writeUint(1 / val > 0 ? (\n                /* positive */\n                0\n              ) : (\n                /* negative 0 */\n                2147483648\n              ), buf, pos);\n            else if (isNaN(val))\n              writeUint(2143289344, buf, pos);\n            else if (val > 34028234663852886e22)\n              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n            else if (val < 11754943508222875e-54)\n              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n            else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n            }\n          }\n          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n          function readFloat_ieee754(readUint, buf, pos) {\n            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n          }\n          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n        })();\n      if (typeof Float64Array !== \"undefined\")\n        (function() {\n          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n          function writeDouble_f64_cpy(val, buf, pos) {\n            f64[0] = val;\n            buf[pos] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n            buf[pos + 4] = f8b[4];\n            buf[pos + 5] = f8b[5];\n            buf[pos + 6] = f8b[6];\n            buf[pos + 7] = f8b[7];\n          }\n          function writeDouble_f64_rev(val, buf, pos) {\n            f64[0] = val;\n            buf[pos] = f8b[7];\n            buf[pos + 1] = f8b[6];\n            buf[pos + 2] = f8b[5];\n            buf[pos + 3] = f8b[4];\n            buf[pos + 4] = f8b[3];\n            buf[pos + 5] = f8b[2];\n            buf[pos + 6] = f8b[1];\n            buf[pos + 7] = f8b[0];\n          }\n          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n          function readDouble_f64_cpy(buf, pos) {\n            f8b[0] = buf[pos];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            f8b[4] = buf[pos + 4];\n            f8b[5] = buf[pos + 5];\n            f8b[6] = buf[pos + 6];\n            f8b[7] = buf[pos + 7];\n            return f64[0];\n          }\n          function readDouble_f64_rev(buf, pos) {\n            f8b[7] = buf[pos];\n            f8b[6] = buf[pos + 1];\n            f8b[5] = buf[pos + 2];\n            f8b[4] = buf[pos + 3];\n            f8b[3] = buf[pos + 4];\n            f8b[2] = buf[pos + 5];\n            f8b[1] = buf[pos + 6];\n            f8b[0] = buf[pos + 7];\n            return f64[0];\n          }\n          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n        })();\n      else\n        (function() {\n          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n              val = -val;\n            if (val === 0) {\n              writeUint(0, buf, pos + off0);\n              writeUint(1 / val > 0 ? (\n                /* positive */\n                0\n              ) : (\n                /* negative 0 */\n                2147483648\n              ), buf, pos + off1);\n            } else if (isNaN(val)) {\n              writeUint(0, buf, pos + off0);\n              writeUint(2146959360, buf, pos + off1);\n            } else if (val > 17976931348623157e292) {\n              writeUint(0, buf, pos + off0);\n              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n            } else {\n              var mantissa;\n              if (val < 22250738585072014e-324) {\n                mantissa = val / 5e-324;\n                writeUint(mantissa >>> 0, buf, pos + off0);\n                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n              } else {\n                var exponent = Math.floor(Math.log(val) / Math.LN2);\n                if (exponent === 1024)\n                  exponent = 1023;\n                mantissa = val * Math.pow(2, -exponent);\n                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n              }\n            }\n          }\n          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n          function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n          }\n          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n        })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"../../node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"../../node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"../../node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// ../../node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"../../node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"../../node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject2(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet5(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n      Object.defineProperty(CustomError.prototype, \"name\", { get: function() {\n        return name;\n      } });\n      CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n      };\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"../../node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"../../node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else\n          for (var i = 0; i < val.length; )\n            buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// ../../node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"../../node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"../../node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// ../../node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"../../node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"../../node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// ../../node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"../../node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// ../../node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"../../node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// ../../node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"../../node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// ../../node_modules/long/src/long.js\nvar require_long = __commonJS({\n  \"../../node_modules/long/src/long.js\"(exports2, module2) {\n    module2.exports = Long4;\n    var wasm = null;\n    try {\n      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n      ])), {}).exports;\n    } catch (e) {\n    }\n    function Long4(low, high, unsigned) {\n      this.low = low | 0;\n      this.high = high | 0;\n      this.unsigned = !!unsigned;\n    }\n    Long4.prototype.__isLong__;\n    Object.defineProperty(Long4.prototype, \"__isLong__\", { value: true });\n    function isLong(obj) {\n      return (obj && obj[\"__isLong__\"]) === true;\n    }\n    Long4.isLong = isLong;\n    var INT_CACHE = {};\n    var UINT_CACHE = {};\n    function fromInt(value, unsigned) {\n      var obj, cachedObj, cache;\n      if (unsigned) {\n        value >>>= 0;\n        if (cache = 0 <= value && value < 256) {\n          cachedObj = UINT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n          UINT_CACHE[value] = obj;\n        return obj;\n      } else {\n        value |= 0;\n        if (cache = -128 <= value && value < 128) {\n          cachedObj = INT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n          INT_CACHE[value] = obj;\n        return obj;\n      }\n    }\n    Long4.fromInt = fromInt;\n    function fromNumber(value, unsigned) {\n      if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n      if (unsigned) {\n        if (value < 0)\n          return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n          return MAX_UNSIGNED_VALUE;\n      } else {\n        if (value <= -TWO_PWR_63_DBL)\n          return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n          return MAX_VALUE;\n      }\n      if (value < 0)\n        return fromNumber(-value, unsigned).neg();\n      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    Long4.fromNumber = fromNumber;\n    function fromBits(lowBits, highBits, unsigned) {\n      return new Long4(lowBits, highBits, unsigned);\n    }\n    Long4.fromBits = fromBits;\n    var pow_dbl = Math.pow;\n    function fromString(str, unsigned, radix) {\n      if (str.length === 0)\n        throw Error(\"empty string\");\n      if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n      if (typeof unsigned === \"number\") {\n        radix = unsigned, unsigned = false;\n      } else {\n        unsigned = !!unsigned;\n      }\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      var p;\n      if ((p = str.indexOf(\"-\")) > 0)\n        throw Error(\"interior hyphen\");\n      else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 8));\n      var result = ZERO;\n      for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n          var power = fromNumber(pow_dbl(radix, size));\n          result = result.mul(power).add(fromNumber(value));\n        } else {\n          result = result.mul(radixToPower);\n          result = result.add(fromNumber(value));\n        }\n      }\n      result.unsigned = unsigned;\n      return result;\n    }\n    Long4.fromString = fromString;\n    function fromValue(val, unsigned) {\n      if (typeof val === \"number\")\n        return fromNumber(val, unsigned);\n      if (typeof val === \"string\")\n        return fromString(val, unsigned);\n      return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    Long4.fromValue = fromValue;\n    var TWO_PWR_16_DBL = 1 << 16;\n    var TWO_PWR_24_DBL = 1 << 24;\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    var ZERO = fromInt(0);\n    Long4.ZERO = ZERO;\n    var UZERO = fromInt(0, true);\n    Long4.UZERO = UZERO;\n    var ONE = fromInt(1);\n    Long4.ONE = ONE;\n    var UONE = fromInt(1, true);\n    Long4.UONE = UONE;\n    var NEG_ONE = fromInt(-1);\n    Long4.NEG_ONE = NEG_ONE;\n    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);\n    Long4.MAX_VALUE = MAX_VALUE;\n    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);\n    Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);\n    Long4.MIN_VALUE = MIN_VALUE;\n    var LongPrototype = Long4.prototype;\n    LongPrototype.toInt = function toInt() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    LongPrototype.toNumber = function toNumber() {\n      if (this.unsigned)\n        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    LongPrototype.toString = function toString(radix) {\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      if (this.isZero())\n        return \"0\";\n      if (this.isNegative()) {\n        if (this.eq(MIN_VALUE)) {\n          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n          return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n          return \"-\" + this.neg().toString(radix);\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n      var result = \"\";\n      while (true) {\n        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero())\n          return digits + result;\n        else {\n          while (digits.length < 6)\n            digits = \"0\" + digits;\n          result = \"\" + digits + result;\n        }\n      }\n    };\n    LongPrototype.getHighBits = function getHighBits() {\n      return this.high;\n    };\n    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n      return this.high >>> 0;\n    };\n    LongPrototype.getLowBits = function getLowBits() {\n      return this.low;\n    };\n    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n      return this.low >>> 0;\n    };\n    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n      if (this.isNegative())\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n      var val = this.high != 0 ? this.high : this.low;\n      for (var bit = 31; bit > 0; bit--)\n        if ((val & 1 << bit) != 0)\n          break;\n      return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    LongPrototype.isZero = function isZero() {\n      return this.high === 0 && this.low === 0;\n    };\n    LongPrototype.eqz = LongPrototype.isZero;\n    LongPrototype.isNegative = function isNegative() {\n      return !this.unsigned && this.high < 0;\n    };\n    LongPrototype.isPositive = function isPositive() {\n      return this.unsigned || this.high >= 0;\n    };\n    LongPrototype.isOdd = function isOdd() {\n      return (this.low & 1) === 1;\n    };\n    LongPrototype.isEven = function isEven() {\n      return (this.low & 1) === 0;\n    };\n    LongPrototype.equals = function equals(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n        return false;\n      return this.high === other.high && this.low === other.low;\n    };\n    LongPrototype.eq = LongPrototype.equals;\n    LongPrototype.notEquals = function notEquals(other) {\n      return !this.eq(\n        /* validates */\n        other\n      );\n    };\n    LongPrototype.neq = LongPrototype.notEquals;\n    LongPrototype.ne = LongPrototype.notEquals;\n    LongPrototype.lessThan = function lessThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) < 0;\n    };\n    LongPrototype.lt = LongPrototype.lessThan;\n    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) <= 0;\n    };\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    LongPrototype.le = LongPrototype.lessThanOrEqual;\n    LongPrototype.greaterThan = function greaterThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) > 0;\n    };\n    LongPrototype.gt = LongPrototype.greaterThan;\n    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) >= 0;\n    };\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    LongPrototype.compare = function compare(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      if (this.eq(other))\n        return 0;\n      var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n      if (thisNeg && !otherNeg)\n        return -1;\n      if (!thisNeg && otherNeg)\n        return 1;\n      if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    LongPrototype.comp = LongPrototype.compare;\n    LongPrototype.negate = function negate() {\n      if (!this.unsigned && this.eq(MIN_VALUE))\n        return MIN_VALUE;\n      return this.not().add(ONE);\n    };\n    LongPrototype.neg = LongPrototype.negate;\n    LongPrototype.add = function add(addend) {\n      if (!isLong(addend))\n        addend = fromValue(addend);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 65535;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    LongPrototype.subtract = function subtract(subtrahend) {\n      if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n      return this.add(subtrahend.neg());\n    };\n    LongPrototype.sub = LongPrototype.subtract;\n    LongPrototype.multiply = function multiply(multiplier) {\n      if (this.isZero())\n        return ZERO;\n      if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n      if (wasm) {\n        var low = wasm.mul(\n          this.low,\n          this.high,\n          multiplier.low,\n          multiplier.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (multiplier.isZero())\n        return ZERO;\n      if (this.eq(MIN_VALUE))\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\n      if (multiplier.eq(MIN_VALUE))\n        return this.isOdd() ? MIN_VALUE : ZERO;\n      if (this.isNegative()) {\n        if (multiplier.isNegative())\n          return this.neg().mul(multiplier.neg());\n        else\n          return this.neg().mul(multiplier).neg();\n      } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 65535;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    LongPrototype.mul = LongPrototype.multiply;\n    LongPrototype.divide = function divide(divisor) {\n      if (!isLong(divisor))\n        divisor = fromValue(divisor);\n      if (divisor.isZero())\n        throw Error(\"division by zero\");\n      if (wasm) {\n        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n          return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (this.isZero())\n        return this.unsigned ? UZERO : ZERO;\n      var approx, rem, res;\n      if (!this.unsigned) {\n        if (this.eq(MIN_VALUE)) {\n          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n            return MIN_VALUE;\n          else if (divisor.eq(MIN_VALUE))\n            return ONE;\n          else {\n            var halfThis = this.shr(1);\n            approx = halfThis.div(divisor).shl(1);\n            if (approx.eq(ZERO)) {\n              return divisor.isNegative() ? ONE : NEG_ONE;\n            } else {\n              rem = this.sub(divisor.mul(approx));\n              res = approx.add(rem.div(divisor));\n              return res;\n            }\n          }\n        } else if (divisor.eq(MIN_VALUE))\n          return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n          if (divisor.isNegative())\n            return this.neg().div(divisor.neg());\n          return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n          return this.div(divisor.neg()).neg();\n        res = ZERO;\n      } else {\n        if (!divisor.unsigned)\n          divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n          return UZERO;\n        if (divisor.gt(this.shru(1)))\n          return UONE;\n        res = UZERO;\n      }\n      rem = this;\n      while (rem.gte(divisor)) {\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n          approx -= delta;\n          approxRes = fromNumber(approx, this.unsigned);\n          approxRem = approxRes.mul(divisor);\n        }\n        if (approxRes.isZero())\n          approxRes = ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n      }\n      return res;\n    };\n    LongPrototype.div = LongPrototype.divide;\n    LongPrototype.modulo = function modulo(divisor) {\n      if (!isLong(divisor))\n        divisor = fromValue(divisor);\n      if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(divisor).mul(divisor));\n    };\n    LongPrototype.mod = LongPrototype.modulo;\n    LongPrototype.rem = LongPrototype.modulo;\n    LongPrototype.not = function not() {\n      return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    LongPrototype.and = function and(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    LongPrototype.or = function or(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    LongPrototype.xor = function xor(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    LongPrototype.shiftLeft = function shiftLeft(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n      else\n        return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    LongPrototype.shl = LongPrototype.shiftLeft;\n    LongPrototype.shiftRight = function shiftRight(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n      else\n        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    LongPrototype.shr = LongPrototype.shiftRight;\n    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      numBits &= 63;\n      if (numBits === 0)\n        return this;\n      else {\n        var high = this.high;\n        if (numBits < 32) {\n          var low = this.low;\n          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n        } else if (numBits === 32)\n          return fromBits(high, 0, this.unsigned);\n        else\n          return fromBits(high >>> numBits - 32, 0, this.unsigned);\n      }\n    };\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    LongPrototype.toSigned = function toSigned() {\n      if (!this.unsigned)\n        return this;\n      return fromBits(this.low, this.high, false);\n    };\n    LongPrototype.toUnsigned = function toUnsigned() {\n      if (this.unsigned)\n        return this;\n      return fromBits(this.low, this.high, true);\n    };\n    LongPrototype.toBytes = function toBytes(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    LongPrototype.toBytesLE = function toBytesLE() {\n      var hi = this.high, lo = this.low;\n      return [\n        lo & 255,\n        lo >>> 8 & 255,\n        lo >>> 16 & 255,\n        lo >>> 24,\n        hi & 255,\n        hi >>> 8 & 255,\n        hi >>> 16 & 255,\n        hi >>> 24\n      ];\n    };\n    LongPrototype.toBytesBE = function toBytesBE() {\n      var hi = this.high, lo = this.low;\n      return [\n        hi >>> 24,\n        hi >>> 16 & 255,\n        hi >>> 8 & 255,\n        hi & 255,\n        lo >>> 24,\n        lo >>> 16 & 255,\n        lo >>> 8 & 255,\n        lo & 255\n      ];\n    };\n    Long4.fromBytes = function fromBytes(bytes, unsigned, le) {\n      return le ? Long4.fromBytesLE(bytes, unsigned) : Long4.fromBytesBE(bytes, unsigned);\n    };\n    Long4.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n      return new Long4(\n        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,\n        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,\n        unsigned\n      );\n    };\n    Long4.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n      return new Long4(\n        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],\n        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],\n        unsigned\n      );\n    };\n  }\n});\n\n// index.ts\nvar mezon_js_protobuf_exports = {};\n__export(mezon_js_protobuf_exports, {\n  WebSocketAdapterPb: () => WebSocketAdapterPb\n});\nmodule.exports = __toCommonJS(mezon_js_protobuf_exports);\n\n// rtapi/realtime.ts\nvar import_minimal5 = __toESM(require_minimal2());\n\n// api/api.ts\nvar import_long3 = __toESM(require_long());\nvar import_minimal4 = __toESM(require_minimal2());\n\n// google/protobuf/struct.ts\nvar import_minimal = __toESM(require_minimal2());\n\n// google/protobuf/timestamp.ts\nvar import_long = __toESM(require_long());\nvar import_minimal2 = __toESM(require_minimal2());\nfunction createBaseTimestamp() {\n  return { seconds: 0, nanos: 0 };\n}\nvar Timestamp = {\n  encode(message, writer = import_minimal2.default.Writer.create()) {\n    if (message.seconds !== 0) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.seconds = longToNumber(reader.int64());\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.nanos = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,\n      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.seconds !== 0) {\n      obj.seconds = Math.round(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      obj.nanos = Math.round(message.nanos);\n    }\n    return obj;\n  },\n  create(base) {\n    return Timestamp.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseTimestamp();\n    message.seconds = (_a = object.seconds) != null ? _a : 0;\n    message.nanos = (_b = object.nanos) != null ? _b : 0;\n    return message;\n  }\n};\nfunction longToNumber(long) {\n  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\nif (import_minimal2.default.util.Long !== import_long.default) {\n  import_minimal2.default.util.Long = import_long.default;\n  import_minimal2.default.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== void 0;\n}\n\n// google/protobuf/wrappers.ts\nvar import_long2 = __toESM(require_long());\nvar import_minimal3 = __toESM(require_minimal2());\nfunction createBaseInt32Value() {\n  return { value: 0 };\n}\nvar Int32Value = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.value !== 0) {\n      writer.uint32(8).int32(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseInt32Value();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.value = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? globalThis.Number(object.value) : 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.value !== 0) {\n      obj.value = Math.round(message.value);\n    }\n    return obj;\n  },\n  create(base) {\n    return Int32Value.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseInt32Value();\n    message.value = (_a = object.value) != null ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseBoolValue() {\n  return { value: false };\n}\nvar BoolValue = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.value !== false) {\n      writer.uint32(8).bool(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseBoolValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.value = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? globalThis.Boolean(object.value) : false };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.value !== false) {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n  create(base) {\n    return BoolValue.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseBoolValue();\n    message.value = (_a = object.value) != null ? _a : false;\n    return message;\n  }\n};\nfunction createBaseStringValue() {\n  return { value: \"\" };\n}\nvar StringValue = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.value !== \"\") {\n      writer.uint32(10).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStringValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.value = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? globalThis.String(object.value) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.value !== \"\") {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n  create(base) {\n    return StringValue.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStringValue();\n    message.value = (_a = object.value) != null ? _a : \"\";\n    return message;\n  }\n};\nif (import_minimal3.default.util.Long !== import_long2.default) {\n  import_minimal3.default.util.Long = import_long2.default;\n  import_minimal3.default.configure();\n}\nfunction isSet2(value) {\n  return value !== null && value !== void 0;\n}\n\n// api/api.ts\nfunction createBaseChannelMessage() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    code: void 0,\n    sender_id: \"\",\n    username: \"\",\n    avatar: \"\",\n    content: \"\",\n    create_time: void 0,\n    update_time: void 0,\n    channel_label: \"\",\n    clan_logo: \"\",\n    category_name: \"\",\n    display_name: \"\",\n    clan_nick: \"\",\n    clan_avatar: \"\",\n    reactions: \"\",\n    mentions: \"\",\n    attachments: \"\",\n    references: \"\",\n    referenced_message: \"\",\n    create_time_seconds: 0,\n    update_time_seconds: 0,\n    mode: 0,\n    hide_editted: false,\n    is_public: false\n  };\n}\nvar ChannelMessage = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.code !== void 0) {\n      Int32Value.encode({ value: message.code }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(42).string(message.sender_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(50).string(message.username);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(58).string(message.avatar);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(66).string(message.content);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(74).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(82).fork()).ldelim();\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(90).string(message.channel_label);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(98).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(106).string(message.category_name);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(114).string(message.display_name);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(122).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(130).string(message.clan_avatar);\n    }\n    if (message.reactions !== \"\") {\n      writer.uint32(138).string(message.reactions);\n    }\n    if (message.mentions !== \"\") {\n      writer.uint32(146).string(message.mentions);\n    }\n    if (message.attachments !== \"\") {\n      writer.uint32(154).string(message.attachments);\n    }\n    if (message.references !== \"\") {\n      writer.uint32(162).string(message.references);\n    }\n    if (message.referenced_message !== \"\") {\n      writer.uint32(170).string(message.referenced_message);\n    }\n    if (message.create_time_seconds !== 0) {\n      writer.uint32(176).uint32(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      writer.uint32(184).uint32(message.update_time_seconds);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(192).int32(message.mode);\n    }\n    if (message.hide_editted !== false) {\n      writer.uint32(200).bool(message.hide_editted);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(208).bool(message.is_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.code = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.clan_nick = reader.string();\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.clan_avatar = reader.string();\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.reactions = reader.string();\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.mentions = reader.string();\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.attachments = reader.string();\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.references = reader.string();\n          continue;\n        case 21:\n          if (tag !== 170) {\n            break;\n          }\n          message.referenced_message = reader.string();\n          continue;\n        case 22:\n          if (tag !== 176) {\n            break;\n          }\n          message.create_time_seconds = reader.uint32();\n          continue;\n        case 23:\n          if (tag !== 184) {\n            break;\n          }\n          message.update_time_seconds = reader.uint32();\n          continue;\n        case 24:\n          if (tag !== 192) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 25:\n          if (tag !== 200) {\n            break;\n          }\n          message.hide_editted = reader.bool();\n          continue;\n        case 26:\n          if (tag !== 208) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      code: isSet3(object.code) ? Number(object.code) : void 0,\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      avatar: isSet3(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      update_time: isSet3(object.update_time) ? fromJsonTimestamp(object.update_time) : void 0,\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      clan_logo: isSet3(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet3(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      display_name: isSet3(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      clan_nick: isSet3(object.clan_nick) ? globalThis.String(object.clan_nick) : \"\",\n      clan_avatar: isSet3(object.clan_avatar) ? globalThis.String(object.clan_avatar) : \"\",\n      reactions: isSet3(object.reactions) ? globalThis.String(object.reactions) : \"\",\n      mentions: isSet3(object.mentions) ? globalThis.String(object.mentions) : \"\",\n      attachments: isSet3(object.attachments) ? globalThis.String(object.attachments) : \"\",\n      references: isSet3(object.references) ? globalThis.String(object.references) : \"\",\n      referenced_message: isSet3(object.referenced_message) ? globalThis.String(object.referenced_message) : \"\",\n      create_time_seconds: isSet3(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,\n      update_time_seconds: isSet3(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,\n      mode: isSet3(object.mode) ? globalThis.Number(object.mode) : 0,\n      hide_editted: isSet3(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,\n      is_public: isSet3(object.is_public) ? globalThis.Boolean(object.is_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.code !== void 0) {\n      obj.code = message.code;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.update_time !== void 0) {\n      obj.update_time = message.update_time.toISOString();\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.clan_nick !== \"\") {\n      obj.clan_nick = message.clan_nick;\n    }\n    if (message.clan_avatar !== \"\") {\n      obj.clan_avatar = message.clan_avatar;\n    }\n    if (message.reactions !== \"\") {\n      obj.reactions = message.reactions;\n    }\n    if (message.mentions !== \"\") {\n      obj.mentions = message.mentions;\n    }\n    if (message.attachments !== \"\") {\n      obj.attachments = message.attachments;\n    }\n    if (message.references !== \"\") {\n      obj.references = message.references;\n    }\n    if (message.referenced_message !== \"\") {\n      obj.referenced_message = message.referenced_message;\n    }\n    if (message.create_time_seconds !== 0) {\n      obj.create_time_seconds = Math.round(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      obj.update_time_seconds = Math.round(message.update_time_seconds);\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.hide_editted !== false) {\n      obj.hide_editted = message.hide_editted;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessage.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;\n    const message = createBaseChannelMessage();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.code = (_d = object.code) != null ? _d : void 0;\n    message.sender_id = (_e = object.sender_id) != null ? _e : \"\";\n    message.username = (_f = object.username) != null ? _f : \"\";\n    message.avatar = (_g = object.avatar) != null ? _g : \"\";\n    message.content = (_h = object.content) != null ? _h : \"\";\n    message.create_time = (_i = object.create_time) != null ? _i : void 0;\n    message.update_time = (_j = object.update_time) != null ? _j : void 0;\n    message.channel_label = (_k = object.channel_label) != null ? _k : \"\";\n    message.clan_logo = (_l = object.clan_logo) != null ? _l : \"\";\n    message.category_name = (_m = object.category_name) != null ? _m : \"\";\n    message.display_name = (_n = object.display_name) != null ? _n : \"\";\n    message.clan_nick = (_o = object.clan_nick) != null ? _o : \"\";\n    message.clan_avatar = (_p = object.clan_avatar) != null ? _p : \"\";\n    message.reactions = (_q = object.reactions) != null ? _q : \"\";\n    message.mentions = (_r = object.mentions) != null ? _r : \"\";\n    message.attachments = (_s = object.attachments) != null ? _s : \"\";\n    message.references = (_t = object.references) != null ? _t : \"\";\n    message.referenced_message = (_u = object.referenced_message) != null ? _u : \"\";\n    message.create_time_seconds = (_v = object.create_time_seconds) != null ? _v : 0;\n    message.update_time_seconds = (_w = object.update_time_seconds) != null ? _w : 0;\n    message.mode = (_x = object.mode) != null ? _x : 0;\n    message.hide_editted = (_y = object.hide_editted) != null ? _y : false;\n    message.is_public = (_z = object.is_public) != null ? _z : false;\n    return message;\n  }\n};\nfunction createBaseMessageMention() {\n  return { id: \"\", user_id: \"\", username: \"\", role_id: \"\", rolename: \"\", create_time: void 0, s: 0, e: 0 };\n}\nvar MessageMention = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.role_id !== \"\") {\n      writer.uint32(34).string(message.role_id);\n    }\n    if (message.rolename !== \"\") {\n      writer.uint32(42).string(message.rolename);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.s !== 0) {\n      writer.uint32(56).int32(message.s);\n    }\n    if (message.e !== 0) {\n      writer.uint32(64).int32(message.e);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageMention();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.rolename = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.s = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.e = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      role_id: isSet3(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      rolename: isSet3(object.rolename) ? globalThis.String(object.rolename) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      s: isSet3(object.s) ? globalThis.Number(object.s) : 0,\n      e: isSet3(object.e) ? globalThis.Number(object.e) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.rolename !== \"\") {\n      obj.rolename = message.rolename;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.s !== 0) {\n      obj.s = Math.round(message.s);\n    }\n    if (message.e !== 0) {\n      obj.e = Math.round(message.e);\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageMention.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseMessageMention();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.role_id = (_d = object.role_id) != null ? _d : \"\";\n    message.rolename = (_e = object.rolename) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.s = (_g = object.s) != null ? _g : 0;\n    message.e = (_h = object.e) != null ? _h : 0;\n    return message;\n  }\n};\nfunction createBaseMessageReaction() {\n  return {\n    id: \"\",\n    emoji_id: \"\",\n    emoji: \"\",\n    sender_id: \"\",\n    sender_name: \"\",\n    sender_avatar: \"\",\n    action: false,\n    count: 0,\n    channel_id: \"\",\n    message_id: \"\",\n    clan_id: \"\",\n    mode: 0,\n    message_sender_id: \"\",\n    is_public: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar MessageReaction = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.emoji_id !== \"\") {\n      writer.uint32(18).string(message.emoji_id);\n    }\n    if (message.emoji !== \"\") {\n      writer.uint32(26).string(message.emoji);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(34).string(message.sender_id);\n    }\n    if (message.sender_name !== \"\") {\n      writer.uint32(42).string(message.sender_name);\n    }\n    if (message.sender_avatar !== \"\") {\n      writer.uint32(50).string(message.sender_avatar);\n    }\n    if (message.action !== false) {\n      writer.uint32(56).bool(message.action);\n    }\n    if (message.count !== 0) {\n      writer.uint32(64).int32(message.count);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(74).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(82).string(message.message_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(90).string(message.clan_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(96).int32(message.mode);\n    }\n    if (message.message_sender_id !== \"\") {\n      writer.uint32(106).string(message.message_sender_id);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(112).bool(message.is_public);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(122).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(128).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageReaction();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.emoji_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.emoji = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.sender_name = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.sender_avatar = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.action = reader.bool();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.count = reader.int32();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 12:\n          if (tag !== 96) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.message_sender_id = reader.string();\n          continue;\n        case 14:\n          if (tag !== 112) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 16:\n          if (tag !== 128) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      emoji_id: isSet3(object.emoji_id) ? globalThis.String(object.emoji_id) : \"\",\n      emoji: isSet3(object.emoji) ? globalThis.String(object.emoji) : \"\",\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      sender_name: isSet3(object.sender_name) ? globalThis.String(object.sender_name) : \"\",\n      sender_avatar: isSet3(object.sender_avatar) ? globalThis.String(object.sender_avatar) : \"\",\n      action: isSet3(object.action) ? globalThis.Boolean(object.action) : false,\n      count: isSet3(object.count) ? globalThis.Number(object.count) : 0,\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      mode: isSet3(object.mode) ? globalThis.Number(object.mode) : 0,\n      message_sender_id: isSet3(object.message_sender_id) ? globalThis.String(object.message_sender_id) : \"\",\n      is_public: isSet3(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      parent_id: isSet3(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet3(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.emoji_id !== \"\") {\n      obj.emoji_id = message.emoji_id;\n    }\n    if (message.emoji !== \"\") {\n      obj.emoji = message.emoji;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.sender_name !== \"\") {\n      obj.sender_name = message.sender_name;\n    }\n    if (message.sender_avatar !== \"\") {\n      obj.sender_avatar = message.sender_avatar;\n    }\n    if (message.action !== false) {\n      obj.action = message.action;\n    }\n    if (message.count !== 0) {\n      obj.count = Math.round(message.count);\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.message_sender_id !== \"\") {\n      obj.message_sender_id = message.message_sender_id;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageReaction.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;\n    const message = createBaseMessageReaction();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.emoji_id = (_b = object.emoji_id) != null ? _b : \"\";\n    message.emoji = (_c = object.emoji) != null ? _c : \"\";\n    message.sender_id = (_d = object.sender_id) != null ? _d : \"\";\n    message.sender_name = (_e = object.sender_name) != null ? _e : \"\";\n    message.sender_avatar = (_f = object.sender_avatar) != null ? _f : \"\";\n    message.action = (_g = object.action) != null ? _g : false;\n    message.count = (_h = object.count) != null ? _h : 0;\n    message.channel_id = (_i = object.channel_id) != null ? _i : \"\";\n    message.message_id = (_j = object.message_id) != null ? _j : \"\";\n    message.clan_id = (_k = object.clan_id) != null ? _k : \"\";\n    message.mode = (_l = object.mode) != null ? _l : 0;\n    message.message_sender_id = (_m = object.message_sender_id) != null ? _m : \"\";\n    message.is_public = (_n = object.is_public) != null ? _n : false;\n    message.parent_id = (_o = object.parent_id) != null ? _o : \"\";\n    message.is_parent_public = (_p = object.is_parent_public) != null ? _p : false;\n    return message;\n  }\n};\nfunction createBaseMessageAttachment() {\n  return { filename: \"\", size: 0, url: \"\", filetype: \"\", width: 0, height: 0 };\n}\nvar MessageAttachment = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.filename !== \"\") {\n      writer.uint32(10).string(message.filename);\n    }\n    if (message.size !== 0) {\n      writer.uint32(16).int64(message.size);\n    }\n    if (message.url !== \"\") {\n      writer.uint32(26).string(message.url);\n    }\n    if (message.filetype !== \"\") {\n      writer.uint32(34).string(message.filetype);\n    }\n    if (message.width !== 0) {\n      writer.uint32(40).int32(message.width);\n    }\n    if (message.height !== 0) {\n      writer.uint32(48).int32(message.height);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageAttachment();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.filename = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.size = longToNumber2(reader.int64());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.url = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.filetype = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.width = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.height = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      filename: isSet3(object.filename) ? globalThis.String(object.filename) : \"\",\n      size: isSet3(object.size) ? globalThis.Number(object.size) : 0,\n      url: isSet3(object.url) ? globalThis.String(object.url) : \"\",\n      filetype: isSet3(object.filetype) ? globalThis.String(object.filetype) : \"\",\n      width: isSet3(object.width) ? globalThis.Number(object.width) : 0,\n      height: isSet3(object.height) ? globalThis.Number(object.height) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.filename !== \"\") {\n      obj.filename = message.filename;\n    }\n    if (message.size !== 0) {\n      obj.size = Math.round(message.size);\n    }\n    if (message.url !== \"\") {\n      obj.url = message.url;\n    }\n    if (message.filetype !== \"\") {\n      obj.filetype = message.filetype;\n    }\n    if (message.width !== 0) {\n      obj.width = Math.round(message.width);\n    }\n    if (message.height !== 0) {\n      obj.height = Math.round(message.height);\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageAttachment.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseMessageAttachment();\n    message.filename = (_a = object.filename) != null ? _a : \"\";\n    message.size = (_b = object.size) != null ? _b : 0;\n    message.url = (_c = object.url) != null ? _c : \"\";\n    message.filetype = (_d = object.filetype) != null ? _d : \"\";\n    message.width = (_e = object.width) != null ? _e : 0;\n    message.height = (_f = object.height) != null ? _f : 0;\n    return message;\n  }\n};\nfunction createBaseMessageRef() {\n  return {\n    message_id: \"\",\n    message_ref_id: \"\",\n    content: \"\",\n    has_attachment: false,\n    ref_type: 0,\n    message_sender_id: \"\",\n    message_sender_username: \"\",\n    mesages_sender_avatar: \"\",\n    message_sender_clan_nick: \"\",\n    message_sender_display_name: \"\"\n  };\n}\nvar MessageRef = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.message_id !== \"\") {\n      writer.uint32(10).string(message.message_id);\n    }\n    if (message.message_ref_id !== \"\") {\n      writer.uint32(18).string(message.message_ref_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.has_attachment !== false) {\n      writer.uint32(32).bool(message.has_attachment);\n    }\n    if (message.ref_type !== 0) {\n      writer.uint32(40).int32(message.ref_type);\n    }\n    if (message.message_sender_id !== \"\") {\n      writer.uint32(50).string(message.message_sender_id);\n    }\n    if (message.message_sender_username !== \"\") {\n      writer.uint32(58).string(message.message_sender_username);\n    }\n    if (message.mesages_sender_avatar !== \"\") {\n      writer.uint32(66).string(message.mesages_sender_avatar);\n    }\n    if (message.message_sender_clan_nick !== \"\") {\n      writer.uint32(74).string(message.message_sender_clan_nick);\n    }\n    if (message.message_sender_display_name !== \"\") {\n      writer.uint32(82).string(message.message_sender_display_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageRef();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message_ref_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.has_attachment = reader.bool();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.ref_type = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.message_sender_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.message_sender_username = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.mesages_sender_avatar = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.message_sender_clan_nick = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.message_sender_display_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      message_ref_id: isSet3(object.message_ref_id) ? globalThis.String(object.message_ref_id) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      has_attachment: isSet3(object.has_attachment) ? globalThis.Boolean(object.has_attachment) : false,\n      ref_type: isSet3(object.ref_type) ? globalThis.Number(object.ref_type) : 0,\n      message_sender_id: isSet3(object.message_sender_id) ? globalThis.String(object.message_sender_id) : \"\",\n      message_sender_username: isSet3(object.message_sender_username) ? globalThis.String(object.message_sender_username) : \"\",\n      mesages_sender_avatar: isSet3(object.mesages_sender_avatar) ? globalThis.String(object.mesages_sender_avatar) : \"\",\n      message_sender_clan_nick: isSet3(object.message_sender_clan_nick) ? globalThis.String(object.message_sender_clan_nick) : \"\",\n      message_sender_display_name: isSet3(object.message_sender_display_name) ? globalThis.String(object.message_sender_display_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.message_ref_id !== \"\") {\n      obj.message_ref_id = message.message_ref_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.has_attachment !== false) {\n      obj.has_attachment = message.has_attachment;\n    }\n    if (message.ref_type !== 0) {\n      obj.ref_type = Math.round(message.ref_type);\n    }\n    if (message.message_sender_id !== \"\") {\n      obj.message_sender_id = message.message_sender_id;\n    }\n    if (message.message_sender_username !== \"\") {\n      obj.message_sender_username = message.message_sender_username;\n    }\n    if (message.mesages_sender_avatar !== \"\") {\n      obj.mesages_sender_avatar = message.mesages_sender_avatar;\n    }\n    if (message.message_sender_clan_nick !== \"\") {\n      obj.message_sender_clan_nick = message.message_sender_clan_nick;\n    }\n    if (message.message_sender_display_name !== \"\") {\n      obj.message_sender_display_name = message.message_sender_display_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageRef.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseMessageRef();\n    message.message_id = (_a = object.message_id) != null ? _a : \"\";\n    message.message_ref_id = (_b = object.message_ref_id) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.has_attachment = (_d = object.has_attachment) != null ? _d : false;\n    message.ref_type = (_e = object.ref_type) != null ? _e : 0;\n    message.message_sender_id = (_f = object.message_sender_id) != null ? _f : \"\";\n    message.message_sender_username = (_g = object.message_sender_username) != null ? _g : \"\";\n    message.mesages_sender_avatar = (_h = object.mesages_sender_avatar) != null ? _h : \"\";\n    message.message_sender_clan_nick = (_i = object.message_sender_clan_nick) != null ? _i : \"\";\n    message.message_sender_display_name = (_j = object.message_sender_display_name) != null ? _j : \"\";\n    return message;\n  }\n};\nfunction createBaseNotification() {\n  return {\n    id: \"\",\n    subject: \"\",\n    content: \"\",\n    code: 0,\n    sender_id: \"\",\n    create_time: void 0,\n    persistent: false,\n    clan_id: \"\",\n    channel_id: \"\",\n    channel_type: 0,\n    avatar_url: \"\"\n  };\n}\nvar Notification = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.subject !== \"\") {\n      writer.uint32(18).string(message.subject);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.code !== 0) {\n      writer.uint32(32).int32(message.code);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(42).string(message.sender_id);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.persistent !== false) {\n      writer.uint32(56).bool(message.persistent);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(66).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(74).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(80).int32(message.channel_type);\n    }\n    if (message.avatar_url !== \"\") {\n      writer.uint32(90).string(message.avatar_url);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotification();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.subject = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.code = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.persistent = reader.bool();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.avatar_url = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      subject: isSet3(object.subject) ? globalThis.String(object.subject) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      code: isSet3(object.code) ? globalThis.Number(object.code) : 0,\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      persistent: isSet3(object.persistent) ? globalThis.Boolean(object.persistent) : false,\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet3(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      avatar_url: isSet3(object.avatar_url) ? globalThis.String(object.avatar_url) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.subject !== \"\") {\n      obj.subject = message.subject;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.code !== 0) {\n      obj.code = Math.round(message.code);\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.persistent !== false) {\n      obj.persistent = message.persistent;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.avatar_url !== \"\") {\n      obj.avatar_url = message.avatar_url;\n    }\n    return obj;\n  },\n  create(base) {\n    return Notification.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseNotification();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.subject = (_b = object.subject) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.code = (_d = object.code) != null ? _d : 0;\n    message.sender_id = (_e = object.sender_id) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.persistent = (_g = object.persistent) != null ? _g : false;\n    message.clan_id = (_h = object.clan_id) != null ? _h : \"\";\n    message.channel_id = (_i = object.channel_id) != null ? _i : \"\";\n    message.channel_type = (_j = object.channel_type) != null ? _j : 0;\n    message.avatar_url = (_k = object.avatar_url) != null ? _k : \"\";\n    return message;\n  }\n};\nfunction createBaseRpc() {\n  return { id: \"\", payload: \"\", http_key: \"\" };\n}\nvar Rpc = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.payload !== \"\") {\n      writer.uint32(18).string(message.payload);\n    }\n    if (message.http_key !== \"\") {\n      writer.uint32(26).string(message.http_key);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRpc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.payload = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.http_key = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      payload: isSet3(object.payload) ? globalThis.String(object.payload) : \"\",\n      http_key: isSet3(object.http_key) ? globalThis.String(object.http_key) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.payload !== \"\") {\n      obj.payload = message.payload;\n    }\n    if (message.http_key !== \"\") {\n      obj.http_key = message.http_key;\n    }\n    return obj;\n  },\n  create(base) {\n    return Rpc.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseRpc();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.payload = (_b = object.payload) != null ? _b : \"\";\n    message.http_key = (_c = object.http_key) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseUser() {\n  return {\n    id: \"\",\n    username: \"\",\n    display_name: \"\",\n    avatar_url: \"\",\n    lang_tag: \"\",\n    location: \"\",\n    timezone: \"\",\n    metadata: \"\",\n    facebook_id: \"\",\n    google_id: \"\",\n    gamecenter_id: \"\",\n    steam_id: \"\",\n    online: false,\n    edge_count: 0,\n    create_time: void 0,\n    update_time: void 0,\n    apple_id: \"\",\n    about_me: \"\",\n    join_time: void 0\n  };\n}\nvar User = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(26).string(message.display_name);\n    }\n    if (message.avatar_url !== \"\") {\n      writer.uint32(34).string(message.avatar_url);\n    }\n    if (message.lang_tag !== \"\") {\n      writer.uint32(42).string(message.lang_tag);\n    }\n    if (message.location !== \"\") {\n      writer.uint32(50).string(message.location);\n    }\n    if (message.timezone !== \"\") {\n      writer.uint32(58).string(message.timezone);\n    }\n    if (message.metadata !== \"\") {\n      writer.uint32(66).string(message.metadata);\n    }\n    if (message.facebook_id !== \"\") {\n      writer.uint32(74).string(message.facebook_id);\n    }\n    if (message.google_id !== \"\") {\n      writer.uint32(82).string(message.google_id);\n    }\n    if (message.gamecenter_id !== \"\") {\n      writer.uint32(90).string(message.gamecenter_id);\n    }\n    if (message.steam_id !== \"\") {\n      writer.uint32(98).string(message.steam_id);\n    }\n    if (message.online !== false) {\n      writer.uint32(104).bool(message.online);\n    }\n    if (message.edge_count !== 0) {\n      writer.uint32(112).int32(message.edge_count);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(122).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(130).fork()).ldelim();\n    }\n    if (message.apple_id !== \"\") {\n      writer.uint32(138).string(message.apple_id);\n    }\n    if (message.about_me !== \"\") {\n      writer.uint32(146).string(message.about_me);\n    }\n    if (message.join_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.join_time), writer.uint32(154).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUser();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.avatar_url = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.lang_tag = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.location = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.timezone = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.metadata = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.facebook_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.google_id = reader.string();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.gamecenter_id = reader.string();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.steam_id = reader.string();\n          continue;\n        case 13:\n          if (tag !== 104) {\n            break;\n          }\n          message.online = reader.bool();\n          continue;\n        case 14:\n          if (tag !== 112) {\n            break;\n          }\n          message.edge_count = reader.int32();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.apple_id = reader.string();\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.about_me = reader.string();\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.join_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      display_name: isSet3(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      avatar_url: isSet3(object.avatar_url) ? globalThis.String(object.avatar_url) : \"\",\n      lang_tag: isSet3(object.lang_tag) ? globalThis.String(object.lang_tag) : \"\",\n      location: isSet3(object.location) ? globalThis.String(object.location) : \"\",\n      timezone: isSet3(object.timezone) ? globalThis.String(object.timezone) : \"\",\n      metadata: isSet3(object.metadata) ? globalThis.String(object.metadata) : \"\",\n      facebook_id: isSet3(object.facebook_id) ? globalThis.String(object.facebook_id) : \"\",\n      google_id: isSet3(object.google_id) ? globalThis.String(object.google_id) : \"\",\n      gamecenter_id: isSet3(object.gamecenter_id) ? globalThis.String(object.gamecenter_id) : \"\",\n      steam_id: isSet3(object.steam_id) ? globalThis.String(object.steam_id) : \"\",\n      online: isSet3(object.online) ? globalThis.Boolean(object.online) : false,\n      edge_count: isSet3(object.edge_count) ? globalThis.Number(object.edge_count) : 0,\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      update_time: isSet3(object.update_time) ? fromJsonTimestamp(object.update_time) : void 0,\n      apple_id: isSet3(object.apple_id) ? globalThis.String(object.apple_id) : \"\",\n      about_me: isSet3(object.about_me) ? globalThis.String(object.about_me) : \"\",\n      join_time: isSet3(object.join_time) ? fromJsonTimestamp(object.join_time) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.avatar_url !== \"\") {\n      obj.avatar_url = message.avatar_url;\n    }\n    if (message.lang_tag !== \"\") {\n      obj.lang_tag = message.lang_tag;\n    }\n    if (message.location !== \"\") {\n      obj.location = message.location;\n    }\n    if (message.timezone !== \"\") {\n      obj.timezone = message.timezone;\n    }\n    if (message.metadata !== \"\") {\n      obj.metadata = message.metadata;\n    }\n    if (message.facebook_id !== \"\") {\n      obj.facebook_id = message.facebook_id;\n    }\n    if (message.google_id !== \"\") {\n      obj.google_id = message.google_id;\n    }\n    if (message.gamecenter_id !== \"\") {\n      obj.gamecenter_id = message.gamecenter_id;\n    }\n    if (message.steam_id !== \"\") {\n      obj.steam_id = message.steam_id;\n    }\n    if (message.online !== false) {\n      obj.online = message.online;\n    }\n    if (message.edge_count !== 0) {\n      obj.edge_count = Math.round(message.edge_count);\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.update_time !== void 0) {\n      obj.update_time = message.update_time.toISOString();\n    }\n    if (message.apple_id !== \"\") {\n      obj.apple_id = message.apple_id;\n    }\n    if (message.about_me !== \"\") {\n      obj.about_me = message.about_me;\n    }\n    if (message.join_time !== void 0) {\n      obj.join_time = message.join_time.toISOString();\n    }\n    return obj;\n  },\n  create(base) {\n    return User.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;\n    const message = createBaseUser();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.display_name = (_c = object.display_name) != null ? _c : \"\";\n    message.avatar_url = (_d = object.avatar_url) != null ? _d : \"\";\n    message.lang_tag = (_e = object.lang_tag) != null ? _e : \"\";\n    message.location = (_f = object.location) != null ? _f : \"\";\n    message.timezone = (_g = object.timezone) != null ? _g : \"\";\n    message.metadata = (_h = object.metadata) != null ? _h : \"\";\n    message.facebook_id = (_i = object.facebook_id) != null ? _i : \"\";\n    message.google_id = (_j = object.google_id) != null ? _j : \"\";\n    message.gamecenter_id = (_k = object.gamecenter_id) != null ? _k : \"\";\n    message.steam_id = (_l = object.steam_id) != null ? _l : \"\";\n    message.online = (_m = object.online) != null ? _m : false;\n    message.edge_count = (_n = object.edge_count) != null ? _n : 0;\n    message.create_time = (_o = object.create_time) != null ? _o : void 0;\n    message.update_time = (_p = object.update_time) != null ? _p : void 0;\n    message.apple_id = (_q = object.apple_id) != null ? _q : \"\";\n    message.about_me = (_r = object.about_me) != null ? _r : \"\";\n    message.join_time = (_s = object.join_time) != null ? _s : void 0;\n    return message;\n  }\n};\nfunction createBaseChannelMessageHeader() {\n  return {\n    id: \"\",\n    timestamp_seconds: 0,\n    sender_id: \"\",\n    content: \"\",\n    attachment: \"\",\n    referece: \"\",\n    mention: \"\",\n    reaction: \"\"\n  };\n}\nvar ChannelMessageHeader = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.timestamp_seconds !== 0) {\n      writer.uint32(16).uint32(message.timestamp_seconds);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(26).string(message.sender_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(34).string(message.content);\n    }\n    if (message.attachment !== \"\") {\n      writer.uint32(42).string(message.attachment);\n    }\n    if (message.referece !== \"\") {\n      writer.uint32(50).string(message.referece);\n    }\n    if (message.mention !== \"\") {\n      writer.uint32(58).string(message.mention);\n    }\n    if (message.reaction !== \"\") {\n      writer.uint32(66).string(message.reaction);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.timestamp_seconds = reader.uint32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.attachment = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.referece = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.mention = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.reaction = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      timestamp_seconds: isSet3(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      attachment: isSet3(object.attachment) ? globalThis.String(object.attachment) : \"\",\n      referece: isSet3(object.referece) ? globalThis.String(object.referece) : \"\",\n      mention: isSet3(object.mention) ? globalThis.String(object.mention) : \"\",\n      reaction: isSet3(object.reaction) ? globalThis.String(object.reaction) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.timestamp_seconds !== 0) {\n      obj.timestamp_seconds = Math.round(message.timestamp_seconds);\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.attachment !== \"\") {\n      obj.attachment = message.attachment;\n    }\n    if (message.referece !== \"\") {\n      obj.referece = message.referece;\n    }\n    if (message.mention !== \"\") {\n      obj.mention = message.mention;\n    }\n    if (message.reaction !== \"\") {\n      obj.reaction = message.reaction;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageHeader.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseChannelMessageHeader();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.timestamp_seconds = (_b = object.timestamp_seconds) != null ? _b : 0;\n    message.sender_id = (_c = object.sender_id) != null ? _c : \"\";\n    message.content = (_d = object.content) != null ? _d : \"\";\n    message.attachment = (_e = object.attachment) != null ? _e : \"\";\n    message.referece = (_f = object.referece) != null ? _f : \"\";\n    message.mention = (_g = object.mention) != null ? _g : \"\";\n    message.reaction = (_h = object.reaction) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelDescription() {\n  return {\n    clan_id: \"\",\n    parrent_id: \"\",\n    channel_id: \"\",\n    category_id: \"\",\n    category_name: \"\",\n    type: void 0,\n    creator_id: \"\",\n    channel_label: \"\",\n    channel_private: 0,\n    channel_avatar: [],\n    user_id: [],\n    last_sent_message: void 0,\n    last_seen_message: void 0,\n    is_online: [],\n    meeting_code: \"\",\n    count_mess_unread: 0,\n    active: 0,\n    last_pin_message: \"\",\n    usernames: \"\",\n    creator_name: \"\",\n    create_time_seconds: 0,\n    update_time_seconds: 0,\n    metadata: [],\n    about_me: [],\n    clan_name: \"\",\n    app_url: \"\"\n  };\n}\nvar ChannelDescription = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(18).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(34).string(message.category_id);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(42).string(message.category_name);\n    }\n    if (message.type !== void 0) {\n      Int32Value.encode({ value: message.type }, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(58).string(message.creator_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(66).string(message.channel_label);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(72).int32(message.channel_private);\n    }\n    for (const v of message.channel_avatar) {\n      writer.uint32(82).string(v);\n    }\n    for (const v of message.user_id) {\n      writer.uint32(90).string(v);\n    }\n    if (message.last_sent_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.last_seen_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(106).fork()).ldelim();\n    }\n    writer.uint32(114).fork();\n    for (const v of message.is_online) {\n      writer.bool(v);\n    }\n    writer.ldelim();\n    if (message.meeting_code !== \"\") {\n      writer.uint32(122).string(message.meeting_code);\n    }\n    if (message.count_mess_unread !== 0) {\n      writer.uint32(128).int32(message.count_mess_unread);\n    }\n    if (message.active !== 0) {\n      writer.uint32(136).int32(message.active);\n    }\n    if (message.last_pin_message !== \"\") {\n      writer.uint32(146).string(message.last_pin_message);\n    }\n    if (message.usernames !== \"\") {\n      writer.uint32(154).string(message.usernames);\n    }\n    if (message.creator_name !== \"\") {\n      writer.uint32(162).string(message.creator_name);\n    }\n    if (message.create_time_seconds !== 0) {\n      writer.uint32(168).uint32(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      writer.uint32(176).uint32(message.update_time_seconds);\n    }\n    for (const v of message.metadata) {\n      writer.uint32(186).string(v);\n    }\n    for (const v of message.about_me) {\n      writer.uint32(194).string(v);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(202).string(message.clan_name);\n    }\n    if (message.app_url !== \"\") {\n      writer.uint32(210).string(message.app_url);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescription();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.parrent_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.channel_avatar.push(reader.string());\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.user_id.push(reader.string());\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag === 112) {\n            message.is_online.push(reader.bool());\n            continue;\n          }\n          if (tag === 114) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.is_online.push(reader.bool());\n            }\n            continue;\n          }\n          break;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 16:\n          if (tag !== 128) {\n            break;\n          }\n          message.count_mess_unread = reader.int32();\n          continue;\n        case 17:\n          if (tag !== 136) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.last_pin_message = reader.string();\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.usernames = reader.string();\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.creator_name = reader.string();\n          continue;\n        case 21:\n          if (tag !== 168) {\n            break;\n          }\n          message.create_time_seconds = reader.uint32();\n          continue;\n        case 22:\n          if (tag !== 176) {\n            break;\n          }\n          message.update_time_seconds = reader.uint32();\n          continue;\n        case 23:\n          if (tag !== 186) {\n            break;\n          }\n          message.metadata.push(reader.string());\n          continue;\n        case 24:\n          if (tag !== 194) {\n            break;\n          }\n          message.about_me.push(reader.string());\n          continue;\n        case 25:\n          if (tag !== 202) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 26:\n          if (tag !== 210) {\n            break;\n          }\n          message.app_url = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      parrent_id: isSet3(object.parrent_id) ? globalThis.String(object.parrent_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      category_id: isSet3(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      category_name: isSet3(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      type: isSet3(object.type) ? Number(object.type) : void 0,\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      channel_private: isSet3(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      channel_avatar: globalThis.Array.isArray(object == null ? void 0 : object.channel_avatar) ? object.channel_avatar.map((e) => globalThis.String(e)) : [],\n      user_id: globalThis.Array.isArray(object == null ? void 0 : object.user_id) ? object.user_id.map((e) => globalThis.String(e)) : [],\n      last_sent_message: isSet3(object.last_sent_message) ? ChannelMessageHeader.fromJSON(object.last_sent_message) : void 0,\n      last_seen_message: isSet3(object.last_seen_message) ? ChannelMessageHeader.fromJSON(object.last_seen_message) : void 0,\n      is_online: globalThis.Array.isArray(object == null ? void 0 : object.is_online) ? object.is_online.map((e) => globalThis.Boolean(e)) : [],\n      meeting_code: isSet3(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      count_mess_unread: isSet3(object.count_mess_unread) ? globalThis.Number(object.count_mess_unread) : 0,\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      last_pin_message: isSet3(object.last_pin_message) ? globalThis.String(object.last_pin_message) : \"\",\n      usernames: isSet3(object.usernames) ? globalThis.String(object.usernames) : \"\",\n      creator_name: isSet3(object.creator_name) ? globalThis.String(object.creator_name) : \"\",\n      create_time_seconds: isSet3(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,\n      update_time_seconds: isSet3(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,\n      metadata: globalThis.Array.isArray(object == null ? void 0 : object.metadata) ? object.metadata.map((e) => globalThis.String(e)) : [],\n      about_me: globalThis.Array.isArray(object == null ? void 0 : object.about_me) ? object.about_me.map((e) => globalThis.String(e)) : [],\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      app_url: isSet3(object.app_url) ? globalThis.String(object.app_url) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.parrent_id !== \"\") {\n      obj.parrent_id = message.parrent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.type !== void 0) {\n      obj.type = message.type;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if ((_a = message.channel_avatar) == null ? void 0 : _a.length) {\n      obj.channel_avatar = message.channel_avatar;\n    }\n    if ((_b = message.user_id) == null ? void 0 : _b.length) {\n      obj.user_id = message.user_id;\n    }\n    if (message.last_sent_message !== void 0) {\n      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);\n    }\n    if (message.last_seen_message !== void 0) {\n      obj.last_seen_message = ChannelMessageHeader.toJSON(message.last_seen_message);\n    }\n    if ((_c = message.is_online) == null ? void 0 : _c.length) {\n      obj.is_online = message.is_online;\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.count_mess_unread !== 0) {\n      obj.count_mess_unread = Math.round(message.count_mess_unread);\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.last_pin_message !== \"\") {\n      obj.last_pin_message = message.last_pin_message;\n    }\n    if (message.usernames !== \"\") {\n      obj.usernames = message.usernames;\n    }\n    if (message.creator_name !== \"\") {\n      obj.creator_name = message.creator_name;\n    }\n    if (message.create_time_seconds !== 0) {\n      obj.create_time_seconds = Math.round(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      obj.update_time_seconds = Math.round(message.update_time_seconds);\n    }\n    if ((_d = message.metadata) == null ? void 0 : _d.length) {\n      obj.metadata = message.metadata;\n    }\n    if ((_e = message.about_me) == null ? void 0 : _e.length) {\n      obj.about_me = message.about_me;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.app_url !== \"\") {\n      obj.app_url = message.app_url;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDescription.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n    const message = createBaseChannelDescription();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.parrent_id = (_b = object.parrent_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.category_id = (_d = object.category_id) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    message.type = (_f = object.type) != null ? _f : void 0;\n    message.creator_id = (_g = object.creator_id) != null ? _g : \"\";\n    message.channel_label = (_h = object.channel_label) != null ? _h : \"\";\n    message.channel_private = (_i = object.channel_private) != null ? _i : 0;\n    message.channel_avatar = ((_j = object.channel_avatar) == null ? void 0 : _j.map((e) => e)) || [];\n    message.user_id = ((_k = object.user_id) == null ? void 0 : _k.map((e) => e)) || [];\n    message.last_sent_message = object.last_sent_message !== void 0 && object.last_sent_message !== null ? ChannelMessageHeader.fromPartial(object.last_sent_message) : void 0;\n    message.last_seen_message = object.last_seen_message !== void 0 && object.last_seen_message !== null ? ChannelMessageHeader.fromPartial(object.last_seen_message) : void 0;\n    message.is_online = ((_l = object.is_online) == null ? void 0 : _l.map((e) => e)) || [];\n    message.meeting_code = (_m = object.meeting_code) != null ? _m : \"\";\n    message.count_mess_unread = (_n = object.count_mess_unread) != null ? _n : 0;\n    message.active = (_o = object.active) != null ? _o : 0;\n    message.last_pin_message = (_p = object.last_pin_message) != null ? _p : \"\";\n    message.usernames = (_q = object.usernames) != null ? _q : \"\";\n    message.creator_name = (_r = object.creator_name) != null ? _r : \"\";\n    message.create_time_seconds = (_s = object.create_time_seconds) != null ? _s : 0;\n    message.update_time_seconds = (_t = object.update_time_seconds) != null ? _t : 0;\n    message.metadata = ((_u = object.metadata) == null ? void 0 : _u.map((e) => e)) || [];\n    message.about_me = ((_v = object.about_me) == null ? void 0 : _v.map((e) => e)) || [];\n    message.clan_name = (_w = object.clan_name) != null ? _w : \"\";\n    message.app_url = (_x = object.app_url) != null ? _x : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelDescList() {\n  return { channeldesc: [], next_cursor: \"\", prev_cursor: \"\", cacheable_cursor: \"\" };\n}\nvar ChannelDescList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.channeldesc) {\n      ChannelDescription.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.next_cursor !== \"\") {\n      writer.uint32(18).string(message.next_cursor);\n    }\n    if (message.prev_cursor !== \"\") {\n      writer.uint32(26).string(message.prev_cursor);\n    }\n    if (message.cacheable_cursor !== \"\") {\n      writer.uint32(34).string(message.cacheable_cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.next_cursor = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.prev_cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.cacheable_cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channeldesc: globalThis.Array.isArray(object == null ? void 0 : object.channeldesc) ? object.channeldesc.map((e) => ChannelDescription.fromJSON(e)) : [],\n      next_cursor: isSet3(object.next_cursor) ? globalThis.String(object.next_cursor) : \"\",\n      prev_cursor: isSet3(object.prev_cursor) ? globalThis.String(object.prev_cursor) : \"\",\n      cacheable_cursor: isSet3(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.channeldesc) == null ? void 0 : _a.length) {\n      obj.channeldesc = message.channeldesc.map((e) => ChannelDescription.toJSON(e));\n    }\n    if (message.next_cursor !== \"\") {\n      obj.next_cursor = message.next_cursor;\n    }\n    if (message.prev_cursor !== \"\") {\n      obj.prev_cursor = message.prev_cursor;\n    }\n    if (message.cacheable_cursor !== \"\") {\n      obj.cacheable_cursor = message.cacheable_cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDescList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseChannelDescList();\n    message.channeldesc = ((_a = object.channeldesc) == null ? void 0 : _a.map((e) => ChannelDescription.fromPartial(e))) || [];\n    message.next_cursor = (_b = object.next_cursor) != null ? _b : \"\";\n    message.prev_cursor = (_c = object.prev_cursor) != null ? _c : \"\";\n    message.cacheable_cursor = (_d = object.cacheable_cursor) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseRole() {\n  return {\n    id: \"\",\n    title: \"\",\n    color: \"\",\n    role_icon: \"\",\n    slug: \"\",\n    description: \"\",\n    creator_id: \"\",\n    clan_id: \"\",\n    active: 0,\n    display_online: 0,\n    allow_mention: 0,\n    role_user_list: void 0,\n    permission_list: void 0,\n    role_channel_active: 0,\n    channel_ids: [],\n    max_level_permission: 0\n  };\n}\nvar Role = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.title !== \"\") {\n      writer.uint32(18).string(message.title);\n    }\n    if (message.color !== \"\") {\n      writer.uint32(26).string(message.color);\n    }\n    if (message.role_icon !== \"\") {\n      writer.uint32(34).string(message.role_icon);\n    }\n    if (message.slug !== \"\") {\n      writer.uint32(42).string(message.slug);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(50).string(message.description);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(58).string(message.creator_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(66).string(message.clan_id);\n    }\n    if (message.active !== 0) {\n      writer.uint32(72).int32(message.active);\n    }\n    if (message.display_online !== 0) {\n      writer.uint32(80).int32(message.display_online);\n    }\n    if (message.allow_mention !== 0) {\n      writer.uint32(88).int32(message.allow_mention);\n    }\n    if (message.role_user_list !== void 0) {\n      RoleUserList.encode(message.role_user_list, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.permission_list !== void 0) {\n      PermissionList.encode(message.permission_list, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.role_channel_active !== 0) {\n      writer.uint32(112).int32(message.role_channel_active);\n    }\n    for (const v of message.channel_ids) {\n      writer.uint32(122).string(v);\n    }\n    if (message.max_level_permission !== 0) {\n      writer.uint32(128).int32(message.max_level_permission);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRole();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.color = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.role_icon = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.slug = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.description = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.display_online = reader.int32();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.allow_mention = reader.int32();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.role_user_list = RoleUserList.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.permission_list = PermissionList.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag !== 112) {\n            break;\n          }\n          message.role_channel_active = reader.int32();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.channel_ids.push(reader.string());\n          continue;\n        case 16:\n          if (tag !== 128) {\n            break;\n          }\n          message.max_level_permission = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      title: isSet3(object.title) ? globalThis.String(object.title) : \"\",\n      color: isSet3(object.color) ? globalThis.String(object.color) : \"\",\n      role_icon: isSet3(object.role_icon) ? globalThis.String(object.role_icon) : \"\",\n      slug: isSet3(object.slug) ? globalThis.String(object.slug) : \"\",\n      description: isSet3(object.description) ? globalThis.String(object.description) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      display_online: isSet3(object.display_online) ? globalThis.Number(object.display_online) : 0,\n      allow_mention: isSet3(object.allow_mention) ? globalThis.Number(object.allow_mention) : 0,\n      role_user_list: isSet3(object.role_user_list) ? RoleUserList.fromJSON(object.role_user_list) : void 0,\n      permission_list: isSet3(object.permission_list) ? PermissionList.fromJSON(object.permission_list) : void 0,\n      role_channel_active: isSet3(object.role_channel_active) ? globalThis.Number(object.role_channel_active) : 0,\n      channel_ids: globalThis.Array.isArray(object == null ? void 0 : object.channel_ids) ? object.channel_ids.map((e) => globalThis.String(e)) : [],\n      max_level_permission: isSet3(object.max_level_permission) ? globalThis.Number(object.max_level_permission) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.color !== \"\") {\n      obj.color = message.color;\n    }\n    if (message.role_icon !== \"\") {\n      obj.role_icon = message.role_icon;\n    }\n    if (message.slug !== \"\") {\n      obj.slug = message.slug;\n    }\n    if (message.description !== \"\") {\n      obj.description = message.description;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.display_online !== 0) {\n      obj.display_online = Math.round(message.display_online);\n    }\n    if (message.allow_mention !== 0) {\n      obj.allow_mention = Math.round(message.allow_mention);\n    }\n    if (message.role_user_list !== void 0) {\n      obj.role_user_list = RoleUserList.toJSON(message.role_user_list);\n    }\n    if (message.permission_list !== void 0) {\n      obj.permission_list = PermissionList.toJSON(message.permission_list);\n    }\n    if (message.role_channel_active !== 0) {\n      obj.role_channel_active = Math.round(message.role_channel_active);\n    }\n    if ((_a = message.channel_ids) == null ? void 0 : _a.length) {\n      obj.channel_ids = message.channel_ids;\n    }\n    if (message.max_level_permission !== 0) {\n      obj.max_level_permission = Math.round(message.max_level_permission);\n    }\n    return obj;\n  },\n  create(base) {\n    return Role.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n    const message = createBaseRole();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.title = (_b = object.title) != null ? _b : \"\";\n    message.color = (_c = object.color) != null ? _c : \"\";\n    message.role_icon = (_d = object.role_icon) != null ? _d : \"\";\n    message.slug = (_e = object.slug) != null ? _e : \"\";\n    message.description = (_f = object.description) != null ? _f : \"\";\n    message.creator_id = (_g = object.creator_id) != null ? _g : \"\";\n    message.clan_id = (_h = object.clan_id) != null ? _h : \"\";\n    message.active = (_i = object.active) != null ? _i : 0;\n    message.display_online = (_j = object.display_online) != null ? _j : 0;\n    message.allow_mention = (_k = object.allow_mention) != null ? _k : 0;\n    message.role_user_list = object.role_user_list !== void 0 && object.role_user_list !== null ? RoleUserList.fromPartial(object.role_user_list) : void 0;\n    message.permission_list = object.permission_list !== void 0 && object.permission_list !== null ? PermissionList.fromPartial(object.permission_list) : void 0;\n    message.role_channel_active = (_l = object.role_channel_active) != null ? _l : 0;\n    message.channel_ids = ((_m = object.channel_ids) == null ? void 0 : _m.map((e) => e)) || [];\n    message.max_level_permission = (_n = object.max_level_permission) != null ? _n : 0;\n    return message;\n  }\n};\nfunction createBasePermission() {\n  return { id: \"\", title: \"\", slug: \"\", description: \"\", active: 0, scope: 0, level: 0 };\n}\nvar Permission = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.title !== \"\") {\n      writer.uint32(18).string(message.title);\n    }\n    if (message.slug !== \"\") {\n      writer.uint32(26).string(message.slug);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(34).string(message.description);\n    }\n    if (message.active !== 0) {\n      writer.uint32(40).int32(message.active);\n    }\n    if (message.scope !== 0) {\n      writer.uint32(48).int32(message.scope);\n    }\n    if (message.level !== 0) {\n      writer.uint32(56).int32(message.level);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermission();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.slug = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.description = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.scope = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.level = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      title: isSet3(object.title) ? globalThis.String(object.title) : \"\",\n      slug: isSet3(object.slug) ? globalThis.String(object.slug) : \"\",\n      description: isSet3(object.description) ? globalThis.String(object.description) : \"\",\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      scope: isSet3(object.scope) ? globalThis.Number(object.scope) : 0,\n      level: isSet3(object.level) ? globalThis.Number(object.level) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.slug !== \"\") {\n      obj.slug = message.slug;\n    }\n    if (message.description !== \"\") {\n      obj.description = message.description;\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.scope !== 0) {\n      obj.scope = Math.round(message.scope);\n    }\n    if (message.level !== 0) {\n      obj.level = Math.round(message.level);\n    }\n    return obj;\n  },\n  create(base) {\n    return Permission.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBasePermission();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.title = (_b = object.title) != null ? _b : \"\";\n    message.slug = (_c = object.slug) != null ? _c : \"\";\n    message.description = (_d = object.description) != null ? _d : \"\";\n    message.active = (_e = object.active) != null ? _e : 0;\n    message.scope = (_f = object.scope) != null ? _f : 0;\n    message.level = (_g = object.level) != null ? _g : 0;\n    return message;\n  }\n};\nfunction createBaseHashtagDmList() {\n  return { hashtag_dm: [] };\n}\nvar HashtagDmList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.hashtag_dm) {\n      HashtagDm.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDmList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.hashtag_dm.push(HashtagDm.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hashtag_dm: globalThis.Array.isArray(object == null ? void 0 : object.hashtag_dm) ? object.hashtag_dm.map((e) => HashtagDm.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.hashtag_dm) == null ? void 0 : _a.length) {\n      obj.hashtag_dm = message.hashtag_dm.map((e) => HashtagDm.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDmList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseHashtagDmList();\n    message.hashtag_dm = ((_a = object.hashtag_dm) == null ? void 0 : _a.map((e) => HashtagDm.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseHashtagDm() {\n  return {\n    channel_id: \"\",\n    channel_label: \"\",\n    clan_id: \"\",\n    clan_name: \"\",\n    meeting_code: \"\",\n    type: 0,\n    channel_private: 0,\n    parrent_id: \"\"\n  };\n}\nvar HashtagDm = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(18).string(message.channel_label);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(34).string(message.clan_name);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(42).string(message.meeting_code);\n    }\n    if (message.type !== 0) {\n      writer.uint32(48).int32(message.type);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(66).string(message.parrent_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDm();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.type = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.parrent_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      meeting_code: isSet3(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      type: isSet3(object.type) ? globalThis.Number(object.type) : 0,\n      channel_private: isSet3(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      parrent_id: isSet3(object.parrent_id) ? globalThis.String(object.parrent_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.type !== 0) {\n      obj.type = Math.round(message.type);\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if (message.parrent_id !== \"\") {\n      obj.parrent_id = message.parrent_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDm.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseHashtagDm();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.channel_label = (_b = object.channel_label) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.clan_name = (_d = object.clan_name) != null ? _d : \"\";\n    message.meeting_code = (_e = object.meeting_code) != null ? _e : \"\";\n    message.type = (_f = object.type) != null ? _f : 0;\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.parrent_id = (_h = object.parrent_id) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseNotificationChannelCategorySettingList() {\n  return { notification_channel_category_settings_list: [] };\n}\nvar NotificationChannelCategorySettingList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.notification_channel_category_settings_list) {\n      NotificationChannelCategorySetting.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelCategorySettingList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.notification_channel_category_settings_list.push(\n            NotificationChannelCategorySetting.decode(reader, reader.uint32())\n          );\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      notification_channel_category_settings_list: globalThis.Array.isArray(object == null ? void 0 : object.notification_channel_category_settings_list) ? object.notification_channel_category_settings_list.map(\n        (e) => NotificationChannelCategorySetting.fromJSON(e)\n      ) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.notification_channel_category_settings_list) == null ? void 0 : _a.length) {\n      obj.notification_channel_category_settings_list = message.notification_channel_category_settings_list.map(\n        (e) => NotificationChannelCategorySetting.toJSON(e)\n      );\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelCategorySettingList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationChannelCategorySettingList();\n    message.notification_channel_category_settings_list = ((_a = object.notification_channel_category_settings_list) == null ? void 0 : _a.map(\n      (e) => NotificationChannelCategorySetting.fromPartial(e)\n    )) || [];\n    return message;\n  }\n};\nfunction createBaseNotificationChannelCategorySetting() {\n  return { id: \"\", channel_category_label: \"\", notification_setting_type: 0, channel_category_title: \"\", action: 0 };\n}\nvar NotificationChannelCategorySetting = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.channel_category_label !== \"\") {\n      writer.uint32(18).string(message.channel_category_label);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(24).int32(message.notification_setting_type);\n    }\n    if (message.channel_category_title !== \"\") {\n      writer.uint32(34).string(message.channel_category_title);\n    }\n    if (message.action !== 0) {\n      writer.uint32(40).int32(message.action);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelCategorySetting();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_category_label = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.notification_setting_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_category_title = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.action = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      channel_category_label: isSet3(object.channel_category_label) ? globalThis.String(object.channel_category_label) : \"\",\n      notification_setting_type: isSet3(object.notification_setting_type) ? globalThis.Number(object.notification_setting_type) : 0,\n      channel_category_title: isSet3(object.channel_category_title) ? globalThis.String(object.channel_category_title) : \"\",\n      action: isSet3(object.action) ? globalThis.Number(object.action) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.channel_category_label !== \"\") {\n      obj.channel_category_label = message.channel_category_label;\n    }\n    if (message.notification_setting_type !== 0) {\n      obj.notification_setting_type = Math.round(message.notification_setting_type);\n    }\n    if (message.channel_category_title !== \"\") {\n      obj.channel_category_title = message.channel_category_title;\n    }\n    if (message.action !== 0) {\n      obj.action = Math.round(message.action);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelCategorySetting.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseNotificationChannelCategorySetting();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.channel_category_label = (_b = object.channel_category_label) != null ? _b : \"\";\n    message.notification_setting_type = (_c = object.notification_setting_type) != null ? _c : 0;\n    message.channel_category_title = (_d = object.channel_category_title) != null ? _d : \"\";\n    message.action = (_e = object.action) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseRoleList() {\n  return { roles: [], next_cursor: \"\", prev_cursor: \"\", cacheable_cursor: \"\" };\n}\nvar RoleList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.roles) {\n      Role.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.next_cursor !== \"\") {\n      writer.uint32(18).string(message.next_cursor);\n    }\n    if (message.prev_cursor !== \"\") {\n      writer.uint32(26).string(message.prev_cursor);\n    }\n    if (message.cacheable_cursor !== \"\") {\n      writer.uint32(34).string(message.cacheable_cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.roles.push(Role.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.next_cursor = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.prev_cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.cacheable_cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      roles: globalThis.Array.isArray(object == null ? void 0 : object.roles) ? object.roles.map((e) => Role.fromJSON(e)) : [],\n      next_cursor: isSet3(object.next_cursor) ? globalThis.String(object.next_cursor) : \"\",\n      prev_cursor: isSet3(object.prev_cursor) ? globalThis.String(object.prev_cursor) : \"\",\n      cacheable_cursor: isSet3(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.roles) == null ? void 0 : _a.length) {\n      obj.roles = message.roles.map((e) => Role.toJSON(e));\n    }\n    if (message.next_cursor !== \"\") {\n      obj.next_cursor = message.next_cursor;\n    }\n    if (message.prev_cursor !== \"\") {\n      obj.prev_cursor = message.prev_cursor;\n    }\n    if (message.cacheable_cursor !== \"\") {\n      obj.cacheable_cursor = message.cacheable_cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleList();\n    message.roles = ((_a = object.roles) == null ? void 0 : _a.map((e) => Role.fromPartial(e))) || [];\n    message.next_cursor = (_b = object.next_cursor) != null ? _b : \"\";\n    message.prev_cursor = (_c = object.prev_cursor) != null ? _c : \"\";\n    message.cacheable_cursor = (_d = object.cacheable_cursor) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBasePermissionList() {\n  return { permissions: [], max_level_permission: 0 };\n}\nvar PermissionList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.permissions) {\n      Permission.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.max_level_permission !== 0) {\n      writer.uint32(16).int32(message.max_level_permission);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.permissions.push(Permission.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.max_level_permission = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      permissions: globalThis.Array.isArray(object == null ? void 0 : object.permissions) ? object.permissions.map((e) => Permission.fromJSON(e)) : [],\n      max_level_permission: isSet3(object.max_level_permission) ? globalThis.Number(object.max_level_permission) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.permissions) == null ? void 0 : _a.length) {\n      obj.permissions = message.permissions.map((e) => Permission.toJSON(e));\n    }\n    if (message.max_level_permission !== 0) {\n      obj.max_level_permission = Math.round(message.max_level_permission);\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePermissionList();\n    message.permissions = ((_a = object.permissions) == null ? void 0 : _a.map((e) => Permission.fromPartial(e))) || [];\n    message.max_level_permission = (_b = object.max_level_permission) != null ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseRoleUserList() {\n  return { role_users: [], cursor: \"\" };\n}\nvar RoleUserList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.role_users) {\n      RoleUserList_RoleUser.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(18).string(message.cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleUserList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_users.push(RoleUserList_RoleUser.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_users: globalThis.Array.isArray(object == null ? void 0 : object.role_users) ? object.role_users.map((e) => RoleUserList_RoleUser.fromJSON(e)) : [],\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.role_users) == null ? void 0 : _a.length) {\n      obj.role_users = message.role_users.map((e) => RoleUserList_RoleUser.toJSON(e));\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleUserList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseRoleUserList();\n    message.role_users = ((_a = object.role_users) == null ? void 0 : _a.map((e) => RoleUserList_RoleUser.fromPartial(e))) || [];\n    message.cursor = (_b = object.cursor) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleUserList_RoleUser() {\n  return { id: \"\", username: \"\", display_name: \"\", avatar_url: \"\", lang_tag: \"\", location: \"\", online: false };\n}\nvar RoleUserList_RoleUser = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(26).string(message.display_name);\n    }\n    if (message.avatar_url !== \"\") {\n      writer.uint32(34).string(message.avatar_url);\n    }\n    if (message.lang_tag !== \"\") {\n      writer.uint32(42).string(message.lang_tag);\n    }\n    if (message.location !== \"\") {\n      writer.uint32(50).string(message.location);\n    }\n    if (message.online !== false) {\n      writer.uint32(56).bool(message.online);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleUserList_RoleUser();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.avatar_url = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.lang_tag = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.location = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.online = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      display_name: isSet3(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      avatar_url: isSet3(object.avatar_url) ? globalThis.String(object.avatar_url) : \"\",\n      lang_tag: isSet3(object.lang_tag) ? globalThis.String(object.lang_tag) : \"\",\n      location: isSet3(object.location) ? globalThis.String(object.location) : \"\",\n      online: isSet3(object.online) ? globalThis.Boolean(object.online) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.avatar_url !== \"\") {\n      obj.avatar_url = message.avatar_url;\n    }\n    if (message.lang_tag !== \"\") {\n      obj.lang_tag = message.lang_tag;\n    }\n    if (message.location !== \"\") {\n      obj.location = message.location;\n    }\n    if (message.online !== false) {\n      obj.online = message.online;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleUserList_RoleUser.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseRoleUserList_RoleUser();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.display_name = (_c = object.display_name) != null ? _c : \"\";\n    message.avatar_url = (_d = object.avatar_url) != null ? _d : \"\";\n    message.lang_tag = (_e = object.lang_tag) != null ? _e : \"\";\n    message.location = (_f = object.location) != null ? _f : \"\";\n    message.online = (_g = object.online) != null ? _g : false;\n    return message;\n  }\n};\nfunction createBaseCreateEventRequest() {\n  return {\n    title: \"\",\n    logo: \"\",\n    description: \"\",\n    clan_id: \"\",\n    channel_id: \"\",\n    address: \"\",\n    start_time: void 0,\n    end_time: void 0,\n    event_id: \"\",\n    event_status: \"\"\n  };\n}\nvar CreateEventRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(18).string(message.logo);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(26).string(message.description);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(50).string(message.address);\n    }\n    if (message.start_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(58).fork()).ldelim();\n    }\n    if (message.end_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(66).fork()).ldelim();\n    }\n    if (message.event_id !== \"\") {\n      writer.uint32(74).string(message.event_id);\n    }\n    if (message.event_status !== \"\") {\n      writer.uint32(82).string(message.event_status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCreateEventRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.description = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.address = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.event_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.event_status = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      title: isSet3(object.title) ? globalThis.String(object.title) : \"\",\n      logo: isSet3(object.logo) ? globalThis.String(object.logo) : \"\",\n      description: isSet3(object.description) ? globalThis.String(object.description) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      address: isSet3(object.address) ? globalThis.String(object.address) : \"\",\n      start_time: isSet3(object.start_time) ? fromJsonTimestamp(object.start_time) : void 0,\n      end_time: isSet3(object.end_time) ? fromJsonTimestamp(object.end_time) : void 0,\n      event_id: isSet3(object.event_id) ? globalThis.String(object.event_id) : \"\",\n      event_status: isSet3(object.event_status) ? globalThis.String(object.event_status) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.description !== \"\") {\n      obj.description = message.description;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.address !== \"\") {\n      obj.address = message.address;\n    }\n    if (message.start_time !== void 0) {\n      obj.start_time = message.start_time.toISOString();\n    }\n    if (message.end_time !== void 0) {\n      obj.end_time = message.end_time.toISOString();\n    }\n    if (message.event_id !== \"\") {\n      obj.event_id = message.event_id;\n    }\n    if (message.event_status !== \"\") {\n      obj.event_status = message.event_status;\n    }\n    return obj;\n  },\n  create(base) {\n    return CreateEventRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseCreateEventRequest();\n    message.title = (_a = object.title) != null ? _a : \"\";\n    message.logo = (_b = object.logo) != null ? _b : \"\";\n    message.description = (_c = object.description) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.address = (_f = object.address) != null ? _f : \"\";\n    message.start_time = (_g = object.start_time) != null ? _g : void 0;\n    message.end_time = (_h = object.end_time) != null ? _h : void 0;\n    message.event_id = (_i = object.event_id) != null ? _i : \"\";\n    message.event_status = (_j = object.event_status) != null ? _j : \"\";\n    return message;\n  }\n};\nfunction createBaseGiveCoffeeEvent() {\n  return { sender_id: \"\", receiver_id: \"\", token_count: 0, message_ref_id: \"\", channel_id: \"\", clan_id: \"\" };\n}\nvar GiveCoffeeEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.sender_id !== \"\") {\n      writer.uint32(10).string(message.sender_id);\n    }\n    if (message.receiver_id !== \"\") {\n      writer.uint32(18).string(message.receiver_id);\n    }\n    if (message.token_count !== 0) {\n      writer.uint32(24).int32(message.token_count);\n    }\n    if (message.message_ref_id !== \"\") {\n      writer.uint32(34).string(message.message_ref_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseGiveCoffeeEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.receiver_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.token_count = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.message_ref_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      receiver_id: isSet3(object.receiver_id) ? globalThis.String(object.receiver_id) : \"\",\n      token_count: isSet3(object.token_count) ? globalThis.Number(object.token_count) : 0,\n      message_ref_id: isSet3(object.message_ref_id) ? globalThis.String(object.message_ref_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.receiver_id !== \"\") {\n      obj.receiver_id = message.receiver_id;\n    }\n    if (message.token_count !== 0) {\n      obj.token_count = Math.round(message.token_count);\n    }\n    if (message.message_ref_id !== \"\") {\n      obj.message_ref_id = message.message_ref_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return GiveCoffeeEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseGiveCoffeeEvent();\n    message.sender_id = (_a = object.sender_id) != null ? _a : \"\";\n    message.receiver_id = (_b = object.receiver_id) != null ? _b : \"\";\n    message.token_count = (_c = object.token_count) != null ? _c : 0;\n    message.message_ref_id = (_d = object.message_ref_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction toTimestamp(date) {\n  const seconds = Math.trunc(date.getTime() / 1e3);\n  const nanos = date.getTime() % 1e3 * 1e6;\n  return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n  let millis = (t.seconds || 0) * 1e3;\n  millis += (t.nanos || 0) / 1e6;\n  return new globalThis.Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n  if (o instanceof globalThis.Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new globalThis.Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\nfunction longToNumber2(long) {\n  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\nif (import_minimal4.default.util.Long !== import_long3.default) {\n  import_minimal4.default.util.Long = import_long3.default;\n  import_minimal4.default.configure();\n}\nfunction isSet3(value) {\n  return value !== null && value !== void 0;\n}\n\n// rtapi/realtime.ts\nfunction createBaseEnvelope() {\n  return {\n    cid: \"\",\n    channel: void 0,\n    clan_join: void 0,\n    channel_join: void 0,\n    channel_leave: void 0,\n    channel_message: void 0,\n    channel_message_ack: void 0,\n    channel_message_send: void 0,\n    channel_message_update: void 0,\n    channel_message_remove: void 0,\n    channel_presence_event: void 0,\n    error: void 0,\n    notifications: void 0,\n    rpc: void 0,\n    status: void 0,\n    status_follow: void 0,\n    status_presence_event: void 0,\n    status_unfollow: void 0,\n    status_update: void 0,\n    stream_data: void 0,\n    stream_presence_event: void 0,\n    ping: void 0,\n    pong: void 0,\n    message_typing_event: void 0,\n    last_seen_message_event: void 0,\n    message_reaction_event: void 0,\n    voice_joined_event: void 0,\n    voice_leaved_event: void 0,\n    voice_started_event: void 0,\n    voice_ended_event: void 0,\n    channel_created_event: void 0,\n    channel_deleted_event: void 0,\n    channel_updated_event: void 0,\n    last_pin_message_event: void 0,\n    custom_status_event: void 0,\n    user_channel_added_event: void 0,\n    user_channel_removed_event: void 0,\n    user_clan_removed_event: void 0,\n    clan_updated_event: void 0,\n    clan_profile_updated_event: void 0,\n    check_name_existed_event: void 0,\n    user_profile_updated_event: void 0,\n    emojis_listed_event: void 0,\n    sticker_listed_event: void 0,\n    channel_desc_list_event: void 0,\n    hashtag_dm_list_event: void 0,\n    notification_channel_setting_event: void 0,\n    notification_category_setting_event: void 0,\n    notification_clan_setting_event: void 0,\n    notifi_react_message_event: void 0,\n    permission_role_channel_list_event: void 0,\n    notification_channel_category_setting_event: void 0,\n    add_clan_user_event: void 0,\n    all_user_clans: void 0,\n    clan_event_created: void 0,\n    user_permission_in_channel_list_event: void 0,\n    role_list_event: void 0,\n    role_assign_event: void 0,\n    clan_deleted_event: void 0,\n    give_coffee_event: void 0,\n    sticker_create_event: void 0,\n    sticker_update_event: void 0,\n    sticker_delete_event: void 0,\n    role_event: void 0,\n    event_emoji: void 0,\n    streaming_joined_event: void 0,\n    streaming_leaved_event: void 0,\n    streaming_started_event: void 0,\n    streaming_ended_event: void 0,\n    all_users_add_channel_event: void 0\n  };\n}\nvar Envelope = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.cid !== \"\") {\n      writer.uint32(10).string(message.cid);\n    }\n    if (message.channel !== void 0) {\n      Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.clan_join !== void 0) {\n      ClanJoin.encode(message.clan_join, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.channel_join !== void 0) {\n      ChannelJoin.encode(message.channel_join, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.channel_leave !== void 0) {\n      ChannelLeave.encode(message.channel_leave, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.channel_message !== void 0) {\n      ChannelMessage.encode(message.channel_message, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.channel_message_ack !== void 0) {\n      ChannelMessageAck.encode(message.channel_message_ack, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.channel_message_send !== void 0) {\n      ChannelMessageSend.encode(message.channel_message_send, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.channel_message_update !== void 0) {\n      ChannelMessageUpdate.encode(message.channel_message_update, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.channel_message_remove !== void 0) {\n      ChannelMessageRemove.encode(message.channel_message_remove, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.channel_presence_event !== void 0) {\n      ChannelPresenceEvent.encode(message.channel_presence_event, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.error !== void 0) {\n      Error2.encode(message.error, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.notifications !== void 0) {\n      Notifications.encode(message.notifications, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.rpc !== void 0) {\n      Rpc.encode(message.rpc, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.status !== void 0) {\n      Status.encode(message.status, writer.uint32(122).fork()).ldelim();\n    }\n    if (message.status_follow !== void 0) {\n      StatusFollow.encode(message.status_follow, writer.uint32(130).fork()).ldelim();\n    }\n    if (message.status_presence_event !== void 0) {\n      StatusPresenceEvent.encode(message.status_presence_event, writer.uint32(138).fork()).ldelim();\n    }\n    if (message.status_unfollow !== void 0) {\n      StatusUnfollow.encode(message.status_unfollow, writer.uint32(146).fork()).ldelim();\n    }\n    if (message.status_update !== void 0) {\n      StatusUpdate.encode(message.status_update, writer.uint32(154).fork()).ldelim();\n    }\n    if (message.stream_data !== void 0) {\n      StreamData.encode(message.stream_data, writer.uint32(162).fork()).ldelim();\n    }\n    if (message.stream_presence_event !== void 0) {\n      StreamPresenceEvent.encode(message.stream_presence_event, writer.uint32(170).fork()).ldelim();\n    }\n    if (message.ping !== void 0) {\n      Ping.encode(message.ping, writer.uint32(178).fork()).ldelim();\n    }\n    if (message.pong !== void 0) {\n      Pong.encode(message.pong, writer.uint32(186).fork()).ldelim();\n    }\n    if (message.message_typing_event !== void 0) {\n      MessageTypingEvent.encode(message.message_typing_event, writer.uint32(194).fork()).ldelim();\n    }\n    if (message.last_seen_message_event !== void 0) {\n      LastSeenMessageEvent.encode(message.last_seen_message_event, writer.uint32(202).fork()).ldelim();\n    }\n    if (message.message_reaction_event !== void 0) {\n      MessageReaction.encode(message.message_reaction_event, writer.uint32(210).fork()).ldelim();\n    }\n    if (message.voice_joined_event !== void 0) {\n      VoiceJoinedEvent.encode(message.voice_joined_event, writer.uint32(218).fork()).ldelim();\n    }\n    if (message.voice_leaved_event !== void 0) {\n      VoiceLeavedEvent.encode(message.voice_leaved_event, writer.uint32(226).fork()).ldelim();\n    }\n    if (message.voice_started_event !== void 0) {\n      VoiceStartedEvent.encode(message.voice_started_event, writer.uint32(234).fork()).ldelim();\n    }\n    if (message.voice_ended_event !== void 0) {\n      VoiceEndedEvent.encode(message.voice_ended_event, writer.uint32(242).fork()).ldelim();\n    }\n    if (message.channel_created_event !== void 0) {\n      ChannelCreatedEvent.encode(message.channel_created_event, writer.uint32(250).fork()).ldelim();\n    }\n    if (message.channel_deleted_event !== void 0) {\n      ChannelDeletedEvent.encode(message.channel_deleted_event, writer.uint32(258).fork()).ldelim();\n    }\n    if (message.channel_updated_event !== void 0) {\n      ChannelUpdatedEvent.encode(message.channel_updated_event, writer.uint32(266).fork()).ldelim();\n    }\n    if (message.last_pin_message_event !== void 0) {\n      LastPinMessageEvent.encode(message.last_pin_message_event, writer.uint32(274).fork()).ldelim();\n    }\n    if (message.custom_status_event !== void 0) {\n      CustomStatusEvent.encode(message.custom_status_event, writer.uint32(282).fork()).ldelim();\n    }\n    if (message.user_channel_added_event !== void 0) {\n      UserChannelAdded.encode(message.user_channel_added_event, writer.uint32(290).fork()).ldelim();\n    }\n    if (message.user_channel_removed_event !== void 0) {\n      UserChannelRemoved.encode(message.user_channel_removed_event, writer.uint32(298).fork()).ldelim();\n    }\n    if (message.user_clan_removed_event !== void 0) {\n      UserClanRemoved.encode(message.user_clan_removed_event, writer.uint32(306).fork()).ldelim();\n    }\n    if (message.clan_updated_event !== void 0) {\n      ClanUpdatedEvent.encode(message.clan_updated_event, writer.uint32(314).fork()).ldelim();\n    }\n    if (message.clan_profile_updated_event !== void 0) {\n      ClanProfileUpdatedEvent.encode(message.clan_profile_updated_event, writer.uint32(322).fork()).ldelim();\n    }\n    if (message.check_name_existed_event !== void 0) {\n      CheckNameExistedEvent.encode(message.check_name_existed_event, writer.uint32(330).fork()).ldelim();\n    }\n    if (message.user_profile_updated_event !== void 0) {\n      UserProfileUpdatedEvent.encode(message.user_profile_updated_event, writer.uint32(338).fork()).ldelim();\n    }\n    if (message.emojis_listed_event !== void 0) {\n      EmojiListedEvent.encode(message.emojis_listed_event, writer.uint32(346).fork()).ldelim();\n    }\n    if (message.sticker_listed_event !== void 0) {\n      StrickerListedEvent.encode(message.sticker_listed_event, writer.uint32(354).fork()).ldelim();\n    }\n    if (message.channel_desc_list_event !== void 0) {\n      ChannelDescListEvent.encode(message.channel_desc_list_event, writer.uint32(362).fork()).ldelim();\n    }\n    if (message.hashtag_dm_list_event !== void 0) {\n      HashtagDmListEvent.encode(message.hashtag_dm_list_event, writer.uint32(370).fork()).ldelim();\n    }\n    if (message.notification_channel_setting_event !== void 0) {\n      NotificationChannelSettingEvent.encode(message.notification_channel_setting_event, writer.uint32(378).fork()).ldelim();\n    }\n    if (message.notification_category_setting_event !== void 0) {\n      NotificationCategorySettingEvent.encode(message.notification_category_setting_event, writer.uint32(386).fork()).ldelim();\n    }\n    if (message.notification_clan_setting_event !== void 0) {\n      NotificationClanSettingEvent.encode(message.notification_clan_setting_event, writer.uint32(394).fork()).ldelim();\n    }\n    if (message.notifi_react_message_event !== void 0) {\n      NotifiReactMessageEvent.encode(message.notifi_react_message_event, writer.uint32(402).fork()).ldelim();\n    }\n    if (message.permission_role_channel_list_event !== void 0) {\n      PermissionRoleChannelListEvent.encode(message.permission_role_channel_list_event, writer.uint32(410).fork()).ldelim();\n    }\n    if (message.notification_channel_category_setting_event !== void 0) {\n      NotificationChannelCategorySettingEvent.encode(\n        message.notification_channel_category_setting_event,\n        writer.uint32(418).fork()\n      ).ldelim();\n    }\n    if (message.add_clan_user_event !== void 0) {\n      AddClanUserEvent.encode(message.add_clan_user_event, writer.uint32(426).fork()).ldelim();\n    }\n    if (message.all_user_clans !== void 0) {\n      AllUserClans.encode(message.all_user_clans, writer.uint32(434).fork()).ldelim();\n    }\n    if (message.clan_event_created !== void 0) {\n      CreateEventRequest.encode(message.clan_event_created, writer.uint32(442).fork()).ldelim();\n    }\n    if (message.user_permission_in_channel_list_event !== void 0) {\n      UserPermissionInChannelListEvent.encode(message.user_permission_in_channel_list_event, writer.uint32(450).fork()).ldelim();\n    }\n    if (message.role_list_event !== void 0) {\n      RoleListEvent.encode(message.role_list_event, writer.uint32(458).fork()).ldelim();\n    }\n    if (message.role_assign_event !== void 0) {\n      RoleAssignedEvent.encode(message.role_assign_event, writer.uint32(466).fork()).ldelim();\n    }\n    if (message.clan_deleted_event !== void 0) {\n      ClanDeletedEvent.encode(message.clan_deleted_event, writer.uint32(474).fork()).ldelim();\n    }\n    if (message.give_coffee_event !== void 0) {\n      GiveCoffeeEvent.encode(message.give_coffee_event, writer.uint32(482).fork()).ldelim();\n    }\n    if (message.sticker_create_event !== void 0) {\n      StickerCreateEvent.encode(message.sticker_create_event, writer.uint32(490).fork()).ldelim();\n    }\n    if (message.sticker_update_event !== void 0) {\n      StickerUpdateEvent.encode(message.sticker_update_event, writer.uint32(498).fork()).ldelim();\n    }\n    if (message.sticker_delete_event !== void 0) {\n      StickerDeleteEvent.encode(message.sticker_delete_event, writer.uint32(506).fork()).ldelim();\n    }\n    if (message.role_event !== void 0) {\n      RoleEvent.encode(message.role_event, writer.uint32(514).fork()).ldelim();\n    }\n    if (message.event_emoji !== void 0) {\n      EventEmoji.encode(message.event_emoji, writer.uint32(522).fork()).ldelim();\n    }\n    if (message.streaming_joined_event !== void 0) {\n      StreamingJoinedEvent.encode(message.streaming_joined_event, writer.uint32(530).fork()).ldelim();\n    }\n    if (message.streaming_leaved_event !== void 0) {\n      StreamingLeavedEvent.encode(message.streaming_leaved_event, writer.uint32(538).fork()).ldelim();\n    }\n    if (message.streaming_started_event !== void 0) {\n      StreamingStartedEvent.encode(message.streaming_started_event, writer.uint32(546).fork()).ldelim();\n    }\n    if (message.streaming_ended_event !== void 0) {\n      StreamingEndedEvent.encode(message.streaming_ended_event, writer.uint32(554).fork()).ldelim();\n    }\n    if (message.all_users_add_channel_event !== void 0) {\n      AllUsersAddChannelEvent.encode(message.all_users_add_channel_event, writer.uint32(562).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEnvelope();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.cid = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel = Channel.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_join = ClanJoin.decode(reader, reader.uint32());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_join = ChannelJoin.decode(reader, reader.uint32());\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_leave = ChannelLeave.decode(reader, reader.uint32());\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.channel_message = ChannelMessage.decode(reader, reader.uint32());\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.channel_message_ack = ChannelMessageAck.decode(reader, reader.uint32());\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.channel_message_send = ChannelMessageSend.decode(reader, reader.uint32());\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_message_update = ChannelMessageUpdate.decode(reader, reader.uint32());\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.channel_message_remove = ChannelMessageRemove.decode(reader, reader.uint32());\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.channel_presence_event = ChannelPresenceEvent.decode(reader, reader.uint32());\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.error = Error2.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.notifications = Notifications.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.rpc = Rpc.decode(reader, reader.uint32());\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.status = Status.decode(reader, reader.uint32());\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.status_follow = StatusFollow.decode(reader, reader.uint32());\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.status_presence_event = StatusPresenceEvent.decode(reader, reader.uint32());\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.status_unfollow = StatusUnfollow.decode(reader, reader.uint32());\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.status_update = StatusUpdate.decode(reader, reader.uint32());\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.stream_data = StreamData.decode(reader, reader.uint32());\n          continue;\n        case 21:\n          if (tag !== 170) {\n            break;\n          }\n          message.stream_presence_event = StreamPresenceEvent.decode(reader, reader.uint32());\n          continue;\n        case 22:\n          if (tag !== 178) {\n            break;\n          }\n          message.ping = Ping.decode(reader, reader.uint32());\n          continue;\n        case 23:\n          if (tag !== 186) {\n            break;\n          }\n          message.pong = Pong.decode(reader, reader.uint32());\n          continue;\n        case 24:\n          if (tag !== 194) {\n            break;\n          }\n          message.message_typing_event = MessageTypingEvent.decode(reader, reader.uint32());\n          continue;\n        case 25:\n          if (tag !== 202) {\n            break;\n          }\n          message.last_seen_message_event = LastSeenMessageEvent.decode(reader, reader.uint32());\n          continue;\n        case 26:\n          if (tag !== 210) {\n            break;\n          }\n          message.message_reaction_event = MessageReaction.decode(reader, reader.uint32());\n          continue;\n        case 27:\n          if (tag !== 218) {\n            break;\n          }\n          message.voice_joined_event = VoiceJoinedEvent.decode(reader, reader.uint32());\n          continue;\n        case 28:\n          if (tag !== 226) {\n            break;\n          }\n          message.voice_leaved_event = VoiceLeavedEvent.decode(reader, reader.uint32());\n          continue;\n        case 29:\n          if (tag !== 234) {\n            break;\n          }\n          message.voice_started_event = VoiceStartedEvent.decode(reader, reader.uint32());\n          continue;\n        case 30:\n          if (tag !== 242) {\n            break;\n          }\n          message.voice_ended_event = VoiceEndedEvent.decode(reader, reader.uint32());\n          continue;\n        case 31:\n          if (tag !== 250) {\n            break;\n          }\n          message.channel_created_event = ChannelCreatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 32:\n          if (tag !== 258) {\n            break;\n          }\n          message.channel_deleted_event = ChannelDeletedEvent.decode(reader, reader.uint32());\n          continue;\n        case 33:\n          if (tag !== 266) {\n            break;\n          }\n          message.channel_updated_event = ChannelUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 34:\n          if (tag !== 274) {\n            break;\n          }\n          message.last_pin_message_event = LastPinMessageEvent.decode(reader, reader.uint32());\n          continue;\n        case 35:\n          if (tag !== 282) {\n            break;\n          }\n          message.custom_status_event = CustomStatusEvent.decode(reader, reader.uint32());\n          continue;\n        case 36:\n          if (tag !== 290) {\n            break;\n          }\n          message.user_channel_added_event = UserChannelAdded.decode(reader, reader.uint32());\n          continue;\n        case 37:\n          if (tag !== 298) {\n            break;\n          }\n          message.user_channel_removed_event = UserChannelRemoved.decode(reader, reader.uint32());\n          continue;\n        case 38:\n          if (tag !== 306) {\n            break;\n          }\n          message.user_clan_removed_event = UserClanRemoved.decode(reader, reader.uint32());\n          continue;\n        case 39:\n          if (tag !== 314) {\n            break;\n          }\n          message.clan_updated_event = ClanUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 40:\n          if (tag !== 322) {\n            break;\n          }\n          message.clan_profile_updated_event = ClanProfileUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 41:\n          if (tag !== 330) {\n            break;\n          }\n          message.check_name_existed_event = CheckNameExistedEvent.decode(reader, reader.uint32());\n          continue;\n        case 42:\n          if (tag !== 338) {\n            break;\n          }\n          message.user_profile_updated_event = UserProfileUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 43:\n          if (tag !== 346) {\n            break;\n          }\n          message.emojis_listed_event = EmojiListedEvent.decode(reader, reader.uint32());\n          continue;\n        case 44:\n          if (tag !== 354) {\n            break;\n          }\n          message.sticker_listed_event = StrickerListedEvent.decode(reader, reader.uint32());\n          continue;\n        case 45:\n          if (tag !== 362) {\n            break;\n          }\n          message.channel_desc_list_event = ChannelDescListEvent.decode(reader, reader.uint32());\n          continue;\n        case 46:\n          if (tag !== 370) {\n            break;\n          }\n          message.hashtag_dm_list_event = HashtagDmListEvent.decode(reader, reader.uint32());\n          continue;\n        case 47:\n          if (tag !== 378) {\n            break;\n          }\n          message.notification_channel_setting_event = NotificationChannelSettingEvent.decode(reader, reader.uint32());\n          continue;\n        case 48:\n          if (tag !== 386) {\n            break;\n          }\n          message.notification_category_setting_event = NotificationCategorySettingEvent.decode(\n            reader,\n            reader.uint32()\n          );\n          continue;\n        case 49:\n          if (tag !== 394) {\n            break;\n          }\n          message.notification_clan_setting_event = NotificationClanSettingEvent.decode(reader, reader.uint32());\n          continue;\n        case 50:\n          if (tag !== 402) {\n            break;\n          }\n          message.notifi_react_message_event = NotifiReactMessageEvent.decode(reader, reader.uint32());\n          continue;\n        case 51:\n          if (tag !== 410) {\n            break;\n          }\n          message.permission_role_channel_list_event = PermissionRoleChannelListEvent.decode(reader, reader.uint32());\n          continue;\n        case 52:\n          if (tag !== 418) {\n            break;\n          }\n          message.notification_channel_category_setting_event = NotificationChannelCategorySettingEvent.decode(\n            reader,\n            reader.uint32()\n          );\n          continue;\n        case 53:\n          if (tag !== 426) {\n            break;\n          }\n          message.add_clan_user_event = AddClanUserEvent.decode(reader, reader.uint32());\n          continue;\n        case 54:\n          if (tag !== 434) {\n            break;\n          }\n          message.all_user_clans = AllUserClans.decode(reader, reader.uint32());\n          continue;\n        case 55:\n          if (tag !== 442) {\n            break;\n          }\n          message.clan_event_created = CreateEventRequest.decode(reader, reader.uint32());\n          continue;\n        case 56:\n          if (tag !== 450) {\n            break;\n          }\n          message.user_permission_in_channel_list_event = UserPermissionInChannelListEvent.decode(\n            reader,\n            reader.uint32()\n          );\n          continue;\n        case 57:\n          if (tag !== 458) {\n            break;\n          }\n          message.role_list_event = RoleListEvent.decode(reader, reader.uint32());\n          continue;\n        case 58:\n          if (tag !== 466) {\n            break;\n          }\n          message.role_assign_event = RoleAssignedEvent.decode(reader, reader.uint32());\n          continue;\n        case 59:\n          if (tag !== 474) {\n            break;\n          }\n          message.clan_deleted_event = ClanDeletedEvent.decode(reader, reader.uint32());\n          continue;\n        case 60:\n          if (tag !== 482) {\n            break;\n          }\n          message.give_coffee_event = GiveCoffeeEvent.decode(reader, reader.uint32());\n          continue;\n        case 61:\n          if (tag !== 490) {\n            break;\n          }\n          message.sticker_create_event = StickerCreateEvent.decode(reader, reader.uint32());\n          continue;\n        case 62:\n          if (tag !== 498) {\n            break;\n          }\n          message.sticker_update_event = StickerUpdateEvent.decode(reader, reader.uint32());\n          continue;\n        case 63:\n          if (tag !== 506) {\n            break;\n          }\n          message.sticker_delete_event = StickerDeleteEvent.decode(reader, reader.uint32());\n          continue;\n        case 64:\n          if (tag !== 514) {\n            break;\n          }\n          message.role_event = RoleEvent.decode(reader, reader.uint32());\n          continue;\n        case 65:\n          if (tag !== 522) {\n            break;\n          }\n          message.event_emoji = EventEmoji.decode(reader, reader.uint32());\n          continue;\n        case 66:\n          if (tag !== 530) {\n            break;\n          }\n          message.streaming_joined_event = StreamingJoinedEvent.decode(reader, reader.uint32());\n          continue;\n        case 67:\n          if (tag !== 538) {\n            break;\n          }\n          message.streaming_leaved_event = StreamingLeavedEvent.decode(reader, reader.uint32());\n          continue;\n        case 68:\n          if (tag !== 546) {\n            break;\n          }\n          message.streaming_started_event = StreamingStartedEvent.decode(reader, reader.uint32());\n          continue;\n        case 69:\n          if (tag !== 554) {\n            break;\n          }\n          message.streaming_ended_event = StreamingEndedEvent.decode(reader, reader.uint32());\n          continue;\n        case 70:\n          if (tag !== 562) {\n            break;\n          }\n          message.all_users_add_channel_event = AllUsersAddChannelEvent.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet4(object.cid) ? globalThis.String(object.cid) : \"\",\n      channel: isSet4(object.channel) ? Channel.fromJSON(object.channel) : void 0,\n      clan_join: isSet4(object.clan_join) ? ClanJoin.fromJSON(object.clan_join) : void 0,\n      channel_join: isSet4(object.channel_join) ? ChannelJoin.fromJSON(object.channel_join) : void 0,\n      channel_leave: isSet4(object.channel_leave) ? ChannelLeave.fromJSON(object.channel_leave) : void 0,\n      channel_message: isSet4(object.channel_message) ? ChannelMessage.fromJSON(object.channel_message) : void 0,\n      channel_message_ack: isSet4(object.channel_message_ack) ? ChannelMessageAck.fromJSON(object.channel_message_ack) : void 0,\n      channel_message_send: isSet4(object.channel_message_send) ? ChannelMessageSend.fromJSON(object.channel_message_send) : void 0,\n      channel_message_update: isSet4(object.channel_message_update) ? ChannelMessageUpdate.fromJSON(object.channel_message_update) : void 0,\n      channel_message_remove: isSet4(object.channel_message_remove) ? ChannelMessageRemove.fromJSON(object.channel_message_remove) : void 0,\n      channel_presence_event: isSet4(object.channel_presence_event) ? ChannelPresenceEvent.fromJSON(object.channel_presence_event) : void 0,\n      error: isSet4(object.error) ? Error2.fromJSON(object.error) : void 0,\n      notifications: isSet4(object.notifications) ? Notifications.fromJSON(object.notifications) : void 0,\n      rpc: isSet4(object.rpc) ? Rpc.fromJSON(object.rpc) : void 0,\n      status: isSet4(object.status) ? Status.fromJSON(object.status) : void 0,\n      status_follow: isSet4(object.status_follow) ? StatusFollow.fromJSON(object.status_follow) : void 0,\n      status_presence_event: isSet4(object.status_presence_event) ? StatusPresenceEvent.fromJSON(object.status_presence_event) : void 0,\n      status_unfollow: isSet4(object.status_unfollow) ? StatusUnfollow.fromJSON(object.status_unfollow) : void 0,\n      status_update: isSet4(object.status_update) ? StatusUpdate.fromJSON(object.status_update) : void 0,\n      stream_data: isSet4(object.stream_data) ? StreamData.fromJSON(object.stream_data) : void 0,\n      stream_presence_event: isSet4(object.stream_presence_event) ? StreamPresenceEvent.fromJSON(object.stream_presence_event) : void 0,\n      ping: isSet4(object.ping) ? Ping.fromJSON(object.ping) : void 0,\n      pong: isSet4(object.pong) ? Pong.fromJSON(object.pong) : void 0,\n      message_typing_event: isSet4(object.message_typing_event) ? MessageTypingEvent.fromJSON(object.message_typing_event) : void 0,\n      last_seen_message_event: isSet4(object.last_seen_message_event) ? LastSeenMessageEvent.fromJSON(object.last_seen_message_event) : void 0,\n      message_reaction_event: isSet4(object.message_reaction_event) ? MessageReaction.fromJSON(object.message_reaction_event) : void 0,\n      voice_joined_event: isSet4(object.voice_joined_event) ? VoiceJoinedEvent.fromJSON(object.voice_joined_event) : void 0,\n      voice_leaved_event: isSet4(object.voice_leaved_event) ? VoiceLeavedEvent.fromJSON(object.voice_leaved_event) : void 0,\n      voice_started_event: isSet4(object.voice_started_event) ? VoiceStartedEvent.fromJSON(object.voice_started_event) : void 0,\n      voice_ended_event: isSet4(object.voice_ended_event) ? VoiceEndedEvent.fromJSON(object.voice_ended_event) : void 0,\n      channel_created_event: isSet4(object.channel_created_event) ? ChannelCreatedEvent.fromJSON(object.channel_created_event) : void 0,\n      channel_deleted_event: isSet4(object.channel_deleted_event) ? ChannelDeletedEvent.fromJSON(object.channel_deleted_event) : void 0,\n      channel_updated_event: isSet4(object.channel_updated_event) ? ChannelUpdatedEvent.fromJSON(object.channel_updated_event) : void 0,\n      last_pin_message_event: isSet4(object.last_pin_message_event) ? LastPinMessageEvent.fromJSON(object.last_pin_message_event) : void 0,\n      custom_status_event: isSet4(object.custom_status_event) ? CustomStatusEvent.fromJSON(object.custom_status_event) : void 0,\n      user_channel_added_event: isSet4(object.user_channel_added_event) ? UserChannelAdded.fromJSON(object.user_channel_added_event) : void 0,\n      user_channel_removed_event: isSet4(object.user_channel_removed_event) ? UserChannelRemoved.fromJSON(object.user_channel_removed_event) : void 0,\n      user_clan_removed_event: isSet4(object.user_clan_removed_event) ? UserClanRemoved.fromJSON(object.user_clan_removed_event) : void 0,\n      clan_updated_event: isSet4(object.clan_updated_event) ? ClanUpdatedEvent.fromJSON(object.clan_updated_event) : void 0,\n      clan_profile_updated_event: isSet4(object.clan_profile_updated_event) ? ClanProfileUpdatedEvent.fromJSON(object.clan_profile_updated_event) : void 0,\n      check_name_existed_event: isSet4(object.check_name_existed_event) ? CheckNameExistedEvent.fromJSON(object.check_name_existed_event) : void 0,\n      user_profile_updated_event: isSet4(object.user_profile_updated_event) ? UserProfileUpdatedEvent.fromJSON(object.user_profile_updated_event) : void 0,\n      emojis_listed_event: isSet4(object.emojis_listed_event) ? EmojiListedEvent.fromJSON(object.emojis_listed_event) : void 0,\n      sticker_listed_event: isSet4(object.sticker_listed_event) ? StrickerListedEvent.fromJSON(object.sticker_listed_event) : void 0,\n      channel_desc_list_event: isSet4(object.channel_desc_list_event) ? ChannelDescListEvent.fromJSON(object.channel_desc_list_event) : void 0,\n      hashtag_dm_list_event: isSet4(object.hashtag_dm_list_event) ? HashtagDmListEvent.fromJSON(object.hashtag_dm_list_event) : void 0,\n      notification_channel_setting_event: isSet4(object.notification_channel_setting_event) ? NotificationChannelSettingEvent.fromJSON(object.notification_channel_setting_event) : void 0,\n      notification_category_setting_event: isSet4(object.notification_category_setting_event) ? NotificationCategorySettingEvent.fromJSON(object.notification_category_setting_event) : void 0,\n      notification_clan_setting_event: isSet4(object.notification_clan_setting_event) ? NotificationClanSettingEvent.fromJSON(object.notification_clan_setting_event) : void 0,\n      notifi_react_message_event: isSet4(object.notifi_react_message_event) ? NotifiReactMessageEvent.fromJSON(object.notifi_react_message_event) : void 0,\n      permission_role_channel_list_event: isSet4(object.permission_role_channel_list_event) ? PermissionRoleChannelListEvent.fromJSON(object.permission_role_channel_list_event) : void 0,\n      notification_channel_category_setting_event: isSet4(object.notification_channel_category_setting_event) ? NotificationChannelCategorySettingEvent.fromJSON(object.notification_channel_category_setting_event) : void 0,\n      add_clan_user_event: isSet4(object.add_clan_user_event) ? AddClanUserEvent.fromJSON(object.add_clan_user_event) : void 0,\n      all_user_clans: isSet4(object.all_user_clans) ? AllUserClans.fromJSON(object.all_user_clans) : void 0,\n      clan_event_created: isSet4(object.clan_event_created) ? CreateEventRequest.fromJSON(object.clan_event_created) : void 0,\n      user_permission_in_channel_list_event: isSet4(object.user_permission_in_channel_list_event) ? UserPermissionInChannelListEvent.fromJSON(object.user_permission_in_channel_list_event) : void 0,\n      role_list_event: isSet4(object.role_list_event) ? RoleListEvent.fromJSON(object.role_list_event) : void 0,\n      role_assign_event: isSet4(object.role_assign_event) ? RoleAssignedEvent.fromJSON(object.role_assign_event) : void 0,\n      clan_deleted_event: isSet4(object.clan_deleted_event) ? ClanDeletedEvent.fromJSON(object.clan_deleted_event) : void 0,\n      give_coffee_event: isSet4(object.give_coffee_event) ? GiveCoffeeEvent.fromJSON(object.give_coffee_event) : void 0,\n      sticker_create_event: isSet4(object.sticker_create_event) ? StickerCreateEvent.fromJSON(object.sticker_create_event) : void 0,\n      sticker_update_event: isSet4(object.sticker_update_event) ? StickerUpdateEvent.fromJSON(object.sticker_update_event) : void 0,\n      sticker_delete_event: isSet4(object.sticker_delete_event) ? StickerDeleteEvent.fromJSON(object.sticker_delete_event) : void 0,\n      role_event: isSet4(object.role_event) ? RoleEvent.fromJSON(object.role_event) : void 0,\n      event_emoji: isSet4(object.event_emoji) ? EventEmoji.fromJSON(object.event_emoji) : void 0,\n      streaming_joined_event: isSet4(object.streaming_joined_event) ? StreamingJoinedEvent.fromJSON(object.streaming_joined_event) : void 0,\n      streaming_leaved_event: isSet4(object.streaming_leaved_event) ? StreamingLeavedEvent.fromJSON(object.streaming_leaved_event) : void 0,\n      streaming_started_event: isSet4(object.streaming_started_event) ? StreamingStartedEvent.fromJSON(object.streaming_started_event) : void 0,\n      streaming_ended_event: isSet4(object.streaming_ended_event) ? StreamingEndedEvent.fromJSON(object.streaming_ended_event) : void 0,\n      all_users_add_channel_event: isSet4(object.all_users_add_channel_event) ? AllUsersAddChannelEvent.fromJSON(object.all_users_add_channel_event) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.cid !== \"\") {\n      obj.cid = message.cid;\n    }\n    if (message.channel !== void 0) {\n      obj.channel = Channel.toJSON(message.channel);\n    }\n    if (message.clan_join !== void 0) {\n      obj.clan_join = ClanJoin.toJSON(message.clan_join);\n    }\n    if (message.channel_join !== void 0) {\n      obj.channel_join = ChannelJoin.toJSON(message.channel_join);\n    }\n    if (message.channel_leave !== void 0) {\n      obj.channel_leave = ChannelLeave.toJSON(message.channel_leave);\n    }\n    if (message.channel_message !== void 0) {\n      obj.channel_message = ChannelMessage.toJSON(message.channel_message);\n    }\n    if (message.channel_message_ack !== void 0) {\n      obj.channel_message_ack = ChannelMessageAck.toJSON(message.channel_message_ack);\n    }\n    if (message.channel_message_send !== void 0) {\n      obj.channel_message_send = ChannelMessageSend.toJSON(message.channel_message_send);\n    }\n    if (message.channel_message_update !== void 0) {\n      obj.channel_message_update = ChannelMessageUpdate.toJSON(message.channel_message_update);\n    }\n    if (message.channel_message_remove !== void 0) {\n      obj.channel_message_remove = ChannelMessageRemove.toJSON(message.channel_message_remove);\n    }\n    if (message.channel_presence_event !== void 0) {\n      obj.channel_presence_event = ChannelPresenceEvent.toJSON(message.channel_presence_event);\n    }\n    if (message.error !== void 0) {\n      obj.error = Error2.toJSON(message.error);\n    }\n    if (message.notifications !== void 0) {\n      obj.notifications = Notifications.toJSON(message.notifications);\n    }\n    if (message.rpc !== void 0) {\n      obj.rpc = Rpc.toJSON(message.rpc);\n    }\n    if (message.status !== void 0) {\n      obj.status = Status.toJSON(message.status);\n    }\n    if (message.status_follow !== void 0) {\n      obj.status_follow = StatusFollow.toJSON(message.status_follow);\n    }\n    if (message.status_presence_event !== void 0) {\n      obj.status_presence_event = StatusPresenceEvent.toJSON(message.status_presence_event);\n    }\n    if (message.status_unfollow !== void 0) {\n      obj.status_unfollow = StatusUnfollow.toJSON(message.status_unfollow);\n    }\n    if (message.status_update !== void 0) {\n      obj.status_update = StatusUpdate.toJSON(message.status_update);\n    }\n    if (message.stream_data !== void 0) {\n      obj.stream_data = StreamData.toJSON(message.stream_data);\n    }\n    if (message.stream_presence_event !== void 0) {\n      obj.stream_presence_event = StreamPresenceEvent.toJSON(message.stream_presence_event);\n    }\n    if (message.ping !== void 0) {\n      obj.ping = Ping.toJSON(message.ping);\n    }\n    if (message.pong !== void 0) {\n      obj.pong = Pong.toJSON(message.pong);\n    }\n    if (message.message_typing_event !== void 0) {\n      obj.message_typing_event = MessageTypingEvent.toJSON(message.message_typing_event);\n    }\n    if (message.last_seen_message_event !== void 0) {\n      obj.last_seen_message_event = LastSeenMessageEvent.toJSON(message.last_seen_message_event);\n    }\n    if (message.message_reaction_event !== void 0) {\n      obj.message_reaction_event = MessageReaction.toJSON(message.message_reaction_event);\n    }\n    if (message.voice_joined_event !== void 0) {\n      obj.voice_joined_event = VoiceJoinedEvent.toJSON(message.voice_joined_event);\n    }\n    if (message.voice_leaved_event !== void 0) {\n      obj.voice_leaved_event = VoiceLeavedEvent.toJSON(message.voice_leaved_event);\n    }\n    if (message.voice_started_event !== void 0) {\n      obj.voice_started_event = VoiceStartedEvent.toJSON(message.voice_started_event);\n    }\n    if (message.voice_ended_event !== void 0) {\n      obj.voice_ended_event = VoiceEndedEvent.toJSON(message.voice_ended_event);\n    }\n    if (message.channel_created_event !== void 0) {\n      obj.channel_created_event = ChannelCreatedEvent.toJSON(message.channel_created_event);\n    }\n    if (message.channel_deleted_event !== void 0) {\n      obj.channel_deleted_event = ChannelDeletedEvent.toJSON(message.channel_deleted_event);\n    }\n    if (message.channel_updated_event !== void 0) {\n      obj.channel_updated_event = ChannelUpdatedEvent.toJSON(message.channel_updated_event);\n    }\n    if (message.last_pin_message_event !== void 0) {\n      obj.last_pin_message_event = LastPinMessageEvent.toJSON(message.last_pin_message_event);\n    }\n    if (message.custom_status_event !== void 0) {\n      obj.custom_status_event = CustomStatusEvent.toJSON(message.custom_status_event);\n    }\n    if (message.user_channel_added_event !== void 0) {\n      obj.user_channel_added_event = UserChannelAdded.toJSON(message.user_channel_added_event);\n    }\n    if (message.user_channel_removed_event !== void 0) {\n      obj.user_channel_removed_event = UserChannelRemoved.toJSON(message.user_channel_removed_event);\n    }\n    if (message.user_clan_removed_event !== void 0) {\n      obj.user_clan_removed_event = UserClanRemoved.toJSON(message.user_clan_removed_event);\n    }\n    if (message.clan_updated_event !== void 0) {\n      obj.clan_updated_event = ClanUpdatedEvent.toJSON(message.clan_updated_event);\n    }\n    if (message.clan_profile_updated_event !== void 0) {\n      obj.clan_profile_updated_event = ClanProfileUpdatedEvent.toJSON(message.clan_profile_updated_event);\n    }\n    if (message.check_name_existed_event !== void 0) {\n      obj.check_name_existed_event = CheckNameExistedEvent.toJSON(message.check_name_existed_event);\n    }\n    if (message.user_profile_updated_event !== void 0) {\n      obj.user_profile_updated_event = UserProfileUpdatedEvent.toJSON(message.user_profile_updated_event);\n    }\n    if (message.emojis_listed_event !== void 0) {\n      obj.emojis_listed_event = EmojiListedEvent.toJSON(message.emojis_listed_event);\n    }\n    if (message.sticker_listed_event !== void 0) {\n      obj.sticker_listed_event = StrickerListedEvent.toJSON(message.sticker_listed_event);\n    }\n    if (message.channel_desc_list_event !== void 0) {\n      obj.channel_desc_list_event = ChannelDescListEvent.toJSON(message.channel_desc_list_event);\n    }\n    if (message.hashtag_dm_list_event !== void 0) {\n      obj.hashtag_dm_list_event = HashtagDmListEvent.toJSON(message.hashtag_dm_list_event);\n    }\n    if (message.notification_channel_setting_event !== void 0) {\n      obj.notification_channel_setting_event = NotificationChannelSettingEvent.toJSON(\n        message.notification_channel_setting_event\n      );\n    }\n    if (message.notification_category_setting_event !== void 0) {\n      obj.notification_category_setting_event = NotificationCategorySettingEvent.toJSON(\n        message.notification_category_setting_event\n      );\n    }\n    if (message.notification_clan_setting_event !== void 0) {\n      obj.notification_clan_setting_event = NotificationClanSettingEvent.toJSON(\n        message.notification_clan_setting_event\n      );\n    }\n    if (message.notifi_react_message_event !== void 0) {\n      obj.notifi_react_message_event = NotifiReactMessageEvent.toJSON(message.notifi_react_message_event);\n    }\n    if (message.permission_role_channel_list_event !== void 0) {\n      obj.permission_role_channel_list_event = PermissionRoleChannelListEvent.toJSON(\n        message.permission_role_channel_list_event\n      );\n    }\n    if (message.notification_channel_category_setting_event !== void 0) {\n      obj.notification_channel_category_setting_event = NotificationChannelCategorySettingEvent.toJSON(\n        message.notification_channel_category_setting_event\n      );\n    }\n    if (message.add_clan_user_event !== void 0) {\n      obj.add_clan_user_event = AddClanUserEvent.toJSON(message.add_clan_user_event);\n    }\n    if (message.all_user_clans !== void 0) {\n      obj.all_user_clans = AllUserClans.toJSON(message.all_user_clans);\n    }\n    if (message.clan_event_created !== void 0) {\n      obj.clan_event_created = CreateEventRequest.toJSON(message.clan_event_created);\n    }\n    if (message.user_permission_in_channel_list_event !== void 0) {\n      obj.user_permission_in_channel_list_event = UserPermissionInChannelListEvent.toJSON(\n        message.user_permission_in_channel_list_event\n      );\n    }\n    if (message.role_list_event !== void 0) {\n      obj.role_list_event = RoleListEvent.toJSON(message.role_list_event);\n    }\n    if (message.role_assign_event !== void 0) {\n      obj.role_assign_event = RoleAssignedEvent.toJSON(message.role_assign_event);\n    }\n    if (message.clan_deleted_event !== void 0) {\n      obj.clan_deleted_event = ClanDeletedEvent.toJSON(message.clan_deleted_event);\n    }\n    if (message.give_coffee_event !== void 0) {\n      obj.give_coffee_event = GiveCoffeeEvent.toJSON(message.give_coffee_event);\n    }\n    if (message.sticker_create_event !== void 0) {\n      obj.sticker_create_event = StickerCreateEvent.toJSON(message.sticker_create_event);\n    }\n    if (message.sticker_update_event !== void 0) {\n      obj.sticker_update_event = StickerUpdateEvent.toJSON(message.sticker_update_event);\n    }\n    if (message.sticker_delete_event !== void 0) {\n      obj.sticker_delete_event = StickerDeleteEvent.toJSON(message.sticker_delete_event);\n    }\n    if (message.role_event !== void 0) {\n      obj.role_event = RoleEvent.toJSON(message.role_event);\n    }\n    if (message.event_emoji !== void 0) {\n      obj.event_emoji = EventEmoji.toJSON(message.event_emoji);\n    }\n    if (message.streaming_joined_event !== void 0) {\n      obj.streaming_joined_event = StreamingJoinedEvent.toJSON(message.streaming_joined_event);\n    }\n    if (message.streaming_leaved_event !== void 0) {\n      obj.streaming_leaved_event = StreamingLeavedEvent.toJSON(message.streaming_leaved_event);\n    }\n    if (message.streaming_started_event !== void 0) {\n      obj.streaming_started_event = StreamingStartedEvent.toJSON(message.streaming_started_event);\n    }\n    if (message.streaming_ended_event !== void 0) {\n      obj.streaming_ended_event = StreamingEndedEvent.toJSON(message.streaming_ended_event);\n    }\n    if (message.all_users_add_channel_event !== void 0) {\n      obj.all_users_add_channel_event = AllUsersAddChannelEvent.toJSON(message.all_users_add_channel_event);\n    }\n    return obj;\n  },\n  create(base) {\n    return Envelope.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseEnvelope();\n    message.cid = (_a = object.cid) != null ? _a : \"\";\n    message.channel = object.channel !== void 0 && object.channel !== null ? Channel.fromPartial(object.channel) : void 0;\n    message.clan_join = object.clan_join !== void 0 && object.clan_join !== null ? ClanJoin.fromPartial(object.clan_join) : void 0;\n    message.channel_join = object.channel_join !== void 0 && object.channel_join !== null ? ChannelJoin.fromPartial(object.channel_join) : void 0;\n    message.channel_leave = object.channel_leave !== void 0 && object.channel_leave !== null ? ChannelLeave.fromPartial(object.channel_leave) : void 0;\n    message.channel_message = object.channel_message !== void 0 && object.channel_message !== null ? ChannelMessage.fromPartial(object.channel_message) : void 0;\n    message.channel_message_ack = object.channel_message_ack !== void 0 && object.channel_message_ack !== null ? ChannelMessageAck.fromPartial(object.channel_message_ack) : void 0;\n    message.channel_message_send = object.channel_message_send !== void 0 && object.channel_message_send !== null ? ChannelMessageSend.fromPartial(object.channel_message_send) : void 0;\n    message.channel_message_update = object.channel_message_update !== void 0 && object.channel_message_update !== null ? ChannelMessageUpdate.fromPartial(object.channel_message_update) : void 0;\n    message.channel_message_remove = object.channel_message_remove !== void 0 && object.channel_message_remove !== null ? ChannelMessageRemove.fromPartial(object.channel_message_remove) : void 0;\n    message.channel_presence_event = object.channel_presence_event !== void 0 && object.channel_presence_event !== null ? ChannelPresenceEvent.fromPartial(object.channel_presence_event) : void 0;\n    message.error = object.error !== void 0 && object.error !== null ? Error2.fromPartial(object.error) : void 0;\n    message.notifications = object.notifications !== void 0 && object.notifications !== null ? Notifications.fromPartial(object.notifications) : void 0;\n    message.rpc = object.rpc !== void 0 && object.rpc !== null ? Rpc.fromPartial(object.rpc) : void 0;\n    message.status = object.status !== void 0 && object.status !== null ? Status.fromPartial(object.status) : void 0;\n    message.status_follow = object.status_follow !== void 0 && object.status_follow !== null ? StatusFollow.fromPartial(object.status_follow) : void 0;\n    message.status_presence_event = object.status_presence_event !== void 0 && object.status_presence_event !== null ? StatusPresenceEvent.fromPartial(object.status_presence_event) : void 0;\n    message.status_unfollow = object.status_unfollow !== void 0 && object.status_unfollow !== null ? StatusUnfollow.fromPartial(object.status_unfollow) : void 0;\n    message.status_update = object.status_update !== void 0 && object.status_update !== null ? StatusUpdate.fromPartial(object.status_update) : void 0;\n    message.stream_data = object.stream_data !== void 0 && object.stream_data !== null ? StreamData.fromPartial(object.stream_data) : void 0;\n    message.stream_presence_event = object.stream_presence_event !== void 0 && object.stream_presence_event !== null ? StreamPresenceEvent.fromPartial(object.stream_presence_event) : void 0;\n    message.ping = object.ping !== void 0 && object.ping !== null ? Ping.fromPartial(object.ping) : void 0;\n    message.pong = object.pong !== void 0 && object.pong !== null ? Pong.fromPartial(object.pong) : void 0;\n    message.message_typing_event = object.message_typing_event !== void 0 && object.message_typing_event !== null ? MessageTypingEvent.fromPartial(object.message_typing_event) : void 0;\n    message.last_seen_message_event = object.last_seen_message_event !== void 0 && object.last_seen_message_event !== null ? LastSeenMessageEvent.fromPartial(object.last_seen_message_event) : void 0;\n    message.message_reaction_event = object.message_reaction_event !== void 0 && object.message_reaction_event !== null ? MessageReaction.fromPartial(object.message_reaction_event) : void 0;\n    message.voice_joined_event = object.voice_joined_event !== void 0 && object.voice_joined_event !== null ? VoiceJoinedEvent.fromPartial(object.voice_joined_event) : void 0;\n    message.voice_leaved_event = object.voice_leaved_event !== void 0 && object.voice_leaved_event !== null ? VoiceLeavedEvent.fromPartial(object.voice_leaved_event) : void 0;\n    message.voice_started_event = object.voice_started_event !== void 0 && object.voice_started_event !== null ? VoiceStartedEvent.fromPartial(object.voice_started_event) : void 0;\n    message.voice_ended_event = object.voice_ended_event !== void 0 && object.voice_ended_event !== null ? VoiceEndedEvent.fromPartial(object.voice_ended_event) : void 0;\n    message.channel_created_event = object.channel_created_event !== void 0 && object.channel_created_event !== null ? ChannelCreatedEvent.fromPartial(object.channel_created_event) : void 0;\n    message.channel_deleted_event = object.channel_deleted_event !== void 0 && object.channel_deleted_event !== null ? ChannelDeletedEvent.fromPartial(object.channel_deleted_event) : void 0;\n    message.channel_updated_event = object.channel_updated_event !== void 0 && object.channel_updated_event !== null ? ChannelUpdatedEvent.fromPartial(object.channel_updated_event) : void 0;\n    message.last_pin_message_event = object.last_pin_message_event !== void 0 && object.last_pin_message_event !== null ? LastPinMessageEvent.fromPartial(object.last_pin_message_event) : void 0;\n    message.custom_status_event = object.custom_status_event !== void 0 && object.custom_status_event !== null ? CustomStatusEvent.fromPartial(object.custom_status_event) : void 0;\n    message.user_channel_added_event = object.user_channel_added_event !== void 0 && object.user_channel_added_event !== null ? UserChannelAdded.fromPartial(object.user_channel_added_event) : void 0;\n    message.user_channel_removed_event = object.user_channel_removed_event !== void 0 && object.user_channel_removed_event !== null ? UserChannelRemoved.fromPartial(object.user_channel_removed_event) : void 0;\n    message.user_clan_removed_event = object.user_clan_removed_event !== void 0 && object.user_clan_removed_event !== null ? UserClanRemoved.fromPartial(object.user_clan_removed_event) : void 0;\n    message.clan_updated_event = object.clan_updated_event !== void 0 && object.clan_updated_event !== null ? ClanUpdatedEvent.fromPartial(object.clan_updated_event) : void 0;\n    message.clan_profile_updated_event = object.clan_profile_updated_event !== void 0 && object.clan_profile_updated_event !== null ? ClanProfileUpdatedEvent.fromPartial(object.clan_profile_updated_event) : void 0;\n    message.check_name_existed_event = object.check_name_existed_event !== void 0 && object.check_name_existed_event !== null ? CheckNameExistedEvent.fromPartial(object.check_name_existed_event) : void 0;\n    message.user_profile_updated_event = object.user_profile_updated_event !== void 0 && object.user_profile_updated_event !== null ? UserProfileUpdatedEvent.fromPartial(object.user_profile_updated_event) : void 0;\n    message.emojis_listed_event = object.emojis_listed_event !== void 0 && object.emojis_listed_event !== null ? EmojiListedEvent.fromPartial(object.emojis_listed_event) : void 0;\n    message.sticker_listed_event = object.sticker_listed_event !== void 0 && object.sticker_listed_event !== null ? StrickerListedEvent.fromPartial(object.sticker_listed_event) : void 0;\n    message.channel_desc_list_event = object.channel_desc_list_event !== void 0 && object.channel_desc_list_event !== null ? ChannelDescListEvent.fromPartial(object.channel_desc_list_event) : void 0;\n    message.hashtag_dm_list_event = object.hashtag_dm_list_event !== void 0 && object.hashtag_dm_list_event !== null ? HashtagDmListEvent.fromPartial(object.hashtag_dm_list_event) : void 0;\n    message.notification_channel_setting_event = object.notification_channel_setting_event !== void 0 && object.notification_channel_setting_event !== null ? NotificationChannelSettingEvent.fromPartial(object.notification_channel_setting_event) : void 0;\n    message.notification_category_setting_event = object.notification_category_setting_event !== void 0 && object.notification_category_setting_event !== null ? NotificationCategorySettingEvent.fromPartial(object.notification_category_setting_event) : void 0;\n    message.notification_clan_setting_event = object.notification_clan_setting_event !== void 0 && object.notification_clan_setting_event !== null ? NotificationClanSettingEvent.fromPartial(object.notification_clan_setting_event) : void 0;\n    message.notifi_react_message_event = object.notifi_react_message_event !== void 0 && object.notifi_react_message_event !== null ? NotifiReactMessageEvent.fromPartial(object.notifi_react_message_event) : void 0;\n    message.permission_role_channel_list_event = object.permission_role_channel_list_event !== void 0 && object.permission_role_channel_list_event !== null ? PermissionRoleChannelListEvent.fromPartial(object.permission_role_channel_list_event) : void 0;\n    message.notification_channel_category_setting_event = object.notification_channel_category_setting_event !== void 0 && object.notification_channel_category_setting_event !== null ? NotificationChannelCategorySettingEvent.fromPartial(object.notification_channel_category_setting_event) : void 0;\n    message.add_clan_user_event = object.add_clan_user_event !== void 0 && object.add_clan_user_event !== null ? AddClanUserEvent.fromPartial(object.add_clan_user_event) : void 0;\n    message.all_user_clans = object.all_user_clans !== void 0 && object.all_user_clans !== null ? AllUserClans.fromPartial(object.all_user_clans) : void 0;\n    message.clan_event_created = object.clan_event_created !== void 0 && object.clan_event_created !== null ? CreateEventRequest.fromPartial(object.clan_event_created) : void 0;\n    message.user_permission_in_channel_list_event = object.user_permission_in_channel_list_event !== void 0 && object.user_permission_in_channel_list_event !== null ? UserPermissionInChannelListEvent.fromPartial(object.user_permission_in_channel_list_event) : void 0;\n    message.role_list_event = object.role_list_event !== void 0 && object.role_list_event !== null ? RoleListEvent.fromPartial(object.role_list_event) : void 0;\n    message.role_assign_event = object.role_assign_event !== void 0 && object.role_assign_event !== null ? RoleAssignedEvent.fromPartial(object.role_assign_event) : void 0;\n    message.clan_deleted_event = object.clan_deleted_event !== void 0 && object.clan_deleted_event !== null ? ClanDeletedEvent.fromPartial(object.clan_deleted_event) : void 0;\n    message.give_coffee_event = object.give_coffee_event !== void 0 && object.give_coffee_event !== null ? GiveCoffeeEvent.fromPartial(object.give_coffee_event) : void 0;\n    message.sticker_create_event = object.sticker_create_event !== void 0 && object.sticker_create_event !== null ? StickerCreateEvent.fromPartial(object.sticker_create_event) : void 0;\n    message.sticker_update_event = object.sticker_update_event !== void 0 && object.sticker_update_event !== null ? StickerUpdateEvent.fromPartial(object.sticker_update_event) : void 0;\n    message.sticker_delete_event = object.sticker_delete_event !== void 0 && object.sticker_delete_event !== null ? StickerDeleteEvent.fromPartial(object.sticker_delete_event) : void 0;\n    message.role_event = object.role_event !== void 0 && object.role_event !== null ? RoleEvent.fromPartial(object.role_event) : void 0;\n    message.event_emoji = object.event_emoji !== void 0 && object.event_emoji !== null ? EventEmoji.fromPartial(object.event_emoji) : void 0;\n    message.streaming_joined_event = object.streaming_joined_event !== void 0 && object.streaming_joined_event !== null ? StreamingJoinedEvent.fromPartial(object.streaming_joined_event) : void 0;\n    message.streaming_leaved_event = object.streaming_leaved_event !== void 0 && object.streaming_leaved_event !== null ? StreamingLeavedEvent.fromPartial(object.streaming_leaved_event) : void 0;\n    message.streaming_started_event = object.streaming_started_event !== void 0 && object.streaming_started_event !== null ? StreamingStartedEvent.fromPartial(object.streaming_started_event) : void 0;\n    message.streaming_ended_event = object.streaming_ended_event !== void 0 && object.streaming_ended_event !== null ? StreamingEndedEvent.fromPartial(object.streaming_ended_event) : void 0;\n    message.all_users_add_channel_event = object.all_users_add_channel_event !== void 0 && object.all_users_add_channel_event !== null ? AllUsersAddChannelEvent.fromPartial(object.all_users_add_channel_event) : void 0;\n    return message;\n  }\n};\nfunction createBaseAllUserClans() {\n  return { user: [] };\n}\nvar AllUserClans = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.user) {\n      User.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAllUserClans();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user.push(User.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { user: globalThis.Array.isArray(object == null ? void 0 : object.user) ? object.user.map((e) => User.fromJSON(e)) : [] };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.user) == null ? void 0 : _a.length) {\n      obj.user = message.user.map((e) => User.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return AllUserClans.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseAllUserClans();\n    message.user = ((_a = object.user) == null ? void 0 : _a.map((e) => User.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseAllUsersAddChannelEvent() {\n  return { channel_id: \"\", user_ids: [], limit: void 0 };\n}\nvar AllUsersAddChannelEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAllUsersAddChannelEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      limit: isSet4(object.limit) ? Number(object.limit) : void 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    return obj;\n  },\n  create(base) {\n    return AllUsersAddChannelEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseAllUsersAddChannelEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    message.limit = (_c = object.limit) != null ? _c : void 0;\n    return message;\n  }\n};\nfunction createBaseAddClanUserEvent() {\n  return { clan_id: \"\", user: void 0 };\n}\nvar AddClanUserEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.user !== void 0) {\n      UserProfileRedis.encode(message.user, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAddClanUserEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user = UserProfileRedis.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      user: isSet4(object.user) ? UserProfileRedis.fromJSON(object.user) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.user !== void 0) {\n      obj.user = UserProfileRedis.toJSON(message.user);\n    }\n    return obj;\n  },\n  create(base) {\n    return AddClanUserEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseAddClanUserEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user = object.user !== void 0 && object.user !== null ? UserProfileRedis.fromPartial(object.user) : void 0;\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannelListEvent() {\n  return { role_id: \"\", channel_id: \"\", permission_role_channel: [], user_id: \"\" };\n}\nvar PermissionRoleChannelListEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.role_id !== \"\") {\n      writer.uint32(10).string(message.role_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    for (const v of message.permission_role_channel) {\n      PermissionRoleChannel.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(34).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannelListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.permission_role_channel.push(PermissionRoleChannel.decode(reader, reader.uint32()));\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_id: isSet4(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      permission_role_channel: globalThis.Array.isArray(object == null ? void 0 : object.permission_role_channel) ? object.permission_role_channel.map((e) => PermissionRoleChannel.fromJSON(e)) : [],\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.permission_role_channel) == null ? void 0 : _a.length) {\n      obj.permission_role_channel = message.permission_role_channel.map((e) => PermissionRoleChannel.toJSON(e));\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannelListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBasePermissionRoleChannelListEvent();\n    message.role_id = (_a = object.role_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.permission_role_channel = ((_c = object.permission_role_channel) == null ? void 0 : _c.map((e) => PermissionRoleChannel.fromPartial(e))) || [];\n    message.user_id = (_d = object.user_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseUserPermissionInChannelListEvent() {\n  return { clan_id: \"\", channel_id: \"\", permissions: void 0 };\n}\nvar UserPermissionInChannelListEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.permissions !== void 0) {\n      PermissionList.encode(message.permissions, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserPermissionInChannelListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.permissions = PermissionList.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      permissions: isSet4(object.permissions) ? PermissionList.fromJSON(object.permissions) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.permissions !== void 0) {\n      obj.permissions = PermissionList.toJSON(message.permissions);\n    }\n    return obj;\n  },\n  create(base) {\n    return UserPermissionInChannelListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserPermissionInChannelListEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.permissions = object.permissions !== void 0 && object.permissions !== null ? PermissionList.fromPartial(object.permissions) : void 0;\n    return message;\n  }\n};\nfunction createBaseRoleListEvent() {\n  return { Limit: 0, State: 0, Cursor: \"\", ClanId: \"\", roles: void 0 };\n}\nvar RoleListEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.Limit !== 0) {\n      writer.uint32(8).int32(message.Limit);\n    }\n    if (message.State !== 0) {\n      writer.uint32(16).int32(message.State);\n    }\n    if (message.Cursor !== \"\") {\n      writer.uint32(26).string(message.Cursor);\n    }\n    if (message.ClanId !== \"\") {\n      writer.uint32(34).string(message.ClanId);\n    }\n    if (message.roles !== void 0) {\n      RoleList.encode(message.roles, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.Limit = reader.int32();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.State = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.Cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.ClanId = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.roles = RoleList.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      Limit: isSet4(object.Limit) ? globalThis.Number(object.Limit) : 0,\n      State: isSet4(object.State) ? globalThis.Number(object.State) : 0,\n      Cursor: isSet4(object.Cursor) ? globalThis.String(object.Cursor) : \"\",\n      ClanId: isSet4(object.ClanId) ? globalThis.String(object.ClanId) : \"\",\n      roles: isSet4(object.roles) ? RoleList.fromJSON(object.roles) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.Limit !== 0) {\n      obj.Limit = Math.round(message.Limit);\n    }\n    if (message.State !== 0) {\n      obj.State = Math.round(message.State);\n    }\n    if (message.Cursor !== \"\") {\n      obj.Cursor = message.Cursor;\n    }\n    if (message.ClanId !== \"\") {\n      obj.ClanId = message.ClanId;\n    }\n    if (message.roles !== void 0) {\n      obj.roles = RoleList.toJSON(message.roles);\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleListEvent();\n    message.Limit = (_a = object.Limit) != null ? _a : 0;\n    message.State = (_b = object.State) != null ? _b : 0;\n    message.Cursor = (_c = object.Cursor) != null ? _c : \"\";\n    message.ClanId = (_d = object.ClanId) != null ? _d : \"\";\n    message.roles = object.roles !== void 0 && object.roles !== null ? RoleList.fromPartial(object.roles) : void 0;\n    return message;\n  }\n};\nfunction createBaseRoleAssignedEvent() {\n  return { ClanId: \"\", role_id: \"\", user_ids_assigned: [], user_ids_removed: [] };\n}\nvar RoleAssignedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.ClanId !== \"\") {\n      writer.uint32(10).string(message.ClanId);\n    }\n    if (message.role_id !== \"\") {\n      writer.uint32(18).string(message.role_id);\n    }\n    for (const v of message.user_ids_assigned) {\n      writer.uint32(26).string(v);\n    }\n    for (const v of message.user_ids_removed) {\n      writer.uint32(34).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleAssignedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.ClanId = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_ids_assigned.push(reader.string());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.user_ids_removed.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      ClanId: isSet4(object.ClanId) ? globalThis.String(object.ClanId) : \"\",\n      role_id: isSet4(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      user_ids_assigned: globalThis.Array.isArray(object == null ? void 0 : object.user_ids_assigned) ? object.user_ids_assigned.map((e) => globalThis.String(e)) : [],\n      user_ids_removed: globalThis.Array.isArray(object == null ? void 0 : object.user_ids_removed) ? object.user_ids_removed.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.ClanId !== \"\") {\n      obj.ClanId = message.ClanId;\n    }\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if ((_a = message.user_ids_assigned) == null ? void 0 : _a.length) {\n      obj.user_ids_assigned = message.user_ids_assigned;\n    }\n    if ((_b = message.user_ids_removed) == null ? void 0 : _b.length) {\n      obj.user_ids_removed = message.user_ids_removed;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleAssignedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleAssignedEvent();\n    message.ClanId = (_a = object.ClanId) != null ? _a : \"\";\n    message.role_id = (_b = object.role_id) != null ? _b : \"\";\n    message.user_ids_assigned = ((_c = object.user_ids_assigned) == null ? void 0 : _c.map((e) => e)) || [];\n    message.user_ids_removed = ((_d = object.user_ids_removed) == null ? void 0 : _d.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannel() {\n  return { permission_id: \"\", active: false };\n}\nvar PermissionRoleChannel = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.permission_id !== \"\") {\n      writer.uint32(10).string(message.permission_id);\n    }\n    if (message.active !== false) {\n      writer.uint32(16).bool(message.active);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.permission_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.active = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      permission_id: isSet4(object.permission_id) ? globalThis.String(object.permission_id) : \"\",\n      active: isSet4(object.active) ? globalThis.Boolean(object.active) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.permission_id !== \"\") {\n      obj.permission_id = message.permission_id;\n    }\n    if (message.active !== false) {\n      obj.active = message.active;\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePermissionRoleChannel();\n    message.permission_id = (_a = object.permission_id) != null ? _a : \"\";\n    message.active = (_b = object.active) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBaseHashtagDmListEvent() {\n  return { user_id: [], limit: void 0, hashtag_dm: void 0 };\n}\nvar HashtagDmListEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.user_id) {\n      writer.uint32(10).string(v);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.hashtag_dm !== void 0) {\n      HashtagDmList.encode(message.hashtag_dm, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDmListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id.push(reader.string());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.hashtag_dm = HashtagDmList.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: globalThis.Array.isArray(object == null ? void 0 : object.user_id) ? object.user_id.map((e) => globalThis.String(e)) : [],\n      limit: isSet4(object.limit) ? Number(object.limit) : void 0,\n      hashtag_dm: isSet4(object.hashtag_dm) ? HashtagDmList.fromJSON(object.hashtag_dm) : void 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.user_id) == null ? void 0 : _a.length) {\n      obj.user_id = message.user_id;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.hashtag_dm !== void 0) {\n      obj.hashtag_dm = HashtagDmList.toJSON(message.hashtag_dm);\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDmListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseHashtagDmListEvent();\n    message.user_id = ((_a = object.user_id) == null ? void 0 : _a.map((e) => e)) || [];\n    message.limit = (_b = object.limit) != null ? _b : void 0;\n    message.hashtag_dm = object.hashtag_dm !== void 0 && object.hashtag_dm !== null ? HashtagDmList.fromPartial(object.hashtag_dm) : void 0;\n    return message;\n  }\n};\nfunction createBaseChannelDescListEvent() {\n  return { channeldesc: void 0 };\n}\nvar ChannelDescListEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channeldesc !== void 0) {\n      ChannelDescList.encode(message.channeldesc, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescListEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channeldesc = ChannelDescList.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { channeldesc: isSet4(object.channeldesc) ? ChannelDescList.fromJSON(object.channeldesc) : void 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channeldesc !== void 0) {\n      obj.channeldesc = ChannelDescList.toJSON(message.channeldesc);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDescListEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    const message = createBaseChannelDescListEvent();\n    message.channeldesc = object.channeldesc !== void 0 && object.channeldesc !== null ? ChannelDescList.fromPartial(object.channeldesc) : void 0;\n    return message;\n  }\n};\nfunction createBaseStrickerListedEvent() {\n  return { stickers: [] };\n}\nvar StrickerListedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.stickers) {\n      ClanSticker.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStrickerListedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.stickers.push(ClanSticker.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stickers: globalThis.Array.isArray(object == null ? void 0 : object.stickers) ? object.stickers.map((e) => ClanSticker.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.stickers) == null ? void 0 : _a.length) {\n      obj.stickers = message.stickers.map((e) => ClanSticker.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return StrickerListedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStrickerListedEvent();\n    message.stickers = ((_a = object.stickers) == null ? void 0 : _a.map((e) => ClanSticker.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseClanSticker() {\n  return {\n    id: \"\",\n    source: \"\",\n    shortname: \"\",\n    category: \"\",\n    creator_id: \"\",\n    create_time: void 0,\n    clan_id: \"\",\n    logo: \"\",\n    clan_name: \"\"\n  };\n}\nvar ClanSticker = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(18).string(message.source);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(58).string(message.clan_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(66).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(74).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanSticker();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.source = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.create_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      source: isSet4(object.source) ? globalThis.String(object.source) : \"\",\n      shortname: isSet4(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      category: isSet4(object.category) ? globalThis.String(object.category) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      create_time: isSet4(object.create_time) ? fromJsonTimestamp2(object.create_time) : void 0,\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.source !== \"\") {\n      obj.source = message.source;\n    }\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanSticker.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseClanSticker();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.source = (_b = object.source) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.clan_id = (_g = object.clan_id) != null ? _g : \"\";\n    message.logo = (_h = object.logo) != null ? _h : \"\";\n    message.clan_name = (_i = object.clan_name) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction createBaseClanEmoji() {\n  return { id: \"\", src: \"\", shortname: \"\", category: \"\", creator_id: \"\", clan_id: \"\", logo: \"\", clan_name: \"\" };\n}\nvar ClanEmoji = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.src !== \"\") {\n      writer.uint32(18).string(message.src);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(58).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(66).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanEmoji();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.src = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      src: isSet4(object.src) ? globalThis.String(object.src) : \"\",\n      shortname: isSet4(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      category: isSet4(object.category) ? globalThis.String(object.category) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.src !== \"\") {\n      obj.src = message.src;\n    }\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanEmoji.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseClanEmoji();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.src = (_b = object.src) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    message.logo = (_g = object.logo) != null ? _g : \"\";\n    message.clan_name = (_h = object.clan_name) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseEmojiListedEvent() {\n  return { clan_id: \"\", emoji_list: [] };\n}\nvar EmojiListedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    for (const v of message.emoji_list) {\n      ClanEmoji.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEmojiListedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.emoji_list.push(ClanEmoji.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      emoji_list: globalThis.Array.isArray(object == null ? void 0 : object.emoji_list) ? object.emoji_list.map((e) => ClanEmoji.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if ((_a = message.emoji_list) == null ? void 0 : _a.length) {\n      obj.emoji_list = message.emoji_list.map((e) => ClanEmoji.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return EmojiListedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseEmojiListedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.emoji_list = ((_b = object.emoji_list) == null ? void 0 : _b.map((e) => ClanEmoji.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseChannel() {\n  return { id: \"\", presences: [], self: void 0, chanel_label: \"\", clan_logo: \"\", category_name: \"\" };\n}\nvar Channel = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    for (const v of message.presences) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.self !== void 0) {\n      UserPresence.encode(message.self, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.chanel_label !== \"\") {\n      writer.uint32(34).string(message.chanel_label);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(42).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(50).string(message.category_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.presences.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.self = UserPresence.decode(reader, reader.uint32());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.chanel_label = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      presences: globalThis.Array.isArray(object == null ? void 0 : object.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : [],\n      self: isSet4(object.self) ? UserPresence.fromJSON(object.self) : void 0,\n      chanel_label: isSet4(object.chanel_label) ? globalThis.String(object.chanel_label) : \"\",\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if ((_a = message.presences) == null ? void 0 : _a.length) {\n      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));\n    }\n    if (message.self !== void 0) {\n      obj.self = UserPresence.toJSON(message.self);\n    }\n    if (message.chanel_label !== \"\") {\n      obj.chanel_label = message.chanel_label;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return Channel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannel();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.presences = ((_b = object.presences) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    message.self = object.self !== void 0 && object.self !== null ? UserPresence.fromPartial(object.self) : void 0;\n    message.chanel_label = (_c = object.chanel_label) != null ? _c : \"\";\n    message.clan_logo = (_d = object.clan_logo) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseClanJoin() {\n  return { clan_id: \"\" };\n}\nvar ClanJoin = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanJoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanJoin.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseClanJoin();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelJoin() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0, parent_id: \"\", is_parent_public: false, is_public: false };\n}\nvar ChannelJoin = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(34).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(40).bool(message.is_parent_public);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(48).bool(message.is_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelJoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelJoin.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseChannelJoin();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    message.parent_id = (_d = object.parent_id) != null ? _d : \"\";\n    message.is_parent_public = (_e = object.is_parent_public) != null ? _e : false;\n    message.is_public = (_f = object.is_public) != null ? _f : false;\n    return message;\n  }\n};\nfunction createBaseChannelLeave() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0, is_public: false };\n}\nvar ChannelLeave = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(32).bool(message.is_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelLeave();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelLeave.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseChannelLeave();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    message.is_public = (_d = object.is_public) != null ? _d : false;\n    return message;\n  }\n};\nfunction createBaseChannelMessageAck() {\n  return {\n    channel_id: \"\",\n    message_id: \"\",\n    code: void 0,\n    username: \"\",\n    create_time: void 0,\n    update_time: void 0,\n    persistent: void 0,\n    clan_logo: \"\",\n    category_name: \"\"\n  };\n}\nvar ChannelMessageAck = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(18).string(message.message_id);\n    }\n    if (message.code !== void 0) {\n      Int32Value.encode({ value: message.code }, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.username !== \"\") {\n      writer.uint32(34).string(message.username);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.create_time), writer.uint32(42).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.update_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.persistent !== void 0) {\n      BoolValue.encode({ value: message.persistent }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(66).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(74).string(message.category_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageAck();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.code = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.create_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.update_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.persistent = BoolValue.decode(reader, reader.uint32()).value;\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      code: isSet4(object.code) ? Number(object.code) : void 0,\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      create_time: isSet4(object.create_time) ? fromJsonTimestamp2(object.create_time) : void 0,\n      update_time: isSet4(object.update_time) ? fromJsonTimestamp2(object.update_time) : void 0,\n      persistent: isSet4(object.persistent) ? Boolean(object.persistent) : void 0,\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.code !== void 0) {\n      obj.code = message.code;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.update_time !== void 0) {\n      obj.update_time = message.update_time.toISOString();\n    }\n    if (message.persistent !== void 0) {\n      obj.persistent = message.persistent;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageAck.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseChannelMessageAck();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.message_id = (_b = object.message_id) != null ? _b : \"\";\n    message.code = (_c = object.code) != null ? _c : void 0;\n    message.username = (_d = object.username) != null ? _d : \"\";\n    message.create_time = (_e = object.create_time) != null ? _e : void 0;\n    message.update_time = (_f = object.update_time) != null ? _f : void 0;\n    message.persistent = (_g = object.persistent) != null ? _g : void 0;\n    message.clan_logo = (_h = object.clan_logo) != null ? _h : \"\";\n    message.category_name = (_i = object.category_name) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelMessageSend() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    content: \"\",\n    mentions: [],\n    attachments: [],\n    references: [],\n    mode: 0,\n    anonymous_message: false,\n    mention_everyone: false,\n    avatar: \"\",\n    is_public: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar ChannelMessageSend = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    for (const v of message.mentions) {\n      MessageMention.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    for (const v of message.attachments) {\n      MessageAttachment.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    for (const v of message.references) {\n      MessageRef.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.mode !== 0) {\n      writer.uint32(56).int32(message.mode);\n    }\n    if (message.anonymous_message !== false) {\n      writer.uint32(64).bool(message.anonymous_message);\n    }\n    if (message.mention_everyone !== false) {\n      writer.uint32(72).bool(message.mention_everyone);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(82).string(message.avatar);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(88).bool(message.is_public);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(98).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(104).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.mentions.push(MessageMention.decode(reader, reader.uint32()));\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.references.push(MessageRef.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.anonymous_message = reader.bool();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.mention_everyone = reader.bool();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 13:\n          if (tag !== 104) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      content: isSet4(object.content) ? globalThis.String(object.content) : \"\",\n      mentions: globalThis.Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => MessageMention.fromJSON(e)) : [],\n      attachments: globalThis.Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => MessageAttachment.fromJSON(e)) : [],\n      references: globalThis.Array.isArray(object == null ? void 0 : object.references) ? object.references.map((e) => MessageRef.fromJSON(e)) : [],\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      anonymous_message: isSet4(object.anonymous_message) ? globalThis.Boolean(object.anonymous_message) : false,\n      mention_everyone: isSet4(object.mention_everyone) ? globalThis.Boolean(object.mention_everyone) : false,\n      avatar: isSet4(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if ((_a = message.mentions) == null ? void 0 : _a.length) {\n      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));\n    }\n    if ((_b = message.attachments) == null ? void 0 : _b.length) {\n      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));\n    }\n    if ((_c = message.references) == null ? void 0 : _c.length) {\n      obj.references = message.references.map((e) => MessageRef.toJSON(e));\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.anonymous_message !== false) {\n      obj.anonymous_message = message.anonymous_message;\n    }\n    if (message.mention_everyone !== false) {\n      obj.mention_everyone = message.mention_everyone;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageSend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;\n    const message = createBaseChannelMessageSend();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.mentions = ((_d = object.mentions) == null ? void 0 : _d.map((e) => MessageMention.fromPartial(e))) || [];\n    message.attachments = ((_e = object.attachments) == null ? void 0 : _e.map((e) => MessageAttachment.fromPartial(e))) || [];\n    message.references = ((_f = object.references) == null ? void 0 : _f.map((e) => MessageRef.fromPartial(e))) || [];\n    message.mode = (_g = object.mode) != null ? _g : 0;\n    message.anonymous_message = (_h = object.anonymous_message) != null ? _h : false;\n    message.mention_everyone = (_i = object.mention_everyone) != null ? _i : false;\n    message.avatar = (_j = object.avatar) != null ? _j : \"\";\n    message.is_public = (_k = object.is_public) != null ? _k : false;\n    message.parent_id = (_l = object.parent_id) != null ? _l : \"\";\n    message.is_parent_public = (_m = object.is_parent_public) != null ? _m : false;\n    return message;\n  }\n};\nfunction createBaseChannelMessageUpdate() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    content: \"\",\n    mentions: [],\n    attachments: [],\n    mode: 0,\n    is_public: false,\n    hide_editted: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar ChannelMessageUpdate = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(34).string(message.content);\n    }\n    for (const v of message.mentions) {\n      MessageMention.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    for (const v of message.attachments) {\n      MessageAttachment.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.mode !== 0) {\n      writer.uint32(56).int32(message.mode);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(64).bool(message.is_public);\n    }\n    if (message.hide_editted !== false) {\n      writer.uint32(72).bool(message.hide_editted);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(82).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(88).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.mentions.push(MessageMention.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.hide_editted = reader.bool();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      content: isSet4(object.content) ? globalThis.String(object.content) : \"\",\n      mentions: globalThis.Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => MessageMention.fromJSON(e)) : [],\n      attachments: globalThis.Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => MessageAttachment.fromJSON(e)) : [],\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      hide_editted: isSet4(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if ((_a = message.mentions) == null ? void 0 : _a.length) {\n      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));\n    }\n    if ((_b = message.attachments) == null ? void 0 : _b.length) {\n      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.hide_editted !== false) {\n      obj.hide_editted = message.hide_editted;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseChannelMessageUpdate();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.content = (_d = object.content) != null ? _d : \"\";\n    message.mentions = ((_e = object.mentions) == null ? void 0 : _e.map((e) => MessageMention.fromPartial(e))) || [];\n    message.attachments = ((_f = object.attachments) == null ? void 0 : _f.map((e) => MessageAttachment.fromPartial(e))) || [];\n    message.mode = (_g = object.mode) != null ? _g : 0;\n    message.is_public = (_h = object.is_public) != null ? _h : false;\n    message.hide_editted = (_i = object.hide_editted) != null ? _i : false;\n    message.parent_id = (_j = object.parent_id) != null ? _j : \"\";\n    message.is_parent_public = (_k = object.is_parent_public) != null ? _k : false;\n    return message;\n  }\n};\nfunction createBaseChannelMessageRemove() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    mode: 0,\n    is_public: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar ChannelMessageRemove = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(40).bool(message.is_public);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(50).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(56).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageRemove();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageRemove.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseChannelMessageRemove();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.is_public = (_e = object.is_public) != null ? _e : false;\n    message.parent_id = (_f = object.parent_id) != null ? _f : \"\";\n    message.is_parent_public = (_g = object.is_parent_public) != null ? _g : false;\n    return message;\n  }\n};\nfunction createBaseChannelPresenceEvent() {\n  return { channel_id: \"\", joins: [], leaves: [], clan_logo: \"\", category_name: \"\", mode: 0 };\n}\nvar ChannelPresenceEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(34).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(42).string(message.category_name);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(48).int32(message.mode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      joins: globalThis.Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: globalThis.Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : [],\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.joins) == null ? void 0 : _a.length) {\n      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));\n    }\n    if ((_b = message.leaves) == null ? void 0 : _b.length) {\n      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseChannelPresenceEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.joins = ((_b = object.joins) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_c = object.leaves) == null ? void 0 : _c.map((e) => UserPresence.fromPartial(e))) || [];\n    message.clan_logo = (_d = object.clan_logo) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    message.mode = (_f = object.mode) != null ? _f : 0;\n    return message;\n  }\n};\nfunction createBaseError() {\n  return { code: 0, message: \"\", context: {} };\n}\nvar Error2 = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).int32(message.code);\n    }\n    if (message.message !== \"\") {\n      writer.uint32(18).string(message.message);\n    }\n    Object.entries(message.context).forEach(([key, value]) => {\n      Error_ContextEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();\n    });\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseError();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.code = reader.int32();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          const entry3 = Error_ContextEntry.decode(reader, reader.uint32());\n          if (entry3.value !== void 0) {\n            message.context[entry3.key] = entry3.value;\n          }\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      code: isSet4(object.code) ? globalThis.Number(object.code) : 0,\n      message: isSet4(object.message) ? globalThis.String(object.message) : \"\",\n      context: isObject(object.context) ? Object.entries(object.context).reduce((acc, [key, value]) => {\n        acc[key] = String(value);\n        return acc;\n      }, {}) : {}\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.code !== 0) {\n      obj.code = Math.round(message.code);\n    }\n    if (message.message !== \"\") {\n      obj.message = message.message;\n    }\n    if (message.context) {\n      const entries = Object.entries(message.context);\n      if (entries.length > 0) {\n        obj.context = {};\n        entries.forEach(([k, v]) => {\n          obj.context[k] = v;\n        });\n      }\n    }\n    return obj;\n  },\n  create(base) {\n    return Error2.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseError();\n    message.code = (_a = object.code) != null ? _a : 0;\n    message.message = (_b = object.message) != null ? _b : \"\";\n    message.context = Object.entries((_c = object.context) != null ? _c : {}).reduce((acc, [key, value]) => {\n      if (value !== void 0) {\n        acc[key] = globalThis.String(value);\n      }\n      return acc;\n    }, {});\n    return message;\n  }\n};\nfunction createBaseError_ContextEntry() {\n  return { key: \"\", value: \"\" };\n}\nvar Error_ContextEntry = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseError_ContextEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.key = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.value = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      key: isSet4(object.key) ? globalThis.String(object.key) : \"\",\n      value: isSet4(object.value) ? globalThis.String(object.value) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.key !== \"\") {\n      obj.key = message.key;\n    }\n    if (message.value !== \"\") {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n  create(base) {\n    return Error_ContextEntry.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseError_ContextEntry();\n    message.key = (_a = object.key) != null ? _a : \"\";\n    message.value = (_b = object.value) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseNotifications() {\n  return { notifications: [] };\n}\nvar Notifications = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.notifications) {\n      Notification.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifications();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.notifications.push(Notification.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      notifications: globalThis.Array.isArray(object == null ? void 0 : object.notifications) ? object.notifications.map((e) => Notification.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.notifications) == null ? void 0 : _a.length) {\n      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return Notifications.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotifications();\n    message.notifications = ((_a = object.notifications) == null ? void 0 : _a.map((e) => Notification.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBasePing() {\n  return {};\n}\nvar Ping = {\n  encode(_, writer = import_minimal5.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePing();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return Ping.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBasePing();\n    return message;\n  }\n};\nfunction createBasePong() {\n  return {};\n}\nvar Pong = {\n  encode(_, writer = import_minimal5.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePong();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return Pong.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBasePong();\n    return message;\n  }\n};\nfunction createBaseStatus() {\n  return { presences: [] };\n}\nvar Status = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.presences) {\n      UserPresence.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatus();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.presences.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      presences: globalThis.Array.isArray(object == null ? void 0 : object.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.presences) == null ? void 0 : _a.length) {\n      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return Status.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatus();\n    message.presences = ((_a = object.presences) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseStatusFollow() {\n  return { user_ids: [], usernames: [] };\n}\nvar StatusFollow = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.user_ids) {\n      writer.uint32(10).string(v);\n    }\n    for (const v of message.usernames) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusFollow();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.usernames.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      usernames: globalThis.Array.isArray(object == null ? void 0 : object.usernames) ? object.usernames.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if ((_b = message.usernames) == null ? void 0 : _b.length) {\n      obj.usernames = message.usernames;\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusFollow.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStatusFollow();\n    message.user_ids = ((_a = object.user_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    message.usernames = ((_b = object.usernames) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseStatusPresenceEvent() {\n  return { joins: [], leaves: [] };\n}\nvar StatusPresenceEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      joins: globalThis.Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: globalThis.Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if ((_a = message.joins) == null ? void 0 : _a.length) {\n      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));\n    }\n    if ((_b = message.leaves) == null ? void 0 : _b.length) {\n      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStatusPresenceEvent();\n    message.joins = ((_a = object.joins) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_b = object.leaves) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseLastPinMessageEvent() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    mode: 0,\n    user_id: \"\",\n    timestamp_seconds: 0,\n    operation: 0,\n    is_public: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar LastPinMessageEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.timestamp_seconds !== 0) {\n      writer.uint32(48).uint32(message.timestamp_seconds);\n    }\n    if (message.operation !== 0) {\n      writer.uint32(56).int32(message.operation);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(64).bool(message.is_public);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(74).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(80).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseLastPinMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.timestamp_seconds = reader.uint32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.operation = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      timestamp_seconds: isSet4(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,\n      operation: isSet4(object.operation) ? globalThis.Number(object.operation) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.timestamp_seconds !== 0) {\n      obj.timestamp_seconds = Math.round(message.timestamp_seconds);\n    }\n    if (message.operation !== 0) {\n      obj.operation = Math.round(message.operation);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return LastPinMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseLastPinMessageEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.timestamp_seconds = (_f = object.timestamp_seconds) != null ? _f : 0;\n    message.operation = (_g = object.operation) != null ? _g : 0;\n    message.is_public = (_h = object.is_public) != null ? _h : false;\n    message.parent_id = (_i = object.parent_id) != null ? _i : \"\";\n    message.is_parent_public = (_j = object.is_parent_public) != null ? _j : false;\n    return message;\n  }\n};\nfunction createBaseLastSeenMessageEvent() {\n  return { clan_id: \"\", channel_id: \"\", message_id: \"\", mode: 0, timestamp_seconds: 0 };\n}\nvar LastSeenMessageEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.timestamp_seconds !== 0) {\n      writer.uint32(40).uint32(message.timestamp_seconds);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseLastSeenMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.timestamp_seconds = reader.uint32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      timestamp_seconds: isSet4(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.timestamp_seconds !== 0) {\n      obj.timestamp_seconds = Math.round(message.timestamp_seconds);\n    }\n    return obj;\n  },\n  create(base) {\n    return LastSeenMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseLastSeenMessageEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.timestamp_seconds = (_e = object.timestamp_seconds) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseMessageTypingEvent() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    sender_id: \"\",\n    mode: 0,\n    is_public: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar MessageTypingEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(26).string(message.sender_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(40).bool(message.is_public);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(50).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(56).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageTypingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      sender_id: isSet4(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageTypingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseMessageTypingEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.sender_id = (_c = object.sender_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.is_public = (_e = object.is_public) != null ? _e : false;\n    message.parent_id = (_f = object.parent_id) != null ? _f : \"\";\n    message.is_parent_public = (_g = object.is_parent_public) != null ? _g : false;\n    return message;\n  }\n};\nfunction createBaseVoiceLeavedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\", voice_user_id: \"\" };\n}\nvar VoiceLeavedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    if (message.voice_user_id !== \"\") {\n      writer.uint32(34).string(message.voice_user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceLeavedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.voice_user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\",\n      voice_user_id: isSet4(object.voice_user_id) ? globalThis.String(object.voice_user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    if (message.voice_user_id !== \"\") {\n      obj.voice_user_id = message.voice_user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceLeavedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseVoiceLeavedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    message.voice_user_id = (_d = object.voice_user_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceJoinedEvent() {\n  return {\n    clan_id: \"\",\n    clan_name: \"\",\n    id: \"\",\n    participant: \"\",\n    user_id: \"\",\n    voice_channel_label: \"\",\n    voice_channel_id: \"\",\n    last_screenshot: \"\"\n  };\n}\nvar VoiceJoinedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.participant !== \"\") {\n      writer.uint32(34).string(message.participant);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.voice_channel_label !== \"\") {\n      writer.uint32(50).string(message.voice_channel_label);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(58).string(message.voice_channel_id);\n    }\n    if (message.last_screenshot !== \"\") {\n      writer.uint32(66).string(message.last_screenshot);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceJoinedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.participant = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.voice_channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.last_screenshot = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      participant: isSet4(object.participant) ? globalThis.String(object.participant) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      voice_channel_label: isSet4(object.voice_channel_label) ? globalThis.String(object.voice_channel_label) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\",\n      last_screenshot: isSet4(object.last_screenshot) ? globalThis.String(object.last_screenshot) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.participant !== \"\") {\n      obj.participant = message.participant;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.voice_channel_label !== \"\") {\n      obj.voice_channel_label = message.voice_channel_label;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    if (message.last_screenshot !== \"\") {\n      obj.last_screenshot = message.last_screenshot;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceJoinedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseVoiceJoinedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.id = (_c = object.id) != null ? _c : \"\";\n    message.participant = (_d = object.participant) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.voice_channel_label = (_f = object.voice_channel_label) != null ? _f : \"\";\n    message.voice_channel_id = (_g = object.voice_channel_id) != null ? _g : \"\";\n    message.last_screenshot = (_h = object.last_screenshot) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceStartedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\n}\nvar VoiceStartedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceStartedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseVoiceStartedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceEndedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\n}\nvar VoiceEndedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceEndedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceEndedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseVoiceEndedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamingLeavedEvent() {\n  return { id: \"\", clan_id: \"\", streaming_channel_id: \"\", streaming_user_id: \"\" };\n}\nvar StreamingLeavedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.streaming_channel_id !== \"\") {\n      writer.uint32(26).string(message.streaming_channel_id);\n    }\n    if (message.streaming_user_id !== \"\") {\n      writer.uint32(34).string(message.streaming_user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingLeavedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.streaming_channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.streaming_user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      streaming_channel_id: isSet4(object.streaming_channel_id) ? globalThis.String(object.streaming_channel_id) : \"\",\n      streaming_user_id: isSet4(object.streaming_user_id) ? globalThis.String(object.streaming_user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.streaming_channel_id !== \"\") {\n      obj.streaming_channel_id = message.streaming_channel_id;\n    }\n    if (message.streaming_user_id !== \"\") {\n      obj.streaming_user_id = message.streaming_user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingLeavedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStreamingLeavedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.streaming_channel_id = (_c = object.streaming_channel_id) != null ? _c : \"\";\n    message.streaming_user_id = (_d = object.streaming_user_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamingJoinedEvent() {\n  return {\n    clan_id: \"\",\n    clan_name: \"\",\n    id: \"\",\n    participant: \"\",\n    user_id: \"\",\n    streaming_channel_label: \"\",\n    streaming_channel_id: \"\"\n  };\n}\nvar StreamingJoinedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.participant !== \"\") {\n      writer.uint32(34).string(message.participant);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.streaming_channel_label !== \"\") {\n      writer.uint32(50).string(message.streaming_channel_label);\n    }\n    if (message.streaming_channel_id !== \"\") {\n      writer.uint32(58).string(message.streaming_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingJoinedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.participant = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.streaming_channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.streaming_channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      participant: isSet4(object.participant) ? globalThis.String(object.participant) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      streaming_channel_label: isSet4(object.streaming_channel_label) ? globalThis.String(object.streaming_channel_label) : \"\",\n      streaming_channel_id: isSet4(object.streaming_channel_id) ? globalThis.String(object.streaming_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.participant !== \"\") {\n      obj.participant = message.participant;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.streaming_channel_label !== \"\") {\n      obj.streaming_channel_label = message.streaming_channel_label;\n    }\n    if (message.streaming_channel_id !== \"\") {\n      obj.streaming_channel_id = message.streaming_channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingJoinedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseStreamingJoinedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.id = (_c = object.id) != null ? _c : \"\";\n    message.participant = (_d = object.participant) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.streaming_channel_label = (_f = object.streaming_channel_label) != null ? _f : \"\";\n    message.streaming_channel_id = (_g = object.streaming_channel_id) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamingStartedEvent() {\n  return { clan_id: \"\", channel_id: \"\", streaming_url: \"\", is_streaming: false };\n}\nvar StreamingStartedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.streaming_url !== \"\") {\n      writer.uint32(26).string(message.streaming_url);\n    }\n    if (message.is_streaming !== false) {\n      writer.uint32(32).bool(message.is_streaming);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.streaming_url = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.is_streaming = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      streaming_url: isSet4(object.streaming_url) ? globalThis.String(object.streaming_url) : \"\",\n      is_streaming: isSet4(object.is_streaming) ? globalThis.Boolean(object.is_streaming) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.streaming_url !== \"\") {\n      obj.streaming_url = message.streaming_url;\n    }\n    if (message.is_streaming !== false) {\n      obj.is_streaming = message.is_streaming;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingStartedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStreamingStartedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.streaming_url = (_c = object.streaming_url) != null ? _c : \"\";\n    message.is_streaming = (_d = object.is_streaming) != null ? _d : false;\n    return message;\n  }\n};\nfunction createBaseStreamingEndedEvent() {\n  return { clan_id: \"\", channel_id: \"\" };\n}\nvar StreamingEndedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingEndedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingEndedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamingEndedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelCreatedEvent() {\n  return {\n    clan_id: \"\",\n    category_id: \"\",\n    creator_id: \"\",\n    parrent_id: \"\",\n    channel_id: \"\",\n    channel_label: \"\",\n    channel_private: 0,\n    channel_type: void 0,\n    status: 0,\n    is_parent_public: false,\n    app_url: \"\"\n  };\n}\nvar ChannelCreatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(26).string(message.creator_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(34).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(50).string(message.channel_label);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.channel_type !== void 0) {\n      Int32Value.encode({ value: message.channel_type }, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(72).int32(message.status);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(80).bool(message.is_parent_public);\n    }\n    if (message.app_url !== \"\") {\n      writer.uint32(90).string(message.app_url);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelCreatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.parrent_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.app_url = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? globalThis.String(object.parrent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      channel_private: isSet4(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : void 0,\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false,\n      app_url: isSet4(object.app_url) ? globalThis.String(object.app_url) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.parrent_id !== \"\") {\n      obj.parrent_id = message.parrent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if (message.channel_type !== void 0) {\n      obj.channel_type = message.channel_type;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    if (message.app_url !== \"\") {\n      obj.app_url = message.app_url;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelCreatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseChannelCreatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.creator_id = (_c = object.creator_id) != null ? _c : \"\";\n    message.parrent_id = (_d = object.parrent_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.channel_label = (_f = object.channel_label) != null ? _f : \"\";\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.channel_type = (_h = object.channel_type) != null ? _h : void 0;\n    message.status = (_i = object.status) != null ? _i : 0;\n    message.is_parent_public = (_j = object.is_parent_public) != null ? _j : false;\n    message.app_url = (_k = object.app_url) != null ? _k : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleEvent() {\n  return { role: void 0, status: 0, user_id: \"\" };\n}\nvar RoleEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.role !== void 0) {\n      Role.encode(message.role, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(16).int32(message.status);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role = Role.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role: isSet4(object.role) ? Role.fromJSON(object.role) : void 0,\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.role !== void 0) {\n      obj.role = Role.toJSON(message.role);\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseRoleEvent();\n    message.role = object.role !== void 0 && object.role !== null ? Role.fromPartial(object.role) : void 0;\n    message.status = (_a = object.status) != null ? _a : 0;\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelDeletedEvent() {\n  return { clan_id: \"\", category_id: \"\", parrent_id: \"\", channel_id: \"\", deletor: \"\" };\n}\nvar ChannelDeletedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(26).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.deletor !== \"\") {\n      writer.uint32(42).string(message.deletor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDeletedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.parrent_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.deletor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? globalThis.String(object.parrent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      deletor: isSet4(object.deletor) ? globalThis.String(object.deletor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.parrent_id !== \"\") {\n      obj.parrent_id = message.parrent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.deletor !== \"\") {\n      obj.deletor = message.deletor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDeletedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannelDeletedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.parrent_id = (_c = object.parrent_id) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.deletor = (_e = object.deletor) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseClanDeletedEvent() {\n  return { clan_id: \"\", deletor: \"\" };\n}\nvar ClanDeletedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.deletor !== \"\") {\n      writer.uint32(18).string(message.deletor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanDeletedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.deletor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      deletor: isSet4(object.deletor) ? globalThis.String(object.deletor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.deletor !== \"\") {\n      obj.deletor = message.deletor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanDeletedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseClanDeletedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.deletor = (_b = object.deletor) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseStickerCreateEvent() {\n  return {\n    clan_id: \"\",\n    source: \"\",\n    shortname: \"\",\n    category: \"\",\n    creator_id: \"\",\n    sticker_id: \"\",\n    logo: \"\",\n    clan_name: \"\"\n  };\n}\nvar StickerCreateEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(18).string(message.source);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.sticker_id !== \"\") {\n      writer.uint32(50).string(message.sticker_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(58).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(66).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerCreateEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.source = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.sticker_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      source: isSet4(object.source) ? globalThis.String(object.source) : \"\",\n      shortname: isSet4(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      category: isSet4(object.category) ? globalThis.String(object.category) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      sticker_id: isSet4(object.sticker_id) ? globalThis.String(object.sticker_id) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.source !== \"\") {\n      obj.source = message.source;\n    }\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.sticker_id !== \"\") {\n      obj.sticker_id = message.sticker_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerCreateEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseStickerCreateEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.source = (_b = object.source) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.sticker_id = (_f = object.sticker_id) != null ? _f : \"\";\n    message.logo = (_g = object.logo) != null ? _g : \"\";\n    message.clan_name = (_h = object.clan_name) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseStickerUpdateEvent() {\n  return { shortname: \"\", sticker_id: \"\", user_id: \"\" };\n}\nvar StickerUpdateEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.shortname !== \"\") {\n      writer.uint32(10).string(message.shortname);\n    }\n    if (message.sticker_id !== \"\") {\n      writer.uint32(18).string(message.sticker_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerUpdateEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sticker_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      shortname: isSet4(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      sticker_id: isSet4(object.sticker_id) ? globalThis.String(object.sticker_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.sticker_id !== \"\") {\n      obj.sticker_id = message.sticker_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerUpdateEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseStickerUpdateEvent();\n    message.shortname = (_a = object.shortname) != null ? _a : \"\";\n    message.sticker_id = (_b = object.sticker_id) != null ? _b : \"\";\n    message.user_id = (_c = object.user_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseStickerDeleteEvent() {\n  return { sticker_id: \"\", user_id: \"\" };\n}\nvar StickerDeleteEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.sticker_id !== \"\") {\n      writer.uint32(18).string(message.sticker_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerDeleteEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sticker_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sticker_id: isSet4(object.sticker_id) ? globalThis.String(object.sticker_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.sticker_id !== \"\") {\n      obj.sticker_id = message.sticker_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerDeleteEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStickerDeleteEvent();\n    message.sticker_id = (_a = object.sticker_id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelUpdatedEvent() {\n  return {\n    clan_id: \"\",\n    category_id: \"\",\n    creator_id: \"\",\n    parrent_id: \"\",\n    channel_id: \"\",\n    channel_label: \"\",\n    channel_type: void 0,\n    status: 0,\n    meeting_code: \"\",\n    is_error: false,\n    channel_private: false,\n    app_url: \"\"\n  };\n}\nvar ChannelUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(26).string(message.creator_id);\n    }\n    if (message.parrent_id !== \"\") {\n      writer.uint32(34).string(message.parrent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(50).string(message.channel_label);\n    }\n    if (message.channel_type !== void 0) {\n      Int32Value.encode({ value: message.channel_type }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(64).int32(message.status);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(74).string(message.meeting_code);\n    }\n    if (message.is_error !== false) {\n      writer.uint32(80).bool(message.is_error);\n    }\n    if (message.channel_private !== false) {\n      writer.uint32(88).bool(message.channel_private);\n    }\n    if (message.app_url !== \"\") {\n      writer.uint32(98).string(message.app_url);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.parrent_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.is_error = reader.bool();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.channel_private = reader.bool();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.app_url = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      parrent_id: isSet4(object.parrent_id) ? globalThis.String(object.parrent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : void 0,\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      meeting_code: isSet4(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      is_error: isSet4(object.is_error) ? globalThis.Boolean(object.is_error) : false,\n      channel_private: isSet4(object.channel_private) ? globalThis.Boolean(object.channel_private) : false,\n      app_url: isSet4(object.app_url) ? globalThis.String(object.app_url) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.parrent_id !== \"\") {\n      obj.parrent_id = message.parrent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.channel_type !== void 0) {\n      obj.channel_type = message.channel_type;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.is_error !== false) {\n      obj.is_error = message.is_error;\n    }\n    if (message.channel_private !== false) {\n      obj.channel_private = message.channel_private;\n    }\n    if (message.app_url !== \"\") {\n      obj.app_url = message.app_url;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n    const message = createBaseChannelUpdatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.creator_id = (_c = object.creator_id) != null ? _c : \"\";\n    message.parrent_id = (_d = object.parrent_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.channel_label = (_f = object.channel_label) != null ? _f : \"\";\n    message.channel_type = (_g = object.channel_type) != null ? _g : void 0;\n    message.status = (_h = object.status) != null ? _h : 0;\n    message.meeting_code = (_i = object.meeting_code) != null ? _i : \"\";\n    message.is_error = (_j = object.is_error) != null ? _j : false;\n    message.channel_private = (_k = object.channel_private) != null ? _k : false;\n    message.app_url = (_l = object.app_url) != null ? _l : \"\";\n    return message;\n  }\n};\nfunction createBaseStatusUnfollow() {\n  return { user_ids: [] };\n}\nvar StatusUnfollow = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.user_ids) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusUnfollow();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusUnfollow.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatusUnfollow();\n    message.user_ids = ((_a = object.user_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseStatusUpdate() {\n  return { status: void 0 };\n}\nvar StatusUpdate = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.status !== void 0) {\n      StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.status = StringValue.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { status: isSet4(object.status) ? String(object.status) : void 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.status !== void 0) {\n      obj.status = message.status;\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatusUpdate();\n    message.status = (_a = object.status) != null ? _a : void 0;\n    return message;\n  }\n};\nfunction createBaseStream() {\n  return { mode: 0, channel_id: \"\", clan_id: \"\", label: \"\" };\n}\nvar Stream = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(34).string(message.label);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStream();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.label = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      label: isSet4(object.label) ? globalThis.String(object.label) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.label !== \"\") {\n      obj.label = message.label;\n    }\n    return obj;\n  },\n  create(base) {\n    return Stream.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStream();\n    message.mode = (_a = object.mode) != null ? _a : 0;\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.label = (_d = object.label) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamData() {\n  return { stream: void 0, sender: void 0, data: \"\", reliable: false };\n}\nvar StreamData = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.stream !== void 0) {\n      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.sender !== void 0) {\n      UserPresence.encode(message.sender, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.data !== \"\") {\n      writer.uint32(26).string(message.data);\n    }\n    if (message.reliable !== false) {\n      writer.uint32(32).bool(message.reliable);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.stream = Stream.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sender = UserPresence.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.data = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.reliable = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stream: isSet4(object.stream) ? Stream.fromJSON(object.stream) : void 0,\n      sender: isSet4(object.sender) ? UserPresence.fromJSON(object.sender) : void 0,\n      data: isSet4(object.data) ? globalThis.String(object.data) : \"\",\n      reliable: isSet4(object.reliable) ? globalThis.Boolean(object.reliable) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.stream !== void 0) {\n      obj.stream = Stream.toJSON(message.stream);\n    }\n    if (message.sender !== void 0) {\n      obj.sender = UserPresence.toJSON(message.sender);\n    }\n    if (message.data !== \"\") {\n      obj.data = message.data;\n    }\n    if (message.reliable !== false) {\n      obj.reliable = message.reliable;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamData.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamData();\n    message.stream = object.stream !== void 0 && object.stream !== null ? Stream.fromPartial(object.stream) : void 0;\n    message.sender = object.sender !== void 0 && object.sender !== null ? UserPresence.fromPartial(object.sender) : void 0;\n    message.data = (_a = object.data) != null ? _a : \"\";\n    message.reliable = (_b = object.reliable) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBaseStreamPresenceEvent() {\n  return { stream: void 0, joins: [], leaves: [] };\n}\nvar StreamPresenceEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.stream !== void 0) {\n      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.stream = Stream.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stream: isSet4(object.stream) ? Stream.fromJSON(object.stream) : void 0,\n      joins: globalThis.Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: globalThis.Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.stream !== void 0) {\n      obj.stream = Stream.toJSON(message.stream);\n    }\n    if ((_a = message.joins) == null ? void 0 : _a.length) {\n      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));\n    }\n    if ((_b = message.leaves) == null ? void 0 : _b.length) {\n      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamPresenceEvent();\n    message.stream = object.stream !== void 0 && object.stream !== null ? Stream.fromPartial(object.stream) : void 0;\n    message.joins = ((_a = object.joins) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_b = object.leaves) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUserPresence() {\n  return { user_id: \"\", session_id: \"\", username: \"\", persistence: false, status: void 0 };\n}\nvar UserPresence = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.session_id !== \"\") {\n      writer.uint32(18).string(message.session_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.persistence !== false) {\n      writer.uint32(32).bool(message.persistence);\n    }\n    if (message.status !== void 0) {\n      StringValue.encode({ value: message.status }, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserPresence();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.session_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.persistence = reader.bool();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.status = StringValue.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      session_id: isSet4(object.session_id) ? globalThis.String(object.session_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      persistence: isSet4(object.persistence) ? globalThis.Boolean(object.persistence) : false,\n      status: isSet4(object.status) ? String(object.status) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.session_id !== \"\") {\n      obj.session_id = message.session_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.persistence !== false) {\n      obj.persistence = message.persistence;\n    }\n    if (message.status !== void 0) {\n      obj.status = message.status;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserPresence.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseUserPresence();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.session_id = (_b = object.session_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.persistence = (_d = object.persistence) != null ? _d : false;\n    message.status = (_e = object.status) != null ? _e : void 0;\n    return message;\n  }\n};\nfunction createBaseCustomStatusEvent() {\n  return { clan_id: \"\", user_id: \"\", username: \"\", status: \"\" };\n}\nvar CustomStatusEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.status !== \"\") {\n      writer.uint32(34).string(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCustomStatusEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.status = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      status: isSet4(object.status) ? globalThis.String(object.status) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.status !== \"\") {\n      obj.status = message.status;\n    }\n    return obj;\n  },\n  create(base) {\n    return CustomStatusEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseCustomStatusEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.status = (_d = object.status) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseUserChannelAdded() {\n  return {\n    channel_id: \"\",\n    users: [],\n    status: \"\",\n    clan_id: \"\",\n    channel_type: 0,\n    is_public: false,\n    parent_id: \"\",\n    is_parent_public: false\n  };\n}\nvar UserChannelAdded = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.users) {\n      UserProfileRedis.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== \"\") {\n      writer.uint32(26).string(message.status);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(40).int32(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(48).bool(message.is_public);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(58).string(message.parent_id);\n    }\n    if (message.is_parent_public !== false) {\n      writer.uint32(64).bool(message.is_parent_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserChannelAdded();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.users.push(UserProfileRedis.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.status = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.is_parent_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      users: globalThis.Array.isArray(object == null ? void 0 : object.users) ? object.users.map((e) => UserProfileRedis.fromJSON(e)) : [],\n      status: isSet4(object.status) ? globalThis.String(object.status) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      is_parent_public: isSet4(object.is_parent_public) ? globalThis.Boolean(object.is_parent_public) : false\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.users) == null ? void 0 : _a.length) {\n      obj.users = message.users.map((e) => UserProfileRedis.toJSON(e));\n    }\n    if (message.status !== \"\") {\n      obj.status = message.status;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.is_parent_public !== false) {\n      obj.is_parent_public = message.is_parent_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserChannelAdded.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseUserChannelAdded();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.users = ((_b = object.users) == null ? void 0 : _b.map((e) => UserProfileRedis.fromPartial(e))) || [];\n    message.status = (_c = object.status) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    message.channel_type = (_e = object.channel_type) != null ? _e : 0;\n    message.is_public = (_f = object.is_public) != null ? _f : false;\n    message.parent_id = (_g = object.parent_id) != null ? _g : \"\";\n    message.is_parent_public = (_h = object.is_parent_public) != null ? _h : false;\n    return message;\n  }\n};\nfunction createBaseUserChannelRemoved() {\n  return { channel_id: \"\", user_ids: [], channel_type: 0 };\n}\nvar UserChannelRemoved = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserChannelRemoved();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    return obj;\n  },\n  create(base) {\n    return UserChannelRemoved.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseUserChannelRemoved();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseUserClanRemoved() {\n  return { clan_id: \"\", user_ids: [] };\n}\nvar UserClanRemoved = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserClanRemoved();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserClanRemoved.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserClanRemoved();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseClanUpdatedEvent() {\n  return { clan_id: \"\", clan_name: \"\", clan_logo: \"\" };\n}\nvar ClanUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(26).string(message.clan_logo);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseClanUpdatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.clan_logo = (_c = object.clan_logo) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseClanProfileUpdatedEvent() {\n  return { user_id: \"\", clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\n}\nvar ClanProfileUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(18).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(26).string(message.clan_avatar);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanProfileUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_nick = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_avatar = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      clan_nick: isSet4(object.clan_nick) ? globalThis.String(object.clan_nick) : \"\",\n      clan_avatar: isSet4(object.clan_avatar) ? globalThis.String(object.clan_avatar) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.clan_nick !== \"\") {\n      obj.clan_nick = message.clan_nick;\n    }\n    if (message.clan_avatar !== \"\") {\n      obj.clan_avatar = message.clan_avatar;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanProfileUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseClanProfileUpdatedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.clan_nick = (_b = object.clan_nick) != null ? _b : \"\";\n    message.clan_avatar = (_c = object.clan_avatar) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseUserProfileUpdatedEvent() {\n  return { user_id: \"\", display_name: \"\", avatar: \"\", about_me: \"\", channel_id: \"\", clan_id: \"\" };\n}\nvar UserProfileUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(18).string(message.display_name);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(26).string(message.avatar);\n    }\n    if (message.about_me !== \"\") {\n      writer.uint32(34).string(message.about_me);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserProfileUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.about_me = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      display_name: isSet4(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      avatar: isSet4(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      about_me: isSet4(object.about_me) ? globalThis.String(object.about_me) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.about_me !== \"\") {\n      obj.about_me = message.about_me;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserProfileUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseUserProfileUpdatedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.display_name = (_b = object.display_name) != null ? _b : \"\";\n    message.avatar = (_c = object.avatar) != null ? _c : \"\";\n    message.about_me = (_d = object.about_me) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseUserProfileRedis() {\n  return {\n    user_id: \"\",\n    username: \"\",\n    avatar: \"\",\n    display_name: \"\",\n    about_me: \"\",\n    custom_status: \"\",\n    create_time_second: 0,\n    fcm_tokens: []\n  };\n}\nvar UserProfileRedis = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(26).string(message.avatar);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(34).string(message.display_name);\n    }\n    if (message.about_me !== \"\") {\n      writer.uint32(42).string(message.about_me);\n    }\n    if (message.custom_status !== \"\") {\n      writer.uint32(50).string(message.custom_status);\n    }\n    if (message.create_time_second !== 0) {\n      writer.uint32(56).uint32(message.create_time_second);\n    }\n    for (const v of message.fcm_tokens) {\n      FCMTokens.encode(v, writer.uint32(66).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserProfileRedis();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.about_me = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.custom_status = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.create_time_second = reader.uint32();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.fcm_tokens.push(FCMTokens.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      avatar: isSet4(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      display_name: isSet4(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      about_me: isSet4(object.about_me) ? globalThis.String(object.about_me) : \"\",\n      custom_status: isSet4(object.custom_status) ? globalThis.String(object.custom_status) : \"\",\n      create_time_second: isSet4(object.create_time_second) ? globalThis.Number(object.create_time_second) : 0,\n      fcm_tokens: globalThis.Array.isArray(object == null ? void 0 : object.fcm_tokens) ? object.fcm_tokens.map((e) => FCMTokens.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.about_me !== \"\") {\n      obj.about_me = message.about_me;\n    }\n    if (message.custom_status !== \"\") {\n      obj.custom_status = message.custom_status;\n    }\n    if (message.create_time_second !== 0) {\n      obj.create_time_second = Math.round(message.create_time_second);\n    }\n    if ((_a = message.fcm_tokens) == null ? void 0 : _a.length) {\n      obj.fcm_tokens = message.fcm_tokens.map((e) => FCMTokens.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return UserProfileRedis.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseUserProfileRedis();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.avatar = (_c = object.avatar) != null ? _c : \"\";\n    message.display_name = (_d = object.display_name) != null ? _d : \"\";\n    message.about_me = (_e = object.about_me) != null ? _e : \"\";\n    message.custom_status = (_f = object.custom_status) != null ? _f : \"\";\n    message.create_time_second = (_g = object.create_time_second) != null ? _g : 0;\n    message.fcm_tokens = ((_h = object.fcm_tokens) == null ? void 0 : _h.map((e) => FCMTokens.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseFCMTokens() {\n  return { device_id: \"\", token_id: \"\" };\n}\nvar FCMTokens = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.device_id !== \"\") {\n      writer.uint32(10).string(message.device_id);\n    }\n    if (message.token_id !== \"\") {\n      writer.uint32(18).string(message.token_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseFCMTokens();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.device_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.token_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      device_id: isSet4(object.device_id) ? globalThis.String(object.device_id) : \"\",\n      token_id: isSet4(object.token_id) ? globalThis.String(object.token_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.device_id !== \"\") {\n      obj.device_id = message.device_id;\n    }\n    if (message.token_id !== \"\") {\n      obj.token_id = message.token_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return FCMTokens.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseFCMTokens();\n    message.device_id = (_a = object.device_id) != null ? _a : \"\";\n    message.token_id = (_b = object.token_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseCheckNameExistedEvent() {\n  return { name: \"\", condition_id: \"\", exist: false, type: 0 };\n}\nvar CheckNameExistedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.condition_id !== \"\") {\n      writer.uint32(18).string(message.condition_id);\n    }\n    if (message.exist !== false) {\n      writer.uint32(24).bool(message.exist);\n    }\n    if (message.type !== 0) {\n      writer.uint32(32).int32(message.type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCheckNameExistedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.name = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.condition_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.exist = reader.bool();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      name: isSet4(object.name) ? globalThis.String(object.name) : \"\",\n      condition_id: isSet4(object.condition_id) ? globalThis.String(object.condition_id) : \"\",\n      exist: isSet4(object.exist) ? globalThis.Boolean(object.exist) : false,\n      type: isSet4(object.type) ? globalThis.Number(object.type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.name !== \"\") {\n      obj.name = message.name;\n    }\n    if (message.condition_id !== \"\") {\n      obj.condition_id = message.condition_id;\n    }\n    if (message.exist !== false) {\n      obj.exist = message.exist;\n    }\n    if (message.type !== 0) {\n      obj.type = Math.round(message.type);\n    }\n    return obj;\n  },\n  create(base) {\n    return CheckNameExistedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseCheckNameExistedEvent();\n    message.name = (_a = object.name) != null ? _a : \"\";\n    message.condition_id = (_b = object.condition_id) != null ? _b : \"\";\n    message.exist = (_c = object.exist) != null ? _c : false;\n    message.type = (_d = object.type) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseNotificationChannelSettingEvent() {\n  return { channel_id: \"\", notification_user_channel: void 0 };\n}\nvar NotificationChannelSettingEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.notification_user_channel !== void 0) {\n      NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelSettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      notification_user_channel: isSet4(object.notification_user_channel) ? NotificationUserChannel.fromJSON(object.notification_user_channel) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.notification_user_channel !== void 0) {\n      obj.notification_user_channel = NotificationUserChannel.toJSON(message.notification_user_channel);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelSettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationChannelSettingEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.notification_user_channel = object.notification_user_channel !== void 0 && object.notification_user_channel !== null ? NotificationUserChannel.fromPartial(object.notification_user_channel) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotificationUserChannel() {\n  return { id: \"\", notification_setting_type: 0, time_mute: void 0, active: 0 };\n}\nvar NotificationUserChannel = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(16).int32(message.notification_setting_type);\n    }\n    if (message.time_mute !== void 0) {\n      Timestamp.encode(toTimestamp2(message.time_mute), writer.uint32(26).fork()).ldelim();\n    }\n    if (message.active !== 0) {\n      writer.uint32(32).int32(message.active);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationUserChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.notification_setting_type = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.time_mute = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      notification_setting_type: isSet4(object.notification_setting_type) ? globalThis.Number(object.notification_setting_type) : 0,\n      time_mute: isSet4(object.time_mute) ? fromJsonTimestamp2(object.time_mute) : void 0,\n      active: isSet4(object.active) ? globalThis.Number(object.active) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.notification_setting_type !== 0) {\n      obj.notification_setting_type = Math.round(message.notification_setting_type);\n    }\n    if (message.time_mute !== void 0) {\n      obj.time_mute = message.time_mute.toISOString();\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationUserChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseNotificationUserChannel();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.notification_setting_type = (_b = object.notification_setting_type) != null ? _b : 0;\n    message.time_mute = (_c = object.time_mute) != null ? _c : void 0;\n    message.active = (_d = object.active) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseNotificationCategorySettingEvent() {\n  return { category_id: \"\", notification_user_channel: void 0 };\n}\nvar NotificationCategorySettingEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.category_id !== \"\") {\n      writer.uint32(10).string(message.category_id);\n    }\n    if (message.notification_user_channel !== void 0) {\n      NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationCategorySettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      notification_user_channel: isSet4(object.notification_user_channel) ? NotificationUserChannel.fromJSON(object.notification_user_channel) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.notification_user_channel !== void 0) {\n      obj.notification_user_channel = NotificationUserChannel.toJSON(message.notification_user_channel);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationCategorySettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationCategorySettingEvent();\n    message.category_id = (_a = object.category_id) != null ? _a : \"\";\n    message.notification_user_channel = object.notification_user_channel !== void 0 && object.notification_user_channel !== null ? NotificationUserChannel.fromPartial(object.notification_user_channel) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotificationClanSettingEvent() {\n  return { clan_id: \"\", notification_setting: void 0 };\n}\nvar NotificationClanSettingEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.notification_setting !== void 0) {\n      NotificationSetting.encode(message.notification_setting, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationClanSettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.notification_setting = NotificationSetting.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      notification_setting: isSet4(object.notification_setting) ? NotificationSetting.fromJSON(object.notification_setting) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.notification_setting !== void 0) {\n      obj.notification_setting = NotificationSetting.toJSON(message.notification_setting);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationClanSettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationClanSettingEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.notification_setting = object.notification_setting !== void 0 && object.notification_setting !== null ? NotificationSetting.fromPartial(object.notification_setting) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotificationSetting() {\n  return { id: \"\", notification_setting_type: 0 };\n}\nvar NotificationSetting = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(16).int32(message.notification_setting_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationSetting();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.notification_setting_type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      notification_setting_type: isSet4(object.notification_setting_type) ? globalThis.Number(object.notification_setting_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.notification_setting_type !== 0) {\n      obj.notification_setting_type = Math.round(message.notification_setting_type);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationSetting.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseNotificationSetting();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.notification_setting_type = (_b = object.notification_setting_type) != null ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseNotifiReactMessageEvent() {\n  return { channel_id: \"\", notifi_react_message: void 0 };\n}\nvar NotifiReactMessageEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.notifi_react_message !== void 0) {\n      NotifiReactMessage.encode(message.notifi_react_message, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifiReactMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.notifi_react_message = NotifiReactMessage.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      notifi_react_message: isSet4(object.notifi_react_message) ? NotifiReactMessage.fromJSON(object.notifi_react_message) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.notifi_react_message !== void 0) {\n      obj.notifi_react_message = NotifiReactMessage.toJSON(message.notifi_react_message);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotifiReactMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotifiReactMessageEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.notifi_react_message = object.notifi_react_message !== void 0 && object.notifi_react_message !== null ? NotifiReactMessage.fromPartial(object.notifi_react_message) : void 0;\n    return message;\n  }\n};\nfunction createBaseNotifiReactMessage() {\n  return { id: \"\", user_id: \"\", channel_id: \"\" };\n}\nvar NotifiReactMessage = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifiReactMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return NotifiReactMessage.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseNotifiReactMessage();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseNotificationChannelCategorySettingEvent() {\n  return { clan_id: \"\", notification_channel_category_settings_list: void 0 };\n}\nvar NotificationChannelCategorySettingEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.notification_channel_category_settings_list !== void 0) {\n      NotificationChannelCategorySettingList.encode(\n        message.notification_channel_category_settings_list,\n        writer.uint32(18).fork()\n      ).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelCategorySettingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.notification_channel_category_settings_list = NotificationChannelCategorySettingList.decode(\n            reader,\n            reader.uint32()\n          );\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      notification_channel_category_settings_list: isSet4(object.notification_channel_category_settings_list) ? NotificationChannelCategorySettingList.fromJSON(object.notification_channel_category_settings_list) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.notification_channel_category_settings_list !== void 0) {\n      obj.notification_channel_category_settings_list = NotificationChannelCategorySettingList.toJSON(\n        message.notification_channel_category_settings_list\n      );\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelCategorySettingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationChannelCategorySettingEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.notification_channel_category_settings_list = object.notification_channel_category_settings_list !== void 0 && object.notification_channel_category_settings_list !== null ? NotificationChannelCategorySettingList.fromPartial(object.notification_channel_category_settings_list) : void 0;\n    return message;\n  }\n};\nfunction createBaseEventEmoji() {\n  return {\n    id: \"\",\n    clan_id: \"\",\n    short_name: \"\",\n    source: \"\",\n    category: \"\",\n    action: 0,\n    user_id: \"\",\n    logo: \"\",\n    clan_name: \"\"\n  };\n}\nvar EventEmoji = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.short_name !== \"\") {\n      writer.uint32(26).string(message.short_name);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(34).string(message.source);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(42).string(message.category);\n    }\n    if (message.action !== 0) {\n      writer.uint32(48).int32(message.action);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(58).string(message.user_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(66).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(74).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEventEmoji();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.short_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.source = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.action = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      short_name: isSet4(object.short_name) ? globalThis.String(object.short_name) : \"\",\n      source: isSet4(object.source) ? globalThis.String(object.source) : \"\",\n      category: isSet4(object.category) ? globalThis.String(object.category) : \"\",\n      action: isSet4(object.action) ? globalThis.Number(object.action) : 0,\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.short_name !== \"\") {\n      obj.short_name = message.short_name;\n    }\n    if (message.source !== \"\") {\n      obj.source = message.source;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.action !== 0) {\n      obj.action = Math.round(message.action);\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return EventEmoji.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseEventEmoji();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.short_name = (_c = object.short_name) != null ? _c : \"\";\n    message.source = (_d = object.source) != null ? _d : \"\";\n    message.category = (_e = object.category) != null ? _e : \"\";\n    message.action = (_f = object.action) != null ? _f : 0;\n    message.user_id = (_g = object.user_id) != null ? _g : \"\";\n    message.logo = (_h = object.logo) != null ? _h : \"\";\n    message.clan_name = (_i = object.clan_name) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction toTimestamp2(date) {\n  const seconds = Math.trunc(date.getTime() / 1e3);\n  const nanos = date.getTime() % 1e3 * 1e6;\n  return { seconds, nanos };\n}\nfunction fromTimestamp2(t) {\n  let millis = (t.seconds || 0) * 1e3;\n  millis += (t.nanos || 0) / 1e6;\n  return new globalThis.Date(millis);\n}\nfunction fromJsonTimestamp2(o) {\n  if (o instanceof globalThis.Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new globalThis.Date(o);\n  } else {\n    return fromTimestamp2(Timestamp.fromJSON(o));\n  }\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction isSet4(value) {\n  return value !== null && value !== void 0;\n}\n\n// web_socket_adapter_pb.ts\nvar WebSocketAdapterPb = class {\n  constructor() {\n  }\n  get onClose() {\n    return this._socket.onclose;\n  }\n  set onClose(value) {\n    this._socket.onclose = value;\n  }\n  get onError() {\n    return this._socket.onerror;\n  }\n  set onError(value) {\n    this._socket.onerror = value;\n  }\n  get onMessage() {\n    return this._socket.onmessage;\n  }\n  set onMessage(value) {\n    if (value) {\n      this._socket.onmessage = (evt) => {\n        const buffer = evt.data;\n        const uintBuffer = new Uint8Array(buffer);\n        const envelope = Envelope.decode(uintBuffer);\n        if (envelope.channel_message) {\n          if (envelope.channel_message.code == void 0) {\n            envelope.channel_message.code = 0;\n          }\n        }\n        value(envelope);\n      };\n    } else {\n      value = null;\n    }\n  }\n  get onOpen() {\n    return this._socket.onopen;\n  }\n  set onOpen(value) {\n    this._socket.onopen = value;\n  }\n  isOpen() {\n    var _a;\n    return ((_a = this._socket) == null ? void 0 : _a.readyState) == WebSocket.OPEN;\n  }\n  close() {\n    var _a;\n    (_a = this._socket) == null ? void 0 : _a.close();\n    this._socket = void 0;\n  }\n  connect(scheme, host, port, createStatus, token, signal) {\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        this.close();\n      });\n    }\n    const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(createStatus.toString())}&token=${encodeURIComponent(token)}&format=protobuf`;\n    this._socket = new WebSocket(url);\n    this._socket.binaryType = \"arraybuffer\";\n  }\n  send(msg) {\n    if (msg.match_data_send) {\n      let payload = msg.match_data_send.data;\n      if (typeof payload == \"string\") {\n        msg.match_data_send.data = new TextEncoder().encode(payload);\n      }\n    } else if (msg.party_data_send) {\n      let payload = msg.party_data_send.data;\n      if (typeof payload == \"string\") {\n        msg.party_data_send.data = new TextEncoder().encode(payload);\n      }\n    }\n    const envelopeWriter = Envelope.encode(Envelope.fromPartial(msg));\n    const encodedMsg = envelopeWriter.finish();\n    this._socket.send(encodedMsg);\n  }\n};\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js?");

/***/ }),

/***/ "./node_modules/mezon-js/dist/mezon-js.cjs.js":
/*!****************************************************!*\
  !*** ./node_modules/mezon-js/dist/mezon-js.cjs.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// index.ts\nvar mezon_js_exports = {};\n__export(mezon_js_exports, {\n  ChannelStreamMode: () => ChannelStreamMode,\n  ChannelType: () => ChannelType,\n  Client: () => Client,\n  DefaultSocket: () => DefaultSocket,\n  NotificationType: () => NotificationType,\n  Session: () => Session,\n  WebSocketAdapterText: () => WebSocketAdapterText\n});\nmodule.exports = __toCommonJS(mezon_js_exports);\n\n// ../../node_modules/whatwg-fetch/fetch.js\nvar g = typeof globalThis !== \"undefined\" && globalThis || typeof self !== \"undefined\" && self || // eslint-disable-next-line no-undef\ntypeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g || {};\nvar support = {\n  searchParams: \"URLSearchParams\" in g,\n  iterable: \"Symbol\" in g && \"iterator\" in Symbol,\n  blob: \"FileReader\" in g && \"Blob\" in g && function() {\n    try {\n      new Blob();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(),\n  formData: \"FormData\" in g,\n  arrayBuffer: \"ArrayBuffer\" in g\n};\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj);\n}\nif (support.arrayBuffer) {\n  viewClasses = [\n    \"[object Int8Array]\",\n    \"[object Uint8Array]\",\n    \"[object Uint8ClampedArray]\",\n    \"[object Int16Array]\",\n    \"[object Uint16Array]\",\n    \"[object Int32Array]\",\n    \"[object Uint32Array]\",\n    \"[object Float32Array]\",\n    \"[object Float64Array]\"\n  ];\n  isArrayBufferView = ArrayBuffer.isView || function(obj) {\n    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n  };\n}\nvar viewClasses;\nvar isArrayBufferView;\nfunction normalizeName(name) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === \"\") {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"');\n  }\n  return name.toLowerCase();\n}\nfunction normalizeValue(value) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift();\n      return { done: value === void 0, value };\n    }\n  };\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator;\n    };\n  }\n  return iterator;\n}\nfunction Headers(headers) {\n  this.map = {};\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value);\n    }, this);\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      if (header.length != 2) {\n        throw new TypeError(\"Headers constructor: expected name/value pair to be length 2, found\" + header.length);\n      }\n      this.append(header[0], header[1]);\n    }, this);\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name]);\n    }, this);\n  }\n}\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name);\n  value = normalizeValue(value);\n  var oldValue = this.map[name];\n  this.map[name] = oldValue ? oldValue + \", \" + value : value;\n};\nHeaders.prototype[\"delete\"] = function(name) {\n  delete this.map[normalizeName(name)];\n};\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name);\n  return this.has(name) ? this.map[name] : null;\n};\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name));\n};\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value);\n};\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this);\n    }\n  }\n};\nHeaders.prototype.keys = function() {\n  var items = [];\n  this.forEach(function(value, name) {\n    items.push(name);\n  });\n  return iteratorFor(items);\n};\nHeaders.prototype.values = function() {\n  var items = [];\n  this.forEach(function(value) {\n    items.push(value);\n  });\n  return iteratorFor(items);\n};\nHeaders.prototype.entries = function() {\n  var items = [];\n  this.forEach(function(value, name) {\n    items.push([name, value]);\n  });\n  return iteratorFor(items);\n};\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n}\nfunction consumed(body) {\n  if (body._noBody)\n    return;\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError(\"Already read\"));\n  }\n  body.bodyUsed = true;\n}\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result);\n    };\n    reader.onerror = function() {\n      reject(reader.error);\n    };\n  });\n}\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  reader.readAsArrayBuffer(blob);\n  return promise;\n}\nfunction readBlobAsText(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);\n  var encoding = match ? match[1] : \"utf-8\";\n  reader.readAsText(blob, encoding);\n  return promise;\n}\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf);\n  var chars2 = new Array(view.length);\n  for (var i = 0; i < view.length; i++) {\n    chars2[i] = String.fromCharCode(view[i]);\n  }\n  return chars2.join(\"\");\n}\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0);\n  } else {\n    var view = new Uint8Array(buf.byteLength);\n    view.set(new Uint8Array(buf));\n    return view.buffer;\n  }\n}\nfunction Body() {\n  this.bodyUsed = false;\n  this._initBody = function(body) {\n    this.bodyUsed = this.bodyUsed;\n    this._bodyInit = body;\n    if (!body) {\n      this._noBody = true;\n      this._bodyText = \"\";\n    } else if (typeof body === \"string\") {\n      this._bodyText = body;\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body;\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body;\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString();\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer);\n      this._bodyInit = new Blob([this._bodyArrayBuffer]);\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body);\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body);\n    }\n    if (!this.headers.get(\"content-type\")) {\n      if (typeof body === \"string\") {\n        this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set(\"content-type\", this._bodyBlob.type);\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n      }\n    }\n  };\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected;\n      }\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob);\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n      } else if (this._bodyFormData) {\n        throw new Error(\"could not read FormData body as blob\");\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]));\n      }\n    };\n  }\n  this.arrayBuffer = function() {\n    if (this._bodyArrayBuffer) {\n      var isConsumed = consumed(this);\n      if (isConsumed) {\n        return isConsumed;\n      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        return Promise.resolve(\n          this._bodyArrayBuffer.buffer.slice(\n            this._bodyArrayBuffer.byteOffset,\n            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n          )\n        );\n      } else {\n        return Promise.resolve(this._bodyArrayBuffer);\n      }\n    } else if (support.blob) {\n      return this.blob().then(readBlobAsArrayBuffer);\n    } else {\n      throw new Error(\"could not read as ArrayBuffer\");\n    }\n  };\n  this.text = function() {\n    var rejected = consumed(this);\n    if (rejected) {\n      return rejected;\n    }\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob);\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n    } else if (this._bodyFormData) {\n      throw new Error(\"could not read FormData body as text\");\n    } else {\n      return Promise.resolve(this._bodyText);\n    }\n  };\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode);\n    };\n  }\n  this.json = function() {\n    return this.text().then(JSON.parse);\n  };\n  return this;\n}\nvar methods = [\"CONNECT\", \"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\", \"TRACE\"];\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase();\n  return methods.indexOf(upcased) > -1 ? upcased : method;\n}\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n  }\n  options = options || {};\n  var body = options.body;\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError(\"Already read\");\n    }\n    this.url = input.url;\n    this.credentials = input.credentials;\n    if (!options.headers) {\n      this.headers = new Headers(input.headers);\n    }\n    this.method = input.method;\n    this.mode = input.mode;\n    this.signal = input.signal;\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit;\n      input.bodyUsed = true;\n    }\n  } else {\n    this.url = String(input);\n  }\n  this.credentials = options.credentials || this.credentials || \"same-origin\";\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers);\n  }\n  this.method = normalizeMethod(options.method || this.method || \"GET\");\n  this.mode = options.mode || this.mode || null;\n  this.signal = options.signal || this.signal || function() {\n    if (\"AbortController\" in g) {\n      var ctrl = new AbortController();\n      return ctrl.signal;\n    }\n  }();\n  this.referrer = null;\n  if ((this.method === \"GET\" || this.method === \"HEAD\") && body) {\n    throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n  }\n  this._initBody(body);\n  if (this.method === \"GET\" || this.method === \"HEAD\") {\n    if (options.cache === \"no-store\" || options.cache === \"no-cache\") {\n      var reParamSearch = /([?&])_=[^&]*/;\n      if (reParamSearch.test(this.url)) {\n        this.url = this.url.replace(reParamSearch, \"$1_=\" + (/* @__PURE__ */ new Date()).getTime());\n      } else {\n        var reQueryString = /\\?/;\n        this.url += (reQueryString.test(this.url) ? \"&\" : \"?\") + \"_=\" + (/* @__PURE__ */ new Date()).getTime();\n      }\n    }\n  }\n}\nRequest.prototype.clone = function() {\n  return new Request(this, { body: this._bodyInit });\n};\nfunction decode(body) {\n  var form = new FormData();\n  body.trim().split(\"&\").forEach(function(bytes) {\n    if (bytes) {\n      var split = bytes.split(\"=\");\n      var name = split.shift().replace(/\\+/g, \" \");\n      var value = split.join(\"=\").replace(/\\+/g, \" \");\n      form.append(decodeURIComponent(name), decodeURIComponent(value));\n    }\n  });\n  return form;\n}\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers();\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \" \");\n  preProcessedHeaders.split(\"\\r\").map(function(header) {\n    return header.indexOf(\"\\n\") === 0 ? header.substr(1, header.length) : header;\n  }).forEach(function(line) {\n    var parts = line.split(\":\");\n    var key = parts.shift().trim();\n    if (key) {\n      var value = parts.join(\":\").trim();\n      try {\n        headers.append(key, value);\n      } catch (error) {\n        console.warn(\"Response \" + error.message);\n      }\n    }\n  });\n  return headers;\n}\nBody.call(Request.prototype);\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n  }\n  if (!options) {\n    options = {};\n  }\n  this.type = \"default\";\n  this.status = options.status === void 0 ? 200 : options.status;\n  if (this.status < 200 || this.status > 599) {\n    throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\");\n  }\n  this.ok = this.status >= 200 && this.status < 300;\n  this.statusText = options.statusText === void 0 ? \"\" : \"\" + options.statusText;\n  this.headers = new Headers(options.headers);\n  this.url = options.url || \"\";\n  this._initBody(bodyInit);\n}\nBody.call(Response.prototype);\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  });\n};\nResponse.error = function() {\n  var response = new Response(null, { status: 200, statusText: \"\" });\n  response.ok = false;\n  response.status = 0;\n  response.type = \"error\";\n  return response;\n};\nvar redirectStatuses = [301, 302, 303, 307, 308];\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError(\"Invalid status code\");\n  }\n  return new Response(null, { status, headers: { location: url } });\n};\nvar DOMException = g.DOMException;\ntry {\n  new DOMException();\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message;\n    this.name = name;\n    var error = Error(message);\n    this.stack = error.stack;\n  };\n  DOMException.prototype = Object.create(Error.prototype);\n  DOMException.prototype.constructor = DOMException;\n}\nfunction fetch2(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init);\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException(\"Aborted\", \"AbortError\"));\n    }\n    var xhr = new XMLHttpRequest();\n    function abortXhr() {\n      xhr.abort();\n    }\n    xhr.onload = function() {\n      var options = {\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || \"\")\n      };\n      if (request.url.indexOf(\"file://\") === 0 && (xhr.status < 200 || xhr.status > 599)) {\n        options.status = 200;\n      } else {\n        options.status = xhr.status;\n      }\n      options.url = \"responseURL\" in xhr ? xhr.responseURL : options.headers.get(\"X-Request-URL\");\n      var body = \"response\" in xhr ? xhr.response : xhr.responseText;\n      setTimeout(function() {\n        resolve(new Response(body, options));\n      }, 0);\n    };\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError(\"Network request failed\"));\n      }, 0);\n    };\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError(\"Network request timed out\"));\n      }, 0);\n    };\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException(\"Aborted\", \"AbortError\"));\n      }, 0);\n    };\n    function fixUrl(url) {\n      try {\n        return url === \"\" && g.location.href ? g.location.href : url;\n      } catch (e) {\n        return url;\n      }\n    }\n    xhr.open(request.method, fixUrl(request.url), true);\n    if (request.credentials === \"include\") {\n      xhr.withCredentials = true;\n    } else if (request.credentials === \"omit\") {\n      xhr.withCredentials = false;\n    }\n    if (\"responseType\" in xhr) {\n      if (support.blob) {\n        xhr.responseType = \"blob\";\n      } else if (support.arrayBuffer) {\n        xhr.responseType = \"arraybuffer\";\n      }\n    }\n    if (init && typeof init.headers === \"object\" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {\n      var names = [];\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        names.push(normalizeName(name));\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n      });\n      request.headers.forEach(function(value, name) {\n        if (names.indexOf(name) === -1) {\n          xhr.setRequestHeader(name, value);\n        }\n      });\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n    }\n    if (request.signal) {\n      request.signal.addEventListener(\"abort\", abortXhr);\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener(\"abort\", abortXhr);\n        }\n      };\n    }\n    xhr.send(typeof request._bodyInit === \"undefined\" ? null : request._bodyInit);\n  });\n}\nfetch2.polyfill = true;\nif (!g.fetch) {\n  g.fetch = fetch2;\n  g.Headers = Headers;\n  g.Request = Request;\n  g.Response = Response;\n}\n\n// ../../node_modules/js-base64/base64.mjs\nvar _hasBuffer = typeof Buffer === \"function\";\nvar _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : void 0;\nvar _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : void 0;\nvar b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar b64chs = Array.prototype.slice.call(b64ch);\nvar b64tab = ((a) => {\n  let tab = {};\n  a.forEach((c, i) => tab[c] = i);\n  return tab;\n})(b64chs);\nvar b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nvar _fromCC = String.fromCharCode.bind(String);\nvar _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nvar _mkUriSafe = (src) => src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0) => m0 == \"+\" ? \"-\" : \"_\");\nvar _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\nvar btoaPolyfill = (bin) => {\n  let u32, c0, c1, c2, asc = \"\";\n  const pad = bin.length % 3;\n  for (let i = 0; i < bin.length; ) {\n    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)\n      throw new TypeError(\"invalid character found\");\n    u32 = c0 << 16 | c1 << 8 | c2;\n    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n  }\n  return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\nvar _btoa = typeof btoa === \"function\" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nvar _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString(\"base64\") : (u8a) => {\n  const maxargs = 4096;\n  let strs = [];\n  for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n  }\n  return _btoa(strs.join(\"\"));\n};\nvar cb_utob = (c) => {\n  if (c.length < 2) {\n    var cc = c.charCodeAt(0);\n    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  } else {\n    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);\n    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  }\n};\nvar re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\nvar utob = (u) => u.replace(re_utob, cb_utob);\nvar _encode = _hasBuffer ? (s) => Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));\nvar encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\nvar atobPolyfill = (asc) => {\n  asc = asc.replace(/\\s+/g, \"\");\n  if (!b64re.test(asc))\n    throw new TypeError(\"malformed base64.\");\n  asc += \"==\".slice(2 - (asc.length & 3));\n  let u24, bin = \"\", r1, r2;\n  for (let i = 0; i < asc.length; ) {\n    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n  }\n  return bin;\n};\nvar _atob = typeof atob === \"function\" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\n\n// utils.ts\nfunction buildFetchOptions(method, options, bodyJson) {\n  const fetchOptions = __spreadValues(__spreadValues({}, { method }), options);\n  fetchOptions.headers = __spreadValues({}, options.headers);\n  if (typeof XMLHttpRequest !== \"undefined\") {\n    const descriptor = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, \"withCredentials\");\n    if (!(descriptor == null ? void 0 : descriptor.set)) {\n      fetchOptions.credentials = \"cocos-ignore\";\n    }\n  }\n  if (!Object.keys(fetchOptions.headers).includes(\"Accept\")) {\n    fetchOptions.headers[\"Accept\"] = \"application/json\";\n  }\n  if (!Object.keys(fetchOptions.headers).includes(\"Content-Type\")) {\n    fetchOptions.headers[\"Content-Type\"] = \"application/json\";\n  }\n  Object.keys(fetchOptions.headers).forEach((key) => {\n    if (!fetchOptions.headers[key]) {\n      delete fetchOptions.headers[key];\n    }\n  });\n  if (bodyJson) {\n    fetchOptions.body = bodyJson;\n  }\n  return fetchOptions;\n}\n\n// api.gen.ts\nvar MezonApi = class {\n  constructor(serverKey, basePath, timeoutMs) {\n    this.serverKey = serverKey;\n    this.basePath = basePath;\n    this.timeoutMs = timeoutMs;\n  }\n  /** A healthcheck which load balancers can use to check the service. */\n  healthcheck(bearerToken, options = {}) {\n    const urlPath = \"/healthcheck\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete the current user's account. */\n  deleteAccount(bearerToken, options = {}) {\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch the current user's account. */\n  getAccount(bearerToken, options = {}) {\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in the current user's account. */\n  updateAccount(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an Apple ID against the server. */\n  authenticateApple(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/apple\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a custom id against the server. */\n  authenticateCustom(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/custom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a device id against the server. */\n  authenticateDevice(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/device\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an email+password against the server. */\n  authenticateEmail(basicAuthUsername, basicAuthPassword, account, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a Facebook OAuth token against the server. */\n  authenticateFacebook(basicAuthUsername, basicAuthPassword, account, create, username, sync, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    queryParams.set(\"sync\", sync);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with a Facebook Instant Game token against the server. */\n  authenticateFacebookInstantGame(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/facebookinstantgame\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Apple's GameCenter against the server. */\n  authenticateGameCenter(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/gamecenter\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Google against the server. */\n  authenticateGoogle(basicAuthUsername, basicAuthPassword, account, create, username, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/google\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Steam against the server. */\n  authenticateSteam(basicAuthUsername, basicAuthPassword, account, create, username, sync, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    queryParams.set(\"sync\", sync);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an Apple ID to the social profiles on the current user's account. */\n  linkApple(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/apple\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a custom ID to the social profiles on the current user's account. */\n  linkCustom(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/custom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a device ID to the social profiles on the current user's account. */\n  linkDevice(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/device\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an email+password to the social profiles on the current user's account. */\n  linkEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Facebook to the social profiles on the current user's account. */\n  linkFacebook(bearerToken, account, sync, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"sync\", sync);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Facebook Instant Game to the social profiles on the current user's account. */\n  linkFacebookInstantGame(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/facebookinstantgame\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Apple's GameCenter to the social profiles on the current user's account. */\n  linkGameCenter(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/gamecenter\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Google to the social profiles on the current user's account. */\n  linkGoogle(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/google\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add Steam to the social profiles on the current user's account. */\n  linkSteam(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an email+password against the server. */\n  registrationEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/registry\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\n  sessionRefresh(basicAuthUsername, basicAuthPassword, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/session/refresh\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the Apple ID from the social profiles on the current user's account. */\n  unlinkApple(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/apple\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the custom ID from the social profiles on the current user's account. */\n  unlinkCustom(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/custom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the device ID from the social profiles on the current user's account. */\n  unlinkDevice(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/device\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the email+password from the social profiles on the current user's account. */\n  unlinkEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Facebook from the social profiles on the current user's account. */\n  unlinkFacebook(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Facebook Instant Game profile from the social profiles on the current user's account. */\n  unlinkFacebookInstantGame(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/facebookinstantgame\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Apple's GameCenter from the social profiles on the current user's account. */\n  unlinkGameCenter(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/gamecenter\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Google from the social profiles on the current user's account. */\n  unlinkGoogle(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/google\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove Steam from the social profiles on the current user's account. */\n  unlinkSteam(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a new apps. */\n  addApp(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/apps/add\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List (and optionally filter) accounts. */\n  listApps(bearerToken, filter, tombstones, cursor, options = {}) {\n    const urlPath = \"/v2/apps/app\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"filter\", filter);\n    queryParams.set(\"tombstones\", tombstones);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an app to clan. */\n  addAppToClan(bearerToken, appId, clanId, options = {}) {\n    if (appId === null || appId === void 0) {\n      throw new Error(\n        \"'appId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/apps/app/{appId}/clan/{clanId}\".replace(\"{appId}\", encodeURIComponent(String(appId))).replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete all information stored for an app. */\n  deleteApp(bearerToken, id, recordDeletion, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"record_deletion\", recordDeletion);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get detailed app information. */\n  getApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update one or more fields on a app. */\n  updateApp(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Ban a app. */\n  banApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}/ban\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Unban an app. */\n  unbanApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}/unban\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateCategoryOrder(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/category/orders\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  listCategoryDescs(bearerToken, clanId, creatorId, categoryName, categoryId, categoryOrder, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/categorydesc/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"creator_id\", creatorId);\n    queryParams.set(\"category_name\", categoryName);\n    queryParams.set(\"category_id\", categoryId);\n    queryParams.set(\"category_order\", categoryOrder);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List channel apps. */\n  listChannelApps(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/channel-apps\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List a channel's message history. */\n  listChannelMessages(bearerToken, clanId, channelId, messageId, direction, limit, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"message_id\", messageId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"direction\", direction);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  addChannelUsers(bearerToken, channelId, userIds, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/add\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all attachment that are part of a channel. */\n  listChannelAttachment(bearerToken, channelId, clanId, fileType, limit, state, cursor, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/attachment\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"file_type\", fileType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Leave a channel the user is a member of. */\n  leaveChannel(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/leave\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Kick a set of users from a channel. */\n  removeChannelUsers(bearerToken, channelId, userIds, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/remove\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listChannelUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/user\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user channels */\n  listChannelDescs(bearerToken, limit, state, cursor, clanId, channelType, options = {}) {\n    const urlPath = \"/v2/channeldesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_type\", channelType);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new channel with the current user as the owner. */\n  createChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channeldesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list user add channel by channel ids */\n  listUsersAddChannelByChannelId(bearerToken, channelId, limit, options = {}) {\n    const urlPath = \"/v2/channeldesc/users/add\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"limit\", limit);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a channel by ID. */\n  deleteChannelDesc(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given channel. */\n  updateChannelDesc(bearerToken, channelId, body, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listChannelVoiceUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/channelvoice\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List clans */\n  listClanDescs(bearerToken, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/clandesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a clan */\n  createClanDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a clan desc by ID. */\n  deleteClanDesc(bearerToken, clanDescId, options = {}) {\n    if (clanDescId === null || clanDescId === void 0) {\n      throw new Error(\n        \"'clanDescId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanDescId}\".replace(\n      \"{clanDescId}\",\n      encodeURIComponent(String(clanDescId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given clan. */\n  updateClanDesc(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Kick a set of users from a clan. */\n  removeClanUsers(bearerToken, clanId, userIds, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanId}/kick\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a clan. */\n  listClanUsers(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanId}/user\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** check duplicate clan name */\n  checkDuplicateClanName(bearerToken, clanName, options = {}) {\n    if (clanName === null || clanName === void 0) {\n      throw new Error(\n        \"'clanName' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanName}\".replace(\n      \"{clanName}\",\n      encodeURIComponent(String(clanName))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get a clan desc profile */\n  getClanDescProfile(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandescprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given clan profile. */\n  updateClanDescProfile(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandescprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  createCategoryDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/createcategory\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteCategoryDesc(bearerToken, categoryId, clanId, options = {}) {\n    if (categoryId === null || categoryId === void 0) {\n      throw new Error(\n        \"'categoryId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/deletecategory/category_id/{categoryId}/clan_id/{clanId}\".replace(\"{categoryId}\", encodeURIComponent(String(categoryId))).replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteCategoryOrder(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/deletecategoryorder/clan_id/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** regist fcm device token */\n  registFCMDeviceToken(bearerToken, token, deviceId, platform, options = {}) {\n    const urlPath = \"/v2/devicetoken\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"token\", token);\n    queryParams.set(\"device_id\", deviceId);\n    queryParams.set(\"platform\", platform);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** close direct message. */\n  closeDirectMess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/direct/close\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** open direct message. */\n  openDirectMess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/direct/open\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Post clan Emoji  /v2/emoji/create */\n  createClanEmoji(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/emoji/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a emoji by ID. */\n  deleteClanEmojiById(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/emoji/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    const body = { clan_id: clanId };\n    let bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update ClanEmoj By id */\n  updateClanEmojiById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/emoji/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get list emoji by user id */\n  getListEmojisByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/emojis\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Search message from elasticsearch service. */\n  searchMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/es/search\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Submit an event for processing in the server's registered runtime custom events handler. */\n  event(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/event\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user events */\n  listEvents(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/eventmanagement\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new event for clan. */\n  createEvent(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given event. */\n  updateEventUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/user\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a event by ID. */\n  deleteEvent(bearerToken, eventId, clanId, options = {}) {\n    if (eventId === null || eventId === void 0) {\n      throw new Error(\n        \"'eventId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/{eventId}\".replace(\n      \"{eventId}\",\n      encodeURIComponent(String(eventId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given event. */\n  updateEvent(bearerToken, eventId, body, options = {}) {\n    if (eventId === null || eventId === void 0) {\n      throw new Error(\n        \"'eventId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/{eventId}\".replace(\n      \"{eventId}\",\n      encodeURIComponent(String(eventId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete one or more users by ID or username. */\n  deleteFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all friends for the current user. */\n  listFriends(bearerToken, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add friends by ID or username to a user's account. */\n  addFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Block one or more users by ID or username. */\n  blockFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend/block\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Import Facebook friends and add them to a user's account. */\n  importFacebookFriends(bearerToken, account, reset, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/friend/facebook\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"reset\", reset);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Import Steam friends and add them to a user's account. */\n  importSteamFriends(bearerToken, account, reset, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\n        \"'account' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/friend/steam\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"reset\", reset);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetChannelCategoryNotiSettingsList */\n  getChannelCategoryNotiSettingsList(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/getChannelCategoryNotiSettingsList\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getUserProfileOnClan(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/getclanprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationChannel */\n  getNotificationCategory(bearerToken, categoryId, options = {}) {\n    const urlPath = \"/v2/getnotificationcategory\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"category_id\", categoryId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationChannel */\n  getNotificationChannel(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/getnotificationchannel\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationClan */\n  getNotificationClan(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/getnotificationclan\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationReactMessage */\n  getNotificationReactMessage(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/getnotificationreactmessage\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Give a coffee */\n  giveMeACoffee(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/givecoffee\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List HashtagDMList */\n  hashtagDMList(bearerToken, userId, limit, options = {}) {\n    const urlPath = \"/v2/hashtagdmlist\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_id\", userId);\n    queryParams.set(\"limit\", limit);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  createLinkInviteUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/invite\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  getLinkInvite(bearerToken, inviteId, options = {}) {\n    if (inviteId === null || inviteId === void 0) {\n      throw new Error(\n        \"'inviteId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/invite/{inviteId}\".replace(\n      \"{inviteId}\",\n      encodeURIComponent(String(inviteId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  inviteUser(bearerToken, inviteId, options = {}) {\n    if (inviteId === null || inviteId === void 0) {\n      throw new Error(\n        \"'inviteId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/invite/{inviteId}\".replace(\n      \"{inviteId}\",\n      encodeURIComponent(String(inviteId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List HashtagDMList */\n  listChannelByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/listchannelbyuserid\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set mute notification user channel. */\n  setMuteNotificationCategory(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/mutenotificationcategory/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set mute notification user channel. */\n  setMuteNotificationChannel(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/mutenotificationchannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete one or more notifications for the current user. */\n  deleteNotifications(bearerToken, ids, options = {}) {\n    const urlPath = \"/v2/notification\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch list of notifications. */\n  listNotifications(bearerToken, clanId, limit, cacheableCursor, options = {}) {\n    const urlPath = \"/v2/notification\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"cacheable_cursor\", cacheableCursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationChannelSetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notificationchannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationClanSetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notificationclan/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationCategorySetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notificationucategory/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotificationCategorySetting(bearerToken, categoryId, options = {}) {\n    const urlPath = \"/v2/notificationusercategory/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"category_id\", categoryId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotificationChannel(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/notificationuserchannel/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotiReactMessage(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/notifireactmessage/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  setNotificationReactMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notifireactmessage/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Ossrs http callback. */\n  streamingServerCallback(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/ossrs/callback\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set permission role channel. */\n  setRoleChannelPermission(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/permissionrolechannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get permission list */\n  getListPermission(bearerToken, options = {}) {\n    const urlPath = \"/v2/permissions\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** GetPermissionByRoleIdChannelId */\n  getPermissionByRoleIdChannelId(bearerToken, roleId, channelId, userId, options = {}) {\n    const urlPath = \"/v2/permissions/roles/channels/users\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"role_id\", roleId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"user_id\", userId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deletePinMessage(bearerToken, messageId, options = {}) {\n    const urlPath = \"/v2/pinmessage/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"message_id\", messageId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getPinMessagesList(bearerToken, messageId, channelId, clanId, options = {}) {\n    const urlPath = \"/v2/pinmessage/get\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"message_id\", messageId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  createPinMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/pinmessage/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  addRolesChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rolechannel/addrole\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update the category of a channel */\n  changeChannelCategory(bearerToken, newCategoryId, body, options = {}) {\n    if (newCategoryId === null || newCategoryId === void 0) {\n      throw new Error(\n        \"'newCategoryId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rolechannel/category/{newCategoryId}\".replace(\n      \"{newCategoryId}\",\n      encodeURIComponent(String(newCategoryId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a role when Delete a role by ID. */\n  deleteRoleChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rolechannel/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** ListRoles */\n  listRoles(bearerToken, clanId, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/roles\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new role for clan. */\n  createRole(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a role when Delete a role by ID. */\n  updateRoleDelete(bearerToken, roleId, body, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/delete/{roleId}\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a role by ID. */\n  deleteRole(bearerToken, roleId, channelId, clanId, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given role. */\n  updateRole(bearerToken, roleId, body, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List role permissions */\n  listRolePermissions(bearerToken, roleId, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}/permissions\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List role permissions */\n  listRoleUsers(bearerToken, roleId, limit, cursor, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}/users\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getRoleOfUserInTheClan(bearerToken, clanId, channelId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roleuserinclan/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Execute a Lua function on the server. */\n  rpcFunc2(bearerToken, basicAuthUsername, basicAuthPassword, id, payload, httpKey, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rpc/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"payload\", payload);\n    queryParams.set(\"http_key\", httpKey);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Execute a Lua function on the server. */\n  rpcFunc(bearerToken, basicAuthUsername, basicAuthPassword, id, payload, httpKey, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (payload === null || payload === void 0) {\n      throw new Error(\n        \"'payload' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rpc/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"http_key\", httpKey);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(payload || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\n  sessionLogout(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/session/logout\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a new sticker */\n  addClanSticker(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/sticker\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a sticker by ID */\n  deleteClanStickerById(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/sticker/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a sticker by ID */\n  updateClanStickerById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/sticker/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get list sticker by user id */\n  getListStickersByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/stickers\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List streaming channels. */\n  listStreamingChannels(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/streaming-channels\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Register streaming in channel ( for bot - get streaming key) */\n  registerStreamingChannel(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/streaming-channels\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listStreamingChannelUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/streaming-channels/users\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get the list of system messages. */\n  getSystemMessagesList(bearerToken, options = {}) {\n    const urlPath = \"/v2/systemmessages\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a system messages. */\n  createSystemMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a specific system messages. */\n  deleteSystemMessage(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get details of a specific system messages. */\n  getSystemMessageByClanId(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a system messages. */\n  updateSystemMessage(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given category. */\n  updateCategory(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/updatecategory/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update channel private. */\n  updateChannelPrivate(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/updatechannelprivate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateUserProfileByClan(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/updateclanprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Upload attachment */\n  uploadAttachmentFile(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/uploadattachmentfile\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch zero or more users by ID and/or username. */\n  getUsers(bearerToken, ids, usernames, facebookIds, options = {}) {\n    const urlPath = \"/v2/user\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    queryParams.set(\"facebook_ids\", facebookIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/user/update\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** ListUserClansByUserId */\n  listUserClansByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/users/clans\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** ListUserPermissionInChannel */\n  listUserPermissionInChannel(bearerToken, clanId, channelId, options = {}) {\n    const urlPath = \"/v2/users/clans/channels\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** create webhook */\n  generateWebhook(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/generate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update webhook name by id */\n  updateWebhookById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/update/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list webhook belong to the channel */\n  listWebhookByChannelId(bearerToken, channelId, clanId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** disabled webhook */\n  deleteWebhookById(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/webhooks/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  buildFullUrl(basePath, fragment, queryParams) {\n    let fullPath = basePath + fragment + \"?\";\n    for (let [k, v] of queryParams) {\n      if (v instanceof Array) {\n        fullPath += v.reduce((prev, curr) => {\n          return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\n        }, \"\");\n      } else {\n        if (v != null) {\n          fullPath += encodeURIComponent(k) + \"=\" + encodeURIComponent(v) + \"&\";\n        }\n      }\n    }\n    return fullPath;\n  }\n};\n\n// session.ts\nvar Session = class _Session {\n  constructor(token, refresh_token, created) {\n    this.created = created;\n    this.token = token;\n    this.refresh_token = refresh_token;\n    this.created_at = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);\n    this.update(token, refresh_token);\n  }\n  isexpired(currenttime) {\n    return this.expires_at - currenttime < 0;\n  }\n  isrefreshexpired(currenttime) {\n    return this.refresh_expires_at - currenttime < 0;\n  }\n  update(token, refreshToken) {\n    const tokenParts = token.split(\".\");\n    if (tokenParts.length != 3) {\n      throw \"jwt is not valid.\";\n    }\n    const tokenDecoded = JSON.parse(_atob(tokenParts[1]));\n    const tokenExpiresAt = Math.floor(parseInt(tokenDecoded[\"exp\"]));\n    if (refreshToken) {\n      const refreshTokenParts = refreshToken.split(\".\");\n      if (refreshTokenParts.length != 3) {\n        throw \"refresh jwt is not valid.\";\n      }\n      const refreshTokenDecoded = JSON.parse(_atob(refreshTokenParts[1]));\n      const refreshTokenExpiresAt = Math.floor(parseInt(refreshTokenDecoded[\"exp\"]));\n      this.refresh_expires_at = refreshTokenExpiresAt;\n      this.refresh_token = refreshToken;\n    }\n    this.token = token;\n    this.expires_at = tokenExpiresAt;\n    this.username = tokenDecoded[\"usn\"];\n    this.user_id = tokenDecoded[\"uid\"];\n    this.vars = tokenDecoded[\"vrs\"];\n  }\n  static restore(token, refreshToken) {\n    return new _Session(token, refreshToken, false);\n  }\n};\n\n// ../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\nvar i;\nvar encode2 = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n  for (i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nvar decode2 = function(base64) {\n  var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\n\n// web_socket_adapter.ts\nvar WebSocketAdapterText = class {\n  get onClose() {\n    return this._socket.onclose;\n  }\n  set onClose(value) {\n    this._socket.onclose = value;\n  }\n  get onError() {\n    return this._socket.onerror;\n  }\n  set onError(value) {\n    this._socket.onerror = value;\n  }\n  get onMessage() {\n    return this._socket.onmessage;\n  }\n  set onMessage(value) {\n    if (value) {\n      this._socket.onmessage = (evt) => {\n        const message = JSON.parse(evt.data);\n        if (message.party_data && message.party_data.data) {\n          message.party_data.data = new Uint8Array(decode2(message.party_data.data));\n        }\n        value(message);\n      };\n    } else {\n      value = null;\n    }\n  }\n  get onOpen() {\n    return this._socket.onopen;\n  }\n  set onOpen(value) {\n    this._socket.onopen = value;\n  }\n  isOpen() {\n    var _a;\n    return ((_a = this._socket) == null ? void 0 : _a.readyState) == WebSocket.OPEN;\n  }\n  connect(scheme, host, port, createStatus, token, signal) {\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        this.close();\n      });\n    }\n    const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(createStatus.toString())}&token=${encodeURIComponent(token)}`;\n    this._socket = new WebSocket(url);\n  }\n  close() {\n    var _a;\n    (_a = this._socket) == null ? void 0 : _a.close();\n    this._socket = void 0;\n  }\n  send(msg) {\n    if (msg.party_data_send) {\n      msg.party_data_send.op_code = msg.party_data_send.op_code.toString();\n      let payload = msg.party_data_send.data;\n      if (payload && payload instanceof Uint8Array) {\n        msg.party_data_send.data = encode2(payload.buffer);\n      } else if (payload) {\n        msg.party_data_send.data = _btoa(payload);\n      }\n    }\n    this._socket.send(JSON.stringify(msg));\n  }\n};\n\n// socket.ts\nvar _DefaultSocket = class _DefaultSocket {\n  constructor(host, port, useSSL = false, verbose = false, adapter = new WebSocketAdapterText(), sendTimeoutMs = _DefaultSocket.DefaultSendTimeoutMs) {\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    this.verbose = verbose;\n    this.adapter = adapter;\n    this.sendTimeoutMs = sendTimeoutMs;\n    this.cIds = {};\n    this.nextCid = 1;\n    this._heartbeatTimeoutMs = _DefaultSocket.DefaultHeartbeatTimeoutMs;\n  }\n  generatecid() {\n    const cid = this.nextCid.toString();\n    ++this.nextCid;\n    return cid;\n  }\n  isOpen() {\n    return this.adapter.isOpen();\n  }\n  connect(session, createStatus = false, connectTimeoutMs = _DefaultSocket.DefaultConnectTimeoutMs, signal) {\n    if (this.adapter.isOpen()) {\n      return Promise.resolve(session);\n    }\n    const scheme = this.useSSL ? \"wss://\" : \"ws://\";\n    this.adapter.connect(scheme, this.host, this.port, createStatus, session.token, signal);\n    this.adapter.onClose = (evt) => {\n      this.ondisconnect(evt);\n    };\n    this.adapter.onError = (evt) => {\n      this.onerror(evt);\n    };\n    this.adapter.onMessage = (message) => {\n      if (this.verbose && window && window.console) {\n        console.log(\"Response: %o\", JSON.stringify(message));\n      }\n      if (!message.cid) {\n        if (message.notifications) {\n          message.notifications.notifications.forEach((n) => {\n            n.content = n.content ? JSON.parse(n.content) : void 0;\n            this.onnotification(n);\n          });\n        } else if (message.voice_started_event) {\n          this.onvoicestarted(message.voice_started_event);\n        } else if (message.voice_ended_event) {\n          this.onvoiceended(message.voice_ended_event);\n        } else if (message.voice_joined_event) {\n          this.onvoicejoined(message.voice_joined_event);\n        } else if (message.voice_leaved_event) {\n          this.onvoiceleaved(message.voice_leaved_event);\n        } else if (message.channel_created_event) {\n          this.onchannelcreated(message.channel_created_event);\n        } else if (message.role_event) {\n          this.onroleevent(message.role_event);\n        } else if (message.event_emoji) {\n          this.oneventemoji(message.event_emoji);\n        } else if (message.channel_deleted_event) {\n          this.onchanneldeleted(message.channel_deleted_event);\n        } else if (message.clan_deleted_event) {\n          this.onclandeleted(message.clan_deleted_event);\n        } else if (message.sticker_create_event) {\n          this.onstickercreated(message.sticker_create_event);\n        } else if (message.sticker_update_event) {\n          this.onstickerupdated(message.sticker_update_event);\n        } else if (message.sticker_delete_event) {\n          this.onstickerdeleted(message.sticker_delete_event);\n        } else if (message.channel_updated_event) {\n          this.onchannelupdated(message.channel_updated_event);\n        } else if (message.clan_profile_updated_event) {\n          this.onclanprofileupdated(message.clan_profile_updated_event);\n        } else if (message.clan_updated_event) {\n          this.onclanupdated(message.clan_updated_event);\n        } else if (message.last_seen_message_event) {\n          this.onlastseenupdated(message.last_seen_message_event);\n        } else if (message.status_presence_event) {\n          this.onstatuspresence(message.status_presence_event);\n        } else if (message.stream_presence_event) {\n          this.onstreampresence(message.stream_presence_event);\n        } else if (message.stream_data) {\n          this.onstreamdata(message.stream_data);\n        } else if (message.channel_message) {\n          var content, reactions, mentions, attachments, references;\n          try {\n            content = JSON.parse(message.channel_message.content);\n          } catch (e2) {\n          }\n          try {\n            reactions = JSON.parse(message.channel_message.reactions);\n          } catch (e2) {\n          }\n          try {\n            mentions = JSON.parse(message.channel_message.mentions);\n          } catch (e2) {\n          }\n          try {\n            attachments = JSON.parse(message.channel_message.attachments);\n          } catch (e2) {\n          }\n          try {\n            references = JSON.parse(message.channel_message.references);\n          } catch (e2) {\n          }\n          var e = {\n            id: message.id || message.channel_message.message_id,\n            avatar: message.channel_message.avatar,\n            channel_id: message.channel_message.channel_id,\n            mode: message.channel_message.mode,\n            channel_label: message.channel_message.channel_label,\n            clan_id: message.channel_message.clan_id,\n            code: message.channel_message.code,\n            create_time: message.channel_message.create_time,\n            message_id: message.channel_message.message_id,\n            sender_id: message.channel_message.sender_id,\n            update_time: message.channel_message.update_time,\n            clan_logo: message.channel_message.clan_logo,\n            category_name: message.channel_message.category_name,\n            username: message.channel_message.username,\n            clan_nick: message.channel_message.clan_nick,\n            clan_avatar: message.channel_message.clan_avatar,\n            display_name: message.channel_message.display_name,\n            content,\n            reactions,\n            mentions,\n            attachments,\n            references,\n            hide_editted: message.channel_message.hide_editted,\n            is_public: message.channel_message.is_public\n          };\n          this.onchannelmessage(e);\n        } else if (message.message_typing_event) {\n          this.onmessagetyping(message.message_typing_event);\n        } else if (message.message_reaction_event) {\n          this.onmessagereaction(message.message_reaction_event);\n        } else if (message.channel_presence_event) {\n          this.onchannelpresence(message.channel_presence_event);\n        } else if (message.last_pin_message_event) {\n          this.onpinmessage(message.last_pin_message_event);\n        } else if (message.custom_status_event) {\n          this.oncustomstatus(message.custom_status_event);\n        } else if (message.user_channel_added_event) {\n          this.onuserchanneladded(message.user_channel_added_event);\n        } else if (message.add_clan_user_event) {\n          this.onuserclanadded(message.add_clan_user_event);\n        } else if (message.user_profile_updated_event) {\n          this.onuserprofileupdate(message.user_profile_updated_event);\n        } else if (message.user_channel_removed_event) {\n          this.onuserchannelremoved(message.user_channel_removed_event);\n        } else if (message.user_clan_removed_event) {\n          this.onuserclanremoved(message.user_clan_removed_event);\n        } else if (message.clan_event_created) {\n          this.oneventcreated(message.clan_event_created);\n        } else if (message.give_coffee_event) {\n          this.oncoffeegiven(message.give_coffee_event);\n        } else if (message.role_assign_event) {\n          this.onroleassign(message.role_assign_event);\n        } else if (message.streaming_started_event) {\n          this.onstreamingchannelstarted(message.streaming_started_event);\n        } else if (message.streaming_ended_event) {\n          this.onstreamingchannelended(message.streaming_ended_event);\n        } else if (message.streaming_joined_event) {\n          this.onstreamingchanneljoined(message.streaming_joined_event);\n        } else if (message.streaming_leaved_event) {\n          this.onstreamingchannelleaved(message.streaming_leaved_event);\n        } else if (message.set_permission_channel_event) {\n          this.onsetpermissionchannel(message.set_permission_channel_event);\n        } else {\n          if (this.verbose && window && window.console) {\n            console.log(\"Unrecognized message received: %o\", message);\n          }\n        }\n      } else {\n        const executor = this.cIds[message.cid];\n        if (!executor) {\n          if (this.verbose && window && window.console) {\n            console.error(\"No promise executor for message: %o\", message);\n          }\n          return;\n        }\n        delete this.cIds[message.cid];\n        if (message.error) {\n          executor.reject(message.error);\n        } else {\n          executor.resolve(message);\n        }\n      }\n    };\n    return new Promise((resolve, reject) => {\n      this.adapter.onOpen = (evt) => {\n        if (this.verbose && window && window.console) {\n          console.log(evt);\n        }\n        this.pingPong();\n        resolve(session);\n      };\n      this.adapter.onError = (evt) => {\n        reject(evt);\n        this.adapter.close();\n      };\n      setTimeout(() => {\n        reject(\"The socket timed out when trying to connect.\");\n      }, connectTimeoutMs);\n    });\n  }\n  disconnect(fireDisconnectEvent = true) {\n    if (this.adapter.isOpen()) {\n      this.adapter.close();\n    }\n    if (fireDisconnectEvent) {\n      this.ondisconnect({});\n    }\n  }\n  setHeartbeatTimeoutMs(ms) {\n    this._heartbeatTimeoutMs = ms;\n  }\n  getHeartbeatTimeoutMs() {\n    return this._heartbeatTimeoutMs;\n  }\n  ondisconnect(evt) {\n    if (this.verbose && window && window.console) {\n      console.log(evt);\n    }\n  }\n  onerror(evt) {\n    if (this.verbose && window && window.console) {\n      console.log(evt);\n    }\n  }\n  onmessagetyping(messagetyping) {\n    if (this.verbose && window && window.console) {\n      console.log(messagetyping);\n    }\n  }\n  onmessagereaction(messagereaction) {\n    if (this.verbose && window && window.console) {\n      console.log(messagereaction);\n    }\n  }\n  onchannelmessage(channelMessage) {\n    if (this.verbose && window && window.console) {\n      console.log(channelMessage);\n    }\n  }\n  onchannelpresence(channelPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(channelPresence);\n    }\n  }\n  onuserchanneladded(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserclanadded(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserprofileupdate(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserchannelremoved(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserclanremoved(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onnotification(notification) {\n    if (this.verbose && window && window.console) {\n      console.log(notification);\n    }\n  }\n  onstatuspresence(statusPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(statusPresence);\n    }\n  }\n  onpinmessage(pin) {\n    if (this.verbose && window && window.console) {\n      console.log(pin);\n    }\n  }\n  onvoiceended(voice) {\n    if (this.verbose && window && window.console) {\n      console.log(voice);\n    }\n  }\n  onvoicestarted(voice) {\n    if (this.verbose && window && window.console) {\n      console.log(voice);\n    }\n  }\n  onvoicejoined(voiceParticipant) {\n    if (this.verbose && window && window.console) {\n      console.log(voiceParticipant);\n    }\n  }\n  onvoiceleaved(voiceParticipant) {\n    if (this.verbose && window && window.console) {\n      console.log(voiceParticipant);\n    }\n  }\n  onchannelcreated(channelCreated) {\n    if (this.verbose && window && window.console) {\n      console.log(channelCreated);\n    }\n  }\n  onroleevent(roleEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(roleEvent);\n    }\n  }\n  oneventemoji(eventEmoji) {\n    if (this.verbose && window && window.console) {\n      console.log(eventEmoji);\n    }\n  }\n  onchanneldeleted(channelDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(channelDeleted);\n    }\n  }\n  onclandeleted(clanDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(clanDeleted);\n    }\n  }\n  onstickercreated(stickerCreated) {\n    if (this.verbose && window && window.console) {\n      console.log(stickerCreated);\n    }\n  }\n  onstickerdeleted(stickerDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(stickerDeleted);\n    }\n  }\n  onstickerupdated(stickerUpdated) {\n    if (this.verbose && window && window.console) {\n      console.log(stickerUpdated);\n    }\n  }\n  onchannelupdated(channelUpdated) {\n    if (this.verbose && window && window.console) {\n      console.log(channelUpdated);\n    }\n  }\n  onclanprofileupdated(clanprofile) {\n    if (this.verbose && window && window.console) {\n      console.log(clanprofile);\n    }\n  }\n  onclanupdated(clan) {\n    if (this.verbose && window && window.console) {\n      console.log(clan);\n    }\n  }\n  onlastseenupdated(event) {\n    if (this.verbose && window && window.console) {\n      console.log(event);\n    }\n  }\n  onstreampresence(streamPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(streamPresence);\n    }\n  }\n  onstreamdata(streamData) {\n    if (this.verbose && window && window.console) {\n      console.log(streamData);\n    }\n  }\n  onheartbeattimeout() {\n    if (this.verbose && window && window.console) {\n      console.log(\"Heartbeat timeout.\");\n    }\n  }\n  oncustomstatus(statusEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(statusEvent);\n    }\n  }\n  oneventcreated(clan_event_created) {\n    if (this.verbose && window && window.console) {\n      console.log(clan_event_created);\n    }\n  }\n  oncoffeegiven(give_coffee_event) {\n    if (this.verbose && window && window.console) {\n      console.log(give_coffee_event);\n    }\n  }\n  onroleassign(role_assign_event) {\n    if (this.verbose && window && window.console) {\n      console.log(role_assign_event);\n    }\n  }\n  onstreamingchannelstarted(streaming_started_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_started_event);\n    }\n  }\n  onstreamingchannelended(streaming_ended_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_ended_event);\n    }\n  }\n  onstreamingchanneljoined(streaming_joined_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_joined_event);\n    }\n  }\n  onstreamingchannelleaved(streaming_leaved_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_leaved_event);\n    }\n  }\n  onsetpermissionchannel(set_permission_channel_event) {\n    if (this.verbose && window && window.console) {\n      console.log(set_permission_channel_event);\n    }\n  }\n  send(message, sendTimeout = _DefaultSocket.DefaultSendTimeoutMs) {\n    const untypedMessage = message;\n    return new Promise((resolve, reject) => {\n      if (!this.adapter.isOpen()) {\n        reject(\"Socket connection has not been established yet.\");\n      } else {\n        if (untypedMessage.channel_message_send) {\n          untypedMessage.channel_message_send.content = JSON.stringify(untypedMessage.channel_message_send.content);\n        } else if (untypedMessage.channel_message_update) {\n          untypedMessage.channel_message_update.content = JSON.stringify(untypedMessage.channel_message_update.content);\n        }\n        const cid = this.generatecid();\n        this.cIds[cid] = { resolve, reject };\n        setTimeout(() => {\n          reject(\"The socket timed out while waiting for a response.\");\n        }, sendTimeout);\n        untypedMessage.cid = cid;\n        this.adapter.send(untypedMessage);\n      }\n    });\n  }\n  followUsers(userIds) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ status_follow: { user_ids: userIds } });\n      return response.status;\n    });\n  }\n  joinClanChat(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        clan_join: {\n          clan_id\n        }\n      });\n      return response.clan_join;\n    });\n  }\n  joinChat(clan_id, parent_id, channel_id, channel_type, is_public, is_parent_public) {\n    return __async(this, null, function* () {\n      const response = yield this.send(\n        {\n          channel_join: {\n            clan_id,\n            parent_id,\n            channel_id,\n            channel_type,\n            is_public,\n            is_parent_public\n          }\n        }\n      );\n      return response.channel;\n    });\n  }\n  leaveChat(clan_id, parent_id, channel_id, channel_type, is_public, is_parent_public) {\n    return this.send({ channel_leave: { clan_id, parent_id, channel_id, channel_type, is_public, is_parent_public } });\n  }\n  removeChatMessage(clan_id, parent_id, channel_id, mode, is_public, is_parent_public, message_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send(\n        {\n          channel_message_remove: {\n            clan_id,\n            parent_id,\n            channel_id,\n            mode,\n            message_id,\n            is_public,\n            is_parent_public\n          }\n        }\n      );\n      return response.channel_message_ack;\n    });\n  }\n  rpc(id, payload, http_key) {\n    return __async(this, null, function* () {\n      const response = yield this.send(\n        {\n          rpc: {\n            id,\n            payload,\n            http_key\n          }\n        }\n      );\n      return response.rpc;\n    });\n  }\n  unfollowUsers(user_ids) {\n    return this.send({ status_unfollow: { user_ids } });\n  }\n  updateChatMessage(clan_id, parent_id, channel_id, mode, is_public, is_parent_public, message_id, content, mentions, attachments, hideEditted) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ channel_message_update: { clan_id, parent_id, channel_id, message_id, content, mentions, attachments, mode, is_public, is_parent_public, hide_editted: hideEditted } });\n      return response.channel_message_ack;\n    });\n  }\n  updateStatus(status) {\n    return this.send({ status_update: { status } });\n  }\n  writeChatMessage(clan_id, parent_id, channel_id, mode, is_public, is_parent_public, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ channel_message_send: { clan_id, parent_id, channel_id, mode, is_public, is_parent_public, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar } });\n      return response.channel_message_ack;\n    });\n  }\n  writeMessageReaction(id, clan_id, parent_id, channel_id, mode, is_public, is_parent_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ message_reaction_event: { id, clan_id, parent_id, channel_id, mode, is_public, is_parent_public, message_id, emoji_id, emoji, count, message_sender_id, action: action_delete } });\n      return response.message_reaction_event;\n    });\n  }\n  writeMessageTyping(clan_id, parent_id, channel_id, mode, is_public, is_parent_public) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ message_typing_event: { clan_id, parent_id, channel_id, mode, is_public, is_parent_public } });\n      return response.message_typing_event;\n    });\n  }\n  writeLastSeenMessage(clan_id, channel_id, mode, message_id, timestamp_seconds) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ last_seen_message_event: { clan_id, channel_id, mode, message_id, timestamp_seconds } });\n      return response.last_seen_message_event;\n    });\n  }\n  writeLastPinMessage(clan_id, parent_id, channel_id, mode, is_public, is_parent_public, message_id, timestamp_seconds, operation) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ last_pin_message_event: { clan_id, parent_id, channel_id, mode, is_public, is_parent_public, message_id, timestamp_seconds, operation } });\n      return response.last_pin_message_event;\n    });\n  }\n  writeVoiceJoined(id, clanId, clanName, voiceChannelId, voiceChannelLabel, participant, lastScreenshot) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ voice_joined_event: { clan_id: clanId, clan_name: clanName, id, participant, voice_channel_id: voiceChannelId, voice_channel_label: voiceChannelLabel, last_screenshot: lastScreenshot } });\n      return response.voice_joined_event;\n    });\n  }\n  writeVoiceLeaved(id, clanId, voiceChannelId, voiceUserId) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ voice_leaved_event: { id, clan_id: clanId, voice_channel_id: voiceChannelId, voice_user_id: voiceUserId } });\n      return response.voice_leaved_event;\n    });\n  }\n  writeCustomStatus(clan_id, status) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ custom_status_event: { clan_id, status } });\n      return response.custom_status_event;\n    });\n  }\n  checkDuplicateName(name, condition_id, type) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ check_name_existed_event: { name, condition_id, type } });\n      return response.check_name_existed_event;\n    });\n  }\n  listClanEmojiByUserId() {\n    return __async(this, null, function* () {\n      const response = yield this.send({ emojis_listed_event: {} });\n      return response.emojis_listed_event;\n    });\n  }\n  listUserPermissionInChannel(clan_id, channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ user_permission_in_channel_list_event: { clan_id, channel_id } });\n      return response.user_permission_in_channel_list_event;\n    });\n  }\n  listRoles(ClanId, Limit, State, Cursor) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ role_list_event: { ClanId, Limit, State, Cursor } });\n      return response.role_list_event;\n    });\n  }\n  listChannelByUserId() {\n    return __async(this, null, function* () {\n      const response = yield this.send({ channel_desc_list_event: {} });\n      return response.channel_desc_list_event;\n    });\n  }\n  listUserClansByUserId() {\n    return __async(this, null, function* () {\n      const response = yield this.send({ all_user_clans: {} });\n      return response.all_user_clans;\n    });\n  }\n  listUsersAddChannelByChannelId(channelId, limit) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ all_users_add_channel_event: { channel_id: channelId, limit } });\n      return response.all_users_add_channel_event;\n    });\n  }\n  hashtagDMList(user_id, limit) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ hashtag_dm_list_event: { user_id, limit } });\n      return response.hashtag_dm_list_event;\n    });\n  }\n  getPermissionByRoleIdChannelId(role_id, channel_id, user_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ permission_role_channel_list_event: { role_id, channel_id, user_id } });\n      return response.permission_role_channel_list_event;\n    });\n  }\n  listStickersByUserId() {\n    return __async(this, null, function* () {\n      const response = yield this.send({ sticker_listed_event: {} });\n      return response.sticker_listed_event;\n    });\n  }\n  getNotificationChannelSetting(channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_channel_setting_event: { channel_id } });\n      return response.notification_channel_setting_event;\n    });\n  }\n  getNotificationCategorySetting(category_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_category_setting_event: { category_id } });\n      return response.notification_category_setting_event;\n    });\n  }\n  getNotificationClanSetting(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_clan_setting_event: { clan_id } });\n      return response.notification_clan_setting_event;\n    });\n  }\n  getNotificationReactMessage(channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notifi_react_message_event: { channel_id } });\n      return response.notifi_react_message_event;\n    });\n  }\n  getNotificationChannelCategorySetting(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ notification_channel_category_setting_event: { clan_id } });\n      return response.notification_channel_category_setting_event;\n    });\n  }\n  pingPong() {\n    return __async(this, null, function* () {\n      if (!this.adapter.isOpen()) {\n        return;\n      }\n      try {\n        yield this.send({ ping: {} }, this._heartbeatTimeoutMs);\n      } catch (e) {\n        if (this.adapter.isOpen()) {\n          if (window && window.console) {\n            console.error(\"Server unreachable from heartbeat.\");\n          }\n          this.onheartbeattimeout();\n          this.adapter.close();\n        }\n        return;\n      }\n      setTimeout(() => this.pingPong(), this._heartbeatTimeoutMs);\n    });\n  }\n};\n_DefaultSocket.DefaultHeartbeatTimeoutMs = 1e4;\n_DefaultSocket.DefaultSendTimeoutMs = 1e4;\n_DefaultSocket.DefaultConnectTimeoutMs = 3e4;\nvar DefaultSocket = _DefaultSocket;\n\n// client.ts\nvar DEFAULT_HOST = \"127.0.0.1\";\nvar DEFAULT_PORT = \"7350\";\nvar DEFAULT_SERVER_KEY = \"defaultkey\";\nvar DEFAULT_TIMEOUT_MS = 7e3;\nvar DEFAULT_EXPIRED_TIMESPAN_MS = 5 * 60 * 1e3;\nvar ChannelType = /* @__PURE__ */ ((ChannelType2) => {\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_TEXT\"] = 1] = \"CHANNEL_TYPE_TEXT\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_GROUP\"] = 2] = \"CHANNEL_TYPE_GROUP\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_DM\"] = 3] = \"CHANNEL_TYPE_DM\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_VOICE\"] = 4] = \"CHANNEL_TYPE_VOICE\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_FORUM\"] = 5] = \"CHANNEL_TYPE_FORUM\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_STREAMING\"] = 6] = \"CHANNEL_TYPE_STREAMING\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_THREAD\"] = 7] = \"CHANNEL_TYPE_THREAD\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_APP\"] = 8] = \"CHANNEL_TYPE_APP\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_ANNOUNCEMENT\"] = 9] = \"CHANNEL_TYPE_ANNOUNCEMENT\";\n  return ChannelType2;\n})(ChannelType || {});\nvar ChannelStreamMode = /* @__PURE__ */ ((ChannelStreamMode2) => {\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_CHANNEL\"] = 2] = \"STREAM_MODE_CHANNEL\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_GROUP\"] = 3] = \"STREAM_MODE_GROUP\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_DM\"] = 4] = \"STREAM_MODE_DM\";\n  return ChannelStreamMode2;\n})(ChannelStreamMode || {});\nvar NotificationType = /* @__PURE__ */ ((NotificationType2) => {\n  NotificationType2[NotificationType2[\"ALL_MESSAGE\"] = 1] = \"ALL_MESSAGE\";\n  NotificationType2[NotificationType2[\"MENTION_MESSAGE\"] = 2] = \"MENTION_MESSAGE\";\n  NotificationType2[NotificationType2[\"NOTHING_MESSAGE\"] = 3] = \"NOTHING_MESSAGE\";\n  return NotificationType2;\n})(NotificationType || {});\nvar Client = class {\n  constructor(serverkey = DEFAULT_SERVER_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = false, timeout = DEFAULT_TIMEOUT_MS, autoRefreshSession = true) {\n    this.serverkey = serverkey;\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    this.timeout = timeout;\n    this.autoRefreshSession = autoRefreshSession;\n    /** The expired timespan used to check session lifetime. */\n    this.expiredTimespanMs = DEFAULT_EXPIRED_TIMESPAN_MS;\n    const scheme = useSSL ? \"https://\" : \"http://\";\n    const basePath = `${scheme}${host}:${port}`;\n    this.apiClient = new MezonApi(serverkey, basePath, timeout);\n  }\n  /** Add users to a channel, or accept their join requests. */\n  addChannelUsers(session, channelId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addChannelUsers(session.token, channelId, ids).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add friends by ID or username to a user's account. */\n  addFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addFriends(session.token, ids, usernames).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Authenticate a user with an Apple ID against the server. */\n  authenticateApple(_0, _1, _2) {\n    return __async(this, arguments, function* (token, create, username, vars = {}, options = {}) {\n      const request = {\n        token,\n        vars\n      };\n      return this.apiClient.authenticateApple(this.serverkey, \"\", request, create, username, options).then((apiSession) => {\n        return new Session(\n          apiSession.token || \"\",\n          apiSession.refresh_token || \"\",\n          apiSession.created || false\n        );\n      });\n    });\n  }\n  /** Authenticate a user with a custom id against the server. */\n  authenticateCustom(id, create, username, vars = {}, options = {}) {\n    const request = {\n      id,\n      vars\n    };\n    return this.apiClient.authenticateCustom(\n      this.serverkey,\n      \"\",\n      request,\n      create,\n      username,\n      options\n    ).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with a device id against the server. */\n  authenticateDevice(id, create, username, vars) {\n    const request = {\n      id,\n      vars\n    };\n    return this.apiClient.authenticateDevice(this.serverkey, \"\", request, create, username).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with an email+password against the server. */\n  authenticateEmail(email, password, username, vars) {\n    const request = {\n      email,\n      password,\n      vars\n    };\n    return this.apiClient.authenticateEmail(this.serverkey, \"\", request, username).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with a Facebook Instant Game token against the server. */\n  authenticateFacebookInstantGame(signedPlayerInfo, create, username, vars, options = {}) {\n    const request = {\n      signed_player_info: signedPlayerInfo,\n      vars\n    };\n    return this.apiClient.authenticateFacebookInstantGame(\n      this.serverkey,\n      \"\",\n      { signed_player_info: request.signed_player_info, vars: request.vars },\n      create,\n      username,\n      options\n    ).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with a Facebook OAuth token against the server. */\n  authenticateFacebook(token, create, username, sync, vars, options = {}) {\n    const request = {\n      token,\n      vars\n    };\n    return this.apiClient.authenticateFacebook(\n      this.serverkey,\n      \"\",\n      request,\n      create,\n      username,\n      sync,\n      options\n    ).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with Google against the server. */\n  authenticateGoogle(_0, _1, _2, _3) {\n    return __async(this, arguments, function* (token, create, username, vars, options = {}) {\n      const request = {\n        token,\n        vars\n      };\n      const apiSession = yield this.apiClient.authenticateGoogle(\n        this.serverkey,\n        \"\",\n        request,\n        create,\n        username,\n        options\n      );\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with GameCenter against the server. */\n  authenticateGameCenter(_0, _1, _2, _3, _4, _5, _6, _7, _8) {\n    return __async(this, arguments, function* (bundleId, playerId, publicKeyUrl, salt, signature, timestamp, username, create, vars, options = {}) {\n      const request = {\n        bundle_id: bundleId,\n        player_id: playerId,\n        public_key_url: publicKeyUrl,\n        salt,\n        signature,\n        timestamp_seconds: timestamp,\n        vars\n      };\n      const apiSession = yield this.apiClient.authenticateGameCenter(\n        this.serverkey,\n        \"\",\n        request,\n        create,\n        username,\n        options\n      );\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false\n      );\n    });\n  }\n  /** Authenticate a user with Steam against the server. */\n  authenticateSteam(token, create, username, sync, vars) {\n    return __async(this, null, function* () {\n      const request = {\n        token,\n        vars,\n        sync\n      };\n      return this.apiClient.authenticateSteam(this.serverkey, \"\", request, create, username).then((apiSession) => {\n        return new Session(\n          apiSession.token || \"\",\n          apiSession.refresh_token || \"\",\n          apiSession.created || false\n        );\n      });\n    });\n  }\n  /** Block one or more users by ID or username. */\n  blockFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.blockFriends(session.token, ids, usernames).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Create a new group with the current user as the creator and superadmin. */\n  uploadAttachmentFile(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.uploadAttachmentFile(session.token, request);\n    });\n  }\n  /** Create a channel within clan */\n  createChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createChannelDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a clan */\n  createClanDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createClanDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /**  */\n  createCategoryDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createCategoryDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a new role for clan. */\n  createRole(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createRole(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a new event for clan. */\n  createEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createEvent(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** add role for channel. */\n  addRolesChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addRolesChannelDesc(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update action role when delete role */\n  deleteRoleChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteRoleChannelDesc(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteApp(session, appId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteApp(session.token, appId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** A socket created with the client's configuration. */\n  createSocket(useSSL = false, verbose = false, adapter = new WebSocketAdapterText(), sendTimeoutMs = DefaultSocket.DefaultSendTimeoutMs) {\n    return new DefaultSocket(\n      this.host,\n      this.port,\n      useSSL,\n      verbose,\n      adapter,\n      sendTimeoutMs\n    );\n  }\n  /** Delete one or more users by ID or username. */\n  deleteFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteFriends(session.token, ids, usernames).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a channel by ID. */\n  deleteChannelDesc(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteChannelDesc(session.token, channelId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a clan desc by ID. */\n  deleteClanDesc(session, clanDescId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanDesc(session.token, clanDescId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a category by ID. */\n  deleteCategoryDesc(session, categoryId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteCategoryDesc(session.token, categoryId, clanId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete one or more notifications */\n  deleteNotifications(session, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotifications(session.token, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Delete a role by ID. */\n  deleteRole(session, roleId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteRole(session.token, roleId, \"\", clanId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a event by ID. */\n  deleteEvent(session, eventId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteEvent(session.token, eventId, clanId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** update user a event by ID. */\n  updateEventUser(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateEventUser(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Submit an event for processing in the server's registered runtime custom events handler. */\n  emitEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.event(session.token, request).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Fetch the current user's account. */\n  getAccount(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getAccount(session.token);\n    });\n  }\n  /** Import Facebook friends and add them to a user's account. */\n  importFacebookFriends(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.importFacebookFriends(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Import Steam friends and add them to a user's account. */\n  importSteamFriends(session, request, reset) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.importSteamFriends(session.token, request, reset).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Fetch zero or more users by ID and/or username. */\n  getUsers(session, ids, usernames, facebookIds) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUsers(session.token, ids, usernames, facebookIds).then((response) => {\n        var result = {\n          users: []\n        };\n        if (response.users == null) {\n          return Promise.resolve(result);\n        }\n        response.users.forEach((u) => {\n          result.users.push({\n            avatar_url: u.avatar_url,\n            create_time: u.create_time,\n            display_name: u.display_name,\n            edge_count: u.edge_count ? Number(u.edge_count) : 0,\n            facebook_id: u.facebook_id,\n            gamecenter_id: u.gamecenter_id,\n            google_id: u.google_id,\n            id: u.id,\n            lang_tag: u.lang_tag,\n            location: u.location,\n            online: u.online,\n            steam_id: u.steam_id,\n            timezone: u.timezone,\n            update_time: u.update_time,\n            username: u.username,\n            metadata: u.metadata ? JSON.parse(u.metadata) : void 0\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Kick a set of users from a clan. */\n  removeClanUsers(session, clanId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeClanUsers(session.token, clanId, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Kick users from a channel, or decline their join requests. */\n  removeChannelUsers(session, channelId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeChannelUsers(session.token, channelId, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** List a channel's message history. */\n  listChannelMessages(session, clanId, channelId, messageId, direction, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelMessages(\n        session.token,\n        clanId,\n        channelId,\n        messageId,\n        direction,\n        limit\n      ).then((response) => {\n        var result = {\n          messages: [],\n          last_seen_message: response.last_seen_message,\n          last_sent_message: response.last_sent_message\n        };\n        if (response.messages == null) {\n          return Promise.resolve(result);\n        }\n        response.messages.forEach((m) => {\n          var content, reactions, mentions, attachments, references;\n          try {\n            content = JSON.parse(m.content);\n          } catch (e) {\n          }\n          try {\n            reactions = JSON.parse(m.reactions || \"[]\");\n          } catch (e) {\n          }\n          try {\n            mentions = JSON.parse(m.mentions || \"[]\");\n          } catch (e) {\n          }\n          try {\n            attachments = JSON.parse(m.attachments || \"[]\");\n          } catch (e) {\n          }\n          try {\n            references = JSON.parse(m.references || \"[]\");\n          } catch (e) {\n          }\n          result.messages.push({\n            channel_id: m.channel_id,\n            code: m.code ? Number(m.code) : 0,\n            create_time: m.create_time || \"\",\n            id: m.message_id,\n            sender_id: m.sender_id,\n            update_time: m.update_time,\n            username: m.username,\n            display_name: m.display_name,\n            avatar: m.avatar,\n            content,\n            channel_label: m.channel_label,\n            clan_logo: m.clan_logo,\n            category_name: m.category_name,\n            clan_nick: m.clan_nick,\n            clan_avatar: m.clan_avatar,\n            attachments,\n            mentions,\n            reactions,\n            references,\n            clan_id: m.clan_id,\n            create_time_seconds: m.create_time_seconds,\n            update_time_seconds: m.update_time_seconds\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelVoiceUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelVoiceUsers(\n        session.token,\n        clanId,\n        channelId,\n        channelType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          voice_channel_users: []\n        };\n        if (response.voice_channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.voice_channel_users.forEach((gu) => {\n          result.voice_channel_users.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            user_id: gu.user_id,\n            participant: gu.participant\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelUsers(\n        session.token,\n        clanId,\n        channelId,\n        channelType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          channel_users: [],\n          cursor: response.cursor,\n          channel_id: response.channel_id\n        };\n        if (response.channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.channel_users.forEach((gu) => {\n          result.channel_users.push({\n            user_id: gu.user_id,\n            role_id: gu.role_id,\n            thread_id: gu.thread_id,\n            clan_avatar: gu.clan_avatar,\n            clan_nick: gu.clan_nick,\n            id: gu.id,\n            clan_id: gu.clan_id\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's attachment. */\n  listChannelAttachments(session, clanId, channelId, fileType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelAttachment(\n        session.token,\n        clanId,\n        channelId,\n        fileType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          attachments: []\n        };\n        if (response.attachments == null) {\n          return Promise.resolve(result);\n        }\n        response.attachments.forEach((at) => {\n          result.attachments.push({\n            filename: at.filename,\n            filesize: at.filesize,\n            filetype: at.filetype,\n            id: at.id,\n            uploader: at.uploader,\n            url: at.url,\n            create_time: at.create_time\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listClanUsers(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanUsers(session.token, clanId).then((response) => {\n        var result = {\n          clan_users: [],\n          cursor: response.cursor,\n          clan_id: response.clan_id\n        };\n        if (response.clan_users == null) {\n          return Promise.resolve(result);\n        }\n        response.clan_users.forEach((gu) => {\n          result.clan_users.push({\n            user: {\n              avatar_url: gu.user.avatar_url,\n              create_time: gu.user.create_time,\n              display_name: gu.user.display_name,\n              edge_count: gu.user.edge_count ? Number(gu.user.edge_count) : 0,\n              facebook_id: gu.user.facebook_id,\n              gamecenter_id: gu.user.gamecenter_id,\n              google_id: gu.user.google_id,\n              id: gu.user.id,\n              lang_tag: gu.user.lang_tag,\n              location: gu.user.location,\n              online: gu.user.online,\n              steam_id: gu.user.steam_id,\n              timezone: gu.user.timezone,\n              update_time: gu.user.update_time,\n              username: gu.user.username,\n              metadata: gu.user.metadata ? JSON.parse(gu.user.metadata) : void 0\n            },\n            role_id: gu.role_id,\n            clan_nick: gu.clan_nick,\n            clan_avatar: gu.clan_avatar\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List channels. */\n  listChannelDescs(session, limit, state, cursor, clanId, channelType) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelDescs(\n        session.token,\n        limit,\n        state,\n        cursor,\n        clanId,\n        channelType\n      ).then((response) => {\n        var result = {\n          channeldesc: [],\n          next_cursor: response.next_cursor,\n          prev_cursor: response.prev_cursor,\n          cacheable_cursor: response.cacheable_cursor\n        };\n        if (response.channeldesc == null) {\n          return Promise.resolve(result);\n        }\n        result.channeldesc = response.channeldesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List clans */\n  listClanDescs(session, limit, state, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanDescs(session.token, limit, state, cursor).then((response) => {\n        var result = {\n          clandesc: []\n        };\n        if (response.clandesc == null) {\n          return Promise.resolve(result);\n        }\n        result.clandesc = response.clandesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List categories. */\n  listCategoryDescs(session, clanId, creatorId, categoryName) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listCategoryDescs(session.token, clanId, creatorId, categoryName).then((response) => {\n        var result = {\n          categorydesc: []\n        };\n        if (response.categorydesc == null) {\n          return Promise.resolve(result);\n        }\n        result.categorydesc = response.categorydesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List event */\n  listEvents(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listEvents(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List permission */\n  getListPermission(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListPermission(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List user roles */\n  listRolePermissions(session, roleId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRolePermissions(session.token, roleId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List user roles */\n  listRoleUsers(session, roleId, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRoleUsers(session.token, roleId, limit, cursor).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  registFCMDeviceToken(session, tokenId, deviceId, platform) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.registFCMDeviceToken(session.token, tokenId, deviceId, platform).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Get a clan desc profile */\n  getClanDescProfile(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getClanDescProfile(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getUserProfileOnClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUserProfileOnClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Add an Apple ID to the social profiles on the current user's account. */\n  linkApple(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkApple(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //\n  closeDirectMess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.closeDirectMess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //\n  openDirectMess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.openDirectMess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add a custom ID to the social profiles on the current user's account. */\n  linkCustom(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkCustom(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add a device ID to the social profiles on the current user's account. */\n  linkDevice(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkDevice(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add an email+password to the social profiles on the current user's account. */\n  linkEmail(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkEmail(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Facebook to the social profiles on the current user's account. */\n  linkFacebook(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkFacebook(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Facebook Instant to the social profiles on the current user's account. */\n  linkFacebookInstantGame(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkFacebookInstantGame(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Google to the social profiles on the current user's account. */\n  linkGoogle(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkGoogle(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add GameCenter to the social profiles on the current user's account. */\n  linkGameCenter(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkGameCenter(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add Steam to the social profiles on the current user's account. */\n  linkSteam(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkSteam(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** List all friends for the current user. */\n  listFriends(session, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listFriends(session.token, limit, state, cursor).then((response) => {\n        var result = {\n          friends: [],\n          cursor: response.cursor\n        };\n        if (response.friends == null) {\n          return Promise.resolve(result);\n        }\n        response.friends.forEach((f) => {\n          result.friends.push({\n            user: {\n              avatar_url: f.user.avatar_url,\n              create_time: f.user.create_time,\n              display_name: f.user.display_name,\n              edge_count: f.user.edge_count ? Number(f.user.edge_count) : 0,\n              facebook_id: f.user.facebook_id,\n              gamecenter_id: f.user.gamecenter_id,\n              google_id: f.user.google_id,\n              id: f.user.id,\n              lang_tag: f.user.lang_tag,\n              location: f.user.location,\n              online: f.user.online,\n              steam_id: f.user.steam_id,\n              timezone: f.user.timezone,\n              update_time: f.user.update_time,\n              username: f.user.username,\n              metadata: f.user.metadata ? JSON.parse(f.user.metadata) : void 0\n            },\n            state: f.state\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Fetch list of notifications. */\n  listNotifications(session, clanId, limit, cacheableCursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listNotifications(session.token, clanId, limit, cacheableCursor).then((response) => {\n        var result = {\n          cacheable_cursor: response.cacheable_cursor,\n          notifications: []\n        };\n        if (response.notifications == null) {\n          return Promise.resolve(result);\n        }\n        response.notifications.forEach((n) => {\n          result.notifications.push({\n            code: n.code ? Number(n.code) : 0,\n            create_time: n.create_time,\n            id: n.id,\n            persistent: n.persistent,\n            sender_id: n.sender_id,\n            subject: n.subject,\n            content: n.content ? JSON.parse(n.content) : void 0\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Execute an RPC function on the server. */\n  rpc(session, basicAuthUsername, basicAuthPassword, id, input) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.rpcFunc(\n        session.token,\n        basicAuthUsername,\n        basicAuthPassword,\n        id,\n        JSON.stringify(input)\n      ).then((response) => {\n        return Promise.resolve({\n          id: response.id,\n          payload: !response.payload ? void 0 : JSON.parse(response.payload)\n        });\n      });\n    });\n  }\n  /** Execute an RPC function on the server. */\n  rpcHttpKey(httpKey, id, input) {\n    return __async(this, null, function* () {\n      return this.apiClient.rpcFunc2(\"\", id, input && JSON.stringify(input) || \"\", httpKey).then((response) => {\n        return Promise.resolve({\n          id: response.id,\n          payload: !response.payload ? void 0 : JSON.parse(response.payload)\n        });\n      }).catch((err) => {\n        throw err;\n      });\n    });\n  }\n  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\n  sessionLogout(session, token, refreshToken) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.sessionLogout(session.token, {\n        refresh_token: refreshToken,\n        token\n      }).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\n  sessionRefresh(_0) {\n    return __async(this, arguments, function* (session, vars = {}) {\n      if (!session) {\n        console.error(\"Cannot refresh a null session.\");\n        return session;\n      }\n      if (session.created && session.expires_at - session.created_at < 70) {\n        console.warn(\n          \"Session lifetime too short, please set '--session.token_expiry_sec' option. See the documentation for more info: https://mezon.vn/docs/mezon/getting-started/configuration/#session\"\n        );\n      }\n      if (session.created && session.refresh_expires_at - session.created_at < 3700) {\n        console.warn(\n          \"Session refresh lifetime too short, please set '--session.refresh_token_expiry_sec' option. See the documentation for more info: https://mezon.vn/docs/mezon/getting-started/configuration/#session\"\n        );\n      }\n      const apiSession = yield this.apiClient.sessionRefresh(this.serverkey, \"\", {\n        token: session.refresh_token,\n        vars\n      });\n      session.update(apiSession.token, apiSession.refresh_token);\n      return session;\n    });\n  }\n  /** Remove the Apple ID from the social profiles on the current user's account. */\n  unlinkApple(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkApple(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove custom ID from the social profiles on the current user's account. */\n  unlinkCustom(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkCustom(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove a device ID from the social profiles on the current user's account. */\n  unlinkDevice(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkDevice(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove an email+password from the social profiles on the current user's account. */\n  unlinkEmail(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkEmail(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Facebook from the social profiles on the current user's account. */\n  unlinkFacebook(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkFacebook(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Facebook Instant social profiles from the current user's account. */\n  unlinkFacebookInstantGame(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkFacebookInstantGame(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Google from the social profiles on the current user's account. */\n  unlinkGoogle(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkGoogle(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove GameCenter from the social profiles on the current user's account. */\n  unlinkGameCenter(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkGameCenter(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove Steam from the social profiles on the current user's account. */\n  unlinkSteam(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkSteam(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in the current user's account. */\n  updateAccount(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateAccount(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given channel */\n  updateChannelDesc(session, channelId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateChannelDesc(session.token, channelId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan. */\n  updateClanDesc(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanDesc(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given category. */\n  updateCategory(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateCategory(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan profile. */\n  updateClanDescProfile(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanDescProfile(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  updateUserProfileByClan(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateUserProfileByClan(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given role. */\n  updateRole(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateRole(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given event. */\n  updateEvent(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateEvent(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given event. */\n  updateApp(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateApp(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan profile. */\n  createLinkInviteUser(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createLinkInviteUser(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get link invite user */\n  getLinkInvite(session, inviteId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getLinkInvite(session.token, inviteId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get permission of user in the clan */\n  GetRoleOfUserInTheClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getRoleOfUserInTheClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** invite user */\n  inviteUser(session, inviteId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.inviteUser(session.token, inviteId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Set default notification clan*/\n  setNotificationClan(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationClanSetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification channel*/\n  setNotificationChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationChannelSetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification category*/\n  setMuteNotificationCategory(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setMuteNotificationCategory(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification channel*/\n  setMuteNotificationChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setMuteNotificationChannel(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** update channel private*/\n  updateChannelPrivate(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateChannelPrivate(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set default notification category*/\n  setNotificationCategory(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationCategorySetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteNotificationCategory(session, category_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotificationCategorySetting(session.token, category_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteNotificationChannel(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotificationChannel(session.token, channel_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** */\n  setNotificationReactMessage(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationReactMessage(session.token, { channel_id }).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //** */\n  deleteNotiReactMessage(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotiReactMessage(session.token, channel_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** query message in elasticsearch */\n  searchMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.searchMessage(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** */\n  createPinMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createPinMessage(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  pinMessagesList(session, messageId, channelId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPinMessagesList(session.token, messageId, channelId, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //** */\n  deletePinMessage(session, message_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deletePinMessage(session.token, message_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** create clan emoji */\n  createClanEmoji(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createClanEmoji(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**update clan emoji by id */\n  updateClanEmojiById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanEmojiById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**delete clan emoji by id */\n  deleteByIdClanEmoji(session, id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanEmojiById(session.token, id, clan_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**create webhook for chaneel */\n  generateWebhookLink(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.generateWebhook(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list webhook belong to the channel */\n  listWebhookByChannelId(session, channel_id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listWebhookByChannelId(session.token, channel_id, clan_id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**update webhook name by id */\n  updateWebhookById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateWebhookById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**disabled webhook by id */\n  deleteWebhookById(session, id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteWebhookById(session.token, id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**check duplicate clan name */\n  checkDuplicateClanName(session, clan_name) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.checkDuplicateClanName(session.token, clan_name).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**Add a new sticker */\n  addClanSticker(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addClanSticker(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**Delete a sticker by ID*/\n  deleteClanStickerById(session, id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanStickerById(session.token, id, clan_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**Update a sticker by ID*/\n  updateClanStickerById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanStickerById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //** update the category of a channel */\n  changeChannelCategory(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.changeChannelCategory(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** */\n  setRoleChannelPermission(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setRoleChannelPermission(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  addApp(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addApp(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  getApp(session, id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getApp(session.token, id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listApps(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listApps(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  addAppToClan(session, appId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addAppToClan(session.token, appId, clanId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  getSystemMessagesList(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getSystemMessagesList(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getSystemMessageByClanId(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getSystemMessageByClanId(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  createSystemMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createSystemMessage(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  updateSystemMessage(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateSystemMessage(session.token, clanId, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteSystemMessage(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteSystemMessage(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  updateCategoryOrder(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateCategoryOrder(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteCategoryOrder(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteCategoryOrder(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  givecoffee(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.giveMeACoffee(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  listStreamingChannels(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listStreamingChannels(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listStreamingChannelUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listStreamingChannelUsers(\n        session.token,\n        clanId,\n        channelId,\n        channelType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          streaming_channel_users: []\n        };\n        if (response.streaming_channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.streaming_channel_users.forEach((gu) => {\n          result.streaming_channel_users.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            user_id: gu.user_id,\n            participant: gu.participant\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  registerStreamingChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.registerStreamingChannel(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelApps(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelApps(session.token, clanId).then((response) => {\n        var result = {\n          channel_apps: []\n        };\n        if (response.channel_apps == null) {\n          return Promise.resolve(result);\n        }\n        response.channel_apps.forEach((gu) => {\n          result.channel_apps.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            app_id: gu.app_id,\n            clan_id: gu.clan_id,\n            url: gu.url\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  getChannelCategoryNotiSettingsList(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getChannelCategoryNotiSettingsList(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationCategory(session, categoryId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationCategory(session.token, categoryId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationChannel(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationChannel(session.token, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationReactMessage(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationReactMessage(session.token, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  hashtagDMList(session, userId, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.hashtagDMList(session.token, userId, limit).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listChannelByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listUsersAddChannelByChannelId(session, channel_id, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listUsersAddChannelByChannelId(session.token, channel_id, limit).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getListEmojisByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListEmojisByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getListStickersByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListStickersByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listUserClansByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listUserClansByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listRoles(session, clanId, limit, state, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRoles(session.token, clanId, limit, state, cursor).then((response) => {\n        var result = {\n          clan_id: clanId,\n          roles: response.roles\n        };\n        return Promise.resolve(result);\n      });\n    });\n  }\n  listUserPermissionInChannel(session, clanId, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listUserPermissionInChannel(session.token, clanId, channelId).then((response) => {\n        var result = {\n          clan_id: clanId,\n          channel_id: channelId,\n          permissions: response.permissions\n        };\n        return Promise.resolve(result);\n      });\n    });\n  }\n  getPermissionByRoleIdChannelId(session, roleId, channelId, userId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired((Date.now() + this.expiredTimespanMs) / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPermissionByRoleIdChannelId(session.token, roleId, channelId, userId).then((response) => {\n        var result = {\n          role_id: roleId,\n          channel_id: channelId,\n          permission_role_channel: response.permission_role_channel,\n          user_id: userId\n        };\n        return Promise.resolve(result);\n      });\n    });\n  }\n};\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/./node_modules/mezon-js/dist/mezon-js.cjs.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Copyright 2021 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nexports.__esModule = true;\r\nvar mezon_js_1 = __webpack_require__(/*! mezon-js */ \"./node_modules/mezon-js/dist/mezon-js.cjs.js\");\r\nvar mezon_js_protobuf_1 = __webpack_require__(/*! mezon-js-protobuf */ \"../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js\");\r\nvar useSSL = true; // Enable if server is run with an SSL certificate.\r\nvar client = new mezon_js_1.Client(\"defaultkey\", \"dev-mezon.nccsoft.vn\", \"7350\", useSSL);\r\n//var client = new Client(\"defaultkey\", \"172.16.11.90\", \"7350\", useSSL);\r\nclient.authenticateEmail(\"acc-test-100@gmail.com\", \"Ncc12345678\").then(function (session) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var socket, session2;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                console.log(\"authenticated.\", session);\r\n                socket = client.createSocket(false, true, new mezon_js_protobuf_1.WebSocketAdapterPb());\r\n                return [4 /*yield*/, socket.connect(session, true)];\r\n            case 1:\r\n                session2 = _a.sent();\r\n                console.log(\"session\", session2);\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}); })[\"catch\"](function (e) {\r\n    console.log(\"error authenticating.\");\r\n});\r\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;