/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js":
/*!**********************************************************!*\
  !*** ../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n  mod2\n));\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// ../../node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"../../node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"../../node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"../../node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"../../node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\")\n        (function() {\n          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n          function writeFloat_f32_cpy(val, buf, pos) {\n            f32[0] = val;\n            buf[pos] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n          }\n          function writeFloat_f32_rev(val, buf, pos) {\n            f32[0] = val;\n            buf[pos] = f8b[3];\n            buf[pos + 1] = f8b[2];\n            buf[pos + 2] = f8b[1];\n            buf[pos + 3] = f8b[0];\n          }\n          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n          function readFloat_f32_cpy(buf, pos) {\n            f8b[0] = buf[pos];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            return f32[0];\n          }\n          function readFloat_f32_rev(buf, pos) {\n            f8b[3] = buf[pos];\n            f8b[2] = buf[pos + 1];\n            f8b[1] = buf[pos + 2];\n            f8b[0] = buf[pos + 3];\n            return f32[0];\n          }\n          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n        })();\n      else\n        (function() {\n          function writeFloat_ieee754(writeUint, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n              val = -val;\n            if (val === 0)\n              writeUint(1 / val > 0 ? (\n                /* positive */\n                0\n              ) : (\n                /* negative 0 */\n                2147483648\n              ), buf, pos);\n            else if (isNaN(val))\n              writeUint(2143289344, buf, pos);\n            else if (val > 34028234663852886e22)\n              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n            else if (val < 11754943508222875e-54)\n              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n            else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n            }\n          }\n          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n          function readFloat_ieee754(readUint, buf, pos) {\n            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n          }\n          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n        })();\n      if (typeof Float64Array !== \"undefined\")\n        (function() {\n          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n          function writeDouble_f64_cpy(val, buf, pos) {\n            f64[0] = val;\n            buf[pos] = f8b[0];\n            buf[pos + 1] = f8b[1];\n            buf[pos + 2] = f8b[2];\n            buf[pos + 3] = f8b[3];\n            buf[pos + 4] = f8b[4];\n            buf[pos + 5] = f8b[5];\n            buf[pos + 6] = f8b[6];\n            buf[pos + 7] = f8b[7];\n          }\n          function writeDouble_f64_rev(val, buf, pos) {\n            f64[0] = val;\n            buf[pos] = f8b[7];\n            buf[pos + 1] = f8b[6];\n            buf[pos + 2] = f8b[5];\n            buf[pos + 3] = f8b[4];\n            buf[pos + 4] = f8b[3];\n            buf[pos + 5] = f8b[2];\n            buf[pos + 6] = f8b[1];\n            buf[pos + 7] = f8b[0];\n          }\n          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n          function readDouble_f64_cpy(buf, pos) {\n            f8b[0] = buf[pos];\n            f8b[1] = buf[pos + 1];\n            f8b[2] = buf[pos + 2];\n            f8b[3] = buf[pos + 3];\n            f8b[4] = buf[pos + 4];\n            f8b[5] = buf[pos + 5];\n            f8b[6] = buf[pos + 6];\n            f8b[7] = buf[pos + 7];\n            return f64[0];\n          }\n          function readDouble_f64_rev(buf, pos) {\n            f8b[7] = buf[pos];\n            f8b[6] = buf[pos + 1];\n            f8b[5] = buf[pos + 2];\n            f8b[4] = buf[pos + 3];\n            f8b[3] = buf[pos + 4];\n            f8b[2] = buf[pos + 5];\n            f8b[1] = buf[pos + 6];\n            f8b[0] = buf[pos + 7];\n            return f64[0];\n          }\n          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n        })();\n      else\n        (function() {\n          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n            var sign = val < 0 ? 1 : 0;\n            if (sign)\n              val = -val;\n            if (val === 0) {\n              writeUint(0, buf, pos + off0);\n              writeUint(1 / val > 0 ? (\n                /* positive */\n                0\n              ) : (\n                /* negative 0 */\n                2147483648\n              ), buf, pos + off1);\n            } else if (isNaN(val)) {\n              writeUint(0, buf, pos + off0);\n              writeUint(2146959360, buf, pos + off1);\n            } else if (val > 17976931348623157e292) {\n              writeUint(0, buf, pos + off0);\n              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n            } else {\n              var mantissa;\n              if (val < 22250738585072014e-324) {\n                mantissa = val / 5e-324;\n                writeUint(mantissa >>> 0, buf, pos + off0);\n                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n              } else {\n                var exponent = Math.floor(Math.log(val) / Math.LN2);\n                if (exponent === 1024)\n                  exponent = 1023;\n                mantissa = val * Math.pow(2, -exponent);\n                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n              }\n            }\n          }\n          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n          function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n          }\n          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n        })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"../../node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// ../../node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"../../node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// ../../node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"../../node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// ../../node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"../../node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"../../node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject2(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet5(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n      Object.defineProperty(CustomError.prototype, \"name\", { get: function() {\n        return name;\n      } });\n      CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n      };\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"../../node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"../../node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else\n          for (var i = 0; i < val.length; )\n            buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// ../../node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"../../node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"../../node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// ../../node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"../../node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// ../../node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"../../node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// ../../node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"../../node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// ../../node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"../../node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// ../../node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"../../node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// ../../node_modules/long/src/long.js\nvar require_long = __commonJS({\n  \"../../node_modules/long/src/long.js\"(exports2, module2) {\n    module2.exports = Long4;\n    var wasm = null;\n    try {\n      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n      ])), {}).exports;\n    } catch (e) {\n    }\n    function Long4(low, high, unsigned) {\n      this.low = low | 0;\n      this.high = high | 0;\n      this.unsigned = !!unsigned;\n    }\n    Long4.prototype.__isLong__;\n    Object.defineProperty(Long4.prototype, \"__isLong__\", { value: true });\n    function isLong(obj) {\n      return (obj && obj[\"__isLong__\"]) === true;\n    }\n    Long4.isLong = isLong;\n    var INT_CACHE = {};\n    var UINT_CACHE = {};\n    function fromInt(value, unsigned) {\n      var obj, cachedObj, cache;\n      if (unsigned) {\n        value >>>= 0;\n        if (cache = 0 <= value && value < 256) {\n          cachedObj = UINT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n          UINT_CACHE[value] = obj;\n        return obj;\n      } else {\n        value |= 0;\n        if (cache = -128 <= value && value < 128) {\n          cachedObj = INT_CACHE[value];\n          if (cachedObj)\n            return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n          INT_CACHE[value] = obj;\n        return obj;\n      }\n    }\n    Long4.fromInt = fromInt;\n    function fromNumber(value, unsigned) {\n      if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n      if (unsigned) {\n        if (value < 0)\n          return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n          return MAX_UNSIGNED_VALUE;\n      } else {\n        if (value <= -TWO_PWR_63_DBL)\n          return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n          return MAX_VALUE;\n      }\n      if (value < 0)\n        return fromNumber(-value, unsigned).neg();\n      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    Long4.fromNumber = fromNumber;\n    function fromBits(lowBits, highBits, unsigned) {\n      return new Long4(lowBits, highBits, unsigned);\n    }\n    Long4.fromBits = fromBits;\n    var pow_dbl = Math.pow;\n    function fromString(str, unsigned, radix) {\n      if (str.length === 0)\n        throw Error(\"empty string\");\n      if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n      if (typeof unsigned === \"number\") {\n        radix = unsigned, unsigned = false;\n      } else {\n        unsigned = !!unsigned;\n      }\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      var p;\n      if ((p = str.indexOf(\"-\")) > 0)\n        throw Error(\"interior hyphen\");\n      else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 8));\n      var result = ZERO;\n      for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n          var power = fromNumber(pow_dbl(radix, size));\n          result = result.mul(power).add(fromNumber(value));\n        } else {\n          result = result.mul(radixToPower);\n          result = result.add(fromNumber(value));\n        }\n      }\n      result.unsigned = unsigned;\n      return result;\n    }\n    Long4.fromString = fromString;\n    function fromValue(val, unsigned) {\n      if (typeof val === \"number\")\n        return fromNumber(val, unsigned);\n      if (typeof val === \"string\")\n        return fromString(val, unsigned);\n      return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    Long4.fromValue = fromValue;\n    var TWO_PWR_16_DBL = 1 << 16;\n    var TWO_PWR_24_DBL = 1 << 24;\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    var ZERO = fromInt(0);\n    Long4.ZERO = ZERO;\n    var UZERO = fromInt(0, true);\n    Long4.UZERO = UZERO;\n    var ONE = fromInt(1);\n    Long4.ONE = ONE;\n    var UONE = fromInt(1, true);\n    Long4.UONE = UONE;\n    var NEG_ONE = fromInt(-1);\n    Long4.NEG_ONE = NEG_ONE;\n    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);\n    Long4.MAX_VALUE = MAX_VALUE;\n    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);\n    Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);\n    Long4.MIN_VALUE = MIN_VALUE;\n    var LongPrototype = Long4.prototype;\n    LongPrototype.toInt = function toInt() {\n      return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    LongPrototype.toNumber = function toNumber() {\n      if (this.unsigned)\n        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    LongPrototype.toString = function toString(radix) {\n      radix = radix || 10;\n      if (radix < 2 || 36 < radix)\n        throw RangeError(\"radix\");\n      if (this.isZero())\n        return \"0\";\n      if (this.isNegative()) {\n        if (this.eq(MIN_VALUE)) {\n          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n          return div.toString(radix) + rem1.toInt().toString(radix);\n        } else\n          return \"-\" + this.neg().toString(radix);\n      }\n      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n      var result = \"\";\n      while (true) {\n        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero())\n          return digits + result;\n        else {\n          while (digits.length < 6)\n            digits = \"0\" + digits;\n          result = \"\" + digits + result;\n        }\n      }\n    };\n    LongPrototype.getHighBits = function getHighBits() {\n      return this.high;\n    };\n    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n      return this.high >>> 0;\n    };\n    LongPrototype.getLowBits = function getLowBits() {\n      return this.low;\n    };\n    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n      return this.low >>> 0;\n    };\n    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n      if (this.isNegative())\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n      var val = this.high != 0 ? this.high : this.low;\n      for (var bit = 31; bit > 0; bit--)\n        if ((val & 1 << bit) != 0)\n          break;\n      return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    LongPrototype.isZero = function isZero() {\n      return this.high === 0 && this.low === 0;\n    };\n    LongPrototype.eqz = LongPrototype.isZero;\n    LongPrototype.isNegative = function isNegative() {\n      return !this.unsigned && this.high < 0;\n    };\n    LongPrototype.isPositive = function isPositive() {\n      return this.unsigned || this.high >= 0;\n    };\n    LongPrototype.isOdd = function isOdd() {\n      return (this.low & 1) === 1;\n    };\n    LongPrototype.isEven = function isEven() {\n      return (this.low & 1) === 0;\n    };\n    LongPrototype.equals = function equals(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n        return false;\n      return this.high === other.high && this.low === other.low;\n    };\n    LongPrototype.eq = LongPrototype.equals;\n    LongPrototype.notEquals = function notEquals(other) {\n      return !this.eq(\n        /* validates */\n        other\n      );\n    };\n    LongPrototype.neq = LongPrototype.notEquals;\n    LongPrototype.ne = LongPrototype.notEquals;\n    LongPrototype.lessThan = function lessThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) < 0;\n    };\n    LongPrototype.lt = LongPrototype.lessThan;\n    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) <= 0;\n    };\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    LongPrototype.le = LongPrototype.lessThanOrEqual;\n    LongPrototype.greaterThan = function greaterThan(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) > 0;\n    };\n    LongPrototype.gt = LongPrototype.greaterThan;\n    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n      return this.comp(\n        /* validates */\n        other\n      ) >= 0;\n    };\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    LongPrototype.compare = function compare(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      if (this.eq(other))\n        return 0;\n      var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n      if (thisNeg && !otherNeg)\n        return -1;\n      if (!thisNeg && otherNeg)\n        return 1;\n      if (!this.unsigned)\n        return this.sub(other).isNegative() ? -1 : 1;\n      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    LongPrototype.comp = LongPrototype.compare;\n    LongPrototype.negate = function negate() {\n      if (!this.unsigned && this.eq(MIN_VALUE))\n        return MIN_VALUE;\n      return this.not().add(ONE);\n    };\n    LongPrototype.neg = LongPrototype.negate;\n    LongPrototype.add = function add(addend) {\n      if (!isLong(addend))\n        addend = fromValue(addend);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = addend.high >>> 16;\n      var b32 = addend.high & 65535;\n      var b16 = addend.low >>> 16;\n      var b00 = addend.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 + b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 + b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 + b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 + b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    LongPrototype.subtract = function subtract(subtrahend) {\n      if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n      return this.add(subtrahend.neg());\n    };\n    LongPrototype.sub = LongPrototype.subtract;\n    LongPrototype.multiply = function multiply(multiplier) {\n      if (this.isZero())\n        return ZERO;\n      if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n      if (wasm) {\n        var low = wasm.mul(\n          this.low,\n          this.high,\n          multiplier.low,\n          multiplier.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (multiplier.isZero())\n        return ZERO;\n      if (this.eq(MIN_VALUE))\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\n      if (multiplier.eq(MIN_VALUE))\n        return this.isOdd() ? MIN_VALUE : ZERO;\n      if (this.isNegative()) {\n        if (multiplier.isNegative())\n          return this.neg().mul(multiplier.neg());\n        else\n          return this.neg().mul(multiplier).neg();\n      } else if (multiplier.isNegative())\n        return this.mul(multiplier.neg()).neg();\n      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n      var a48 = this.high >>> 16;\n      var a32 = this.high & 65535;\n      var a16 = this.low >>> 16;\n      var a00 = this.low & 65535;\n      var b48 = multiplier.high >>> 16;\n      var b32 = multiplier.high & 65535;\n      var b16 = multiplier.low >>> 16;\n      var b00 = multiplier.low & 65535;\n      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n      c00 += a00 * b00;\n      c16 += c00 >>> 16;\n      c00 &= 65535;\n      c16 += a16 * b00;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c16 += a00 * b16;\n      c32 += c16 >>> 16;\n      c16 &= 65535;\n      c32 += a32 * b00;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a16 * b16;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c32 += a00 * b32;\n      c48 += c32 >>> 16;\n      c32 &= 65535;\n      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n      c48 &= 65535;\n      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    LongPrototype.mul = LongPrototype.multiply;\n    LongPrototype.divide = function divide(divisor) {\n      if (!isLong(divisor))\n        divisor = fromValue(divisor);\n      if (divisor.isZero())\n        throw Error(\"division by zero\");\n      if (wasm) {\n        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {\n          return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      if (this.isZero())\n        return this.unsigned ? UZERO : ZERO;\n      var approx, rem, res;\n      if (!this.unsigned) {\n        if (this.eq(MIN_VALUE)) {\n          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n            return MIN_VALUE;\n          else if (divisor.eq(MIN_VALUE))\n            return ONE;\n          else {\n            var halfThis = this.shr(1);\n            approx = halfThis.div(divisor).shl(1);\n            if (approx.eq(ZERO)) {\n              return divisor.isNegative() ? ONE : NEG_ONE;\n            } else {\n              rem = this.sub(divisor.mul(approx));\n              res = approx.add(rem.div(divisor));\n              return res;\n            }\n          }\n        } else if (divisor.eq(MIN_VALUE))\n          return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n          if (divisor.isNegative())\n            return this.neg().div(divisor.neg());\n          return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative())\n          return this.div(divisor.neg()).neg();\n        res = ZERO;\n      } else {\n        if (!divisor.unsigned)\n          divisor = divisor.toUnsigned();\n        if (divisor.gt(this))\n          return UZERO;\n        if (divisor.gt(this.shru(1)))\n          return UONE;\n        res = UZERO;\n      }\n      rem = this;\n      while (rem.gte(divisor)) {\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\n          approx -= delta;\n          approxRes = fromNumber(approx, this.unsigned);\n          approxRem = approxRes.mul(divisor);\n        }\n        if (approxRes.isZero())\n          approxRes = ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n      }\n      return res;\n    };\n    LongPrototype.div = LongPrototype.divide;\n    LongPrototype.modulo = function modulo(divisor) {\n      if (!isLong(divisor))\n        divisor = fromValue(divisor);\n      if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\n          this.low,\n          this.high,\n          divisor.low,\n          divisor.high\n        );\n        return fromBits(low, wasm.get_high(), this.unsigned);\n      }\n      return this.sub(this.div(divisor).mul(divisor));\n    };\n    LongPrototype.mod = LongPrototype.modulo;\n    LongPrototype.rem = LongPrototype.modulo;\n    LongPrototype.not = function not() {\n      return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    LongPrototype.and = function and(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    LongPrototype.or = function or(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    LongPrototype.xor = function xor(other) {\n      if (!isLong(other))\n        other = fromValue(other);\n      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    LongPrototype.shiftLeft = function shiftLeft(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n      else\n        return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    LongPrototype.shl = LongPrototype.shiftLeft;\n    LongPrototype.shiftRight = function shiftRight(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      if ((numBits &= 63) === 0)\n        return this;\n      else if (numBits < 32)\n        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n      else\n        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    LongPrototype.shr = LongPrototype.shiftRight;\n    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n      if (isLong(numBits))\n        numBits = numBits.toInt();\n      numBits &= 63;\n      if (numBits === 0)\n        return this;\n      else {\n        var high = this.high;\n        if (numBits < 32) {\n          var low = this.low;\n          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n        } else if (numBits === 32)\n          return fromBits(high, 0, this.unsigned);\n        else\n          return fromBits(high >>> numBits - 32, 0, this.unsigned);\n      }\n    };\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    LongPrototype.toSigned = function toSigned() {\n      if (!this.unsigned)\n        return this;\n      return fromBits(this.low, this.high, false);\n    };\n    LongPrototype.toUnsigned = function toUnsigned() {\n      if (this.unsigned)\n        return this;\n      return fromBits(this.low, this.high, true);\n    };\n    LongPrototype.toBytes = function toBytes(le) {\n      return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    LongPrototype.toBytesLE = function toBytesLE() {\n      var hi = this.high, lo = this.low;\n      return [\n        lo & 255,\n        lo >>> 8 & 255,\n        lo >>> 16 & 255,\n        lo >>> 24,\n        hi & 255,\n        hi >>> 8 & 255,\n        hi >>> 16 & 255,\n        hi >>> 24\n      ];\n    };\n    LongPrototype.toBytesBE = function toBytesBE() {\n      var hi = this.high, lo = this.low;\n      return [\n        hi >>> 24,\n        hi >>> 16 & 255,\n        hi >>> 8 & 255,\n        hi & 255,\n        lo >>> 24,\n        lo >>> 16 & 255,\n        lo >>> 8 & 255,\n        lo & 255\n      ];\n    };\n    Long4.fromBytes = function fromBytes(bytes, unsigned, le) {\n      return le ? Long4.fromBytesLE(bytes, unsigned) : Long4.fromBytesBE(bytes, unsigned);\n    };\n    Long4.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n      return new Long4(\n        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,\n        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,\n        unsigned\n      );\n    };\n    Long4.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n      return new Long4(\n        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],\n        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],\n        unsigned\n      );\n    };\n  }\n});\n\n// index.ts\nvar mezon_js_protobuf_exports = {};\n__export(mezon_js_protobuf_exports, {\n  WebSocketAdapterPb: () => WebSocketAdapterPb\n});\nmodule.exports = __toCommonJS(mezon_js_protobuf_exports);\n\n// rtapi/realtime.ts\nvar import_minimal5 = __toESM(require_minimal2());\n\n// api/api.ts\nvar import_long3 = __toESM(require_long());\nvar import_minimal4 = __toESM(require_minimal2());\n\n// google/protobuf/struct.ts\nvar import_minimal = __toESM(require_minimal2());\n\n// google/protobuf/timestamp.ts\nvar import_long = __toESM(require_long());\nvar import_minimal2 = __toESM(require_minimal2());\nfunction createBaseTimestamp() {\n  return { seconds: 0, nanos: 0 };\n}\nvar Timestamp = {\n  encode(message, writer = import_minimal2.default.Writer.create()) {\n    if (message.seconds !== 0) {\n      writer.uint32(8).int64(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      writer.uint32(16).int32(message.nanos);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal2.default.Reader ? input : import_minimal2.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseTimestamp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.seconds = longToNumber(reader.int64());\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.nanos = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,\n      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.seconds !== 0) {\n      obj.seconds = Math.round(message.seconds);\n    }\n    if (message.nanos !== 0) {\n      obj.nanos = Math.round(message.nanos);\n    }\n    return obj;\n  },\n  create(base) {\n    return Timestamp.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseTimestamp();\n    message.seconds = (_a = object.seconds) != null ? _a : 0;\n    message.nanos = (_b = object.nanos) != null ? _b : 0;\n    return message;\n  }\n};\nfunction longToNumber(long) {\n  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\nif (import_minimal2.default.util.Long !== import_long.default) {\n  import_minimal2.default.util.Long = import_long.default;\n  import_minimal2.default.configure();\n}\nfunction isSet(value) {\n  return value !== null && value !== void 0;\n}\n\n// google/protobuf/wrappers.ts\nvar import_long2 = __toESM(require_long());\nvar import_minimal3 = __toESM(require_minimal2());\nfunction createBaseInt32Value() {\n  return { value: 0 };\n}\nvar Int32Value = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.value !== 0) {\n      writer.uint32(8).int32(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseInt32Value();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.value = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? globalThis.Number(object.value) : 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.value !== 0) {\n      obj.value = Math.round(message.value);\n    }\n    return obj;\n  },\n  create(base) {\n    return Int32Value.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseInt32Value();\n    message.value = (_a = object.value) != null ? _a : 0;\n    return message;\n  }\n};\nfunction createBaseBoolValue() {\n  return { value: false };\n}\nvar BoolValue = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.value !== false) {\n      writer.uint32(8).bool(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseBoolValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.value = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? globalThis.Boolean(object.value) : false };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.value !== false) {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n  create(base) {\n    return BoolValue.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseBoolValue();\n    message.value = (_a = object.value) != null ? _a : false;\n    return message;\n  }\n};\nfunction createBaseStringValue() {\n  return { value: \"\" };\n}\nvar StringValue = {\n  encode(message, writer = import_minimal3.default.Writer.create()) {\n    if (message.value !== \"\") {\n      writer.uint32(10).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStringValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.value = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { value: isSet2(object.value) ? globalThis.String(object.value) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.value !== \"\") {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n  create(base) {\n    return StringValue.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStringValue();\n    message.value = (_a = object.value) != null ? _a : \"\";\n    return message;\n  }\n};\nif (import_minimal3.default.util.Long !== import_long2.default) {\n  import_minimal3.default.util.Long = import_long2.default;\n  import_minimal3.default.configure();\n}\nfunction isSet2(value) {\n  return value !== null && value !== void 0;\n}\n\n// api/api.ts\nfunction createBaseChannelMessage() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    code: void 0,\n    sender_id: \"\",\n    username: \"\",\n    avatar: \"\",\n    content: \"\",\n    create_time: void 0,\n    update_time: void 0,\n    channel_label: \"\",\n    clan_logo: \"\",\n    category_name: \"\",\n    display_name: \"\",\n    clan_nick: \"\",\n    clan_avatar: \"\",\n    reactions: \"\",\n    mentions: \"\",\n    attachments: \"\",\n    references: \"\",\n    referenced_message: \"\",\n    create_time_seconds: 0,\n    update_time_seconds: 0,\n    mode: 0,\n    hide_editted: false,\n    is_public: false,\n    topic_id: \"\"\n  };\n}\nvar ChannelMessage = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.code !== void 0) {\n      Int32Value.encode({ value: message.code }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(42).string(message.sender_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(50).string(message.username);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(58).string(message.avatar);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(66).string(message.content);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(74).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(82).fork()).ldelim();\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(90).string(message.channel_label);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(98).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(106).string(message.category_name);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(114).string(message.display_name);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(122).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(130).string(message.clan_avatar);\n    }\n    if (message.reactions !== \"\") {\n      writer.uint32(138).string(message.reactions);\n    }\n    if (message.mentions !== \"\") {\n      writer.uint32(146).string(message.mentions);\n    }\n    if (message.attachments !== \"\") {\n      writer.uint32(154).string(message.attachments);\n    }\n    if (message.references !== \"\") {\n      writer.uint32(162).string(message.references);\n    }\n    if (message.referenced_message !== \"\") {\n      writer.uint32(170).string(message.referenced_message);\n    }\n    if (message.create_time_seconds !== 0) {\n      writer.uint32(176).uint32(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      writer.uint32(184).uint32(message.update_time_seconds);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(192).int32(message.mode);\n    }\n    if (message.hide_editted !== false) {\n      writer.uint32(200).bool(message.hide_editted);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(208).bool(message.is_public);\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(218).string(message.topic_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.code = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.clan_nick = reader.string();\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.clan_avatar = reader.string();\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.reactions = reader.string();\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.mentions = reader.string();\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.attachments = reader.string();\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.references = reader.string();\n          continue;\n        case 21:\n          if (tag !== 170) {\n            break;\n          }\n          message.referenced_message = reader.string();\n          continue;\n        case 22:\n          if (tag !== 176) {\n            break;\n          }\n          message.create_time_seconds = reader.uint32();\n          continue;\n        case 23:\n          if (tag !== 184) {\n            break;\n          }\n          message.update_time_seconds = reader.uint32();\n          continue;\n        case 24:\n          if (tag !== 192) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 25:\n          if (tag !== 200) {\n            break;\n          }\n          message.hide_editted = reader.bool();\n          continue;\n        case 26:\n          if (tag !== 208) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 27:\n          if (tag !== 218) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      code: isSet3(object.code) ? Number(object.code) : void 0,\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      avatar: isSet3(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      update_time: isSet3(object.update_time) ? fromJsonTimestamp(object.update_time) : void 0,\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      clan_logo: isSet3(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet3(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      display_name: isSet3(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      clan_nick: isSet3(object.clan_nick) ? globalThis.String(object.clan_nick) : \"\",\n      clan_avatar: isSet3(object.clan_avatar) ? globalThis.String(object.clan_avatar) : \"\",\n      reactions: isSet3(object.reactions) ? globalThis.String(object.reactions) : \"\",\n      mentions: isSet3(object.mentions) ? globalThis.String(object.mentions) : \"\",\n      attachments: isSet3(object.attachments) ? globalThis.String(object.attachments) : \"\",\n      references: isSet3(object.references) ? globalThis.String(object.references) : \"\",\n      referenced_message: isSet3(object.referenced_message) ? globalThis.String(object.referenced_message) : \"\",\n      create_time_seconds: isSet3(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,\n      update_time_seconds: isSet3(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,\n      mode: isSet3(object.mode) ? globalThis.Number(object.mode) : 0,\n      hide_editted: isSet3(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,\n      is_public: isSet3(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      topic_id: isSet3(object.topic_id) ? globalThis.String(object.topic_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.code !== void 0) {\n      obj.code = message.code;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.update_time !== void 0) {\n      obj.update_time = message.update_time.toISOString();\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.clan_nick !== \"\") {\n      obj.clan_nick = message.clan_nick;\n    }\n    if (message.clan_avatar !== \"\") {\n      obj.clan_avatar = message.clan_avatar;\n    }\n    if (message.reactions !== \"\") {\n      obj.reactions = message.reactions;\n    }\n    if (message.mentions !== \"\") {\n      obj.mentions = message.mentions;\n    }\n    if (message.attachments !== \"\") {\n      obj.attachments = message.attachments;\n    }\n    if (message.references !== \"\") {\n      obj.references = message.references;\n    }\n    if (message.referenced_message !== \"\") {\n      obj.referenced_message = message.referenced_message;\n    }\n    if (message.create_time_seconds !== 0) {\n      obj.create_time_seconds = Math.round(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      obj.update_time_seconds = Math.round(message.update_time_seconds);\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.hide_editted !== false) {\n      obj.hide_editted = message.hide_editted;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessage.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A;\n    const message = createBaseChannelMessage();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.code = (_d = object.code) != null ? _d : void 0;\n    message.sender_id = (_e = object.sender_id) != null ? _e : \"\";\n    message.username = (_f = object.username) != null ? _f : \"\";\n    message.avatar = (_g = object.avatar) != null ? _g : \"\";\n    message.content = (_h = object.content) != null ? _h : \"\";\n    message.create_time = (_i = object.create_time) != null ? _i : void 0;\n    message.update_time = (_j = object.update_time) != null ? _j : void 0;\n    message.channel_label = (_k = object.channel_label) != null ? _k : \"\";\n    message.clan_logo = (_l = object.clan_logo) != null ? _l : \"\";\n    message.category_name = (_m = object.category_name) != null ? _m : \"\";\n    message.display_name = (_n = object.display_name) != null ? _n : \"\";\n    message.clan_nick = (_o = object.clan_nick) != null ? _o : \"\";\n    message.clan_avatar = (_p = object.clan_avatar) != null ? _p : \"\";\n    message.reactions = (_q = object.reactions) != null ? _q : \"\";\n    message.mentions = (_r = object.mentions) != null ? _r : \"\";\n    message.attachments = (_s = object.attachments) != null ? _s : \"\";\n    message.references = (_t = object.references) != null ? _t : \"\";\n    message.referenced_message = (_u = object.referenced_message) != null ? _u : \"\";\n    message.create_time_seconds = (_v = object.create_time_seconds) != null ? _v : 0;\n    message.update_time_seconds = (_w = object.update_time_seconds) != null ? _w : 0;\n    message.mode = (_x = object.mode) != null ? _x : 0;\n    message.hide_editted = (_y = object.hide_editted) != null ? _y : false;\n    message.is_public = (_z = object.is_public) != null ? _z : false;\n    message.topic_id = (_A = object.topic_id) != null ? _A : \"\";\n    return message;\n  }\n};\nfunction createBaseMessageMention() {\n  return { id: \"\", user_id: \"\", username: \"\", role_id: \"\", rolename: \"\", create_time: void 0, s: 0, e: 0 };\n}\nvar MessageMention = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.role_id !== \"\") {\n      writer.uint32(34).string(message.role_id);\n    }\n    if (message.rolename !== \"\") {\n      writer.uint32(42).string(message.rolename);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.s !== 0) {\n      writer.uint32(56).int32(message.s);\n    }\n    if (message.e !== 0) {\n      writer.uint32(64).int32(message.e);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageMention();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.rolename = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.s = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.e = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      role_id: isSet3(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      rolename: isSet3(object.rolename) ? globalThis.String(object.rolename) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      s: isSet3(object.s) ? globalThis.Number(object.s) : 0,\n      e: isSet3(object.e) ? globalThis.Number(object.e) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.rolename !== \"\") {\n      obj.rolename = message.rolename;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.s !== 0) {\n      obj.s = Math.round(message.s);\n    }\n    if (message.e !== 0) {\n      obj.e = Math.round(message.e);\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageMention.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseMessageMention();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.role_id = (_d = object.role_id) != null ? _d : \"\";\n    message.rolename = (_e = object.rolename) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.s = (_g = object.s) != null ? _g : 0;\n    message.e = (_h = object.e) != null ? _h : 0;\n    return message;\n  }\n};\nfunction createBaseMessageReaction() {\n  return {\n    id: \"\",\n    emoji_id: \"\",\n    emoji: \"\",\n    sender_id: \"\",\n    sender_name: \"\",\n    sender_avatar: \"\",\n    action: false,\n    count: 0,\n    channel_id: \"\",\n    message_id: \"\",\n    clan_id: \"\",\n    mode: 0,\n    message_sender_id: \"\",\n    is_public: false,\n    topic_id: \"\",\n    emoji_recent_id: \"\"\n  };\n}\nvar MessageReaction = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.emoji_id !== \"\") {\n      writer.uint32(18).string(message.emoji_id);\n    }\n    if (message.emoji !== \"\") {\n      writer.uint32(26).string(message.emoji);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(34).string(message.sender_id);\n    }\n    if (message.sender_name !== \"\") {\n      writer.uint32(42).string(message.sender_name);\n    }\n    if (message.sender_avatar !== \"\") {\n      writer.uint32(50).string(message.sender_avatar);\n    }\n    if (message.action !== false) {\n      writer.uint32(56).bool(message.action);\n    }\n    if (message.count !== 0) {\n      writer.uint32(64).int32(message.count);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(74).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(82).string(message.message_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(90).string(message.clan_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(96).int32(message.mode);\n    }\n    if (message.message_sender_id !== \"\") {\n      writer.uint32(106).string(message.message_sender_id);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(112).bool(message.is_public);\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(122).string(message.topic_id);\n    }\n    if (message.emoji_recent_id !== \"\") {\n      writer.uint32(130).string(message.emoji_recent_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageReaction();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.emoji_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.emoji = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.sender_name = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.sender_avatar = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.action = reader.bool();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.count = reader.int32();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 12:\n          if (tag !== 96) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.message_sender_id = reader.string();\n          continue;\n        case 14:\n          if (tag !== 112) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.emoji_recent_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      emoji_id: isSet3(object.emoji_id) ? globalThis.String(object.emoji_id) : \"\",\n      emoji: isSet3(object.emoji) ? globalThis.String(object.emoji) : \"\",\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      sender_name: isSet3(object.sender_name) ? globalThis.String(object.sender_name) : \"\",\n      sender_avatar: isSet3(object.sender_avatar) ? globalThis.String(object.sender_avatar) : \"\",\n      action: isSet3(object.action) ? globalThis.Boolean(object.action) : false,\n      count: isSet3(object.count) ? globalThis.Number(object.count) : 0,\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      mode: isSet3(object.mode) ? globalThis.Number(object.mode) : 0,\n      message_sender_id: isSet3(object.message_sender_id) ? globalThis.String(object.message_sender_id) : \"\",\n      is_public: isSet3(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      topic_id: isSet3(object.topic_id) ? globalThis.String(object.topic_id) : \"\",\n      emoji_recent_id: isSet3(object.emoji_recent_id) ? globalThis.String(object.emoji_recent_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.emoji_id !== \"\") {\n      obj.emoji_id = message.emoji_id;\n    }\n    if (message.emoji !== \"\") {\n      obj.emoji = message.emoji;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.sender_name !== \"\") {\n      obj.sender_name = message.sender_name;\n    }\n    if (message.sender_avatar !== \"\") {\n      obj.sender_avatar = message.sender_avatar;\n    }\n    if (message.action !== false) {\n      obj.action = message.action;\n    }\n    if (message.count !== 0) {\n      obj.count = Math.round(message.count);\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.message_sender_id !== \"\") {\n      obj.message_sender_id = message.message_sender_id;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    if (message.emoji_recent_id !== \"\") {\n      obj.emoji_recent_id = message.emoji_recent_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageReaction.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;\n    const message = createBaseMessageReaction();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.emoji_id = (_b = object.emoji_id) != null ? _b : \"\";\n    message.emoji = (_c = object.emoji) != null ? _c : \"\";\n    message.sender_id = (_d = object.sender_id) != null ? _d : \"\";\n    message.sender_name = (_e = object.sender_name) != null ? _e : \"\";\n    message.sender_avatar = (_f = object.sender_avatar) != null ? _f : \"\";\n    message.action = (_g = object.action) != null ? _g : false;\n    message.count = (_h = object.count) != null ? _h : 0;\n    message.channel_id = (_i = object.channel_id) != null ? _i : \"\";\n    message.message_id = (_j = object.message_id) != null ? _j : \"\";\n    message.clan_id = (_k = object.clan_id) != null ? _k : \"\";\n    message.mode = (_l = object.mode) != null ? _l : 0;\n    message.message_sender_id = (_m = object.message_sender_id) != null ? _m : \"\";\n    message.is_public = (_n = object.is_public) != null ? _n : false;\n    message.topic_id = (_o = object.topic_id) != null ? _o : \"\";\n    message.emoji_recent_id = (_p = object.emoji_recent_id) != null ? _p : \"\";\n    return message;\n  }\n};\nfunction createBaseMessageAttachment() {\n  return { filename: \"\", size: 0, url: \"\", filetype: \"\", width: 0, height: 0, thumbnail: \"\" };\n}\nvar MessageAttachment = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.filename !== \"\") {\n      writer.uint32(10).string(message.filename);\n    }\n    if (message.size !== 0) {\n      writer.uint32(16).int64(message.size);\n    }\n    if (message.url !== \"\") {\n      writer.uint32(26).string(message.url);\n    }\n    if (message.filetype !== \"\") {\n      writer.uint32(34).string(message.filetype);\n    }\n    if (message.width !== 0) {\n      writer.uint32(40).int32(message.width);\n    }\n    if (message.height !== 0) {\n      writer.uint32(48).int32(message.height);\n    }\n    if (message.thumbnail !== \"\") {\n      writer.uint32(58).string(message.thumbnail);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageAttachment();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.filename = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.size = longToNumber2(reader.int64());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.url = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.filetype = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.width = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.height = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.thumbnail = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      filename: isSet3(object.filename) ? globalThis.String(object.filename) : \"\",\n      size: isSet3(object.size) ? globalThis.Number(object.size) : 0,\n      url: isSet3(object.url) ? globalThis.String(object.url) : \"\",\n      filetype: isSet3(object.filetype) ? globalThis.String(object.filetype) : \"\",\n      width: isSet3(object.width) ? globalThis.Number(object.width) : 0,\n      height: isSet3(object.height) ? globalThis.Number(object.height) : 0,\n      thumbnail: isSet3(object.thumbnail) ? globalThis.String(object.thumbnail) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.filename !== \"\") {\n      obj.filename = message.filename;\n    }\n    if (message.size !== 0) {\n      obj.size = Math.round(message.size);\n    }\n    if (message.url !== \"\") {\n      obj.url = message.url;\n    }\n    if (message.filetype !== \"\") {\n      obj.filetype = message.filetype;\n    }\n    if (message.width !== 0) {\n      obj.width = Math.round(message.width);\n    }\n    if (message.height !== 0) {\n      obj.height = Math.round(message.height);\n    }\n    if (message.thumbnail !== \"\") {\n      obj.thumbnail = message.thumbnail;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageAttachment.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseMessageAttachment();\n    message.filename = (_a = object.filename) != null ? _a : \"\";\n    message.size = (_b = object.size) != null ? _b : 0;\n    message.url = (_c = object.url) != null ? _c : \"\";\n    message.filetype = (_d = object.filetype) != null ? _d : \"\";\n    message.width = (_e = object.width) != null ? _e : 0;\n    message.height = (_f = object.height) != null ? _f : 0;\n    message.thumbnail = (_g = object.thumbnail) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseMessageRef() {\n  return {\n    message_id: \"\",\n    message_ref_id: \"\",\n    content: \"\",\n    has_attachment: false,\n    ref_type: 0,\n    message_sender_id: \"\",\n    message_sender_username: \"\",\n    mesages_sender_avatar: \"\",\n    message_sender_clan_nick: \"\",\n    message_sender_display_name: \"\"\n  };\n}\nvar MessageRef = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.message_id !== \"\") {\n      writer.uint32(10).string(message.message_id);\n    }\n    if (message.message_ref_id !== \"\") {\n      writer.uint32(18).string(message.message_ref_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.has_attachment !== false) {\n      writer.uint32(32).bool(message.has_attachment);\n    }\n    if (message.ref_type !== 0) {\n      writer.uint32(40).int32(message.ref_type);\n    }\n    if (message.message_sender_id !== \"\") {\n      writer.uint32(50).string(message.message_sender_id);\n    }\n    if (message.message_sender_username !== \"\") {\n      writer.uint32(58).string(message.message_sender_username);\n    }\n    if (message.mesages_sender_avatar !== \"\") {\n      writer.uint32(66).string(message.mesages_sender_avatar);\n    }\n    if (message.message_sender_clan_nick !== \"\") {\n      writer.uint32(74).string(message.message_sender_clan_nick);\n    }\n    if (message.message_sender_display_name !== \"\") {\n      writer.uint32(82).string(message.message_sender_display_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageRef();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message_ref_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.has_attachment = reader.bool();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.ref_type = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.message_sender_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.message_sender_username = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.mesages_sender_avatar = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.message_sender_clan_nick = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.message_sender_display_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      message_ref_id: isSet3(object.message_ref_id) ? globalThis.String(object.message_ref_id) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      has_attachment: isSet3(object.has_attachment) ? globalThis.Boolean(object.has_attachment) : false,\n      ref_type: isSet3(object.ref_type) ? globalThis.Number(object.ref_type) : 0,\n      message_sender_id: isSet3(object.message_sender_id) ? globalThis.String(object.message_sender_id) : \"\",\n      message_sender_username: isSet3(object.message_sender_username) ? globalThis.String(object.message_sender_username) : \"\",\n      mesages_sender_avatar: isSet3(object.mesages_sender_avatar) ? globalThis.String(object.mesages_sender_avatar) : \"\",\n      message_sender_clan_nick: isSet3(object.message_sender_clan_nick) ? globalThis.String(object.message_sender_clan_nick) : \"\",\n      message_sender_display_name: isSet3(object.message_sender_display_name) ? globalThis.String(object.message_sender_display_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.message_ref_id !== \"\") {\n      obj.message_ref_id = message.message_ref_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.has_attachment !== false) {\n      obj.has_attachment = message.has_attachment;\n    }\n    if (message.ref_type !== 0) {\n      obj.ref_type = Math.round(message.ref_type);\n    }\n    if (message.message_sender_id !== \"\") {\n      obj.message_sender_id = message.message_sender_id;\n    }\n    if (message.message_sender_username !== \"\") {\n      obj.message_sender_username = message.message_sender_username;\n    }\n    if (message.mesages_sender_avatar !== \"\") {\n      obj.mesages_sender_avatar = message.mesages_sender_avatar;\n    }\n    if (message.message_sender_clan_nick !== \"\") {\n      obj.message_sender_clan_nick = message.message_sender_clan_nick;\n    }\n    if (message.message_sender_display_name !== \"\") {\n      obj.message_sender_display_name = message.message_sender_display_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageRef.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseMessageRef();\n    message.message_id = (_a = object.message_id) != null ? _a : \"\";\n    message.message_ref_id = (_b = object.message_ref_id) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.has_attachment = (_d = object.has_attachment) != null ? _d : false;\n    message.ref_type = (_e = object.ref_type) != null ? _e : 0;\n    message.message_sender_id = (_f = object.message_sender_id) != null ? _f : \"\";\n    message.message_sender_username = (_g = object.message_sender_username) != null ? _g : \"\";\n    message.mesages_sender_avatar = (_h = object.mesages_sender_avatar) != null ? _h : \"\";\n    message.message_sender_clan_nick = (_i = object.message_sender_clan_nick) != null ? _i : \"\";\n    message.message_sender_display_name = (_j = object.message_sender_display_name) != null ? _j : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelMessageList() {\n  return { messages: [], last_seen_message: void 0, last_sent_message: void 0 };\n}\nvar ChannelMessageList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.messages) {\n      ChannelMessage.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.last_seen_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.last_sent_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.messages.push(ChannelMessage.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      messages: globalThis.Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e) => ChannelMessage.fromJSON(e)) : [],\n      last_seen_message: isSet3(object.last_seen_message) ? ChannelMessageHeader.fromJSON(object.last_seen_message) : void 0,\n      last_sent_message: isSet3(object.last_sent_message) ? ChannelMessageHeader.fromJSON(object.last_sent_message) : void 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.messages) == null ? void 0 : _a.length) {\n      obj.messages = message.messages.map((e) => ChannelMessage.toJSON(e));\n    }\n    if (message.last_seen_message !== void 0) {\n      obj.last_seen_message = ChannelMessageHeader.toJSON(message.last_seen_message);\n    }\n    if (message.last_sent_message !== void 0) {\n      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseChannelMessageList();\n    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => ChannelMessage.fromPartial(e))) || [];\n    message.last_seen_message = object.last_seen_message !== void 0 && object.last_seen_message !== null ? ChannelMessageHeader.fromPartial(object.last_seen_message) : void 0;\n    message.last_sent_message = object.last_sent_message !== void 0 && object.last_sent_message !== null ? ChannelMessageHeader.fromPartial(object.last_sent_message) : void 0;\n    return message;\n  }\n};\nfunction createBaseChannelUserList() {\n  return { channel_users: [], cursor: \"\", channel_id: \"\" };\n}\nvar ChannelUserList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.channel_users) {\n      ChannelUserList_ChannelUser.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(18).string(message.cursor);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelUserList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_users.push(ChannelUserList_ChannelUser.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_users: globalThis.Array.isArray(object == null ? void 0 : object.channel_users) ? object.channel_users.map((e) => ChannelUserList_ChannelUser.fromJSON(e)) : [],\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.channel_users) == null ? void 0 : _a.length) {\n      obj.channel_users = message.channel_users.map((e) => ChannelUserList_ChannelUser.toJSON(e));\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelUserList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseChannelUserList();\n    message.channel_users = ((_a = object.channel_users) == null ? void 0 : _a.map((e) => ChannelUserList_ChannelUser.fromPartial(e))) || [];\n    message.cursor = (_b = object.cursor) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelUserList_ChannelUser() {\n  return { user_id: \"\", role_id: [], id: \"\", thread_id: \"\", clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\n}\nvar ChannelUserList_ChannelUser = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    for (const v of message.role_id) {\n      writer.uint32(18).string(v);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.thread_id !== \"\") {\n      writer.uint32(34).string(message.thread_id);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(42).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(50).string(message.clan_avatar);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(58).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelUserList_ChannelUser();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.role_id.push(reader.string());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.thread_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.clan_nick = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_avatar = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      role_id: globalThis.Array.isArray(object == null ? void 0 : object.role_id) ? object.role_id.map((e) => globalThis.String(e)) : [],\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      thread_id: isSet3(object.thread_id) ? globalThis.String(object.thread_id) : \"\",\n      clan_nick: isSet3(object.clan_nick) ? globalThis.String(object.clan_nick) : \"\",\n      clan_avatar: isSet3(object.clan_avatar) ? globalThis.String(object.clan_avatar) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if ((_a = message.role_id) == null ? void 0 : _a.length) {\n      obj.role_id = message.role_id;\n    }\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.thread_id !== \"\") {\n      obj.thread_id = message.thread_id;\n    }\n    if (message.clan_nick !== \"\") {\n      obj.clan_nick = message.clan_nick;\n    }\n    if (message.clan_avatar !== \"\") {\n      obj.clan_avatar = message.clan_avatar;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelUserList_ChannelUser.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseChannelUserList_ChannelUser();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.role_id = ((_b = object.role_id) == null ? void 0 : _b.map((e) => e)) || [];\n    message.id = (_c = object.id) != null ? _c : \"\";\n    message.thread_id = (_d = object.thread_id) != null ? _d : \"\";\n    message.clan_nick = (_e = object.clan_nick) != null ? _e : \"\";\n    message.clan_avatar = (_f = object.clan_avatar) != null ? _f : \"\";\n    message.clan_id = (_g = object.clan_id) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceChannelUser() {\n  return { id: \"\", user_id: \"\", channel_id: \"\", participant: \"\" };\n}\nvar VoiceChannelUser = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    if (message.participant !== \"\") {\n      writer.uint32(34).string(message.participant);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceChannelUser();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.participant = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      participant: isSet3(object.participant) ? globalThis.String(object.participant) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.participant !== \"\") {\n      obj.participant = message.participant;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceChannelUser.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseVoiceChannelUser();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.participant = (_d = object.participant) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceChannelUserList() {\n  return { voice_channel_users: [] };\n}\nvar VoiceChannelUserList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.voice_channel_users) {\n      VoiceChannelUser.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceChannelUserList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.voice_channel_users.push(VoiceChannelUser.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      voice_channel_users: globalThis.Array.isArray(object == null ? void 0 : object.voice_channel_users) ? object.voice_channel_users.map((e) => VoiceChannelUser.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.voice_channel_users) == null ? void 0 : _a.length) {\n      obj.voice_channel_users = message.voice_channel_users.map((e) => VoiceChannelUser.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceChannelUserList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseVoiceChannelUserList();\n    message.voice_channel_users = ((_a = object.voice_channel_users) == null ? void 0 : _a.map((e) => VoiceChannelUser.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseChannelAttachment() {\n  return {\n    id: \"\",\n    filename: \"\",\n    filetype: \"\",\n    filesize: \"\",\n    url: \"\",\n    uploader: \"\",\n    create_time: void 0,\n    message_id: \"\",\n    width: 0,\n    height: 0\n  };\n}\nvar ChannelAttachment = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.filename !== \"\") {\n      writer.uint32(18).string(message.filename);\n    }\n    if (message.filetype !== \"\") {\n      writer.uint32(26).string(message.filetype);\n    }\n    if (message.filesize !== \"\") {\n      writer.uint32(34).string(message.filesize);\n    }\n    if (message.url !== \"\") {\n      writer.uint32(42).string(message.url);\n    }\n    if (message.uploader !== \"\") {\n      writer.uint32(50).string(message.uploader);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(58).fork()).ldelim();\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(66).string(message.message_id);\n    }\n    if (message.width !== 0) {\n      writer.uint32(72).int32(message.width);\n    }\n    if (message.height !== 0) {\n      writer.uint32(80).int32(message.height);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelAttachment();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.filename = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.filetype = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.filesize = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.url = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.uploader = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.width = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.height = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      filename: isSet3(object.filename) ? globalThis.String(object.filename) : \"\",\n      filetype: isSet3(object.filetype) ? globalThis.String(object.filetype) : \"\",\n      filesize: isSet3(object.filesize) ? globalThis.String(object.filesize) : \"\",\n      url: isSet3(object.url) ? globalThis.String(object.url) : \"\",\n      uploader: isSet3(object.uploader) ? globalThis.String(object.uploader) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      width: isSet3(object.width) ? globalThis.Number(object.width) : 0,\n      height: isSet3(object.height) ? globalThis.Number(object.height) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.filename !== \"\") {\n      obj.filename = message.filename;\n    }\n    if (message.filetype !== \"\") {\n      obj.filetype = message.filetype;\n    }\n    if (message.filesize !== \"\") {\n      obj.filesize = message.filesize;\n    }\n    if (message.url !== \"\") {\n      obj.url = message.url;\n    }\n    if (message.uploader !== \"\") {\n      obj.uploader = message.uploader;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.width !== 0) {\n      obj.width = Math.round(message.width);\n    }\n    if (message.height !== 0) {\n      obj.height = Math.round(message.height);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelAttachment.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseChannelAttachment();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.filename = (_b = object.filename) != null ? _b : \"\";\n    message.filetype = (_c = object.filetype) != null ? _c : \"\";\n    message.filesize = (_d = object.filesize) != null ? _d : \"\";\n    message.url = (_e = object.url) != null ? _e : \"\";\n    message.uploader = (_f = object.uploader) != null ? _f : \"\";\n    message.create_time = (_g = object.create_time) != null ? _g : void 0;\n    message.message_id = (_h = object.message_id) != null ? _h : \"\";\n    message.width = (_i = object.width) != null ? _i : 0;\n    message.height = (_j = object.height) != null ? _j : 0;\n    return message;\n  }\n};\nfunction createBaseChannelAttachmentList() {\n  return { attachments: [] };\n}\nvar ChannelAttachmentList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.attachments) {\n      ChannelAttachment.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelAttachmentList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.attachments.push(ChannelAttachment.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      attachments: globalThis.Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => ChannelAttachment.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.attachments) == null ? void 0 : _a.length) {\n      obj.attachments = message.attachments.map((e) => ChannelAttachment.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelAttachmentList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseChannelAttachmentList();\n    message.attachments = ((_a = object.attachments) == null ? void 0 : _a.map((e) => ChannelAttachment.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseListChannelMessagesRequest() {\n  return { clan_id: \"\", channel_id: \"\", message_id: \"\", limit: void 0, direction: void 0, topic_id: \"\" };\n}\nvar ListChannelMessagesRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.direction !== void 0) {\n      Int32Value.encode({ value: message.direction }, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(50).string(message.topic_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListChannelMessagesRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.direction = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet3(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      direction: isSet3(object.direction) ? Number(object.direction) : void 0,\n      topic_id: isSet3(object.topic_id) ? globalThis.String(object.topic_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.direction !== void 0) {\n      obj.direction = message.direction;\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListChannelMessagesRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseListChannelMessagesRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.limit = (_d = object.limit) != null ? _d : void 0;\n    message.direction = (_e = object.direction) != null ? _e : void 0;\n    message.topic_id = (_f = object.topic_id) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseListChannelUsersRequest() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0, limit: void 0, state: void 0, cursor: \"\" };\n}\nvar ListChannelUsersRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.state !== void 0) {\n      Int32Value.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(50).string(message.cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListChannelUsersRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.state = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet3(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      state: isSet3(object.state) ? Number(object.state) : void 0,\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.state !== void 0) {\n      obj.state = message.state;\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListChannelUsersRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseListChannelUsersRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    message.limit = (_d = object.limit) != null ? _d : void 0;\n    message.state = (_e = object.state) != null ? _e : void 0;\n    message.cursor = (_f = object.cursor) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseListChannelAttachmentRequest() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    file_type: \"\",\n    limit: void 0,\n    state: void 0,\n    before: \"\",\n    after: \"\",\n    around: \"\"\n  };\n}\nvar ListChannelAttachmentRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.file_type !== \"\") {\n      writer.uint32(26).string(message.file_type);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.state !== void 0) {\n      Int32Value.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.before !== \"\") {\n      writer.uint32(50).string(message.before);\n    }\n    if (message.after !== \"\") {\n      writer.uint32(58).string(message.after);\n    }\n    if (message.around !== \"\") {\n      writer.uint32(66).string(message.around);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListChannelAttachmentRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.file_type = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.state = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.before = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.after = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.around = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      file_type: isSet3(object.file_type) ? globalThis.String(object.file_type) : \"\",\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      state: isSet3(object.state) ? Number(object.state) : void 0,\n      before: isSet3(object.before) ? globalThis.String(object.before) : \"\",\n      after: isSet3(object.after) ? globalThis.String(object.after) : \"\",\n      around: isSet3(object.around) ? globalThis.String(object.around) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.file_type !== \"\") {\n      obj.file_type = message.file_type;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.state !== void 0) {\n      obj.state = message.state;\n    }\n    if (message.before !== \"\") {\n      obj.before = message.before;\n    }\n    if (message.after !== \"\") {\n      obj.after = message.after;\n    }\n    if (message.around !== \"\") {\n      obj.around = message.around;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListChannelAttachmentRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseListChannelAttachmentRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.file_type = (_c = object.file_type) != null ? _c : \"\";\n    message.limit = (_d = object.limit) != null ? _d : void 0;\n    message.state = (_e = object.state) != null ? _e : void 0;\n    message.before = (_f = object.before) != null ? _f : \"\";\n    message.after = (_g = object.after) != null ? _g : \"\";\n    message.around = (_h = object.around) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseListNotificationsRequest() {\n  return { limit: void 0, clan_id: \"\", notification_id: \"\", category: 0, direction: void 0 };\n}\nvar ListNotificationsRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.notification_id !== \"\") {\n      writer.uint32(26).string(message.notification_id);\n    }\n    if (message.category !== 0) {\n      writer.uint32(32).int32(message.category);\n    }\n    if (message.direction !== void 0) {\n      Int32Value.encode({ value: message.direction }, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListNotificationsRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.notification_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.category = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.direction = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      notification_id: isSet3(object.notification_id) ? globalThis.String(object.notification_id) : \"\",\n      category: isSet3(object.category) ? globalThis.Number(object.category) : 0,\n      direction: isSet3(object.direction) ? Number(object.direction) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.notification_id !== \"\") {\n      obj.notification_id = message.notification_id;\n    }\n    if (message.category !== 0) {\n      obj.category = Math.round(message.category);\n    }\n    if (message.direction !== void 0) {\n      obj.direction = message.direction;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListNotificationsRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseListNotificationsRequest();\n    message.limit = (_a = object.limit) != null ? _a : void 0;\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.notification_id = (_c = object.notification_id) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : 0;\n    message.direction = (_e = object.direction) != null ? _e : void 0;\n    return message;\n  }\n};\nfunction createBaseNotification() {\n  return {\n    id: \"\",\n    subject: \"\",\n    content: \"\",\n    code: 0,\n    sender_id: \"\",\n    create_time: void 0,\n    persistent: false,\n    clan_id: \"\",\n    channel_id: \"\",\n    channel_type: 0,\n    avatar_url: \"\",\n    channel: void 0,\n    topic_id: \"\",\n    category: 0\n  };\n}\nvar Notification = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.subject !== \"\") {\n      writer.uint32(18).string(message.subject);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.code !== 0) {\n      writer.uint32(32).int32(message.code);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(42).string(message.sender_id);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.persistent !== false) {\n      writer.uint32(56).bool(message.persistent);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(66).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(74).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(80).int32(message.channel_type);\n    }\n    if (message.avatar_url !== \"\") {\n      writer.uint32(90).string(message.avatar_url);\n    }\n    if (message.channel !== void 0) {\n      ChannelDescription.encode(message.channel, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(106).string(message.topic_id);\n    }\n    if (message.category !== 0) {\n      writer.uint32(112).int32(message.category);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotification();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.subject = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.code = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.persistent = reader.bool();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.avatar_url = reader.string();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.channel = ChannelDescription.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n        case 14:\n          if (tag !== 112) {\n            break;\n          }\n          message.category = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      subject: isSet3(object.subject) ? globalThis.String(object.subject) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      code: isSet3(object.code) ? globalThis.Number(object.code) : 0,\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      persistent: isSet3(object.persistent) ? globalThis.Boolean(object.persistent) : false,\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet3(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      avatar_url: isSet3(object.avatar_url) ? globalThis.String(object.avatar_url) : \"\",\n      channel: isSet3(object.channel) ? ChannelDescription.fromJSON(object.channel) : void 0,\n      topic_id: isSet3(object.topic_id) ? globalThis.String(object.topic_id) : \"\",\n      category: isSet3(object.category) ? globalThis.Number(object.category) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.subject !== \"\") {\n      obj.subject = message.subject;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.code !== 0) {\n      obj.code = Math.round(message.code);\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.persistent !== false) {\n      obj.persistent = message.persistent;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.avatar_url !== \"\") {\n      obj.avatar_url = message.avatar_url;\n    }\n    if (message.channel !== void 0) {\n      obj.channel = ChannelDescription.toJSON(message.channel);\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    if (message.category !== 0) {\n      obj.category = Math.round(message.category);\n    }\n    return obj;\n  },\n  create(base) {\n    return Notification.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;\n    const message = createBaseNotification();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.subject = (_b = object.subject) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.code = (_d = object.code) != null ? _d : 0;\n    message.sender_id = (_e = object.sender_id) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.persistent = (_g = object.persistent) != null ? _g : false;\n    message.clan_id = (_h = object.clan_id) != null ? _h : \"\";\n    message.channel_id = (_i = object.channel_id) != null ? _i : \"\";\n    message.channel_type = (_j = object.channel_type) != null ? _j : 0;\n    message.avatar_url = (_k = object.avatar_url) != null ? _k : \"\";\n    message.channel = object.channel !== void 0 && object.channel !== null ? ChannelDescription.fromPartial(object.channel) : void 0;\n    message.topic_id = (_l = object.topic_id) != null ? _l : \"\";\n    message.category = (_m = object.category) != null ? _m : 0;\n    return message;\n  }\n};\nfunction createBaseEmojiRecent() {\n  return { emoji_recents_id: \"\", emoji_id: \"\", update_time: void 0 };\n}\nvar EmojiRecent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.emoji_recents_id !== \"\") {\n      writer.uint32(10).string(message.emoji_recents_id);\n    }\n    if (message.emoji_id !== \"\") {\n      writer.uint32(18).string(message.emoji_id);\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEmojiRecent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.emoji_recents_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.emoji_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      emoji_recents_id: isSet3(object.emoji_recents_id) ? globalThis.String(object.emoji_recents_id) : \"\",\n      emoji_id: isSet3(object.emoji_id) ? globalThis.String(object.emoji_id) : \"\",\n      update_time: isSet3(object.update_time) ? fromJsonTimestamp(object.update_time) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.emoji_recents_id !== \"\") {\n      obj.emoji_recents_id = message.emoji_recents_id;\n    }\n    if (message.emoji_id !== \"\") {\n      obj.emoji_id = message.emoji_id;\n    }\n    if (message.update_time !== void 0) {\n      obj.update_time = message.update_time.toISOString();\n    }\n    return obj;\n  },\n  create(base) {\n    return EmojiRecent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseEmojiRecent();\n    message.emoji_recents_id = (_a = object.emoji_recents_id) != null ? _a : \"\";\n    message.emoji_id = (_b = object.emoji_id) != null ? _b : \"\";\n    message.update_time = (_c = object.update_time) != null ? _c : void 0;\n    return message;\n  }\n};\nfunction createBaseEmojiRecentList() {\n  return { emoji_recents: [] };\n}\nvar EmojiRecentList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.emoji_recents) {\n      EmojiRecent.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEmojiRecentList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.emoji_recents.push(EmojiRecent.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      emoji_recents: globalThis.Array.isArray(object == null ? void 0 : object.emoji_recents) ? object.emoji_recents.map((e) => EmojiRecent.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.emoji_recents) == null ? void 0 : _a.length) {\n      obj.emoji_recents = message.emoji_recents.map((e) => EmojiRecent.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return EmojiRecentList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseEmojiRecentList();\n    message.emoji_recents = ((_a = object.emoji_recents) == null ? void 0 : _a.map((e) => EmojiRecent.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseNotificationList() {\n  return { notifications: [], cacheable_cursor: \"\" };\n}\nvar NotificationList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.notifications) {\n      Notification.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.cacheable_cursor !== \"\") {\n      writer.uint32(18).string(message.cacheable_cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.notifications.push(Notification.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.cacheable_cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      notifications: globalThis.Array.isArray(object == null ? void 0 : object.notifications) ? object.notifications.map((e) => Notification.fromJSON(e)) : [],\n      cacheable_cursor: isSet3(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.notifications) == null ? void 0 : _a.length) {\n      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));\n    }\n    if (message.cacheable_cursor !== \"\") {\n      obj.cacheable_cursor = message.cacheable_cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseNotificationList();\n    message.notifications = ((_a = object.notifications) == null ? void 0 : _a.map((e) => Notification.fromPartial(e))) || [];\n    message.cacheable_cursor = (_b = object.cacheable_cursor) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseRpc() {\n  return { id: \"\", payload: \"\", http_key: \"\" };\n}\nvar Rpc = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.payload !== \"\") {\n      writer.uint32(18).string(message.payload);\n    }\n    if (message.http_key !== \"\") {\n      writer.uint32(26).string(message.http_key);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRpc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.payload = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.http_key = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      payload: isSet3(object.payload) ? globalThis.String(object.payload) : \"\",\n      http_key: isSet3(object.http_key) ? globalThis.String(object.http_key) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.payload !== \"\") {\n      obj.payload = message.payload;\n    }\n    if (message.http_key !== \"\") {\n      obj.http_key = message.http_key;\n    }\n    return obj;\n  },\n  create(base) {\n    return Rpc.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseRpc();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.payload = (_b = object.payload) != null ? _b : \"\";\n    message.http_key = (_c = object.http_key) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseClanDesc() {\n  return {\n    creator_id: \"\",\n    clan_name: \"\",\n    logo: \"\",\n    banner: \"\",\n    clan_id: \"\",\n    status: 0,\n    badge_count: 0,\n    is_onboarding: false,\n    welcome_channel_id: \"\",\n    onboarding_banner: \"\",\n    clan_order: 0\n  };\n}\nvar ClanDesc = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.creator_id !== \"\") {\n      writer.uint32(10).string(message.creator_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(26).string(message.logo);\n    }\n    if (message.banner !== \"\") {\n      writer.uint32(34).string(message.banner);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(42).string(message.clan_id);\n    }\n    if (message.status !== 0) {\n      writer.uint32(48).int32(message.status);\n    }\n    if (message.badge_count !== 0) {\n      writer.uint32(56).int32(message.badge_count);\n    }\n    if (message.is_onboarding !== false) {\n      writer.uint32(64).bool(message.is_onboarding);\n    }\n    if (message.welcome_channel_id !== \"\") {\n      writer.uint32(74).string(message.welcome_channel_id);\n    }\n    if (message.onboarding_banner !== \"\") {\n      writer.uint32(82).string(message.onboarding_banner);\n    }\n    if (message.clan_order !== 0) {\n      writer.uint32(88).int32(message.clan_order);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanDesc();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.banner = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.badge_count = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.is_onboarding = reader.bool();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.welcome_channel_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.onboarding_banner = reader.string();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.clan_order = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      logo: isSet3(object.logo) ? globalThis.String(object.logo) : \"\",\n      banner: isSet3(object.banner) ? globalThis.String(object.banner) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      status: isSet3(object.status) ? globalThis.Number(object.status) : 0,\n      badge_count: isSet3(object.badge_count) ? globalThis.Number(object.badge_count) : 0,\n      is_onboarding: isSet3(object.is_onboarding) ? globalThis.Boolean(object.is_onboarding) : false,\n      welcome_channel_id: isSet3(object.welcome_channel_id) ? globalThis.String(object.welcome_channel_id) : \"\",\n      onboarding_banner: isSet3(object.onboarding_banner) ? globalThis.String(object.onboarding_banner) : \"\",\n      clan_order: isSet3(object.clan_order) ? globalThis.Number(object.clan_order) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.banner !== \"\") {\n      obj.banner = message.banner;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.badge_count !== 0) {\n      obj.badge_count = Math.round(message.badge_count);\n    }\n    if (message.is_onboarding !== false) {\n      obj.is_onboarding = message.is_onboarding;\n    }\n    if (message.welcome_channel_id !== \"\") {\n      obj.welcome_channel_id = message.welcome_channel_id;\n    }\n    if (message.onboarding_banner !== \"\") {\n      obj.onboarding_banner = message.onboarding_banner;\n    }\n    if (message.clan_order !== 0) {\n      obj.clan_order = Math.round(message.clan_order);\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanDesc.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseClanDesc();\n    message.creator_id = (_a = object.creator_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.logo = (_c = object.logo) != null ? _c : \"\";\n    message.banner = (_d = object.banner) != null ? _d : \"\";\n    message.clan_id = (_e = object.clan_id) != null ? _e : \"\";\n    message.status = (_f = object.status) != null ? _f : 0;\n    message.badge_count = (_g = object.badge_count) != null ? _g : 0;\n    message.is_onboarding = (_h = object.is_onboarding) != null ? _h : false;\n    message.welcome_channel_id = (_i = object.welcome_channel_id) != null ? _i : \"\";\n    message.onboarding_banner = (_j = object.onboarding_banner) != null ? _j : \"\";\n    message.clan_order = (_k = object.clan_order) != null ? _k : 0;\n    return message;\n  }\n};\nfunction createBaseListClanDescRequest() {\n  return { limit: void 0, state: void 0, cursor: \"\" };\n}\nvar ListClanDescRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.state !== void 0) {\n      Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(26).string(message.cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListClanDescRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.state = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      state: isSet3(object.state) ? Number(object.state) : void 0,\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.state !== void 0) {\n      obj.state = message.state;\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListClanDescRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseListClanDescRequest();\n    message.limit = (_a = object.limit) != null ? _a : void 0;\n    message.state = (_b = object.state) != null ? _b : void 0;\n    message.cursor = (_c = object.cursor) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseClanDescList() {\n  return { clandesc: [] };\n}\nvar ClanDescList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.clandesc) {\n      ClanDesc.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanDescList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clandesc.push(ClanDesc.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clandesc: globalThis.Array.isArray(object == null ? void 0 : object.clandesc) ? object.clandesc.map((e) => ClanDesc.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.clandesc) == null ? void 0 : _a.length) {\n      obj.clandesc = message.clandesc.map((e) => ClanDesc.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanDescList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseClanDescList();\n    message.clandesc = ((_a = object.clandesc) == null ? void 0 : _a.map((e) => ClanDesc.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseChannelMessageHeader() {\n  return {\n    id: \"\",\n    timestamp_seconds: 0,\n    sender_id: \"\",\n    content: \"\",\n    attachment: \"\",\n    reference: \"\",\n    mention: \"\",\n    reaction: \"\",\n    repliers: []\n  };\n}\nvar ChannelMessageHeader = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.timestamp_seconds !== 0) {\n      writer.uint32(16).uint32(message.timestamp_seconds);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(26).string(message.sender_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(34).string(message.content);\n    }\n    if (message.attachment !== \"\") {\n      writer.uint32(42).string(message.attachment);\n    }\n    if (message.reference !== \"\") {\n      writer.uint32(50).string(message.reference);\n    }\n    if (message.mention !== \"\") {\n      writer.uint32(58).string(message.mention);\n    }\n    if (message.reaction !== \"\") {\n      writer.uint32(66).string(message.reaction);\n    }\n    for (const v of message.repliers) {\n      writer.uint32(74).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageHeader();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.timestamp_seconds = reader.uint32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.attachment = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.reference = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.mention = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.reaction = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.repliers.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      timestamp_seconds: isSet3(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      content: isSet3(object.content) ? globalThis.String(object.content) : \"\",\n      attachment: isSet3(object.attachment) ? globalThis.String(object.attachment) : \"\",\n      reference: isSet3(object.reference) ? globalThis.String(object.reference) : \"\",\n      mention: isSet3(object.mention) ? globalThis.String(object.mention) : \"\",\n      reaction: isSet3(object.reaction) ? globalThis.String(object.reaction) : \"\",\n      repliers: globalThis.Array.isArray(object == null ? void 0 : object.repliers) ? object.repliers.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.timestamp_seconds !== 0) {\n      obj.timestamp_seconds = Math.round(message.timestamp_seconds);\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.attachment !== \"\") {\n      obj.attachment = message.attachment;\n    }\n    if (message.reference !== \"\") {\n      obj.reference = message.reference;\n    }\n    if (message.mention !== \"\") {\n      obj.mention = message.mention;\n    }\n    if (message.reaction !== \"\") {\n      obj.reaction = message.reaction;\n    }\n    if ((_a = message.repliers) == null ? void 0 : _a.length) {\n      obj.repliers = message.repliers;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageHeader.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseChannelMessageHeader();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.timestamp_seconds = (_b = object.timestamp_seconds) != null ? _b : 0;\n    message.sender_id = (_c = object.sender_id) != null ? _c : \"\";\n    message.content = (_d = object.content) != null ? _d : \"\";\n    message.attachment = (_e = object.attachment) != null ? _e : \"\";\n    message.reference = (_f = object.reference) != null ? _f : \"\";\n    message.mention = (_g = object.mention) != null ? _g : \"\";\n    message.reaction = (_h = object.reaction) != null ? _h : \"\";\n    message.repliers = ((_i = object.repliers) == null ? void 0 : _i.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseChannelDescription() {\n  return {\n    clan_id: \"\",\n    parent_id: \"\",\n    channel_id: \"\",\n    category_id: \"\",\n    category_name: \"\",\n    type: void 0,\n    creator_id: \"\",\n    channel_label: \"\",\n    channel_private: 0,\n    channel_avatar: [],\n    user_id: [],\n    last_sent_message: void 0,\n    last_seen_message: void 0,\n    is_online: [],\n    meeting_code: \"\",\n    count_mess_unread: 0,\n    active: 0,\n    last_pin_message: \"\",\n    usernames: [],\n    creator_name: \"\",\n    create_time_seconds: 0,\n    update_time_seconds: 0,\n    metadata: [],\n    about_me: [],\n    clan_name: \"\",\n    app_id: \"\",\n    is_mute: false,\n    age_restricted: 0,\n    topic: \"\",\n    e2ee: 0,\n    display_names: []\n  };\n}\nvar ChannelDescription = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(18).string(message.parent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(34).string(message.category_id);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(42).string(message.category_name);\n    }\n    if (message.type !== void 0) {\n      Int32Value.encode({ value: message.type }, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(58).string(message.creator_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(66).string(message.channel_label);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(72).int32(message.channel_private);\n    }\n    for (const v of message.channel_avatar) {\n      writer.uint32(82).string(v);\n    }\n    for (const v of message.user_id) {\n      writer.uint32(90).string(v);\n    }\n    if (message.last_sent_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.last_seen_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(106).fork()).ldelim();\n    }\n    writer.uint32(114).fork();\n    for (const v of message.is_online) {\n      writer.bool(v);\n    }\n    writer.ldelim();\n    if (message.meeting_code !== \"\") {\n      writer.uint32(122).string(message.meeting_code);\n    }\n    if (message.count_mess_unread !== 0) {\n      writer.uint32(128).int32(message.count_mess_unread);\n    }\n    if (message.active !== 0) {\n      writer.uint32(136).int32(message.active);\n    }\n    if (message.last_pin_message !== \"\") {\n      writer.uint32(146).string(message.last_pin_message);\n    }\n    for (const v of message.usernames) {\n      writer.uint32(154).string(v);\n    }\n    if (message.creator_name !== \"\") {\n      writer.uint32(162).string(message.creator_name);\n    }\n    if (message.create_time_seconds !== 0) {\n      writer.uint32(168).uint32(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      writer.uint32(176).uint32(message.update_time_seconds);\n    }\n    for (const v of message.metadata) {\n      writer.uint32(186).string(v);\n    }\n    for (const v of message.about_me) {\n      writer.uint32(194).string(v);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(202).string(message.clan_name);\n    }\n    if (message.app_id !== \"\") {\n      writer.uint32(210).string(message.app_id);\n    }\n    if (message.is_mute !== false) {\n      writer.uint32(216).bool(message.is_mute);\n    }\n    if (message.age_restricted !== 0) {\n      writer.uint32(224).int32(message.age_restricted);\n    }\n    if (message.topic !== \"\") {\n      writer.uint32(234).string(message.topic);\n    }\n    if (message.e2ee !== 0) {\n      writer.uint32(240).int32(message.e2ee);\n    }\n    for (const v of message.display_names) {\n      writer.uint32(250).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescription();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.channel_avatar.push(reader.string());\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.user_id.push(reader.string());\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag === 112) {\n            message.is_online.push(reader.bool());\n            continue;\n          }\n          if (tag === 114) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.is_online.push(reader.bool());\n            }\n            continue;\n          }\n          break;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 16:\n          if (tag !== 128) {\n            break;\n          }\n          message.count_mess_unread = reader.int32();\n          continue;\n        case 17:\n          if (tag !== 136) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.last_pin_message = reader.string();\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.usernames.push(reader.string());\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.creator_name = reader.string();\n          continue;\n        case 21:\n          if (tag !== 168) {\n            break;\n          }\n          message.create_time_seconds = reader.uint32();\n          continue;\n        case 22:\n          if (tag !== 176) {\n            break;\n          }\n          message.update_time_seconds = reader.uint32();\n          continue;\n        case 23:\n          if (tag !== 186) {\n            break;\n          }\n          message.metadata.push(reader.string());\n          continue;\n        case 24:\n          if (tag !== 194) {\n            break;\n          }\n          message.about_me.push(reader.string());\n          continue;\n        case 25:\n          if (tag !== 202) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 26:\n          if (tag !== 210) {\n            break;\n          }\n          message.app_id = reader.string();\n          continue;\n        case 27:\n          if (tag !== 216) {\n            break;\n          }\n          message.is_mute = reader.bool();\n          continue;\n        case 28:\n          if (tag !== 224) {\n            break;\n          }\n          message.age_restricted = reader.int32();\n          continue;\n        case 29:\n          if (tag !== 234) {\n            break;\n          }\n          message.topic = reader.string();\n          continue;\n        case 30:\n          if (tag !== 240) {\n            break;\n          }\n          message.e2ee = reader.int32();\n          continue;\n        case 31:\n          if (tag !== 250) {\n            break;\n          }\n          message.display_names.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      parent_id: isSet3(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      category_id: isSet3(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      category_name: isSet3(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      type: isSet3(object.type) ? Number(object.type) : void 0,\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      channel_private: isSet3(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      channel_avatar: globalThis.Array.isArray(object == null ? void 0 : object.channel_avatar) ? object.channel_avatar.map((e) => globalThis.String(e)) : [],\n      user_id: globalThis.Array.isArray(object == null ? void 0 : object.user_id) ? object.user_id.map((e) => globalThis.String(e)) : [],\n      last_sent_message: isSet3(object.last_sent_message) ? ChannelMessageHeader.fromJSON(object.last_sent_message) : void 0,\n      last_seen_message: isSet3(object.last_seen_message) ? ChannelMessageHeader.fromJSON(object.last_seen_message) : void 0,\n      is_online: globalThis.Array.isArray(object == null ? void 0 : object.is_online) ? object.is_online.map((e) => globalThis.Boolean(e)) : [],\n      meeting_code: isSet3(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      count_mess_unread: isSet3(object.count_mess_unread) ? globalThis.Number(object.count_mess_unread) : 0,\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      last_pin_message: isSet3(object.last_pin_message) ? globalThis.String(object.last_pin_message) : \"\",\n      usernames: globalThis.Array.isArray(object == null ? void 0 : object.usernames) ? object.usernames.map((e) => globalThis.String(e)) : [],\n      creator_name: isSet3(object.creator_name) ? globalThis.String(object.creator_name) : \"\",\n      create_time_seconds: isSet3(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,\n      update_time_seconds: isSet3(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,\n      metadata: globalThis.Array.isArray(object == null ? void 0 : object.metadata) ? object.metadata.map((e) => globalThis.String(e)) : [],\n      about_me: globalThis.Array.isArray(object == null ? void 0 : object.about_me) ? object.about_me.map((e) => globalThis.String(e)) : [],\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      app_id: isSet3(object.app_id) ? globalThis.String(object.app_id) : \"\",\n      is_mute: isSet3(object.is_mute) ? globalThis.Boolean(object.is_mute) : false,\n      age_restricted: isSet3(object.age_restricted) ? globalThis.Number(object.age_restricted) : 0,\n      topic: isSet3(object.topic) ? globalThis.String(object.topic) : \"\",\n      e2ee: isSet3(object.e2ee) ? globalThis.Number(object.e2ee) : 0,\n      display_names: globalThis.Array.isArray(object == null ? void 0 : object.display_names) ? object.display_names.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.type !== void 0) {\n      obj.type = message.type;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if ((_a = message.channel_avatar) == null ? void 0 : _a.length) {\n      obj.channel_avatar = message.channel_avatar;\n    }\n    if ((_b = message.user_id) == null ? void 0 : _b.length) {\n      obj.user_id = message.user_id;\n    }\n    if (message.last_sent_message !== void 0) {\n      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);\n    }\n    if (message.last_seen_message !== void 0) {\n      obj.last_seen_message = ChannelMessageHeader.toJSON(message.last_seen_message);\n    }\n    if ((_c = message.is_online) == null ? void 0 : _c.length) {\n      obj.is_online = message.is_online;\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.count_mess_unread !== 0) {\n      obj.count_mess_unread = Math.round(message.count_mess_unread);\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.last_pin_message !== \"\") {\n      obj.last_pin_message = message.last_pin_message;\n    }\n    if ((_d = message.usernames) == null ? void 0 : _d.length) {\n      obj.usernames = message.usernames;\n    }\n    if (message.creator_name !== \"\") {\n      obj.creator_name = message.creator_name;\n    }\n    if (message.create_time_seconds !== 0) {\n      obj.create_time_seconds = Math.round(message.create_time_seconds);\n    }\n    if (message.update_time_seconds !== 0) {\n      obj.update_time_seconds = Math.round(message.update_time_seconds);\n    }\n    if ((_e = message.metadata) == null ? void 0 : _e.length) {\n      obj.metadata = message.metadata;\n    }\n    if ((_f = message.about_me) == null ? void 0 : _f.length) {\n      obj.about_me = message.about_me;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.app_id !== \"\") {\n      obj.app_id = message.app_id;\n    }\n    if (message.is_mute !== false) {\n      obj.is_mute = message.is_mute;\n    }\n    if (message.age_restricted !== 0) {\n      obj.age_restricted = Math.round(message.age_restricted);\n    }\n    if (message.topic !== \"\") {\n      obj.topic = message.topic;\n    }\n    if (message.e2ee !== 0) {\n      obj.e2ee = Math.round(message.e2ee);\n    }\n    if ((_g = message.display_names) == null ? void 0 : _g.length) {\n      obj.display_names = message.display_names;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDescription.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C;\n    const message = createBaseChannelDescription();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.parent_id = (_b = object.parent_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.category_id = (_d = object.category_id) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    message.type = (_f = object.type) != null ? _f : void 0;\n    message.creator_id = (_g = object.creator_id) != null ? _g : \"\";\n    message.channel_label = (_h = object.channel_label) != null ? _h : \"\";\n    message.channel_private = (_i = object.channel_private) != null ? _i : 0;\n    message.channel_avatar = ((_j = object.channel_avatar) == null ? void 0 : _j.map((e) => e)) || [];\n    message.user_id = ((_k = object.user_id) == null ? void 0 : _k.map((e) => e)) || [];\n    message.last_sent_message = object.last_sent_message !== void 0 && object.last_sent_message !== null ? ChannelMessageHeader.fromPartial(object.last_sent_message) : void 0;\n    message.last_seen_message = object.last_seen_message !== void 0 && object.last_seen_message !== null ? ChannelMessageHeader.fromPartial(object.last_seen_message) : void 0;\n    message.is_online = ((_l = object.is_online) == null ? void 0 : _l.map((e) => e)) || [];\n    message.meeting_code = (_m = object.meeting_code) != null ? _m : \"\";\n    message.count_mess_unread = (_n = object.count_mess_unread) != null ? _n : 0;\n    message.active = (_o = object.active) != null ? _o : 0;\n    message.last_pin_message = (_p = object.last_pin_message) != null ? _p : \"\";\n    message.usernames = ((_q = object.usernames) == null ? void 0 : _q.map((e) => e)) || [];\n    message.creator_name = (_r = object.creator_name) != null ? _r : \"\";\n    message.create_time_seconds = (_s = object.create_time_seconds) != null ? _s : 0;\n    message.update_time_seconds = (_t = object.update_time_seconds) != null ? _t : 0;\n    message.metadata = ((_u = object.metadata) == null ? void 0 : _u.map((e) => e)) || [];\n    message.about_me = ((_v = object.about_me) == null ? void 0 : _v.map((e) => e)) || [];\n    message.clan_name = (_w = object.clan_name) != null ? _w : \"\";\n    message.app_id = (_x = object.app_id) != null ? _x : \"\";\n    message.is_mute = (_y = object.is_mute) != null ? _y : false;\n    message.age_restricted = (_z = object.age_restricted) != null ? _z : 0;\n    message.topic = (_A = object.topic) != null ? _A : \"\";\n    message.e2ee = (_B = object.e2ee) != null ? _B : 0;\n    message.display_names = ((_C = object.display_names) == null ? void 0 : _C.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseChannelDescList() {\n  return { channeldesc: [], next_cursor: \"\", prev_cursor: \"\", cacheable_cursor: \"\", page: 0 };\n}\nvar ChannelDescList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.channeldesc) {\n      ChannelDescription.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.next_cursor !== \"\") {\n      writer.uint32(18).string(message.next_cursor);\n    }\n    if (message.prev_cursor !== \"\") {\n      writer.uint32(26).string(message.prev_cursor);\n    }\n    if (message.cacheable_cursor !== \"\") {\n      writer.uint32(34).string(message.cacheable_cursor);\n    }\n    if (message.page !== 0) {\n      writer.uint32(40).int32(message.page);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDescList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.next_cursor = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.prev_cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.cacheable_cursor = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.page = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channeldesc: globalThis.Array.isArray(object == null ? void 0 : object.channeldesc) ? object.channeldesc.map((e) => ChannelDescription.fromJSON(e)) : [],\n      next_cursor: isSet3(object.next_cursor) ? globalThis.String(object.next_cursor) : \"\",\n      prev_cursor: isSet3(object.prev_cursor) ? globalThis.String(object.prev_cursor) : \"\",\n      cacheable_cursor: isSet3(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : \"\",\n      page: isSet3(object.page) ? globalThis.Number(object.page) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.channeldesc) == null ? void 0 : _a.length) {\n      obj.channeldesc = message.channeldesc.map((e) => ChannelDescription.toJSON(e));\n    }\n    if (message.next_cursor !== \"\") {\n      obj.next_cursor = message.next_cursor;\n    }\n    if (message.prev_cursor !== \"\") {\n      obj.prev_cursor = message.prev_cursor;\n    }\n    if (message.cacheable_cursor !== \"\") {\n      obj.cacheable_cursor = message.cacheable_cursor;\n    }\n    if (message.page !== 0) {\n      obj.page = Math.round(message.page);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDescList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannelDescList();\n    message.channeldesc = ((_a = object.channeldesc) == null ? void 0 : _a.map((e) => ChannelDescription.fromPartial(e))) || [];\n    message.next_cursor = (_b = object.next_cursor) != null ? _b : \"\";\n    message.prev_cursor = (_c = object.prev_cursor) != null ? _c : \"\";\n    message.cacheable_cursor = (_d = object.cacheable_cursor) != null ? _d : \"\";\n    message.page = (_e = object.page) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseListThreadRequest() {\n  return { limit: void 0, state: void 0, clan_id: \"\", channel_id: \"\", thread_id: \"\", page: void 0 };\n}\nvar ListThreadRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.state !== void 0) {\n      Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.thread_id !== \"\") {\n      writer.uint32(42).string(message.thread_id);\n    }\n    if (message.page !== void 0) {\n      Int32Value.encode({ value: message.page }, writer.uint32(50).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListThreadRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.state = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.thread_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.page = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      state: isSet3(object.state) ? Number(object.state) : void 0,\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      thread_id: isSet3(object.thread_id) ? globalThis.String(object.thread_id) : \"\",\n      page: isSet3(object.page) ? Number(object.page) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.state !== void 0) {\n      obj.state = message.state;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.thread_id !== \"\") {\n      obj.thread_id = message.thread_id;\n    }\n    if (message.page !== void 0) {\n      obj.page = message.page;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListThreadRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseListThreadRequest();\n    message.limit = (_a = object.limit) != null ? _a : void 0;\n    message.state = (_b = object.state) != null ? _b : void 0;\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.thread_id = (_e = object.thread_id) != null ? _e : \"\";\n    message.page = (_f = object.page) != null ? _f : void 0;\n    return message;\n  }\n};\nfunction createBaseListChannelDescsRequest() {\n  return { limit: void 0, state: void 0, cursor: \"\", clan_id: \"\", channel_type: 0 };\n}\nvar ListChannelDescsRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.state !== void 0) {\n      Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(26).string(message.cursor);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(40).int32(message.channel_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListChannelDescsRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.state = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      state: isSet3(object.state) ? Number(object.state) : void 0,\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_type: isSet3(object.channel_type) ? globalThis.Number(object.channel_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.state !== void 0) {\n      obj.state = message.state;\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    return obj;\n  },\n  create(base) {\n    return ListChannelDescsRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseListChannelDescsRequest();\n    message.limit = (_a = object.limit) != null ? _a : void 0;\n    message.state = (_b = object.state) != null ? _b : void 0;\n    message.cursor = (_c = object.cursor) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    message.channel_type = (_e = object.channel_type) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseListChannelDetailRequest() {\n  return { channel_id: \"\" };\n}\nvar ListChannelDetailRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListChannelDetailRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListChannelDetailRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListChannelDetailRequest();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseRole() {\n  return {\n    id: \"\",\n    title: \"\",\n    color: \"\",\n    role_icon: \"\",\n    slug: \"\",\n    description: \"\",\n    creator_id: \"\",\n    clan_id: \"\",\n    active: 0,\n    display_online: 0,\n    allow_mention: 0,\n    role_user_list: void 0,\n    permission_list: void 0,\n    role_channel_active: 0,\n    channel_ids: [],\n    max_level_permission: 0,\n    order_role: 0\n  };\n}\nvar Role = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.title !== \"\") {\n      writer.uint32(18).string(message.title);\n    }\n    if (message.color !== \"\") {\n      writer.uint32(26).string(message.color);\n    }\n    if (message.role_icon !== \"\") {\n      writer.uint32(34).string(message.role_icon);\n    }\n    if (message.slug !== \"\") {\n      writer.uint32(42).string(message.slug);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(50).string(message.description);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(58).string(message.creator_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(66).string(message.clan_id);\n    }\n    if (message.active !== 0) {\n      writer.uint32(72).int32(message.active);\n    }\n    if (message.display_online !== 0) {\n      writer.uint32(80).int32(message.display_online);\n    }\n    if (message.allow_mention !== 0) {\n      writer.uint32(88).int32(message.allow_mention);\n    }\n    if (message.role_user_list !== void 0) {\n      RoleUserList.encode(message.role_user_list, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.permission_list !== void 0) {\n      PermissionList.encode(message.permission_list, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.role_channel_active !== 0) {\n      writer.uint32(112).int32(message.role_channel_active);\n    }\n    for (const v of message.channel_ids) {\n      writer.uint32(122).string(v);\n    }\n    if (message.max_level_permission !== 0) {\n      writer.uint32(128).int32(message.max_level_permission);\n    }\n    if (message.order_role !== 0) {\n      writer.uint32(136).int32(message.order_role);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRole();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.color = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.role_icon = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.slug = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.description = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.display_online = reader.int32();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.allow_mention = reader.int32();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.role_user_list = RoleUserList.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.permission_list = PermissionList.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag !== 112) {\n            break;\n          }\n          message.role_channel_active = reader.int32();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.channel_ids.push(reader.string());\n          continue;\n        case 16:\n          if (tag !== 128) {\n            break;\n          }\n          message.max_level_permission = reader.int32();\n          continue;\n        case 17:\n          if (tag !== 136) {\n            break;\n          }\n          message.order_role = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      title: isSet3(object.title) ? globalThis.String(object.title) : \"\",\n      color: isSet3(object.color) ? globalThis.String(object.color) : \"\",\n      role_icon: isSet3(object.role_icon) ? globalThis.String(object.role_icon) : \"\",\n      slug: isSet3(object.slug) ? globalThis.String(object.slug) : \"\",\n      description: isSet3(object.description) ? globalThis.String(object.description) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      display_online: isSet3(object.display_online) ? globalThis.Number(object.display_online) : 0,\n      allow_mention: isSet3(object.allow_mention) ? globalThis.Number(object.allow_mention) : 0,\n      role_user_list: isSet3(object.role_user_list) ? RoleUserList.fromJSON(object.role_user_list) : void 0,\n      permission_list: isSet3(object.permission_list) ? PermissionList.fromJSON(object.permission_list) : void 0,\n      role_channel_active: isSet3(object.role_channel_active) ? globalThis.Number(object.role_channel_active) : 0,\n      channel_ids: globalThis.Array.isArray(object == null ? void 0 : object.channel_ids) ? object.channel_ids.map((e) => globalThis.String(e)) : [],\n      max_level_permission: isSet3(object.max_level_permission) ? globalThis.Number(object.max_level_permission) : 0,\n      order_role: isSet3(object.order_role) ? globalThis.Number(object.order_role) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.color !== \"\") {\n      obj.color = message.color;\n    }\n    if (message.role_icon !== \"\") {\n      obj.role_icon = message.role_icon;\n    }\n    if (message.slug !== \"\") {\n      obj.slug = message.slug;\n    }\n    if (message.description !== \"\") {\n      obj.description = message.description;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.display_online !== 0) {\n      obj.display_online = Math.round(message.display_online);\n    }\n    if (message.allow_mention !== 0) {\n      obj.allow_mention = Math.round(message.allow_mention);\n    }\n    if (message.role_user_list !== void 0) {\n      obj.role_user_list = RoleUserList.toJSON(message.role_user_list);\n    }\n    if (message.permission_list !== void 0) {\n      obj.permission_list = PermissionList.toJSON(message.permission_list);\n    }\n    if (message.role_channel_active !== 0) {\n      obj.role_channel_active = Math.round(message.role_channel_active);\n    }\n    if ((_a = message.channel_ids) == null ? void 0 : _a.length) {\n      obj.channel_ids = message.channel_ids;\n    }\n    if (message.max_level_permission !== 0) {\n      obj.max_level_permission = Math.round(message.max_level_permission);\n    }\n    if (message.order_role !== 0) {\n      obj.order_role = Math.round(message.order_role);\n    }\n    return obj;\n  },\n  create(base) {\n    return Role.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;\n    const message = createBaseRole();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.title = (_b = object.title) != null ? _b : \"\";\n    message.color = (_c = object.color) != null ? _c : \"\";\n    message.role_icon = (_d = object.role_icon) != null ? _d : \"\";\n    message.slug = (_e = object.slug) != null ? _e : \"\";\n    message.description = (_f = object.description) != null ? _f : \"\";\n    message.creator_id = (_g = object.creator_id) != null ? _g : \"\";\n    message.clan_id = (_h = object.clan_id) != null ? _h : \"\";\n    message.active = (_i = object.active) != null ? _i : 0;\n    message.display_online = (_j = object.display_online) != null ? _j : 0;\n    message.allow_mention = (_k = object.allow_mention) != null ? _k : 0;\n    message.role_user_list = object.role_user_list !== void 0 && object.role_user_list !== null ? RoleUserList.fromPartial(object.role_user_list) : void 0;\n    message.permission_list = object.permission_list !== void 0 && object.permission_list !== null ? PermissionList.fromPartial(object.permission_list) : void 0;\n    message.role_channel_active = (_l = object.role_channel_active) != null ? _l : 0;\n    message.channel_ids = ((_m = object.channel_ids) == null ? void 0 : _m.map((e) => e)) || [];\n    message.max_level_permission = (_n = object.max_level_permission) != null ? _n : 0;\n    message.order_role = (_o = object.order_role) != null ? _o : 0;\n    return message;\n  }\n};\nfunction createBasePermission() {\n  return { id: \"\", title: \"\", slug: \"\", description: \"\", active: 0, scope: 0, level: 0 };\n}\nvar Permission = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.title !== \"\") {\n      writer.uint32(18).string(message.title);\n    }\n    if (message.slug !== \"\") {\n      writer.uint32(26).string(message.slug);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(34).string(message.description);\n    }\n    if (message.active !== 0) {\n      writer.uint32(40).int32(message.active);\n    }\n    if (message.scope !== 0) {\n      writer.uint32(48).int32(message.scope);\n    }\n    if (message.level !== 0) {\n      writer.uint32(56).int32(message.level);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermission();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.slug = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.description = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.scope = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.level = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      title: isSet3(object.title) ? globalThis.String(object.title) : \"\",\n      slug: isSet3(object.slug) ? globalThis.String(object.slug) : \"\",\n      description: isSet3(object.description) ? globalThis.String(object.description) : \"\",\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      scope: isSet3(object.scope) ? globalThis.Number(object.scope) : 0,\n      level: isSet3(object.level) ? globalThis.Number(object.level) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.slug !== \"\") {\n      obj.slug = message.slug;\n    }\n    if (message.description !== \"\") {\n      obj.description = message.description;\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.scope !== 0) {\n      obj.scope = Math.round(message.scope);\n    }\n    if (message.level !== 0) {\n      obj.level = Math.round(message.level);\n    }\n    return obj;\n  },\n  create(base) {\n    return Permission.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBasePermission();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.title = (_b = object.title) != null ? _b : \"\";\n    message.slug = (_c = object.slug) != null ? _c : \"\";\n    message.description = (_d = object.description) != null ? _d : \"\";\n    message.active = (_e = object.active) != null ? _e : 0;\n    message.scope = (_f = object.scope) != null ? _f : 0;\n    message.level = (_g = object.level) != null ? _g : 0;\n    return message;\n  }\n};\nfunction createBaseNotificationSetting() {\n  return { id: \"\", notification_setting_type: 0 };\n}\nvar NotificationSetting = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(16).int32(message.notification_setting_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationSetting();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.notification_setting_type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      notification_setting_type: isSet3(object.notification_setting_type) ? globalThis.Number(object.notification_setting_type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.notification_setting_type !== 0) {\n      obj.notification_setting_type = Math.round(message.notification_setting_type);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationSetting.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseNotificationSetting();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.notification_setting_type = (_b = object.notification_setting_type) != null ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseNotificationUserChannel() {\n  return { id: \"\", notification_setting_type: 0, time_mute: void 0, active: 0, channel_id: \"\" };\n}\nvar NotificationUserChannel = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(16).int32(message.notification_setting_type);\n    }\n    if (message.time_mute !== void 0) {\n      Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();\n    }\n    if (message.active !== 0) {\n      writer.uint32(32).int32(message.active);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationUserChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.notification_setting_type = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.time_mute = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      notification_setting_type: isSet3(object.notification_setting_type) ? globalThis.Number(object.notification_setting_type) : 0,\n      time_mute: isSet3(object.time_mute) ? fromJsonTimestamp(object.time_mute) : void 0,\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.notification_setting_type !== 0) {\n      obj.notification_setting_type = Math.round(message.notification_setting_type);\n    }\n    if (message.time_mute !== void 0) {\n      obj.time_mute = message.time_mute.toISOString();\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationUserChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseNotificationUserChannel();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.notification_setting_type = (_b = object.notification_setting_type) != null ? _b : 0;\n    message.time_mute = (_c = object.time_mute) != null ? _c : void 0;\n    message.active = (_d = object.active) != null ? _d : 0;\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseNotifiReactMessage() {\n  return { id: \"\", user_id: \"\", channel_id: \"\" };\n}\nvar NotifiReactMessage = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifiReactMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return NotifiReactMessage.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseNotifiReactMessage();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseDefaultNotificationCategory() {\n  return { category_id: \"\" };\n}\nvar DefaultNotificationCategory = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.category_id !== \"\") {\n      writer.uint32(10).string(message.category_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseDefaultNotificationCategory();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { category_id: isSet3(object.category_id) ? globalThis.String(object.category_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return DefaultNotificationCategory.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseDefaultNotificationCategory();\n    message.category_id = (_a = object.category_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseNotificationChannel() {\n  return { channel_id: \"\" };\n}\nvar NotificationChannel = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationChannel();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseNotificationClan() {\n  return { clan_id: \"\" };\n}\nvar NotificationClan = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationClan();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationClan.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationClan();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseHashtagDmListRequest() {\n  return { user_id: [], limit: void 0 };\n}\nvar HashtagDmListRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.user_id) {\n      writer.uint32(10).string(v);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDmListRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id.push(reader.string());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: globalThis.Array.isArray(object == null ? void 0 : object.user_id) ? object.user_id.map((e) => globalThis.String(e)) : [],\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.user_id) == null ? void 0 : _a.length) {\n      obj.user_id = message.user_id;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDmListRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseHashtagDmListRequest();\n    message.user_id = ((_a = object.user_id) == null ? void 0 : _a.map((e) => e)) || [];\n    message.limit = (_b = object.limit) != null ? _b : void 0;\n    return message;\n  }\n};\nfunction createBaseHashtagDmList() {\n  return { hashtag_dm: [] };\n}\nvar HashtagDmList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.hashtag_dm) {\n      HashtagDm.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDmList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.hashtag_dm.push(HashtagDm.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      hashtag_dm: globalThis.Array.isArray(object == null ? void 0 : object.hashtag_dm) ? object.hashtag_dm.map((e) => HashtagDm.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.hashtag_dm) == null ? void 0 : _a.length) {\n      obj.hashtag_dm = message.hashtag_dm.map((e) => HashtagDm.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDmList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseHashtagDmList();\n    message.hashtag_dm = ((_a = object.hashtag_dm) == null ? void 0 : _a.map((e) => HashtagDm.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseHashtagDm() {\n  return {\n    channel_id: \"\",\n    channel_label: \"\",\n    clan_id: \"\",\n    clan_name: \"\",\n    meeting_code: \"\",\n    type: 0,\n    channel_private: 0,\n    parent_id: \"\"\n  };\n}\nvar HashtagDm = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(18).string(message.channel_label);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(34).string(message.clan_name);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(42).string(message.meeting_code);\n    }\n    if (message.type !== 0) {\n      writer.uint32(48).int32(message.type);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(66).string(message.parent_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHashtagDm();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.type = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      meeting_code: isSet3(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      type: isSet3(object.type) ? globalThis.Number(object.type) : 0,\n      channel_private: isSet3(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      parent_id: isSet3(object.parent_id) ? globalThis.String(object.parent_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.type !== 0) {\n      obj.type = Math.round(message.type);\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return HashtagDm.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseHashtagDm();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.channel_label = (_b = object.channel_label) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.clan_name = (_d = object.clan_name) != null ? _d : \"\";\n    message.meeting_code = (_e = object.meeting_code) != null ? _e : \"\";\n    message.type = (_f = object.type) != null ? _f : 0;\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.parent_id = (_h = object.parent_id) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseNotificationChannelCategorySettingList() {\n  return { notification_channel_category_settings_list: [] };\n}\nvar NotificationChannelCategorySettingList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.notification_channel_category_settings_list) {\n      NotificationChannelCategorySetting.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelCategorySettingList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.notification_channel_category_settings_list.push(\n            NotificationChannelCategorySetting.decode(reader, reader.uint32())\n          );\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      notification_channel_category_settings_list: globalThis.Array.isArray(object == null ? void 0 : object.notification_channel_category_settings_list) ? object.notification_channel_category_settings_list.map(\n        (e) => NotificationChannelCategorySetting.fromJSON(e)\n      ) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.notification_channel_category_settings_list) == null ? void 0 : _a.length) {\n      obj.notification_channel_category_settings_list = message.notification_channel_category_settings_list.map(\n        (e) => NotificationChannelCategorySetting.toJSON(e)\n      );\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelCategorySettingList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotificationChannelCategorySettingList();\n    message.notification_channel_category_settings_list = ((_a = object.notification_channel_category_settings_list) == null ? void 0 : _a.map(\n      (e) => NotificationChannelCategorySetting.fromPartial(e)\n    )) || [];\n    return message;\n  }\n};\nfunction createBaseNotificationChannelCategorySetting() {\n  return { id: \"\", channel_category_label: \"\", notification_setting_type: 0, channel_category_title: \"\", action: 0 };\n}\nvar NotificationChannelCategorySetting = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.channel_category_label !== \"\") {\n      writer.uint32(18).string(message.channel_category_label);\n    }\n    if (message.notification_setting_type !== 0) {\n      writer.uint32(24).int32(message.notification_setting_type);\n    }\n    if (message.channel_category_title !== \"\") {\n      writer.uint32(34).string(message.channel_category_title);\n    }\n    if (message.action !== 0) {\n      writer.uint32(40).int32(message.action);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotificationChannelCategorySetting();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_category_label = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.notification_setting_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_category_title = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.action = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      channel_category_label: isSet3(object.channel_category_label) ? globalThis.String(object.channel_category_label) : \"\",\n      notification_setting_type: isSet3(object.notification_setting_type) ? globalThis.Number(object.notification_setting_type) : 0,\n      channel_category_title: isSet3(object.channel_category_title) ? globalThis.String(object.channel_category_title) : \"\",\n      action: isSet3(object.action) ? globalThis.Number(object.action) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.channel_category_label !== \"\") {\n      obj.channel_category_label = message.channel_category_label;\n    }\n    if (message.notification_setting_type !== 0) {\n      obj.notification_setting_type = Math.round(message.notification_setting_type);\n    }\n    if (message.channel_category_title !== \"\") {\n      obj.channel_category_title = message.channel_category_title;\n    }\n    if (message.action !== 0) {\n      obj.action = Math.round(message.action);\n    }\n    return obj;\n  },\n  create(base) {\n    return NotificationChannelCategorySetting.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseNotificationChannelCategorySetting();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.channel_category_label = (_b = object.channel_category_label) != null ? _b : \"\";\n    message.notification_setting_type = (_c = object.notification_setting_type) != null ? _c : 0;\n    message.channel_category_title = (_d = object.channel_category_title) != null ? _d : \"\";\n    message.action = (_e = object.action) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseRoleList() {\n  return { roles: [], next_cursor: \"\", prev_cursor: \"\", cacheable_cursor: \"\" };\n}\nvar RoleList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.roles) {\n      Role.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.next_cursor !== \"\") {\n      writer.uint32(18).string(message.next_cursor);\n    }\n    if (message.prev_cursor !== \"\") {\n      writer.uint32(26).string(message.prev_cursor);\n    }\n    if (message.cacheable_cursor !== \"\") {\n      writer.uint32(34).string(message.cacheable_cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.roles.push(Role.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.next_cursor = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.prev_cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.cacheable_cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      roles: globalThis.Array.isArray(object == null ? void 0 : object.roles) ? object.roles.map((e) => Role.fromJSON(e)) : [],\n      next_cursor: isSet3(object.next_cursor) ? globalThis.String(object.next_cursor) : \"\",\n      prev_cursor: isSet3(object.prev_cursor) ? globalThis.String(object.prev_cursor) : \"\",\n      cacheable_cursor: isSet3(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.roles) == null ? void 0 : _a.length) {\n      obj.roles = message.roles.map((e) => Role.toJSON(e));\n    }\n    if (message.next_cursor !== \"\") {\n      obj.next_cursor = message.next_cursor;\n    }\n    if (message.prev_cursor !== \"\") {\n      obj.prev_cursor = message.prev_cursor;\n    }\n    if (message.cacheable_cursor !== \"\") {\n      obj.cacheable_cursor = message.cacheable_cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleList();\n    message.roles = ((_a = object.roles) == null ? void 0 : _a.map((e) => Role.fromPartial(e))) || [];\n    message.next_cursor = (_b = object.next_cursor) != null ? _b : \"\";\n    message.prev_cursor = (_c = object.prev_cursor) != null ? _c : \"\";\n    message.cacheable_cursor = (_d = object.cacheable_cursor) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBasePermissionList() {\n  return { permissions: [], max_level_permission: 0 };\n}\nvar PermissionList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.permissions) {\n      Permission.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.max_level_permission !== 0) {\n      writer.uint32(16).int32(message.max_level_permission);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.permissions.push(Permission.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.max_level_permission = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      permissions: globalThis.Array.isArray(object == null ? void 0 : object.permissions) ? object.permissions.map((e) => Permission.fromJSON(e)) : [],\n      max_level_permission: isSet3(object.max_level_permission) ? globalThis.Number(object.max_level_permission) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.permissions) == null ? void 0 : _a.length) {\n      obj.permissions = message.permissions.map((e) => Permission.toJSON(e));\n    }\n    if (message.max_level_permission !== 0) {\n      obj.max_level_permission = Math.round(message.max_level_permission);\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePermissionList();\n    message.permissions = ((_a = object.permissions) == null ? void 0 : _a.map((e) => Permission.fromPartial(e))) || [];\n    message.max_level_permission = (_b = object.max_level_permission) != null ? _b : 0;\n    return message;\n  }\n};\nfunction createBaseListPermissionsRequest() {\n  return { role_id: \"\" };\n}\nvar ListPermissionsRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.role_id !== \"\") {\n      writer.uint32(10).string(message.role_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListPermissionsRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { role_id: isSet3(object.role_id) ? globalThis.String(object.role_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListPermissionsRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListPermissionsRequest();\n    message.role_id = (_a = object.role_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseListRoleUsersRequest() {\n  return { role_id: \"\", limit: void 0, cursor: \"\" };\n}\nvar ListRoleUsersRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.role_id !== \"\") {\n      writer.uint32(10).string(message.role_id);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(26).string(message.cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListRoleUsersRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_id: isSet3(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListRoleUsersRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseListRoleUsersRequest();\n    message.role_id = (_a = object.role_id) != null ? _a : \"\";\n    message.limit = (_b = object.limit) != null ? _b : void 0;\n    message.cursor = (_c = object.cursor) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseListPermissionOfUsersRequest() {\n  return { clan_id: \"\", channel_id: \"\" };\n}\nvar ListPermissionOfUsersRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListPermissionOfUsersRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListPermissionOfUsersRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseListPermissionOfUsersRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleUserList() {\n  return { role_users: [], cursor: \"\" };\n}\nvar RoleUserList = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.role_users) {\n      RoleUserList_RoleUser.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(18).string(message.cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleUserList();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_users.push(RoleUserList_RoleUser.decode(reader, reader.uint32()));\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_users: globalThis.Array.isArray(object == null ? void 0 : object.role_users) ? object.role_users.map((e) => RoleUserList_RoleUser.fromJSON(e)) : [],\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.role_users) == null ? void 0 : _a.length) {\n      obj.role_users = message.role_users.map((e) => RoleUserList_RoleUser.toJSON(e));\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleUserList.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseRoleUserList();\n    message.role_users = ((_a = object.role_users) == null ? void 0 : _a.map((e) => RoleUserList_RoleUser.fromPartial(e))) || [];\n    message.cursor = (_b = object.cursor) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleUserList_RoleUser() {\n  return { id: \"\", username: \"\", display_name: \"\", avatar_url: \"\", lang_tag: \"\", location: \"\", online: false };\n}\nvar RoleUserList_RoleUser = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(26).string(message.display_name);\n    }\n    if (message.avatar_url !== \"\") {\n      writer.uint32(34).string(message.avatar_url);\n    }\n    if (message.lang_tag !== \"\") {\n      writer.uint32(42).string(message.lang_tag);\n    }\n    if (message.location !== \"\") {\n      writer.uint32(50).string(message.location);\n    }\n    if (message.online !== false) {\n      writer.uint32(56).bool(message.online);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleUserList_RoleUser();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.avatar_url = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.lang_tag = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.location = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.online = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      username: isSet3(object.username) ? globalThis.String(object.username) : \"\",\n      display_name: isSet3(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      avatar_url: isSet3(object.avatar_url) ? globalThis.String(object.avatar_url) : \"\",\n      lang_tag: isSet3(object.lang_tag) ? globalThis.String(object.lang_tag) : \"\",\n      location: isSet3(object.location) ? globalThis.String(object.location) : \"\",\n      online: isSet3(object.online) ? globalThis.Boolean(object.online) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.avatar_url !== \"\") {\n      obj.avatar_url = message.avatar_url;\n    }\n    if (message.lang_tag !== \"\") {\n      obj.lang_tag = message.lang_tag;\n    }\n    if (message.location !== \"\") {\n      obj.location = message.location;\n    }\n    if (message.online !== false) {\n      obj.online = message.online;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleUserList_RoleUser.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseRoleUserList_RoleUser();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.display_name = (_c = object.display_name) != null ? _c : \"\";\n    message.avatar_url = (_d = object.avatar_url) != null ? _d : \"\";\n    message.lang_tag = (_e = object.lang_tag) != null ? _e : \"\";\n    message.location = (_f = object.location) != null ? _f : \"\";\n    message.online = (_g = object.online) != null ? _g : false;\n    return message;\n  }\n};\nfunction createBaseCreateEventRequest() {\n  return {\n    title: \"\",\n    logo: \"\",\n    description: \"\",\n    clan_id: \"\",\n    channel_voice_id: \"\",\n    address: \"\",\n    start_time: void 0,\n    end_time: void 0,\n    event_id: \"\",\n    event_status: 0,\n    channel_id: \"\",\n    action: 0,\n    repeat_type: 0,\n    creator_id: \"\",\n    user_id: \"\",\n    is_private: void 0,\n    meet_room: void 0\n  };\n}\nvar CreateEventRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(18).string(message.logo);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(26).string(message.description);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    if (message.channel_voice_id !== \"\") {\n      writer.uint32(42).string(message.channel_voice_id);\n    }\n    if (message.address !== \"\") {\n      writer.uint32(50).string(message.address);\n    }\n    if (message.start_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(58).fork()).ldelim();\n    }\n    if (message.end_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(66).fork()).ldelim();\n    }\n    if (message.event_id !== \"\") {\n      writer.uint32(74).string(message.event_id);\n    }\n    if (message.event_status !== 0) {\n      writer.uint32(80).int32(message.event_status);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(90).string(message.channel_id);\n    }\n    if (message.action !== 0) {\n      writer.uint32(96).int32(message.action);\n    }\n    if (message.repeat_type !== 0) {\n      writer.uint32(104).int32(message.repeat_type);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(114).string(message.creator_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(122).string(message.user_id);\n    }\n    if (message.is_private !== void 0) {\n      BoolValue.encode({ value: message.is_private }, writer.uint32(130).fork()).ldelim();\n    }\n    if (message.meet_room !== void 0) {\n      GenerateMezonMeetResponse.encode(message.meet_room, writer.uint32(138).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCreateEventRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.description = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_voice_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.address = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.event_id = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.event_status = reader.int32();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 12:\n          if (tag !== 96) {\n            break;\n          }\n          message.action = reader.int32();\n          continue;\n        case 13:\n          if (tag !== 104) {\n            break;\n          }\n          message.repeat_type = reader.int32();\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.is_private = BoolValue.decode(reader, reader.uint32()).value;\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.meet_room = GenerateMezonMeetResponse.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      title: isSet3(object.title) ? globalThis.String(object.title) : \"\",\n      logo: isSet3(object.logo) ? globalThis.String(object.logo) : \"\",\n      description: isSet3(object.description) ? globalThis.String(object.description) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_voice_id: isSet3(object.channel_voice_id) ? globalThis.String(object.channel_voice_id) : \"\",\n      address: isSet3(object.address) ? globalThis.String(object.address) : \"\",\n      start_time: isSet3(object.start_time) ? fromJsonTimestamp(object.start_time) : void 0,\n      end_time: isSet3(object.end_time) ? fromJsonTimestamp(object.end_time) : void 0,\n      event_id: isSet3(object.event_id) ? globalThis.String(object.event_id) : \"\",\n      event_status: isSet3(object.event_status) ? globalThis.Number(object.event_status) : 0,\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      action: isSet3(object.action) ? globalThis.Number(object.action) : 0,\n      repeat_type: isSet3(object.repeat_type) ? globalThis.Number(object.repeat_type) : 0,\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      is_private: isSet3(object.is_private) ? Boolean(object.is_private) : void 0,\n      meet_room: isSet3(object.meet_room) ? GenerateMezonMeetResponse.fromJSON(object.meet_room) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.description !== \"\") {\n      obj.description = message.description;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_voice_id !== \"\") {\n      obj.channel_voice_id = message.channel_voice_id;\n    }\n    if (message.address !== \"\") {\n      obj.address = message.address;\n    }\n    if (message.start_time !== void 0) {\n      obj.start_time = message.start_time.toISOString();\n    }\n    if (message.end_time !== void 0) {\n      obj.end_time = message.end_time.toISOString();\n    }\n    if (message.event_id !== \"\") {\n      obj.event_id = message.event_id;\n    }\n    if (message.event_status !== 0) {\n      obj.event_status = Math.round(message.event_status);\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.action !== 0) {\n      obj.action = Math.round(message.action);\n    }\n    if (message.repeat_type !== 0) {\n      obj.repeat_type = Math.round(message.repeat_type);\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.is_private !== void 0) {\n      obj.is_private = message.is_private;\n    }\n    if (message.meet_room !== void 0) {\n      obj.meet_room = GenerateMezonMeetResponse.toJSON(message.meet_room);\n    }\n    return obj;\n  },\n  create(base) {\n    return CreateEventRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;\n    const message = createBaseCreateEventRequest();\n    message.title = (_a = object.title) != null ? _a : \"\";\n    message.logo = (_b = object.logo) != null ? _b : \"\";\n    message.description = (_c = object.description) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    message.channel_voice_id = (_e = object.channel_voice_id) != null ? _e : \"\";\n    message.address = (_f = object.address) != null ? _f : \"\";\n    message.start_time = (_g = object.start_time) != null ? _g : void 0;\n    message.end_time = (_h = object.end_time) != null ? _h : void 0;\n    message.event_id = (_i = object.event_id) != null ? _i : \"\";\n    message.event_status = (_j = object.event_status) != null ? _j : 0;\n    message.channel_id = (_k = object.channel_id) != null ? _k : \"\";\n    message.action = (_l = object.action) != null ? _l : 0;\n    message.repeat_type = (_m = object.repeat_type) != null ? _m : 0;\n    message.creator_id = (_n = object.creator_id) != null ? _n : \"\";\n    message.user_id = (_o = object.user_id) != null ? _o : \"\";\n    message.is_private = (_p = object.is_private) != null ? _p : void 0;\n    message.meet_room = object.meet_room !== void 0 && object.meet_room !== null ? GenerateMezonMeetResponse.fromPartial(object.meet_room) : void 0;\n    return message;\n  }\n};\nfunction createBasePermissionUpdate() {\n  return { permission_id: \"\", slug: \"\", type: 0 };\n}\nvar PermissionUpdate = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.permission_id !== \"\") {\n      writer.uint32(10).string(message.permission_id);\n    }\n    if (message.slug !== \"\") {\n      writer.uint32(18).string(message.slug);\n    }\n    if (message.type !== 0) {\n      writer.uint32(24).int32(message.type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.permission_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.slug = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      permission_id: isSet3(object.permission_id) ? globalThis.String(object.permission_id) : \"\",\n      slug: isSet3(object.slug) ? globalThis.String(object.slug) : \"\",\n      type: isSet3(object.type) ? globalThis.Number(object.type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.permission_id !== \"\") {\n      obj.permission_id = message.permission_id;\n    }\n    if (message.slug !== \"\") {\n      obj.slug = message.slug;\n    }\n    if (message.type !== 0) {\n      obj.type = Math.round(message.type);\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBasePermissionUpdate();\n    message.permission_id = (_a = object.permission_id) != null ? _a : \"\";\n    message.slug = (_b = object.slug) != null ? _b : \"\";\n    message.type = (_c = object.type) != null ? _c : 0;\n    return message;\n  }\n};\nfunction createBaseClanEmoji() {\n  return {\n    id: \"\",\n    src: \"\",\n    shortname: \"\",\n    category: \"\",\n    creator_id: \"\",\n    clan_id: \"\",\n    logo: \"\",\n    clan_name: \"\",\n    is_for_sale: false\n  };\n}\nvar ClanEmoji = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.src !== \"\") {\n      writer.uint32(18).string(message.src);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(58).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(66).string(message.clan_name);\n    }\n    if (message.is_for_sale !== false) {\n      writer.uint32(72).bool(message.is_for_sale);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanEmoji();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.src = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.is_for_sale = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      src: isSet3(object.src) ? globalThis.String(object.src) : \"\",\n      shortname: isSet3(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      category: isSet3(object.category) ? globalThis.String(object.category) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      logo: isSet3(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      is_for_sale: isSet3(object.is_for_sale) ? globalThis.Boolean(object.is_for_sale) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.src !== \"\") {\n      obj.src = message.src;\n    }\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.is_for_sale !== false) {\n      obj.is_for_sale = message.is_for_sale;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanEmoji.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseClanEmoji();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.src = (_b = object.src) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    message.logo = (_g = object.logo) != null ? _g : \"\";\n    message.clan_name = (_h = object.clan_name) != null ? _h : \"\";\n    message.is_for_sale = (_i = object.is_for_sale) != null ? _i : false;\n    return message;\n  }\n};\nfunction createBaseEmojiListedResponse() {\n  return { emoji_list: [] };\n}\nvar EmojiListedResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.emoji_list) {\n      ClanEmoji.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEmojiListedResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.emoji_list.push(ClanEmoji.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      emoji_list: globalThis.Array.isArray(object == null ? void 0 : object.emoji_list) ? object.emoji_list.map((e) => ClanEmoji.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.emoji_list) == null ? void 0 : _a.length) {\n      obj.emoji_list = message.emoji_list.map((e) => ClanEmoji.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return EmojiListedResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseEmojiListedResponse();\n    message.emoji_list = ((_a = object.emoji_list) == null ? void 0 : _a.map((e) => ClanEmoji.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseStickerListedResponse() {\n  return { stickers: [] };\n}\nvar StickerListedResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.stickers) {\n      ClanSticker.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerListedResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.stickers.push(ClanSticker.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stickers: globalThis.Array.isArray(object == null ? void 0 : object.stickers) ? object.stickers.map((e) => ClanSticker.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.stickers) == null ? void 0 : _a.length) {\n      obj.stickers = message.stickers.map((e) => ClanSticker.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerListedResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStickerListedResponse();\n    message.stickers = ((_a = object.stickers) == null ? void 0 : _a.map((e) => ClanSticker.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseClanSticker() {\n  return {\n    id: \"\",\n    source: \"\",\n    shortname: \"\",\n    category: \"\",\n    creator_id: \"\",\n    create_time: void 0,\n    clan_id: \"\",\n    logo: \"\",\n    clan_name: \"\",\n    media_type: 0,\n    is_for_sale: false\n  };\n}\nvar ClanSticker = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(18).string(message.source);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(58).string(message.clan_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(66).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(74).string(message.clan_name);\n    }\n    if (message.media_type !== 0) {\n      writer.uint32(80).int32(message.media_type);\n    }\n    if (message.is_for_sale !== false) {\n      writer.uint32(88).bool(message.is_for_sale);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanSticker();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.source = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.media_type = reader.int32();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.is_for_sale = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      source: isSet3(object.source) ? globalThis.String(object.source) : \"\",\n      shortname: isSet3(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      category: isSet3(object.category) ? globalThis.String(object.category) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      create_time: isSet3(object.create_time) ? fromJsonTimestamp(object.create_time) : void 0,\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      logo: isSet3(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet3(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      media_type: isSet3(object.media_type) ? globalThis.Number(object.media_type) : 0,\n      is_for_sale: isSet3(object.is_for_sale) ? globalThis.Boolean(object.is_for_sale) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.source !== \"\") {\n      obj.source = message.source;\n    }\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.media_type !== 0) {\n      obj.media_type = Math.round(message.media_type);\n    }\n    if (message.is_for_sale !== false) {\n      obj.is_for_sale = message.is_for_sale;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanSticker.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseClanSticker();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.source = (_b = object.source) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.create_time = (_f = object.create_time) != null ? _f : void 0;\n    message.clan_id = (_g = object.clan_id) != null ? _g : \"\";\n    message.logo = (_h = object.logo) != null ? _h : \"\";\n    message.clan_name = (_i = object.clan_name) != null ? _i : \"\";\n    message.media_type = (_j = object.media_type) != null ? _j : 0;\n    message.is_for_sale = (_k = object.is_for_sale) != null ? _k : false;\n    return message;\n  }\n};\nfunction createBaseAllUsersAddChannelRequest() {\n  return { channel_id: \"\", limit: void 0 };\n}\nvar AllUsersAddChannelRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAllUsersAddChannelRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    return obj;\n  },\n  create(base) {\n    return AllUsersAddChannelRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseAllUsersAddChannelRequest();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.limit = (_b = object.limit) != null ? _b : void 0;\n    return message;\n  }\n};\nfunction createBaseAllUsersAddChannelResponse() {\n  return { channel_id: \"\", user_ids: [], limit: void 0 };\n}\nvar AllUsersAddChannelResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAllUsersAddChannelResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    return obj;\n  },\n  create(base) {\n    return AllUsersAddChannelResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseAllUsersAddChannelResponse();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    message.limit = (_c = object.limit) != null ? _c : void 0;\n    return message;\n  }\n};\nfunction createBaseWebhook() {\n  return {\n    id: \"\",\n    webhook_name: \"\",\n    channel_id: \"\",\n    active: 0,\n    url: \"\",\n    creator_id: \"\",\n    create_time: \"\",\n    update_time: \"\",\n    avatar: \"\",\n    status: 0\n  };\n}\nvar Webhook = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.webhook_name !== \"\") {\n      writer.uint32(18).string(message.webhook_name);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    if (message.active !== 0) {\n      writer.uint32(32).int32(message.active);\n    }\n    if (message.url !== \"\") {\n      writer.uint32(42).string(message.url);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(50).string(message.creator_id);\n    }\n    if (message.create_time !== \"\") {\n      writer.uint32(58).string(message.create_time);\n    }\n    if (message.update_time !== \"\") {\n      writer.uint32(66).string(message.update_time);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(74).string(message.avatar);\n    }\n    if (message.status !== 0) {\n      writer.uint32(80).int32(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseWebhook();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.webhook_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.url = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.create_time = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.update_time = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      webhook_name: isSet3(object.webhook_name) ? globalThis.String(object.webhook_name) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      url: isSet3(object.url) ? globalThis.String(object.url) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      create_time: isSet3(object.create_time) ? globalThis.String(object.create_time) : \"\",\n      update_time: isSet3(object.update_time) ? globalThis.String(object.update_time) : \"\",\n      avatar: isSet3(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      status: isSet3(object.status) ? globalThis.Number(object.status) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.webhook_name !== \"\") {\n      obj.webhook_name = message.webhook_name;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.url !== \"\") {\n      obj.url = message.url;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.create_time !== \"\") {\n      obj.create_time = message.create_time;\n    }\n    if (message.update_time !== \"\") {\n      obj.update_time = message.update_time;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    return obj;\n  },\n  create(base) {\n    return Webhook.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseWebhook();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.webhook_name = (_b = object.webhook_name) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.active = (_d = object.active) != null ? _d : 0;\n    message.url = (_e = object.url) != null ? _e : \"\";\n    message.creator_id = (_f = object.creator_id) != null ? _f : \"\";\n    message.create_time = (_g = object.create_time) != null ? _g : \"\";\n    message.update_time = (_h = object.update_time) != null ? _h : \"\";\n    message.avatar = (_i = object.avatar) != null ? _i : \"\";\n    message.status = (_j = object.status) != null ? _j : 0;\n    return message;\n  }\n};\nfunction createBaseWebhookListRequest() {\n  return { channel_id: \"\", clan_id: \"\" };\n}\nvar WebhookListRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseWebhookListRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return WebhookListRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseWebhookListRequest();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseWebhookListResponse() {\n  return { webhooks: [] };\n}\nvar WebhookListResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.webhooks) {\n      Webhook.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseWebhookListResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.webhooks.push(Webhook.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      webhooks: globalThis.Array.isArray(object == null ? void 0 : object.webhooks) ? object.webhooks.map((e) => Webhook.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.webhooks) == null ? void 0 : _a.length) {\n      obj.webhooks = message.webhooks.map((e) => Webhook.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return WebhookListResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseWebhookListResponse();\n    message.webhooks = ((_a = object.webhooks) == null ? void 0 : _a.map((e) => Webhook.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseGiveCoffeeEvent() {\n  return { sender_id: \"\", receiver_id: \"\", token_count: 0, message_ref_id: \"\", channel_id: \"\", clan_id: \"\" };\n}\nvar GiveCoffeeEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.sender_id !== \"\") {\n      writer.uint32(10).string(message.sender_id);\n    }\n    if (message.receiver_id !== \"\") {\n      writer.uint32(18).string(message.receiver_id);\n    }\n    if (message.token_count !== 0) {\n      writer.uint32(24).int32(message.token_count);\n    }\n    if (message.message_ref_id !== \"\") {\n      writer.uint32(34).string(message.message_ref_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseGiveCoffeeEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.receiver_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.token_count = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.message_ref_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      receiver_id: isSet3(object.receiver_id) ? globalThis.String(object.receiver_id) : \"\",\n      token_count: isSet3(object.token_count) ? globalThis.Number(object.token_count) : 0,\n      message_ref_id: isSet3(object.message_ref_id) ? globalThis.String(object.message_ref_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.receiver_id !== \"\") {\n      obj.receiver_id = message.receiver_id;\n    }\n    if (message.token_count !== 0) {\n      obj.token_count = Math.round(message.token_count);\n    }\n    if (message.message_ref_id !== \"\") {\n      obj.message_ref_id = message.message_ref_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return GiveCoffeeEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseGiveCoffeeEvent();\n    message.sender_id = (_a = object.sender_id) != null ? _a : \"\";\n    message.receiver_id = (_b = object.receiver_id) != null ? _b : \"\";\n    message.token_count = (_c = object.token_count) != null ? _c : 0;\n    message.message_ref_id = (_d = object.message_ref_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleListEventRequest() {\n  return { clan_id: \"\", limit: 0, state: 0, cursor: \"\" };\n}\nvar RoleListEventRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.limit !== 0) {\n      writer.uint32(16).int32(message.limit);\n    }\n    if (message.state !== 0) {\n      writer.uint32(24).int32(message.state);\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(34).string(message.cursor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleListEventRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.limit = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.state = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      limit: isSet3(object.limit) ? globalThis.Number(object.limit) : 0,\n      state: isSet3(object.state) ? globalThis.Number(object.state) : 0,\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.limit !== 0) {\n      obj.limit = Math.round(message.limit);\n    }\n    if (message.state !== 0) {\n      obj.state = Math.round(message.state);\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleListEventRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleListEventRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.limit = (_b = object.limit) != null ? _b : 0;\n    message.state = (_c = object.state) != null ? _c : 0;\n    message.cursor = (_d = object.cursor) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleListEventResponse() {\n  return { limit: 0, state: 0, cursor: \"\", clanId: \"\", roles: void 0 };\n}\nvar RoleListEventResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.limit !== 0) {\n      writer.uint32(8).int32(message.limit);\n    }\n    if (message.state !== 0) {\n      writer.uint32(16).int32(message.state);\n    }\n    if (message.cursor !== \"\") {\n      writer.uint32(26).string(message.cursor);\n    }\n    if (message.clanId !== \"\") {\n      writer.uint32(34).string(message.clanId);\n    }\n    if (message.roles !== void 0) {\n      RoleList.encode(message.roles, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleListEventResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.limit = reader.int32();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.state = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.cursor = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clanId = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.roles = RoleList.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      limit: isSet3(object.limit) ? globalThis.Number(object.limit) : 0,\n      state: isSet3(object.state) ? globalThis.Number(object.state) : 0,\n      cursor: isSet3(object.cursor) ? globalThis.String(object.cursor) : \"\",\n      clanId: isSet3(object.clanId) ? globalThis.String(object.clanId) : \"\",\n      roles: isSet3(object.roles) ? RoleList.fromJSON(object.roles) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.limit !== 0) {\n      obj.limit = Math.round(message.limit);\n    }\n    if (message.state !== 0) {\n      obj.state = Math.round(message.state);\n    }\n    if (message.cursor !== \"\") {\n      obj.cursor = message.cursor;\n    }\n    if (message.clanId !== \"\") {\n      obj.clanId = message.clanId;\n    }\n    if (message.roles !== void 0) {\n      obj.roles = RoleList.toJSON(message.roles);\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleListEventResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleListEventResponse();\n    message.limit = (_a = object.limit) != null ? _a : 0;\n    message.state = (_b = object.state) != null ? _b : 0;\n    message.cursor = (_c = object.cursor) != null ? _c : \"\";\n    message.clanId = (_d = object.clanId) != null ? _d : \"\";\n    message.roles = object.roles !== void 0 && object.roles !== null ? RoleList.fromPartial(object.roles) : void 0;\n    return message;\n  }\n};\nfunction createBaseUserPermissionInChannelListRequest() {\n  return { clan_id: \"\", channel_id: \"\" };\n}\nvar UserPermissionInChannelListRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserPermissionInChannelListRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserPermissionInChannelListRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserPermissionInChannelListRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseUserPermissionInChannelListResponse() {\n  return { clan_id: \"\", channel_id: \"\", permissions: void 0 };\n}\nvar UserPermissionInChannelListResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.permissions !== void 0) {\n      PermissionList.encode(message.permissions, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserPermissionInChannelListResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.permissions = PermissionList.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      permissions: isSet3(object.permissions) ? PermissionList.fromJSON(object.permissions) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.permissions !== void 0) {\n      obj.permissions = PermissionList.toJSON(message.permissions);\n    }\n    return obj;\n  },\n  create(base) {\n    return UserPermissionInChannelListResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserPermissionInChannelListResponse();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.permissions = object.permissions !== void 0 && object.permissions !== null ? PermissionList.fromPartial(object.permissions) : void 0;\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannel() {\n  return { permission_id: \"\", active: false };\n}\nvar PermissionRoleChannel = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.permission_id !== \"\") {\n      writer.uint32(10).string(message.permission_id);\n    }\n    if (message.active !== false) {\n      writer.uint32(16).bool(message.active);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.permission_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.active = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      permission_id: isSet3(object.permission_id) ? globalThis.String(object.permission_id) : \"\",\n      active: isSet3(object.active) ? globalThis.Boolean(object.active) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.permission_id !== \"\") {\n      obj.permission_id = message.permission_id;\n    }\n    if (message.active !== false) {\n      obj.active = message.active;\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBasePermissionRoleChannel();\n    message.permission_id = (_a = object.permission_id) != null ? _a : \"\";\n    message.active = (_b = object.active) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannelListEventRequest() {\n  return { role_id: \"\", channel_id: \"\", user_id: \"\" };\n}\nvar PermissionRoleChannelListEventRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.role_id !== \"\") {\n      writer.uint32(10).string(message.role_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(34).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannelListEventRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_id: isSet3(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannelListEventRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBasePermissionRoleChannelListEventRequest();\n    message.role_id = (_a = object.role_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.user_id = (_c = object.user_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBasePermissionRoleChannelListEventResponse() {\n  return { role_id: \"\", channel_id: \"\", user_id: \"\", permission_role_channel: [] };\n}\nvar PermissionRoleChannelListEventResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.role_id !== \"\") {\n      writer.uint32(10).string(message.role_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    for (const v of message.permission_role_channel) {\n      PermissionRoleChannel.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionRoleChannelListEventResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.permission_role_channel.push(PermissionRoleChannel.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role_id: isSet3(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      permission_role_channel: globalThis.Array.isArray(object == null ? void 0 : object.permission_role_channel) ? object.permission_role_channel.map((e) => PermissionRoleChannel.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if ((_a = message.permission_role_channel) == null ? void 0 : _a.length) {\n      obj.permission_role_channel = message.permission_role_channel.map((e) => PermissionRoleChannel.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionRoleChannelListEventResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBasePermissionRoleChannelListEventResponse();\n    message.role_id = (_a = object.role_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.user_id = (_c = object.user_id) != null ? _c : \"\";\n    message.permission_role_channel = ((_d = object.permission_role_channel) == null ? void 0 : _d.map((e) => PermissionRoleChannel.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseChannelSettingListRequest() {\n  return {\n    clan_id: \"\",\n    parent_id: \"\",\n    category_id: \"\",\n    privateChannel: void 0,\n    active: void 0,\n    status: void 0,\n    type: void 0,\n    limit: void 0,\n    page: void 0,\n    channel_label: \"\"\n  };\n}\nvar ChannelSettingListRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(18).string(message.parent_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(26).string(message.category_id);\n    }\n    if (message.privateChannel !== void 0) {\n      Int32Value.encode({ value: message.privateChannel }, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.active !== void 0) {\n      Int32Value.encode({ value: message.active }, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.status !== void 0) {\n      Int32Value.encode({ value: message.status }, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.type !== void 0) {\n      Int32Value.encode({ value: message.type }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.limit !== void 0) {\n      Int32Value.encode({ value: message.limit }, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.page !== void 0) {\n      Int32Value.encode({ value: message.page }, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(82).string(message.channel_label);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelSettingListRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.privateChannel = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.active = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.status = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.limit = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.page = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      parent_id: isSet3(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      category_id: isSet3(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      privateChannel: isSet3(object.privateChannel) ? Number(object.privateChannel) : void 0,\n      active: isSet3(object.active) ? Number(object.active) : void 0,\n      status: isSet3(object.status) ? Number(object.status) : void 0,\n      type: isSet3(object.type) ? Number(object.type) : void 0,\n      limit: isSet3(object.limit) ? Number(object.limit) : void 0,\n      page: isSet3(object.page) ? Number(object.page) : void 0,\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.privateChannel !== void 0) {\n      obj.privateChannel = message.privateChannel;\n    }\n    if (message.active !== void 0) {\n      obj.active = message.active;\n    }\n    if (message.status !== void 0) {\n      obj.status = message.status;\n    }\n    if (message.type !== void 0) {\n      obj.type = message.type;\n    }\n    if (message.limit !== void 0) {\n      obj.limit = message.limit;\n    }\n    if (message.page !== void 0) {\n      obj.page = message.page;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelSettingListRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    const message = createBaseChannelSettingListRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.parent_id = (_b = object.parent_id) != null ? _b : \"\";\n    message.category_id = (_c = object.category_id) != null ? _c : \"\";\n    message.privateChannel = (_d = object.privateChannel) != null ? _d : void 0;\n    message.active = (_e = object.active) != null ? _e : void 0;\n    message.status = (_f = object.status) != null ? _f : void 0;\n    message.type = (_g = object.type) != null ? _g : void 0;\n    message.limit = (_h = object.limit) != null ? _h : void 0;\n    message.page = (_i = object.page) != null ? _i : void 0;\n    message.channel_label = (_j = object.channel_label) != null ? _j : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelSettingItem() {\n  return {\n    id: \"\",\n    creator_id: \"\",\n    parent_id: \"\",\n    channel_label: \"\",\n    category_id: \"\",\n    meeting_code: \"\",\n    channel_private: 0,\n    channel_type: 0,\n    active: 0,\n    user_ids: [],\n    message_count: 0,\n    last_sent_message: void 0\n  };\n}\nvar ChannelSettingItem = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(18).string(message.creator_id);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(26).string(message.parent_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(34).string(message.channel_label);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(42).string(message.category_id);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(50).string(message.meeting_code);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(64).int32(message.channel_type);\n    }\n    if (message.active !== 0) {\n      writer.uint32(72).int32(message.active);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(82).string(v);\n    }\n    if (message.message_count !== 0) {\n      writer.uint32(88).int64(message.message_count);\n    }\n    if (message.last_sent_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelSettingItem();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.message_count = longToNumber2(reader.int64());\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      parent_id: isSet3(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      channel_label: isSet3(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      category_id: isSet3(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      meeting_code: isSet3(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      channel_private: isSet3(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      channel_type: isSet3(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      message_count: isSet3(object.message_count) ? globalThis.Number(object.message_count) : 0,\n      last_sent_message: isSet3(object.last_sent_message) ? ChannelMessageHeader.fromJSON(object.last_sent_message) : void 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if (message.message_count !== 0) {\n      obj.message_count = Math.round(message.message_count);\n    }\n    if (message.last_sent_message !== void 0) {\n      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelSettingItem.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseChannelSettingItem();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.creator_id = (_b = object.creator_id) != null ? _b : \"\";\n    message.parent_id = (_c = object.parent_id) != null ? _c : \"\";\n    message.channel_label = (_d = object.channel_label) != null ? _d : \"\";\n    message.category_id = (_e = object.category_id) != null ? _e : \"\";\n    message.meeting_code = (_f = object.meeting_code) != null ? _f : \"\";\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.channel_type = (_h = object.channel_type) != null ? _h : 0;\n    message.active = (_i = object.active) != null ? _i : 0;\n    message.user_ids = ((_j = object.user_ids) == null ? void 0 : _j.map((e) => e)) || [];\n    message.message_count = (_k = object.message_count) != null ? _k : 0;\n    message.last_sent_message = object.last_sent_message !== void 0 && object.last_sent_message !== null ? ChannelMessageHeader.fromPartial(object.last_sent_message) : void 0;\n    return message;\n  }\n};\nfunction createBaseChannelSettingListResponse() {\n  return { clan_id: \"\", channel_count: 0, thread_count: 0, channel_setting_list: [] };\n}\nvar ChannelSettingListResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_count !== 0) {\n      writer.uint32(16).int32(message.channel_count);\n    }\n    if (message.thread_count !== 0) {\n      writer.uint32(24).int32(message.thread_count);\n    }\n    for (const v of message.channel_setting_list) {\n      ChannelSettingItem.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelSettingListResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.channel_count = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.thread_count = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_setting_list.push(ChannelSettingItem.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_count: isSet3(object.channel_count) ? globalThis.Number(object.channel_count) : 0,\n      thread_count: isSet3(object.thread_count) ? globalThis.Number(object.thread_count) : 0,\n      channel_setting_list: globalThis.Array.isArray(object == null ? void 0 : object.channel_setting_list) ? object.channel_setting_list.map((e) => ChannelSettingItem.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_count !== 0) {\n      obj.channel_count = Math.round(message.channel_count);\n    }\n    if (message.thread_count !== 0) {\n      obj.thread_count = Math.round(message.thread_count);\n    }\n    if ((_a = message.channel_setting_list) == null ? void 0 : _a.length) {\n      obj.channel_setting_list = message.channel_setting_list.map((e) => ChannelSettingItem.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelSettingListResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseChannelSettingListResponse();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_count = (_b = object.channel_count) != null ? _b : 0;\n    message.thread_count = (_c = object.thread_count) != null ? _c : 0;\n    message.channel_setting_list = ((_d = object.channel_setting_list) == null ? void 0 : _d.map((e) => ChannelSettingItem.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseListFavoriteChannelRequest() {\n  return { clan_id: \"\" };\n}\nvar ListFavoriteChannelRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListFavoriteChannelRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListFavoriteChannelRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListFavoriteChannelRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseListFavoriteChannelResponse() {\n  return { channel_ids: [] };\n}\nvar ListFavoriteChannelResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.channel_ids) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListFavoriteChannelResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_ids.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_ids: globalThis.Array.isArray(object == null ? void 0 : object.channel_ids) ? object.channel_ids.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.channel_ids) == null ? void 0 : _a.length) {\n      obj.channel_ids = message.channel_ids;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListFavoriteChannelResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListFavoriteChannelResponse();\n    message.channel_ids = ((_a = object.channel_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseUserActivity() {\n  return {\n    user_id: \"\",\n    activity_name: \"\",\n    activity_type: 0,\n    activity_description: \"\",\n    start_time: void 0,\n    end_time: void 0,\n    application_id: \"\",\n    status: 0\n  };\n}\nvar UserActivity = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.activity_name !== \"\") {\n      writer.uint32(18).string(message.activity_name);\n    }\n    if (message.activity_type !== 0) {\n      writer.uint32(24).int32(message.activity_type);\n    }\n    if (message.activity_description !== \"\") {\n      writer.uint32(34).string(message.activity_description);\n    }\n    if (message.start_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(42).fork()).ldelim();\n    }\n    if (message.end_time !== void 0) {\n      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.application_id !== \"\") {\n      writer.uint32(58).string(message.application_id);\n    }\n    if (message.status !== 0) {\n      writer.uint32(64).int32(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserActivity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.activity_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.activity_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.activity_description = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.application_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet3(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      activity_name: isSet3(object.activity_name) ? globalThis.String(object.activity_name) : \"\",\n      activity_type: isSet3(object.activity_type) ? globalThis.Number(object.activity_type) : 0,\n      activity_description: isSet3(object.activity_description) ? globalThis.String(object.activity_description) : \"\",\n      start_time: isSet3(object.start_time) ? fromJsonTimestamp(object.start_time) : void 0,\n      end_time: isSet3(object.end_time) ? fromJsonTimestamp(object.end_time) : void 0,\n      application_id: isSet3(object.application_id) ? globalThis.String(object.application_id) : \"\",\n      status: isSet3(object.status) ? globalThis.Number(object.status) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.activity_name !== \"\") {\n      obj.activity_name = message.activity_name;\n    }\n    if (message.activity_type !== 0) {\n      obj.activity_type = Math.round(message.activity_type);\n    }\n    if (message.activity_description !== \"\") {\n      obj.activity_description = message.activity_description;\n    }\n    if (message.start_time !== void 0) {\n      obj.start_time = message.start_time.toISOString();\n    }\n    if (message.end_time !== void 0) {\n      obj.end_time = message.end_time.toISOString();\n    }\n    if (message.application_id !== \"\") {\n      obj.application_id = message.application_id;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    return obj;\n  },\n  create(base) {\n    return UserActivity.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseUserActivity();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.activity_name = (_b = object.activity_name) != null ? _b : \"\";\n    message.activity_type = (_c = object.activity_type) != null ? _c : 0;\n    message.activity_description = (_d = object.activity_description) != null ? _d : \"\";\n    message.start_time = (_e = object.start_time) != null ? _e : void 0;\n    message.end_time = (_f = object.end_time) != null ? _f : void 0;\n    message.application_id = (_g = object.application_id) != null ? _g : \"\";\n    message.status = (_h = object.status) != null ? _h : 0;\n    return message;\n  }\n};\nfunction createBaseTokenSentEvent() {\n  return {\n    sender_id: \"\",\n    sender_name: \"\",\n    receiver_id: \"\",\n    amount: 0,\n    note: \"\",\n    extra_attribute: \"\",\n    transaction_id: \"\"\n  };\n}\nvar TokenSentEvent = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.sender_id !== \"\") {\n      writer.uint32(10).string(message.sender_id);\n    }\n    if (message.sender_name !== \"\") {\n      writer.uint32(18).string(message.sender_name);\n    }\n    if (message.receiver_id !== \"\") {\n      writer.uint32(26).string(message.receiver_id);\n    }\n    if (message.amount !== 0) {\n      writer.uint32(32).int32(message.amount);\n    }\n    if (message.note !== \"\") {\n      writer.uint32(42).string(message.note);\n    }\n    if (message.extra_attribute !== \"\") {\n      writer.uint32(50).string(message.extra_attribute);\n    }\n    if (message.transaction_id !== \"\") {\n      writer.uint32(58).string(message.transaction_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseTokenSentEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sender_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.receiver_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.amount = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.note = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.extra_attribute = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.transaction_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sender_id: isSet3(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      sender_name: isSet3(object.sender_name) ? globalThis.String(object.sender_name) : \"\",\n      receiver_id: isSet3(object.receiver_id) ? globalThis.String(object.receiver_id) : \"\",\n      amount: isSet3(object.amount) ? globalThis.Number(object.amount) : 0,\n      note: isSet3(object.note) ? globalThis.String(object.note) : \"\",\n      extra_attribute: isSet3(object.extra_attribute) ? globalThis.String(object.extra_attribute) : \"\",\n      transaction_id: isSet3(object.transaction_id) ? globalThis.String(object.transaction_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.sender_name !== \"\") {\n      obj.sender_name = message.sender_name;\n    }\n    if (message.receiver_id !== \"\") {\n      obj.receiver_id = message.receiver_id;\n    }\n    if (message.amount !== 0) {\n      obj.amount = Math.round(message.amount);\n    }\n    if (message.note !== \"\") {\n      obj.note = message.note;\n    }\n    if (message.extra_attribute !== \"\") {\n      obj.extra_attribute = message.extra_attribute;\n    }\n    if (message.transaction_id !== \"\") {\n      obj.transaction_id = message.transaction_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return TokenSentEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseTokenSentEvent();\n    message.sender_id = (_a = object.sender_id) != null ? _a : \"\";\n    message.sender_name = (_b = object.sender_name) != null ? _b : \"\";\n    message.receiver_id = (_c = object.receiver_id) != null ? _c : \"\";\n    message.amount = (_d = object.amount) != null ? _d : 0;\n    message.note = (_e = object.note) != null ? _e : \"\";\n    message.extra_attribute = (_f = object.extra_attribute) != null ? _f : \"\";\n    message.transaction_id = (_g = object.transaction_id) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseClanWebhook() {\n  return {\n    id: \"\",\n    webhook_name: \"\",\n    clan_id: \"\",\n    active: 0,\n    url: \"\",\n    creator_id: \"\",\n    avatar: \"\",\n    create_time: \"\",\n    update_time: \"\"\n  };\n}\nvar ClanWebhook = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.webhook_name !== \"\") {\n      writer.uint32(18).string(message.webhook_name);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.active !== 0) {\n      writer.uint32(32).int32(message.active);\n    }\n    if (message.url !== \"\") {\n      writer.uint32(42).string(message.url);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(50).string(message.creator_id);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(58).string(message.avatar);\n    }\n    if (message.create_time !== \"\") {\n      writer.uint32(66).string(message.create_time);\n    }\n    if (message.update_time !== \"\") {\n      writer.uint32(74).string(message.update_time);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanWebhook();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.webhook_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.url = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.create_time = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.update_time = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet3(object.id) ? globalThis.String(object.id) : \"\",\n      webhook_name: isSet3(object.webhook_name) ? globalThis.String(object.webhook_name) : \"\",\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      active: isSet3(object.active) ? globalThis.Number(object.active) : 0,\n      url: isSet3(object.url) ? globalThis.String(object.url) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      avatar: isSet3(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      create_time: isSet3(object.create_time) ? globalThis.String(object.create_time) : \"\",\n      update_time: isSet3(object.update_time) ? globalThis.String(object.update_time) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.webhook_name !== \"\") {\n      obj.webhook_name = message.webhook_name;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.url !== \"\") {\n      obj.url = message.url;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.create_time !== \"\") {\n      obj.create_time = message.create_time;\n    }\n    if (message.update_time !== \"\") {\n      obj.update_time = message.update_time;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanWebhook.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseClanWebhook();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.webhook_name = (_b = object.webhook_name) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.active = (_d = object.active) != null ? _d : 0;\n    message.url = (_e = object.url) != null ? _e : \"\";\n    message.creator_id = (_f = object.creator_id) != null ? _f : \"\";\n    message.avatar = (_g = object.avatar) != null ? _g : \"\";\n    message.create_time = (_h = object.create_time) != null ? _h : \"\";\n    message.update_time = (_i = object.update_time) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction createBaseListClanWebhookRequest() {\n  return { clan_id: \"\" };\n}\nvar ListClanWebhookRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListClanWebhookRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ListClanWebhookRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListClanWebhookRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseListClanWebhookResponse() {\n  return { list_clan_webhooks: [] };\n}\nvar ListClanWebhookResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    for (const v of message.list_clan_webhooks) {\n      ClanWebhook.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListClanWebhookResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.list_clan_webhooks.push(ClanWebhook.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      list_clan_webhooks: globalThis.Array.isArray(object == null ? void 0 : object.list_clan_webhooks) ? object.list_clan_webhooks.map((e) => ClanWebhook.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.list_clan_webhooks) == null ? void 0 : _a.length) {\n      obj.list_clan_webhooks = message.list_clan_webhooks.map((e) => ClanWebhook.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return ListClanWebhookResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListClanWebhookResponse();\n    message.list_clan_webhooks = ((_a = object.list_clan_webhooks) == null ? void 0 : _a.map((e) => ClanWebhook.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseGenerateMezonMeetResponse() {\n  return { meet_id: \"\", room_name: \"\", external_link: \"\", creator_id: \"\", event_id: \"\" };\n}\nvar GenerateMezonMeetResponse = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.meet_id !== \"\") {\n      writer.uint32(10).string(message.meet_id);\n    }\n    if (message.room_name !== \"\") {\n      writer.uint32(18).string(message.room_name);\n    }\n    if (message.external_link !== \"\") {\n      writer.uint32(26).string(message.external_link);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(34).string(message.creator_id);\n    }\n    if (message.event_id !== \"\") {\n      writer.uint32(42).string(message.event_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseGenerateMezonMeetResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.meet_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.room_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.external_link = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.event_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      meet_id: isSet3(object.meet_id) ? globalThis.String(object.meet_id) : \"\",\n      room_name: isSet3(object.room_name) ? globalThis.String(object.room_name) : \"\",\n      external_link: isSet3(object.external_link) ? globalThis.String(object.external_link) : \"\",\n      creator_id: isSet3(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      event_id: isSet3(object.event_id) ? globalThis.String(object.event_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.meet_id !== \"\") {\n      obj.meet_id = message.meet_id;\n    }\n    if (message.room_name !== \"\") {\n      obj.room_name = message.room_name;\n    }\n    if (message.external_link !== \"\") {\n      obj.external_link = message.external_link;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.event_id !== \"\") {\n      obj.event_id = message.event_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return GenerateMezonMeetResponse.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseGenerateMezonMeetResponse();\n    message.meet_id = (_a = object.meet_id) != null ? _a : \"\";\n    message.room_name = (_b = object.room_name) != null ? _b : \"\";\n    message.external_link = (_c = object.external_link) != null ? _c : \"\";\n    message.creator_id = (_d = object.creator_id) != null ? _d : \"\";\n    message.event_id = (_e = object.event_id) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseSearchThreadRequest() {\n  return { clan_id: \"\", channel_id: \"\", label: \"\" };\n}\nvar SearchThreadRequest = {\n  encode(message, writer = import_minimal4.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(26).string(message.label);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal4.default.Reader ? input : import_minimal4.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseSearchThreadRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.label = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet3(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet3(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      label: isSet3(object.label) ? globalThis.String(object.label) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.label !== \"\") {\n      obj.label = message.label;\n    }\n    return obj;\n  },\n  create(base) {\n    return SearchThreadRequest.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseSearchThreadRequest();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.label = (_c = object.label) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction toTimestamp(date) {\n  const seconds = Math.trunc(date.getTime() / 1e3);\n  const nanos = date.getTime() % 1e3 * 1e6;\n  return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n  let millis = (t.seconds || 0) * 1e3;\n  millis += (t.nanos || 0) / 1e6;\n  return new globalThis.Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n  if (o instanceof globalThis.Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new globalThis.Date(o);\n  } else {\n    return fromTimestamp(Timestamp.fromJSON(o));\n  }\n}\nfunction longToNumber2(long) {\n  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return long.toNumber();\n}\nif (import_minimal4.default.util.Long !== import_long3.default) {\n  import_minimal4.default.util.Long = import_long3.default;\n  import_minimal4.default.configure();\n}\nfunction isSet3(value) {\n  return value !== null && value !== void 0;\n}\n\n// rtapi/realtime.ts\nfunction createBaseEnvelope() {\n  return {\n    cid: \"\",\n    channel: void 0,\n    clan_join: void 0,\n    channel_join: void 0,\n    channel_leave: void 0,\n    channel_message: void 0,\n    channel_message_ack: void 0,\n    channel_message_send: void 0,\n    channel_message_update: void 0,\n    channel_message_remove: void 0,\n    channel_presence_event: void 0,\n    error: void 0,\n    notifications: void 0,\n    rpc: void 0,\n    status: void 0,\n    status_follow: void 0,\n    status_presence_event: void 0,\n    status_unfollow: void 0,\n    status_update: void 0,\n    stream_data: void 0,\n    stream_presence_event: void 0,\n    ping: void 0,\n    pong: void 0,\n    message_typing_event: void 0,\n    last_seen_message_event: void 0,\n    message_reaction_event: void 0,\n    voice_joined_event: void 0,\n    voice_leaved_event: void 0,\n    voice_started_event: void 0,\n    voice_ended_event: void 0,\n    channel_created_event: void 0,\n    channel_deleted_event: void 0,\n    channel_updated_event: void 0,\n    last_pin_message_event: void 0,\n    custom_status_event: void 0,\n    user_channel_added_event: void 0,\n    user_channel_removed_event: void 0,\n    user_clan_removed_event: void 0,\n    clan_updated_event: void 0,\n    clan_profile_updated_event: void 0,\n    check_name_existed_event: void 0,\n    user_profile_updated_event: void 0,\n    add_clan_user_event: void 0,\n    clan_event_created: void 0,\n    role_assign_event: void 0,\n    clan_deleted_event: void 0,\n    give_coffee_event: void 0,\n    sticker_create_event: void 0,\n    sticker_update_event: void 0,\n    sticker_delete_event: void 0,\n    role_event: void 0,\n    event_emoji: void 0,\n    streaming_joined_event: void 0,\n    streaming_leaved_event: void 0,\n    streaming_started_event: void 0,\n    streaming_ended_event: void 0,\n    permission_set_event: void 0,\n    permission_changed_event: void 0,\n    token_sent_event: void 0,\n    message_button_clicked: void 0,\n    unmute_event: void 0,\n    webrtc_signaling_fwd: void 0,\n    list_activity: void 0,\n    dropdown_box_selected: void 0,\n    incoming_call_push: void 0,\n    sd_topic_event: void 0,\n    follow_event: void 0,\n    channel_app_event: void 0,\n    user_status_event: void 0,\n    remove_friend: void 0,\n    webhook_event: void 0,\n    noti_user_channel: void 0,\n    join_channel_app_data: void 0,\n    canvas_event: void 0,\n    unpin_message_event: void 0,\n    category_event: void 0,\n    handle_participant_meet_state_event: void 0,\n    delete_account_event: void 0,\n    ephemeral_message_send: void 0,\n    block_friend: void 0,\n    voice_reaction_send: void 0,\n    mark_as_read: void 0,\n    list_data_socket: void 0\n  };\n}\nvar Envelope = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.cid !== \"\") {\n      writer.uint32(10).string(message.cid);\n    }\n    if (message.channel !== void 0) {\n      Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.clan_join !== void 0) {\n      ClanJoin.encode(message.clan_join, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.channel_join !== void 0) {\n      ChannelJoin.encode(message.channel_join, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.channel_leave !== void 0) {\n      ChannelLeave.encode(message.channel_leave, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.channel_message !== void 0) {\n      ChannelMessage.encode(message.channel_message, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.channel_message_ack !== void 0) {\n      ChannelMessageAck.encode(message.channel_message_ack, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.channel_message_send !== void 0) {\n      ChannelMessageSend.encode(message.channel_message_send, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.channel_message_update !== void 0) {\n      ChannelMessageUpdate.encode(message.channel_message_update, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.channel_message_remove !== void 0) {\n      ChannelMessageRemove.encode(message.channel_message_remove, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.channel_presence_event !== void 0) {\n      ChannelPresenceEvent.encode(message.channel_presence_event, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.error !== void 0) {\n      Error2.encode(message.error, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.notifications !== void 0) {\n      Notifications.encode(message.notifications, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.rpc !== void 0) {\n      Rpc.encode(message.rpc, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.status !== void 0) {\n      Status.encode(message.status, writer.uint32(122).fork()).ldelim();\n    }\n    if (message.status_follow !== void 0) {\n      StatusFollow.encode(message.status_follow, writer.uint32(130).fork()).ldelim();\n    }\n    if (message.status_presence_event !== void 0) {\n      StatusPresenceEvent.encode(message.status_presence_event, writer.uint32(138).fork()).ldelim();\n    }\n    if (message.status_unfollow !== void 0) {\n      StatusUnfollow.encode(message.status_unfollow, writer.uint32(146).fork()).ldelim();\n    }\n    if (message.status_update !== void 0) {\n      StatusUpdate.encode(message.status_update, writer.uint32(154).fork()).ldelim();\n    }\n    if (message.stream_data !== void 0) {\n      StreamData.encode(message.stream_data, writer.uint32(162).fork()).ldelim();\n    }\n    if (message.stream_presence_event !== void 0) {\n      StreamPresenceEvent.encode(message.stream_presence_event, writer.uint32(170).fork()).ldelim();\n    }\n    if (message.ping !== void 0) {\n      Ping.encode(message.ping, writer.uint32(178).fork()).ldelim();\n    }\n    if (message.pong !== void 0) {\n      Pong.encode(message.pong, writer.uint32(186).fork()).ldelim();\n    }\n    if (message.message_typing_event !== void 0) {\n      MessageTypingEvent.encode(message.message_typing_event, writer.uint32(194).fork()).ldelim();\n    }\n    if (message.last_seen_message_event !== void 0) {\n      LastSeenMessageEvent.encode(message.last_seen_message_event, writer.uint32(202).fork()).ldelim();\n    }\n    if (message.message_reaction_event !== void 0) {\n      MessageReaction.encode(message.message_reaction_event, writer.uint32(210).fork()).ldelim();\n    }\n    if (message.voice_joined_event !== void 0) {\n      VoiceJoinedEvent.encode(message.voice_joined_event, writer.uint32(218).fork()).ldelim();\n    }\n    if (message.voice_leaved_event !== void 0) {\n      VoiceLeavedEvent.encode(message.voice_leaved_event, writer.uint32(226).fork()).ldelim();\n    }\n    if (message.voice_started_event !== void 0) {\n      VoiceStartedEvent.encode(message.voice_started_event, writer.uint32(234).fork()).ldelim();\n    }\n    if (message.voice_ended_event !== void 0) {\n      VoiceEndedEvent.encode(message.voice_ended_event, writer.uint32(242).fork()).ldelim();\n    }\n    if (message.channel_created_event !== void 0) {\n      ChannelCreatedEvent.encode(message.channel_created_event, writer.uint32(250).fork()).ldelim();\n    }\n    if (message.channel_deleted_event !== void 0) {\n      ChannelDeletedEvent.encode(message.channel_deleted_event, writer.uint32(258).fork()).ldelim();\n    }\n    if (message.channel_updated_event !== void 0) {\n      ChannelUpdatedEvent.encode(message.channel_updated_event, writer.uint32(266).fork()).ldelim();\n    }\n    if (message.last_pin_message_event !== void 0) {\n      LastPinMessageEvent.encode(message.last_pin_message_event, writer.uint32(274).fork()).ldelim();\n    }\n    if (message.custom_status_event !== void 0) {\n      CustomStatusEvent.encode(message.custom_status_event, writer.uint32(282).fork()).ldelim();\n    }\n    if (message.user_channel_added_event !== void 0) {\n      UserChannelAdded.encode(message.user_channel_added_event, writer.uint32(290).fork()).ldelim();\n    }\n    if (message.user_channel_removed_event !== void 0) {\n      UserChannelRemoved.encode(message.user_channel_removed_event, writer.uint32(298).fork()).ldelim();\n    }\n    if (message.user_clan_removed_event !== void 0) {\n      UserClanRemoved.encode(message.user_clan_removed_event, writer.uint32(306).fork()).ldelim();\n    }\n    if (message.clan_updated_event !== void 0) {\n      ClanUpdatedEvent.encode(message.clan_updated_event, writer.uint32(314).fork()).ldelim();\n    }\n    if (message.clan_profile_updated_event !== void 0) {\n      ClanProfileUpdatedEvent.encode(message.clan_profile_updated_event, writer.uint32(322).fork()).ldelim();\n    }\n    if (message.check_name_existed_event !== void 0) {\n      CheckNameExistedEvent.encode(message.check_name_existed_event, writer.uint32(330).fork()).ldelim();\n    }\n    if (message.user_profile_updated_event !== void 0) {\n      UserProfileUpdatedEvent.encode(message.user_profile_updated_event, writer.uint32(338).fork()).ldelim();\n    }\n    if (message.add_clan_user_event !== void 0) {\n      AddClanUserEvent.encode(message.add_clan_user_event, writer.uint32(346).fork()).ldelim();\n    }\n    if (message.clan_event_created !== void 0) {\n      CreateEventRequest.encode(message.clan_event_created, writer.uint32(354).fork()).ldelim();\n    }\n    if (message.role_assign_event !== void 0) {\n      RoleAssignedEvent.encode(message.role_assign_event, writer.uint32(362).fork()).ldelim();\n    }\n    if (message.clan_deleted_event !== void 0) {\n      ClanDeletedEvent.encode(message.clan_deleted_event, writer.uint32(370).fork()).ldelim();\n    }\n    if (message.give_coffee_event !== void 0) {\n      GiveCoffeeEvent.encode(message.give_coffee_event, writer.uint32(378).fork()).ldelim();\n    }\n    if (message.sticker_create_event !== void 0) {\n      StickerCreateEvent.encode(message.sticker_create_event, writer.uint32(386).fork()).ldelim();\n    }\n    if (message.sticker_update_event !== void 0) {\n      StickerUpdateEvent.encode(message.sticker_update_event, writer.uint32(394).fork()).ldelim();\n    }\n    if (message.sticker_delete_event !== void 0) {\n      StickerDeleteEvent.encode(message.sticker_delete_event, writer.uint32(402).fork()).ldelim();\n    }\n    if (message.role_event !== void 0) {\n      RoleEvent.encode(message.role_event, writer.uint32(410).fork()).ldelim();\n    }\n    if (message.event_emoji !== void 0) {\n      EventEmoji.encode(message.event_emoji, writer.uint32(418).fork()).ldelim();\n    }\n    if (message.streaming_joined_event !== void 0) {\n      StreamingJoinedEvent.encode(message.streaming_joined_event, writer.uint32(426).fork()).ldelim();\n    }\n    if (message.streaming_leaved_event !== void 0) {\n      StreamingLeavedEvent.encode(message.streaming_leaved_event, writer.uint32(434).fork()).ldelim();\n    }\n    if (message.streaming_started_event !== void 0) {\n      StreamingStartedEvent.encode(message.streaming_started_event, writer.uint32(442).fork()).ldelim();\n    }\n    if (message.streaming_ended_event !== void 0) {\n      StreamingEndedEvent.encode(message.streaming_ended_event, writer.uint32(450).fork()).ldelim();\n    }\n    if (message.permission_set_event !== void 0) {\n      PermissionSetEvent.encode(message.permission_set_event, writer.uint32(458).fork()).ldelim();\n    }\n    if (message.permission_changed_event !== void 0) {\n      PermissionChangedEvent.encode(message.permission_changed_event, writer.uint32(466).fork()).ldelim();\n    }\n    if (message.token_sent_event !== void 0) {\n      TokenSentEvent.encode(message.token_sent_event, writer.uint32(474).fork()).ldelim();\n    }\n    if (message.message_button_clicked !== void 0) {\n      MessageButtonClicked.encode(message.message_button_clicked, writer.uint32(482).fork()).ldelim();\n    }\n    if (message.unmute_event !== void 0) {\n      UnmuteEvent.encode(message.unmute_event, writer.uint32(490).fork()).ldelim();\n    }\n    if (message.webrtc_signaling_fwd !== void 0) {\n      WebrtcSignalingFwd.encode(message.webrtc_signaling_fwd, writer.uint32(498).fork()).ldelim();\n    }\n    if (message.list_activity !== void 0) {\n      ListActivity.encode(message.list_activity, writer.uint32(506).fork()).ldelim();\n    }\n    if (message.dropdown_box_selected !== void 0) {\n      DropdownBoxSelected.encode(message.dropdown_box_selected, writer.uint32(514).fork()).ldelim();\n    }\n    if (message.incoming_call_push !== void 0) {\n      IncomingCallPush.encode(message.incoming_call_push, writer.uint32(522).fork()).ldelim();\n    }\n    if (message.sd_topic_event !== void 0) {\n      SdTopicEvent.encode(message.sd_topic_event, writer.uint32(530).fork()).ldelim();\n    }\n    if (message.follow_event !== void 0) {\n      FollowEvent.encode(message.follow_event, writer.uint32(538).fork()).ldelim();\n    }\n    if (message.channel_app_event !== void 0) {\n      ChannelAppEvent.encode(message.channel_app_event, writer.uint32(546).fork()).ldelim();\n    }\n    if (message.user_status_event !== void 0) {\n      UserStatusEvent.encode(message.user_status_event, writer.uint32(554).fork()).ldelim();\n    }\n    if (message.remove_friend !== void 0) {\n      RemoveFriend.encode(message.remove_friend, writer.uint32(562).fork()).ldelim();\n    }\n    if (message.webhook_event !== void 0) {\n      Webhook.encode(message.webhook_event, writer.uint32(570).fork()).ldelim();\n    }\n    if (message.noti_user_channel !== void 0) {\n      NotificationUserChannel.encode(message.noti_user_channel, writer.uint32(578).fork()).ldelim();\n    }\n    if (message.join_channel_app_data !== void 0) {\n      JoinChannelAppData.encode(message.join_channel_app_data, writer.uint32(586).fork()).ldelim();\n    }\n    if (message.canvas_event !== void 0) {\n      ChannelCanvas.encode(message.canvas_event, writer.uint32(594).fork()).ldelim();\n    }\n    if (message.unpin_message_event !== void 0) {\n      UnpinMessageEvent.encode(message.unpin_message_event, writer.uint32(602).fork()).ldelim();\n    }\n    if (message.category_event !== void 0) {\n      CategoryEvent.encode(message.category_event, writer.uint32(610).fork()).ldelim();\n    }\n    if (message.handle_participant_meet_state_event !== void 0) {\n      HandleParticipantMeetStateEvent.encode(message.handle_participant_meet_state_event, writer.uint32(618).fork()).ldelim();\n    }\n    if (message.delete_account_event !== void 0) {\n      DeleteAccountEvent.encode(message.delete_account_event, writer.uint32(626).fork()).ldelim();\n    }\n    if (message.ephemeral_message_send !== void 0) {\n      EphemeralMessageSend.encode(message.ephemeral_message_send, writer.uint32(634).fork()).ldelim();\n    }\n    if (message.block_friend !== void 0) {\n      BlockFriend.encode(message.block_friend, writer.uint32(642).fork()).ldelim();\n    }\n    if (message.voice_reaction_send !== void 0) {\n      VoiceReactionSend.encode(message.voice_reaction_send, writer.uint32(650).fork()).ldelim();\n    }\n    if (message.mark_as_read !== void 0) {\n      MarkAsRead.encode(message.mark_as_read, writer.uint32(658).fork()).ldelim();\n    }\n    if (message.list_data_socket !== void 0) {\n      ListDataSocket.encode(message.list_data_socket, writer.uint32(666).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEnvelope();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.cid = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel = Channel.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_join = ClanJoin.decode(reader, reader.uint32());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_join = ChannelJoin.decode(reader, reader.uint32());\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_leave = ChannelLeave.decode(reader, reader.uint32());\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.channel_message = ChannelMessage.decode(reader, reader.uint32());\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.channel_message_ack = ChannelMessageAck.decode(reader, reader.uint32());\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.channel_message_send = ChannelMessageSend.decode(reader, reader.uint32());\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_message_update = ChannelMessageUpdate.decode(reader, reader.uint32());\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.channel_message_remove = ChannelMessageRemove.decode(reader, reader.uint32());\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.channel_presence_event = ChannelPresenceEvent.decode(reader, reader.uint32());\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.error = Error2.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.notifications = Notifications.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.rpc = Rpc.decode(reader, reader.uint32());\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.status = Status.decode(reader, reader.uint32());\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.status_follow = StatusFollow.decode(reader, reader.uint32());\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.status_presence_event = StatusPresenceEvent.decode(reader, reader.uint32());\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.status_unfollow = StatusUnfollow.decode(reader, reader.uint32());\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.status_update = StatusUpdate.decode(reader, reader.uint32());\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.stream_data = StreamData.decode(reader, reader.uint32());\n          continue;\n        case 21:\n          if (tag !== 170) {\n            break;\n          }\n          message.stream_presence_event = StreamPresenceEvent.decode(reader, reader.uint32());\n          continue;\n        case 22:\n          if (tag !== 178) {\n            break;\n          }\n          message.ping = Ping.decode(reader, reader.uint32());\n          continue;\n        case 23:\n          if (tag !== 186) {\n            break;\n          }\n          message.pong = Pong.decode(reader, reader.uint32());\n          continue;\n        case 24:\n          if (tag !== 194) {\n            break;\n          }\n          message.message_typing_event = MessageTypingEvent.decode(reader, reader.uint32());\n          continue;\n        case 25:\n          if (tag !== 202) {\n            break;\n          }\n          message.last_seen_message_event = LastSeenMessageEvent.decode(reader, reader.uint32());\n          continue;\n        case 26:\n          if (tag !== 210) {\n            break;\n          }\n          message.message_reaction_event = MessageReaction.decode(reader, reader.uint32());\n          continue;\n        case 27:\n          if (tag !== 218) {\n            break;\n          }\n          message.voice_joined_event = VoiceJoinedEvent.decode(reader, reader.uint32());\n          continue;\n        case 28:\n          if (tag !== 226) {\n            break;\n          }\n          message.voice_leaved_event = VoiceLeavedEvent.decode(reader, reader.uint32());\n          continue;\n        case 29:\n          if (tag !== 234) {\n            break;\n          }\n          message.voice_started_event = VoiceStartedEvent.decode(reader, reader.uint32());\n          continue;\n        case 30:\n          if (tag !== 242) {\n            break;\n          }\n          message.voice_ended_event = VoiceEndedEvent.decode(reader, reader.uint32());\n          continue;\n        case 31:\n          if (tag !== 250) {\n            break;\n          }\n          message.channel_created_event = ChannelCreatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 32:\n          if (tag !== 258) {\n            break;\n          }\n          message.channel_deleted_event = ChannelDeletedEvent.decode(reader, reader.uint32());\n          continue;\n        case 33:\n          if (tag !== 266) {\n            break;\n          }\n          message.channel_updated_event = ChannelUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 34:\n          if (tag !== 274) {\n            break;\n          }\n          message.last_pin_message_event = LastPinMessageEvent.decode(reader, reader.uint32());\n          continue;\n        case 35:\n          if (tag !== 282) {\n            break;\n          }\n          message.custom_status_event = CustomStatusEvent.decode(reader, reader.uint32());\n          continue;\n        case 36:\n          if (tag !== 290) {\n            break;\n          }\n          message.user_channel_added_event = UserChannelAdded.decode(reader, reader.uint32());\n          continue;\n        case 37:\n          if (tag !== 298) {\n            break;\n          }\n          message.user_channel_removed_event = UserChannelRemoved.decode(reader, reader.uint32());\n          continue;\n        case 38:\n          if (tag !== 306) {\n            break;\n          }\n          message.user_clan_removed_event = UserClanRemoved.decode(reader, reader.uint32());\n          continue;\n        case 39:\n          if (tag !== 314) {\n            break;\n          }\n          message.clan_updated_event = ClanUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 40:\n          if (tag !== 322) {\n            break;\n          }\n          message.clan_profile_updated_event = ClanProfileUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 41:\n          if (tag !== 330) {\n            break;\n          }\n          message.check_name_existed_event = CheckNameExistedEvent.decode(reader, reader.uint32());\n          continue;\n        case 42:\n          if (tag !== 338) {\n            break;\n          }\n          message.user_profile_updated_event = UserProfileUpdatedEvent.decode(reader, reader.uint32());\n          continue;\n        case 43:\n          if (tag !== 346) {\n            break;\n          }\n          message.add_clan_user_event = AddClanUserEvent.decode(reader, reader.uint32());\n          continue;\n        case 44:\n          if (tag !== 354) {\n            break;\n          }\n          message.clan_event_created = CreateEventRequest.decode(reader, reader.uint32());\n          continue;\n        case 45:\n          if (tag !== 362) {\n            break;\n          }\n          message.role_assign_event = RoleAssignedEvent.decode(reader, reader.uint32());\n          continue;\n        case 46:\n          if (tag !== 370) {\n            break;\n          }\n          message.clan_deleted_event = ClanDeletedEvent.decode(reader, reader.uint32());\n          continue;\n        case 47:\n          if (tag !== 378) {\n            break;\n          }\n          message.give_coffee_event = GiveCoffeeEvent.decode(reader, reader.uint32());\n          continue;\n        case 48:\n          if (tag !== 386) {\n            break;\n          }\n          message.sticker_create_event = StickerCreateEvent.decode(reader, reader.uint32());\n          continue;\n        case 49:\n          if (tag !== 394) {\n            break;\n          }\n          message.sticker_update_event = StickerUpdateEvent.decode(reader, reader.uint32());\n          continue;\n        case 50:\n          if (tag !== 402) {\n            break;\n          }\n          message.sticker_delete_event = StickerDeleteEvent.decode(reader, reader.uint32());\n          continue;\n        case 51:\n          if (tag !== 410) {\n            break;\n          }\n          message.role_event = RoleEvent.decode(reader, reader.uint32());\n          continue;\n        case 52:\n          if (tag !== 418) {\n            break;\n          }\n          message.event_emoji = EventEmoji.decode(reader, reader.uint32());\n          continue;\n        case 53:\n          if (tag !== 426) {\n            break;\n          }\n          message.streaming_joined_event = StreamingJoinedEvent.decode(reader, reader.uint32());\n          continue;\n        case 54:\n          if (tag !== 434) {\n            break;\n          }\n          message.streaming_leaved_event = StreamingLeavedEvent.decode(reader, reader.uint32());\n          continue;\n        case 55:\n          if (tag !== 442) {\n            break;\n          }\n          message.streaming_started_event = StreamingStartedEvent.decode(reader, reader.uint32());\n          continue;\n        case 56:\n          if (tag !== 450) {\n            break;\n          }\n          message.streaming_ended_event = StreamingEndedEvent.decode(reader, reader.uint32());\n          continue;\n        case 57:\n          if (tag !== 458) {\n            break;\n          }\n          message.permission_set_event = PermissionSetEvent.decode(reader, reader.uint32());\n          continue;\n        case 58:\n          if (tag !== 466) {\n            break;\n          }\n          message.permission_changed_event = PermissionChangedEvent.decode(reader, reader.uint32());\n          continue;\n        case 59:\n          if (tag !== 474) {\n            break;\n          }\n          message.token_sent_event = TokenSentEvent.decode(reader, reader.uint32());\n          continue;\n        case 60:\n          if (tag !== 482) {\n            break;\n          }\n          message.message_button_clicked = MessageButtonClicked.decode(reader, reader.uint32());\n          continue;\n        case 61:\n          if (tag !== 490) {\n            break;\n          }\n          message.unmute_event = UnmuteEvent.decode(reader, reader.uint32());\n          continue;\n        case 62:\n          if (tag !== 498) {\n            break;\n          }\n          message.webrtc_signaling_fwd = WebrtcSignalingFwd.decode(reader, reader.uint32());\n          continue;\n        case 63:\n          if (tag !== 506) {\n            break;\n          }\n          message.list_activity = ListActivity.decode(reader, reader.uint32());\n          continue;\n        case 64:\n          if (tag !== 514) {\n            break;\n          }\n          message.dropdown_box_selected = DropdownBoxSelected.decode(reader, reader.uint32());\n          continue;\n        case 65:\n          if (tag !== 522) {\n            break;\n          }\n          message.incoming_call_push = IncomingCallPush.decode(reader, reader.uint32());\n          continue;\n        case 66:\n          if (tag !== 530) {\n            break;\n          }\n          message.sd_topic_event = SdTopicEvent.decode(reader, reader.uint32());\n          continue;\n        case 67:\n          if (tag !== 538) {\n            break;\n          }\n          message.follow_event = FollowEvent.decode(reader, reader.uint32());\n          continue;\n        case 68:\n          if (tag !== 546) {\n            break;\n          }\n          message.channel_app_event = ChannelAppEvent.decode(reader, reader.uint32());\n          continue;\n        case 69:\n          if (tag !== 554) {\n            break;\n          }\n          message.user_status_event = UserStatusEvent.decode(reader, reader.uint32());\n          continue;\n        case 70:\n          if (tag !== 562) {\n            break;\n          }\n          message.remove_friend = RemoveFriend.decode(reader, reader.uint32());\n          continue;\n        case 71:\n          if (tag !== 570) {\n            break;\n          }\n          message.webhook_event = Webhook.decode(reader, reader.uint32());\n          continue;\n        case 72:\n          if (tag !== 578) {\n            break;\n          }\n          message.noti_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\n          continue;\n        case 73:\n          if (tag !== 586) {\n            break;\n          }\n          message.join_channel_app_data = JoinChannelAppData.decode(reader, reader.uint32());\n          continue;\n        case 74:\n          if (tag !== 594) {\n            break;\n          }\n          message.canvas_event = ChannelCanvas.decode(reader, reader.uint32());\n          continue;\n        case 75:\n          if (tag !== 602) {\n            break;\n          }\n          message.unpin_message_event = UnpinMessageEvent.decode(reader, reader.uint32());\n          continue;\n        case 76:\n          if (tag !== 610) {\n            break;\n          }\n          message.category_event = CategoryEvent.decode(reader, reader.uint32());\n          continue;\n        case 77:\n          if (tag !== 618) {\n            break;\n          }\n          message.handle_participant_meet_state_event = HandleParticipantMeetStateEvent.decode(reader, reader.uint32());\n          continue;\n        case 78:\n          if (tag !== 626) {\n            break;\n          }\n          message.delete_account_event = DeleteAccountEvent.decode(reader, reader.uint32());\n          continue;\n        case 79:\n          if (tag !== 634) {\n            break;\n          }\n          message.ephemeral_message_send = EphemeralMessageSend.decode(reader, reader.uint32());\n          continue;\n        case 80:\n          if (tag !== 642) {\n            break;\n          }\n          message.block_friend = BlockFriend.decode(reader, reader.uint32());\n          continue;\n        case 81:\n          if (tag !== 650) {\n            break;\n          }\n          message.voice_reaction_send = VoiceReactionSend.decode(reader, reader.uint32());\n          continue;\n        case 82:\n          if (tag !== 658) {\n            break;\n          }\n          message.mark_as_read = MarkAsRead.decode(reader, reader.uint32());\n          continue;\n        case 83:\n          if (tag !== 666) {\n            break;\n          }\n          message.list_data_socket = ListDataSocket.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      cid: isSet4(object.cid) ? globalThis.String(object.cid) : \"\",\n      channel: isSet4(object.channel) ? Channel.fromJSON(object.channel) : void 0,\n      clan_join: isSet4(object.clan_join) ? ClanJoin.fromJSON(object.clan_join) : void 0,\n      channel_join: isSet4(object.channel_join) ? ChannelJoin.fromJSON(object.channel_join) : void 0,\n      channel_leave: isSet4(object.channel_leave) ? ChannelLeave.fromJSON(object.channel_leave) : void 0,\n      channel_message: isSet4(object.channel_message) ? ChannelMessage.fromJSON(object.channel_message) : void 0,\n      channel_message_ack: isSet4(object.channel_message_ack) ? ChannelMessageAck.fromJSON(object.channel_message_ack) : void 0,\n      channel_message_send: isSet4(object.channel_message_send) ? ChannelMessageSend.fromJSON(object.channel_message_send) : void 0,\n      channel_message_update: isSet4(object.channel_message_update) ? ChannelMessageUpdate.fromJSON(object.channel_message_update) : void 0,\n      channel_message_remove: isSet4(object.channel_message_remove) ? ChannelMessageRemove.fromJSON(object.channel_message_remove) : void 0,\n      channel_presence_event: isSet4(object.channel_presence_event) ? ChannelPresenceEvent.fromJSON(object.channel_presence_event) : void 0,\n      error: isSet4(object.error) ? Error2.fromJSON(object.error) : void 0,\n      notifications: isSet4(object.notifications) ? Notifications.fromJSON(object.notifications) : void 0,\n      rpc: isSet4(object.rpc) ? Rpc.fromJSON(object.rpc) : void 0,\n      status: isSet4(object.status) ? Status.fromJSON(object.status) : void 0,\n      status_follow: isSet4(object.status_follow) ? StatusFollow.fromJSON(object.status_follow) : void 0,\n      status_presence_event: isSet4(object.status_presence_event) ? StatusPresenceEvent.fromJSON(object.status_presence_event) : void 0,\n      status_unfollow: isSet4(object.status_unfollow) ? StatusUnfollow.fromJSON(object.status_unfollow) : void 0,\n      status_update: isSet4(object.status_update) ? StatusUpdate.fromJSON(object.status_update) : void 0,\n      stream_data: isSet4(object.stream_data) ? StreamData.fromJSON(object.stream_data) : void 0,\n      stream_presence_event: isSet4(object.stream_presence_event) ? StreamPresenceEvent.fromJSON(object.stream_presence_event) : void 0,\n      ping: isSet4(object.ping) ? Ping.fromJSON(object.ping) : void 0,\n      pong: isSet4(object.pong) ? Pong.fromJSON(object.pong) : void 0,\n      message_typing_event: isSet4(object.message_typing_event) ? MessageTypingEvent.fromJSON(object.message_typing_event) : void 0,\n      last_seen_message_event: isSet4(object.last_seen_message_event) ? LastSeenMessageEvent.fromJSON(object.last_seen_message_event) : void 0,\n      message_reaction_event: isSet4(object.message_reaction_event) ? MessageReaction.fromJSON(object.message_reaction_event) : void 0,\n      voice_joined_event: isSet4(object.voice_joined_event) ? VoiceJoinedEvent.fromJSON(object.voice_joined_event) : void 0,\n      voice_leaved_event: isSet4(object.voice_leaved_event) ? VoiceLeavedEvent.fromJSON(object.voice_leaved_event) : void 0,\n      voice_started_event: isSet4(object.voice_started_event) ? VoiceStartedEvent.fromJSON(object.voice_started_event) : void 0,\n      voice_ended_event: isSet4(object.voice_ended_event) ? VoiceEndedEvent.fromJSON(object.voice_ended_event) : void 0,\n      channel_created_event: isSet4(object.channel_created_event) ? ChannelCreatedEvent.fromJSON(object.channel_created_event) : void 0,\n      channel_deleted_event: isSet4(object.channel_deleted_event) ? ChannelDeletedEvent.fromJSON(object.channel_deleted_event) : void 0,\n      channel_updated_event: isSet4(object.channel_updated_event) ? ChannelUpdatedEvent.fromJSON(object.channel_updated_event) : void 0,\n      last_pin_message_event: isSet4(object.last_pin_message_event) ? LastPinMessageEvent.fromJSON(object.last_pin_message_event) : void 0,\n      custom_status_event: isSet4(object.custom_status_event) ? CustomStatusEvent.fromJSON(object.custom_status_event) : void 0,\n      user_channel_added_event: isSet4(object.user_channel_added_event) ? UserChannelAdded.fromJSON(object.user_channel_added_event) : void 0,\n      user_channel_removed_event: isSet4(object.user_channel_removed_event) ? UserChannelRemoved.fromJSON(object.user_channel_removed_event) : void 0,\n      user_clan_removed_event: isSet4(object.user_clan_removed_event) ? UserClanRemoved.fromJSON(object.user_clan_removed_event) : void 0,\n      clan_updated_event: isSet4(object.clan_updated_event) ? ClanUpdatedEvent.fromJSON(object.clan_updated_event) : void 0,\n      clan_profile_updated_event: isSet4(object.clan_profile_updated_event) ? ClanProfileUpdatedEvent.fromJSON(object.clan_profile_updated_event) : void 0,\n      check_name_existed_event: isSet4(object.check_name_existed_event) ? CheckNameExistedEvent.fromJSON(object.check_name_existed_event) : void 0,\n      user_profile_updated_event: isSet4(object.user_profile_updated_event) ? UserProfileUpdatedEvent.fromJSON(object.user_profile_updated_event) : void 0,\n      add_clan_user_event: isSet4(object.add_clan_user_event) ? AddClanUserEvent.fromJSON(object.add_clan_user_event) : void 0,\n      clan_event_created: isSet4(object.clan_event_created) ? CreateEventRequest.fromJSON(object.clan_event_created) : void 0,\n      role_assign_event: isSet4(object.role_assign_event) ? RoleAssignedEvent.fromJSON(object.role_assign_event) : void 0,\n      clan_deleted_event: isSet4(object.clan_deleted_event) ? ClanDeletedEvent.fromJSON(object.clan_deleted_event) : void 0,\n      give_coffee_event: isSet4(object.give_coffee_event) ? GiveCoffeeEvent.fromJSON(object.give_coffee_event) : void 0,\n      sticker_create_event: isSet4(object.sticker_create_event) ? StickerCreateEvent.fromJSON(object.sticker_create_event) : void 0,\n      sticker_update_event: isSet4(object.sticker_update_event) ? StickerUpdateEvent.fromJSON(object.sticker_update_event) : void 0,\n      sticker_delete_event: isSet4(object.sticker_delete_event) ? StickerDeleteEvent.fromJSON(object.sticker_delete_event) : void 0,\n      role_event: isSet4(object.role_event) ? RoleEvent.fromJSON(object.role_event) : void 0,\n      event_emoji: isSet4(object.event_emoji) ? EventEmoji.fromJSON(object.event_emoji) : void 0,\n      streaming_joined_event: isSet4(object.streaming_joined_event) ? StreamingJoinedEvent.fromJSON(object.streaming_joined_event) : void 0,\n      streaming_leaved_event: isSet4(object.streaming_leaved_event) ? StreamingLeavedEvent.fromJSON(object.streaming_leaved_event) : void 0,\n      streaming_started_event: isSet4(object.streaming_started_event) ? StreamingStartedEvent.fromJSON(object.streaming_started_event) : void 0,\n      streaming_ended_event: isSet4(object.streaming_ended_event) ? StreamingEndedEvent.fromJSON(object.streaming_ended_event) : void 0,\n      permission_set_event: isSet4(object.permission_set_event) ? PermissionSetEvent.fromJSON(object.permission_set_event) : void 0,\n      permission_changed_event: isSet4(object.permission_changed_event) ? PermissionChangedEvent.fromJSON(object.permission_changed_event) : void 0,\n      token_sent_event: isSet4(object.token_sent_event) ? TokenSentEvent.fromJSON(object.token_sent_event) : void 0,\n      message_button_clicked: isSet4(object.message_button_clicked) ? MessageButtonClicked.fromJSON(object.message_button_clicked) : void 0,\n      unmute_event: isSet4(object.unmute_event) ? UnmuteEvent.fromJSON(object.unmute_event) : void 0,\n      webrtc_signaling_fwd: isSet4(object.webrtc_signaling_fwd) ? WebrtcSignalingFwd.fromJSON(object.webrtc_signaling_fwd) : void 0,\n      list_activity: isSet4(object.list_activity) ? ListActivity.fromJSON(object.list_activity) : void 0,\n      dropdown_box_selected: isSet4(object.dropdown_box_selected) ? DropdownBoxSelected.fromJSON(object.dropdown_box_selected) : void 0,\n      incoming_call_push: isSet4(object.incoming_call_push) ? IncomingCallPush.fromJSON(object.incoming_call_push) : void 0,\n      sd_topic_event: isSet4(object.sd_topic_event) ? SdTopicEvent.fromJSON(object.sd_topic_event) : void 0,\n      follow_event: isSet4(object.follow_event) ? FollowEvent.fromJSON(object.follow_event) : void 0,\n      channel_app_event: isSet4(object.channel_app_event) ? ChannelAppEvent.fromJSON(object.channel_app_event) : void 0,\n      user_status_event: isSet4(object.user_status_event) ? UserStatusEvent.fromJSON(object.user_status_event) : void 0,\n      remove_friend: isSet4(object.remove_friend) ? RemoveFriend.fromJSON(object.remove_friend) : void 0,\n      webhook_event: isSet4(object.webhook_event) ? Webhook.fromJSON(object.webhook_event) : void 0,\n      noti_user_channel: isSet4(object.noti_user_channel) ? NotificationUserChannel.fromJSON(object.noti_user_channel) : void 0,\n      join_channel_app_data: isSet4(object.join_channel_app_data) ? JoinChannelAppData.fromJSON(object.join_channel_app_data) : void 0,\n      canvas_event: isSet4(object.canvas_event) ? ChannelCanvas.fromJSON(object.canvas_event) : void 0,\n      unpin_message_event: isSet4(object.unpin_message_event) ? UnpinMessageEvent.fromJSON(object.unpin_message_event) : void 0,\n      category_event: isSet4(object.category_event) ? CategoryEvent.fromJSON(object.category_event) : void 0,\n      handle_participant_meet_state_event: isSet4(object.handle_participant_meet_state_event) ? HandleParticipantMeetStateEvent.fromJSON(object.handle_participant_meet_state_event) : void 0,\n      delete_account_event: isSet4(object.delete_account_event) ? DeleteAccountEvent.fromJSON(object.delete_account_event) : void 0,\n      ephemeral_message_send: isSet4(object.ephemeral_message_send) ? EphemeralMessageSend.fromJSON(object.ephemeral_message_send) : void 0,\n      block_friend: isSet4(object.block_friend) ? BlockFriend.fromJSON(object.block_friend) : void 0,\n      voice_reaction_send: isSet4(object.voice_reaction_send) ? VoiceReactionSend.fromJSON(object.voice_reaction_send) : void 0,\n      mark_as_read: isSet4(object.mark_as_read) ? MarkAsRead.fromJSON(object.mark_as_read) : void 0,\n      list_data_socket: isSet4(object.list_data_socket) ? ListDataSocket.fromJSON(object.list_data_socket) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.cid !== \"\") {\n      obj.cid = message.cid;\n    }\n    if (message.channel !== void 0) {\n      obj.channel = Channel.toJSON(message.channel);\n    }\n    if (message.clan_join !== void 0) {\n      obj.clan_join = ClanJoin.toJSON(message.clan_join);\n    }\n    if (message.channel_join !== void 0) {\n      obj.channel_join = ChannelJoin.toJSON(message.channel_join);\n    }\n    if (message.channel_leave !== void 0) {\n      obj.channel_leave = ChannelLeave.toJSON(message.channel_leave);\n    }\n    if (message.channel_message !== void 0) {\n      obj.channel_message = ChannelMessage.toJSON(message.channel_message);\n    }\n    if (message.channel_message_ack !== void 0) {\n      obj.channel_message_ack = ChannelMessageAck.toJSON(message.channel_message_ack);\n    }\n    if (message.channel_message_send !== void 0) {\n      obj.channel_message_send = ChannelMessageSend.toJSON(message.channel_message_send);\n    }\n    if (message.channel_message_update !== void 0) {\n      obj.channel_message_update = ChannelMessageUpdate.toJSON(message.channel_message_update);\n    }\n    if (message.channel_message_remove !== void 0) {\n      obj.channel_message_remove = ChannelMessageRemove.toJSON(message.channel_message_remove);\n    }\n    if (message.channel_presence_event !== void 0) {\n      obj.channel_presence_event = ChannelPresenceEvent.toJSON(message.channel_presence_event);\n    }\n    if (message.error !== void 0) {\n      obj.error = Error2.toJSON(message.error);\n    }\n    if (message.notifications !== void 0) {\n      obj.notifications = Notifications.toJSON(message.notifications);\n    }\n    if (message.rpc !== void 0) {\n      obj.rpc = Rpc.toJSON(message.rpc);\n    }\n    if (message.status !== void 0) {\n      obj.status = Status.toJSON(message.status);\n    }\n    if (message.status_follow !== void 0) {\n      obj.status_follow = StatusFollow.toJSON(message.status_follow);\n    }\n    if (message.status_presence_event !== void 0) {\n      obj.status_presence_event = StatusPresenceEvent.toJSON(message.status_presence_event);\n    }\n    if (message.status_unfollow !== void 0) {\n      obj.status_unfollow = StatusUnfollow.toJSON(message.status_unfollow);\n    }\n    if (message.status_update !== void 0) {\n      obj.status_update = StatusUpdate.toJSON(message.status_update);\n    }\n    if (message.stream_data !== void 0) {\n      obj.stream_data = StreamData.toJSON(message.stream_data);\n    }\n    if (message.stream_presence_event !== void 0) {\n      obj.stream_presence_event = StreamPresenceEvent.toJSON(message.stream_presence_event);\n    }\n    if (message.ping !== void 0) {\n      obj.ping = Ping.toJSON(message.ping);\n    }\n    if (message.pong !== void 0) {\n      obj.pong = Pong.toJSON(message.pong);\n    }\n    if (message.message_typing_event !== void 0) {\n      obj.message_typing_event = MessageTypingEvent.toJSON(message.message_typing_event);\n    }\n    if (message.last_seen_message_event !== void 0) {\n      obj.last_seen_message_event = LastSeenMessageEvent.toJSON(message.last_seen_message_event);\n    }\n    if (message.message_reaction_event !== void 0) {\n      obj.message_reaction_event = MessageReaction.toJSON(message.message_reaction_event);\n    }\n    if (message.voice_joined_event !== void 0) {\n      obj.voice_joined_event = VoiceJoinedEvent.toJSON(message.voice_joined_event);\n    }\n    if (message.voice_leaved_event !== void 0) {\n      obj.voice_leaved_event = VoiceLeavedEvent.toJSON(message.voice_leaved_event);\n    }\n    if (message.voice_started_event !== void 0) {\n      obj.voice_started_event = VoiceStartedEvent.toJSON(message.voice_started_event);\n    }\n    if (message.voice_ended_event !== void 0) {\n      obj.voice_ended_event = VoiceEndedEvent.toJSON(message.voice_ended_event);\n    }\n    if (message.channel_created_event !== void 0) {\n      obj.channel_created_event = ChannelCreatedEvent.toJSON(message.channel_created_event);\n    }\n    if (message.channel_deleted_event !== void 0) {\n      obj.channel_deleted_event = ChannelDeletedEvent.toJSON(message.channel_deleted_event);\n    }\n    if (message.channel_updated_event !== void 0) {\n      obj.channel_updated_event = ChannelUpdatedEvent.toJSON(message.channel_updated_event);\n    }\n    if (message.last_pin_message_event !== void 0) {\n      obj.last_pin_message_event = LastPinMessageEvent.toJSON(message.last_pin_message_event);\n    }\n    if (message.custom_status_event !== void 0) {\n      obj.custom_status_event = CustomStatusEvent.toJSON(message.custom_status_event);\n    }\n    if (message.user_channel_added_event !== void 0) {\n      obj.user_channel_added_event = UserChannelAdded.toJSON(message.user_channel_added_event);\n    }\n    if (message.user_channel_removed_event !== void 0) {\n      obj.user_channel_removed_event = UserChannelRemoved.toJSON(message.user_channel_removed_event);\n    }\n    if (message.user_clan_removed_event !== void 0) {\n      obj.user_clan_removed_event = UserClanRemoved.toJSON(message.user_clan_removed_event);\n    }\n    if (message.clan_updated_event !== void 0) {\n      obj.clan_updated_event = ClanUpdatedEvent.toJSON(message.clan_updated_event);\n    }\n    if (message.clan_profile_updated_event !== void 0) {\n      obj.clan_profile_updated_event = ClanProfileUpdatedEvent.toJSON(message.clan_profile_updated_event);\n    }\n    if (message.check_name_existed_event !== void 0) {\n      obj.check_name_existed_event = CheckNameExistedEvent.toJSON(message.check_name_existed_event);\n    }\n    if (message.user_profile_updated_event !== void 0) {\n      obj.user_profile_updated_event = UserProfileUpdatedEvent.toJSON(message.user_profile_updated_event);\n    }\n    if (message.add_clan_user_event !== void 0) {\n      obj.add_clan_user_event = AddClanUserEvent.toJSON(message.add_clan_user_event);\n    }\n    if (message.clan_event_created !== void 0) {\n      obj.clan_event_created = CreateEventRequest.toJSON(message.clan_event_created);\n    }\n    if (message.role_assign_event !== void 0) {\n      obj.role_assign_event = RoleAssignedEvent.toJSON(message.role_assign_event);\n    }\n    if (message.clan_deleted_event !== void 0) {\n      obj.clan_deleted_event = ClanDeletedEvent.toJSON(message.clan_deleted_event);\n    }\n    if (message.give_coffee_event !== void 0) {\n      obj.give_coffee_event = GiveCoffeeEvent.toJSON(message.give_coffee_event);\n    }\n    if (message.sticker_create_event !== void 0) {\n      obj.sticker_create_event = StickerCreateEvent.toJSON(message.sticker_create_event);\n    }\n    if (message.sticker_update_event !== void 0) {\n      obj.sticker_update_event = StickerUpdateEvent.toJSON(message.sticker_update_event);\n    }\n    if (message.sticker_delete_event !== void 0) {\n      obj.sticker_delete_event = StickerDeleteEvent.toJSON(message.sticker_delete_event);\n    }\n    if (message.role_event !== void 0) {\n      obj.role_event = RoleEvent.toJSON(message.role_event);\n    }\n    if (message.event_emoji !== void 0) {\n      obj.event_emoji = EventEmoji.toJSON(message.event_emoji);\n    }\n    if (message.streaming_joined_event !== void 0) {\n      obj.streaming_joined_event = StreamingJoinedEvent.toJSON(message.streaming_joined_event);\n    }\n    if (message.streaming_leaved_event !== void 0) {\n      obj.streaming_leaved_event = StreamingLeavedEvent.toJSON(message.streaming_leaved_event);\n    }\n    if (message.streaming_started_event !== void 0) {\n      obj.streaming_started_event = StreamingStartedEvent.toJSON(message.streaming_started_event);\n    }\n    if (message.streaming_ended_event !== void 0) {\n      obj.streaming_ended_event = StreamingEndedEvent.toJSON(message.streaming_ended_event);\n    }\n    if (message.permission_set_event !== void 0) {\n      obj.permission_set_event = PermissionSetEvent.toJSON(message.permission_set_event);\n    }\n    if (message.permission_changed_event !== void 0) {\n      obj.permission_changed_event = PermissionChangedEvent.toJSON(message.permission_changed_event);\n    }\n    if (message.token_sent_event !== void 0) {\n      obj.token_sent_event = TokenSentEvent.toJSON(message.token_sent_event);\n    }\n    if (message.message_button_clicked !== void 0) {\n      obj.message_button_clicked = MessageButtonClicked.toJSON(message.message_button_clicked);\n    }\n    if (message.unmute_event !== void 0) {\n      obj.unmute_event = UnmuteEvent.toJSON(message.unmute_event);\n    }\n    if (message.webrtc_signaling_fwd !== void 0) {\n      obj.webrtc_signaling_fwd = WebrtcSignalingFwd.toJSON(message.webrtc_signaling_fwd);\n    }\n    if (message.list_activity !== void 0) {\n      obj.list_activity = ListActivity.toJSON(message.list_activity);\n    }\n    if (message.dropdown_box_selected !== void 0) {\n      obj.dropdown_box_selected = DropdownBoxSelected.toJSON(message.dropdown_box_selected);\n    }\n    if (message.incoming_call_push !== void 0) {\n      obj.incoming_call_push = IncomingCallPush.toJSON(message.incoming_call_push);\n    }\n    if (message.sd_topic_event !== void 0) {\n      obj.sd_topic_event = SdTopicEvent.toJSON(message.sd_topic_event);\n    }\n    if (message.follow_event !== void 0) {\n      obj.follow_event = FollowEvent.toJSON(message.follow_event);\n    }\n    if (message.channel_app_event !== void 0) {\n      obj.channel_app_event = ChannelAppEvent.toJSON(message.channel_app_event);\n    }\n    if (message.user_status_event !== void 0) {\n      obj.user_status_event = UserStatusEvent.toJSON(message.user_status_event);\n    }\n    if (message.remove_friend !== void 0) {\n      obj.remove_friend = RemoveFriend.toJSON(message.remove_friend);\n    }\n    if (message.webhook_event !== void 0) {\n      obj.webhook_event = Webhook.toJSON(message.webhook_event);\n    }\n    if (message.noti_user_channel !== void 0) {\n      obj.noti_user_channel = NotificationUserChannel.toJSON(message.noti_user_channel);\n    }\n    if (message.join_channel_app_data !== void 0) {\n      obj.join_channel_app_data = JoinChannelAppData.toJSON(message.join_channel_app_data);\n    }\n    if (message.canvas_event !== void 0) {\n      obj.canvas_event = ChannelCanvas.toJSON(message.canvas_event);\n    }\n    if (message.unpin_message_event !== void 0) {\n      obj.unpin_message_event = UnpinMessageEvent.toJSON(message.unpin_message_event);\n    }\n    if (message.category_event !== void 0) {\n      obj.category_event = CategoryEvent.toJSON(message.category_event);\n    }\n    if (message.handle_participant_meet_state_event !== void 0) {\n      obj.handle_participant_meet_state_event = HandleParticipantMeetStateEvent.toJSON(\n        message.handle_participant_meet_state_event\n      );\n    }\n    if (message.delete_account_event !== void 0) {\n      obj.delete_account_event = DeleteAccountEvent.toJSON(message.delete_account_event);\n    }\n    if (message.ephemeral_message_send !== void 0) {\n      obj.ephemeral_message_send = EphemeralMessageSend.toJSON(message.ephemeral_message_send);\n    }\n    if (message.block_friend !== void 0) {\n      obj.block_friend = BlockFriend.toJSON(message.block_friend);\n    }\n    if (message.voice_reaction_send !== void 0) {\n      obj.voice_reaction_send = VoiceReactionSend.toJSON(message.voice_reaction_send);\n    }\n    if (message.mark_as_read !== void 0) {\n      obj.mark_as_read = MarkAsRead.toJSON(message.mark_as_read);\n    }\n    if (message.list_data_socket !== void 0) {\n      obj.list_data_socket = ListDataSocket.toJSON(message.list_data_socket);\n    }\n    return obj;\n  },\n  create(base) {\n    return Envelope.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseEnvelope();\n    message.cid = (_a = object.cid) != null ? _a : \"\";\n    message.channel = object.channel !== void 0 && object.channel !== null ? Channel.fromPartial(object.channel) : void 0;\n    message.clan_join = object.clan_join !== void 0 && object.clan_join !== null ? ClanJoin.fromPartial(object.clan_join) : void 0;\n    message.channel_join = object.channel_join !== void 0 && object.channel_join !== null ? ChannelJoin.fromPartial(object.channel_join) : void 0;\n    message.channel_leave = object.channel_leave !== void 0 && object.channel_leave !== null ? ChannelLeave.fromPartial(object.channel_leave) : void 0;\n    message.channel_message = object.channel_message !== void 0 && object.channel_message !== null ? ChannelMessage.fromPartial(object.channel_message) : void 0;\n    message.channel_message_ack = object.channel_message_ack !== void 0 && object.channel_message_ack !== null ? ChannelMessageAck.fromPartial(object.channel_message_ack) : void 0;\n    message.channel_message_send = object.channel_message_send !== void 0 && object.channel_message_send !== null ? ChannelMessageSend.fromPartial(object.channel_message_send) : void 0;\n    message.channel_message_update = object.channel_message_update !== void 0 && object.channel_message_update !== null ? ChannelMessageUpdate.fromPartial(object.channel_message_update) : void 0;\n    message.channel_message_remove = object.channel_message_remove !== void 0 && object.channel_message_remove !== null ? ChannelMessageRemove.fromPartial(object.channel_message_remove) : void 0;\n    message.channel_presence_event = object.channel_presence_event !== void 0 && object.channel_presence_event !== null ? ChannelPresenceEvent.fromPartial(object.channel_presence_event) : void 0;\n    message.error = object.error !== void 0 && object.error !== null ? Error2.fromPartial(object.error) : void 0;\n    message.notifications = object.notifications !== void 0 && object.notifications !== null ? Notifications.fromPartial(object.notifications) : void 0;\n    message.rpc = object.rpc !== void 0 && object.rpc !== null ? Rpc.fromPartial(object.rpc) : void 0;\n    message.status = object.status !== void 0 && object.status !== null ? Status.fromPartial(object.status) : void 0;\n    message.status_follow = object.status_follow !== void 0 && object.status_follow !== null ? StatusFollow.fromPartial(object.status_follow) : void 0;\n    message.status_presence_event = object.status_presence_event !== void 0 && object.status_presence_event !== null ? StatusPresenceEvent.fromPartial(object.status_presence_event) : void 0;\n    message.status_unfollow = object.status_unfollow !== void 0 && object.status_unfollow !== null ? StatusUnfollow.fromPartial(object.status_unfollow) : void 0;\n    message.status_update = object.status_update !== void 0 && object.status_update !== null ? StatusUpdate.fromPartial(object.status_update) : void 0;\n    message.stream_data = object.stream_data !== void 0 && object.stream_data !== null ? StreamData.fromPartial(object.stream_data) : void 0;\n    message.stream_presence_event = object.stream_presence_event !== void 0 && object.stream_presence_event !== null ? StreamPresenceEvent.fromPartial(object.stream_presence_event) : void 0;\n    message.ping = object.ping !== void 0 && object.ping !== null ? Ping.fromPartial(object.ping) : void 0;\n    message.pong = object.pong !== void 0 && object.pong !== null ? Pong.fromPartial(object.pong) : void 0;\n    message.message_typing_event = object.message_typing_event !== void 0 && object.message_typing_event !== null ? MessageTypingEvent.fromPartial(object.message_typing_event) : void 0;\n    message.last_seen_message_event = object.last_seen_message_event !== void 0 && object.last_seen_message_event !== null ? LastSeenMessageEvent.fromPartial(object.last_seen_message_event) : void 0;\n    message.message_reaction_event = object.message_reaction_event !== void 0 && object.message_reaction_event !== null ? MessageReaction.fromPartial(object.message_reaction_event) : void 0;\n    message.voice_joined_event = object.voice_joined_event !== void 0 && object.voice_joined_event !== null ? VoiceJoinedEvent.fromPartial(object.voice_joined_event) : void 0;\n    message.voice_leaved_event = object.voice_leaved_event !== void 0 && object.voice_leaved_event !== null ? VoiceLeavedEvent.fromPartial(object.voice_leaved_event) : void 0;\n    message.voice_started_event = object.voice_started_event !== void 0 && object.voice_started_event !== null ? VoiceStartedEvent.fromPartial(object.voice_started_event) : void 0;\n    message.voice_ended_event = object.voice_ended_event !== void 0 && object.voice_ended_event !== null ? VoiceEndedEvent.fromPartial(object.voice_ended_event) : void 0;\n    message.channel_created_event = object.channel_created_event !== void 0 && object.channel_created_event !== null ? ChannelCreatedEvent.fromPartial(object.channel_created_event) : void 0;\n    message.channel_deleted_event = object.channel_deleted_event !== void 0 && object.channel_deleted_event !== null ? ChannelDeletedEvent.fromPartial(object.channel_deleted_event) : void 0;\n    message.channel_updated_event = object.channel_updated_event !== void 0 && object.channel_updated_event !== null ? ChannelUpdatedEvent.fromPartial(object.channel_updated_event) : void 0;\n    message.last_pin_message_event = object.last_pin_message_event !== void 0 && object.last_pin_message_event !== null ? LastPinMessageEvent.fromPartial(object.last_pin_message_event) : void 0;\n    message.custom_status_event = object.custom_status_event !== void 0 && object.custom_status_event !== null ? CustomStatusEvent.fromPartial(object.custom_status_event) : void 0;\n    message.user_channel_added_event = object.user_channel_added_event !== void 0 && object.user_channel_added_event !== null ? UserChannelAdded.fromPartial(object.user_channel_added_event) : void 0;\n    message.user_channel_removed_event = object.user_channel_removed_event !== void 0 && object.user_channel_removed_event !== null ? UserChannelRemoved.fromPartial(object.user_channel_removed_event) : void 0;\n    message.user_clan_removed_event = object.user_clan_removed_event !== void 0 && object.user_clan_removed_event !== null ? UserClanRemoved.fromPartial(object.user_clan_removed_event) : void 0;\n    message.clan_updated_event = object.clan_updated_event !== void 0 && object.clan_updated_event !== null ? ClanUpdatedEvent.fromPartial(object.clan_updated_event) : void 0;\n    message.clan_profile_updated_event = object.clan_profile_updated_event !== void 0 && object.clan_profile_updated_event !== null ? ClanProfileUpdatedEvent.fromPartial(object.clan_profile_updated_event) : void 0;\n    message.check_name_existed_event = object.check_name_existed_event !== void 0 && object.check_name_existed_event !== null ? CheckNameExistedEvent.fromPartial(object.check_name_existed_event) : void 0;\n    message.user_profile_updated_event = object.user_profile_updated_event !== void 0 && object.user_profile_updated_event !== null ? UserProfileUpdatedEvent.fromPartial(object.user_profile_updated_event) : void 0;\n    message.add_clan_user_event = object.add_clan_user_event !== void 0 && object.add_clan_user_event !== null ? AddClanUserEvent.fromPartial(object.add_clan_user_event) : void 0;\n    message.clan_event_created = object.clan_event_created !== void 0 && object.clan_event_created !== null ? CreateEventRequest.fromPartial(object.clan_event_created) : void 0;\n    message.role_assign_event = object.role_assign_event !== void 0 && object.role_assign_event !== null ? RoleAssignedEvent.fromPartial(object.role_assign_event) : void 0;\n    message.clan_deleted_event = object.clan_deleted_event !== void 0 && object.clan_deleted_event !== null ? ClanDeletedEvent.fromPartial(object.clan_deleted_event) : void 0;\n    message.give_coffee_event = object.give_coffee_event !== void 0 && object.give_coffee_event !== null ? GiveCoffeeEvent.fromPartial(object.give_coffee_event) : void 0;\n    message.sticker_create_event = object.sticker_create_event !== void 0 && object.sticker_create_event !== null ? StickerCreateEvent.fromPartial(object.sticker_create_event) : void 0;\n    message.sticker_update_event = object.sticker_update_event !== void 0 && object.sticker_update_event !== null ? StickerUpdateEvent.fromPartial(object.sticker_update_event) : void 0;\n    message.sticker_delete_event = object.sticker_delete_event !== void 0 && object.sticker_delete_event !== null ? StickerDeleteEvent.fromPartial(object.sticker_delete_event) : void 0;\n    message.role_event = object.role_event !== void 0 && object.role_event !== null ? RoleEvent.fromPartial(object.role_event) : void 0;\n    message.event_emoji = object.event_emoji !== void 0 && object.event_emoji !== null ? EventEmoji.fromPartial(object.event_emoji) : void 0;\n    message.streaming_joined_event = object.streaming_joined_event !== void 0 && object.streaming_joined_event !== null ? StreamingJoinedEvent.fromPartial(object.streaming_joined_event) : void 0;\n    message.streaming_leaved_event = object.streaming_leaved_event !== void 0 && object.streaming_leaved_event !== null ? StreamingLeavedEvent.fromPartial(object.streaming_leaved_event) : void 0;\n    message.streaming_started_event = object.streaming_started_event !== void 0 && object.streaming_started_event !== null ? StreamingStartedEvent.fromPartial(object.streaming_started_event) : void 0;\n    message.streaming_ended_event = object.streaming_ended_event !== void 0 && object.streaming_ended_event !== null ? StreamingEndedEvent.fromPartial(object.streaming_ended_event) : void 0;\n    message.permission_set_event = object.permission_set_event !== void 0 && object.permission_set_event !== null ? PermissionSetEvent.fromPartial(object.permission_set_event) : void 0;\n    message.permission_changed_event = object.permission_changed_event !== void 0 && object.permission_changed_event !== null ? PermissionChangedEvent.fromPartial(object.permission_changed_event) : void 0;\n    message.token_sent_event = object.token_sent_event !== void 0 && object.token_sent_event !== null ? TokenSentEvent.fromPartial(object.token_sent_event) : void 0;\n    message.message_button_clicked = object.message_button_clicked !== void 0 && object.message_button_clicked !== null ? MessageButtonClicked.fromPartial(object.message_button_clicked) : void 0;\n    message.unmute_event = object.unmute_event !== void 0 && object.unmute_event !== null ? UnmuteEvent.fromPartial(object.unmute_event) : void 0;\n    message.webrtc_signaling_fwd = object.webrtc_signaling_fwd !== void 0 && object.webrtc_signaling_fwd !== null ? WebrtcSignalingFwd.fromPartial(object.webrtc_signaling_fwd) : void 0;\n    message.list_activity = object.list_activity !== void 0 && object.list_activity !== null ? ListActivity.fromPartial(object.list_activity) : void 0;\n    message.dropdown_box_selected = object.dropdown_box_selected !== void 0 && object.dropdown_box_selected !== null ? DropdownBoxSelected.fromPartial(object.dropdown_box_selected) : void 0;\n    message.incoming_call_push = object.incoming_call_push !== void 0 && object.incoming_call_push !== null ? IncomingCallPush.fromPartial(object.incoming_call_push) : void 0;\n    message.sd_topic_event = object.sd_topic_event !== void 0 && object.sd_topic_event !== null ? SdTopicEvent.fromPartial(object.sd_topic_event) : void 0;\n    message.follow_event = object.follow_event !== void 0 && object.follow_event !== null ? FollowEvent.fromPartial(object.follow_event) : void 0;\n    message.channel_app_event = object.channel_app_event !== void 0 && object.channel_app_event !== null ? ChannelAppEvent.fromPartial(object.channel_app_event) : void 0;\n    message.user_status_event = object.user_status_event !== void 0 && object.user_status_event !== null ? UserStatusEvent.fromPartial(object.user_status_event) : void 0;\n    message.remove_friend = object.remove_friend !== void 0 && object.remove_friend !== null ? RemoveFriend.fromPartial(object.remove_friend) : void 0;\n    message.webhook_event = object.webhook_event !== void 0 && object.webhook_event !== null ? Webhook.fromPartial(object.webhook_event) : void 0;\n    message.noti_user_channel = object.noti_user_channel !== void 0 && object.noti_user_channel !== null ? NotificationUserChannel.fromPartial(object.noti_user_channel) : void 0;\n    message.join_channel_app_data = object.join_channel_app_data !== void 0 && object.join_channel_app_data !== null ? JoinChannelAppData.fromPartial(object.join_channel_app_data) : void 0;\n    message.canvas_event = object.canvas_event !== void 0 && object.canvas_event !== null ? ChannelCanvas.fromPartial(object.canvas_event) : void 0;\n    message.unpin_message_event = object.unpin_message_event !== void 0 && object.unpin_message_event !== null ? UnpinMessageEvent.fromPartial(object.unpin_message_event) : void 0;\n    message.category_event = object.category_event !== void 0 && object.category_event !== null ? CategoryEvent.fromPartial(object.category_event) : void 0;\n    message.handle_participant_meet_state_event = object.handle_participant_meet_state_event !== void 0 && object.handle_participant_meet_state_event !== null ? HandleParticipantMeetStateEvent.fromPartial(object.handle_participant_meet_state_event) : void 0;\n    message.delete_account_event = object.delete_account_event !== void 0 && object.delete_account_event !== null ? DeleteAccountEvent.fromPartial(object.delete_account_event) : void 0;\n    message.ephemeral_message_send = object.ephemeral_message_send !== void 0 && object.ephemeral_message_send !== null ? EphemeralMessageSend.fromPartial(object.ephemeral_message_send) : void 0;\n    message.block_friend = object.block_friend !== void 0 && object.block_friend !== null ? BlockFriend.fromPartial(object.block_friend) : void 0;\n    message.voice_reaction_send = object.voice_reaction_send !== void 0 && object.voice_reaction_send !== null ? VoiceReactionSend.fromPartial(object.voice_reaction_send) : void 0;\n    message.mark_as_read = object.mark_as_read !== void 0 && object.mark_as_read !== null ? MarkAsRead.fromPartial(object.mark_as_read) : void 0;\n    message.list_data_socket = object.list_data_socket !== void 0 && object.list_data_socket !== null ? ListDataSocket.fromPartial(object.list_data_socket) : void 0;\n    return message;\n  }\n};\nfunction createBaseFollowEvent() {\n  return {};\n}\nvar FollowEvent = {\n  encode(_, writer = import_minimal5.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseFollowEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return FollowEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBaseFollowEvent();\n    return message;\n  }\n};\nfunction createBaseChannelCanvas() {\n  return {\n    id: \"\",\n    title: \"\",\n    content: \"\",\n    creator_id: \"\",\n    editor_id: \"\",\n    is_default: false,\n    channel_id: \"\",\n    status: 0\n  };\n}\nvar ChannelCanvas = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.title !== \"\") {\n      writer.uint32(18).string(message.title);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(34).string(message.creator_id);\n    }\n    if (message.editor_id !== \"\") {\n      writer.uint32(42).string(message.editor_id);\n    }\n    if (message.is_default !== false) {\n      writer.uint32(48).bool(message.is_default);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(58).string(message.channel_id);\n    }\n    if (message.status !== 0) {\n      writer.uint32(64).int32(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelCanvas();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.title = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.editor_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.is_default = reader.bool();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      title: isSet4(object.title) ? globalThis.String(object.title) : \"\",\n      content: isSet4(object.content) ? globalThis.String(object.content) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      editor_id: isSet4(object.editor_id) ? globalThis.String(object.editor_id) : \"\",\n      is_default: isSet4(object.is_default) ? globalThis.Boolean(object.is_default) : false,\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.title !== \"\") {\n      obj.title = message.title;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.editor_id !== \"\") {\n      obj.editor_id = message.editor_id;\n    }\n    if (message.is_default !== false) {\n      obj.is_default = message.is_default;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelCanvas.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseChannelCanvas();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.title = (_b = object.title) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.creator_id = (_d = object.creator_id) != null ? _d : \"\";\n    message.editor_id = (_e = object.editor_id) != null ? _e : \"\";\n    message.is_default = (_f = object.is_default) != null ? _f : false;\n    message.channel_id = (_g = object.channel_id) != null ? _g : \"\";\n    message.status = (_h = object.status) != null ? _h : 0;\n    return message;\n  }\n};\nfunction createBaseIncomingCallPush() {\n  return { receiver_id: \"\", json_data: \"\", channel_id: \"\", caller_id: \"\" };\n}\nvar IncomingCallPush = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.receiver_id !== \"\") {\n      writer.uint32(10).string(message.receiver_id);\n    }\n    if (message.json_data !== \"\") {\n      writer.uint32(26).string(message.json_data);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.caller_id !== \"\") {\n      writer.uint32(42).string(message.caller_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseIncomingCallPush();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.receiver_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.json_data = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.caller_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      receiver_id: isSet4(object.receiver_id) ? globalThis.String(object.receiver_id) : \"\",\n      json_data: isSet4(object.json_data) ? globalThis.String(object.json_data) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      caller_id: isSet4(object.caller_id) ? globalThis.String(object.caller_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.receiver_id !== \"\") {\n      obj.receiver_id = message.receiver_id;\n    }\n    if (message.json_data !== \"\") {\n      obj.json_data = message.json_data;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.caller_id !== \"\") {\n      obj.caller_id = message.caller_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return IncomingCallPush.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseIncomingCallPush();\n    message.receiver_id = (_a = object.receiver_id) != null ? _a : \"\";\n    message.json_data = (_b = object.json_data) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.caller_id = (_d = object.caller_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseWebrtcSignalingFwd() {\n  return { receiver_id: \"\", data_type: 0, json_data: \"\", channel_id: \"\", caller_id: \"\" };\n}\nvar WebrtcSignalingFwd = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.receiver_id !== \"\") {\n      writer.uint32(10).string(message.receiver_id);\n    }\n    if (message.data_type !== 0) {\n      writer.uint32(16).int32(message.data_type);\n    }\n    if (message.json_data !== \"\") {\n      writer.uint32(26).string(message.json_data);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.caller_id !== \"\") {\n      writer.uint32(42).string(message.caller_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseWebrtcSignalingFwd();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.receiver_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.data_type = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.json_data = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.caller_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      receiver_id: isSet4(object.receiver_id) ? globalThis.String(object.receiver_id) : \"\",\n      data_type: isSet4(object.data_type) ? globalThis.Number(object.data_type) : 0,\n      json_data: isSet4(object.json_data) ? globalThis.String(object.json_data) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      caller_id: isSet4(object.caller_id) ? globalThis.String(object.caller_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.receiver_id !== \"\") {\n      obj.receiver_id = message.receiver_id;\n    }\n    if (message.data_type !== 0) {\n      obj.data_type = Math.round(message.data_type);\n    }\n    if (message.json_data !== \"\") {\n      obj.json_data = message.json_data;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.caller_id !== \"\") {\n      obj.caller_id = message.caller_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return WebrtcSignalingFwd.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseWebrtcSignalingFwd();\n    message.receiver_id = (_a = object.receiver_id) != null ? _a : \"\";\n    message.data_type = (_b = object.data_type) != null ? _b : 0;\n    message.json_data = (_c = object.json_data) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.caller_id = (_e = object.caller_id) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseAddClanUserEvent() {\n  return { clan_id: \"\", user: void 0, invitor: \"\" };\n}\nvar AddClanUserEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.user !== void 0) {\n      UserProfileRedis.encode(message.user, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.invitor !== \"\") {\n      writer.uint32(26).string(message.invitor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseAddClanUserEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user = UserProfileRedis.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.invitor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      user: isSet4(object.user) ? UserProfileRedis.fromJSON(object.user) : void 0,\n      invitor: isSet4(object.invitor) ? globalThis.String(object.invitor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.user !== void 0) {\n      obj.user = UserProfileRedis.toJSON(message.user);\n    }\n    if (message.invitor !== \"\") {\n      obj.invitor = message.invitor;\n    }\n    return obj;\n  },\n  create(base) {\n    return AddClanUserEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseAddClanUserEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user = object.user !== void 0 && object.user !== null ? UserProfileRedis.fromPartial(object.user) : void 0;\n    message.invitor = (_b = object.invitor) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseRoleAssignedEvent() {\n  return { ClanId: \"\", role_id: \"\", user_ids_assigned: [], user_ids_removed: [] };\n}\nvar RoleAssignedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.ClanId !== \"\") {\n      writer.uint32(10).string(message.ClanId);\n    }\n    if (message.role_id !== \"\") {\n      writer.uint32(18).string(message.role_id);\n    }\n    for (const v of message.user_ids_assigned) {\n      writer.uint32(26).string(v);\n    }\n    for (const v of message.user_ids_removed) {\n      writer.uint32(34).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleAssignedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.ClanId = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_ids_assigned.push(reader.string());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.user_ids_removed.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      ClanId: isSet4(object.ClanId) ? globalThis.String(object.ClanId) : \"\",\n      role_id: isSet4(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      user_ids_assigned: globalThis.Array.isArray(object == null ? void 0 : object.user_ids_assigned) ? object.user_ids_assigned.map((e) => globalThis.String(e)) : [],\n      user_ids_removed: globalThis.Array.isArray(object == null ? void 0 : object.user_ids_removed) ? object.user_ids_removed.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.ClanId !== \"\") {\n      obj.ClanId = message.ClanId;\n    }\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if ((_a = message.user_ids_assigned) == null ? void 0 : _a.length) {\n      obj.user_ids_assigned = message.user_ids_assigned;\n    }\n    if ((_b = message.user_ids_removed) == null ? void 0 : _b.length) {\n      obj.user_ids_removed = message.user_ids_removed;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleAssignedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseRoleAssignedEvent();\n    message.ClanId = (_a = object.ClanId) != null ? _a : \"\";\n    message.role_id = (_b = object.role_id) != null ? _b : \"\";\n    message.user_ids_assigned = ((_c = object.user_ids_assigned) == null ? void 0 : _c.map((e) => e)) || [];\n    message.user_ids_removed = ((_d = object.user_ids_removed) == null ? void 0 : _d.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseChannel() {\n  return { id: \"\", presences: [], self: void 0, chanel_label: \"\", clan_logo: \"\", category_name: \"\" };\n}\nvar Channel = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    for (const v of message.presences) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.self !== void 0) {\n      UserPresence.encode(message.self, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.chanel_label !== \"\") {\n      writer.uint32(34).string(message.chanel_label);\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(42).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(50).string(message.category_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannel();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.presences.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.self = UserPresence.decode(reader, reader.uint32());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.chanel_label = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      presences: globalThis.Array.isArray(object == null ? void 0 : object.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : [],\n      self: isSet4(object.self) ? UserPresence.fromJSON(object.self) : void 0,\n      chanel_label: isSet4(object.chanel_label) ? globalThis.String(object.chanel_label) : \"\",\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if ((_a = message.presences) == null ? void 0 : _a.length) {\n      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));\n    }\n    if (message.self !== void 0) {\n      obj.self = UserPresence.toJSON(message.self);\n    }\n    if (message.chanel_label !== \"\") {\n      obj.chanel_label = message.chanel_label;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return Channel.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannel();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.presences = ((_b = object.presences) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    message.self = object.self !== void 0 && object.self !== null ? UserPresence.fromPartial(object.self) : void 0;\n    message.chanel_label = (_c = object.chanel_label) != null ? _c : \"\";\n    message.clan_logo = (_d = object.clan_logo) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseClanJoin() {\n  return { clan_id: \"\" };\n}\nvar ClanJoin = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanJoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanJoin.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseClanJoin();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelJoin() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0, is_public: false };\n}\nvar ChannelJoin = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(32).bool(message.is_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelJoin();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelJoin.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseChannelJoin();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    message.is_public = (_d = object.is_public) != null ? _d : false;\n    return message;\n  }\n};\nfunction createBaseChannelLeave() {\n  return { clan_id: \"\", channel_id: \"\", channel_type: 0, is_public: false };\n}\nvar ChannelLeave = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(32).bool(message.is_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelLeave();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelLeave.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseChannelLeave();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    message.is_public = (_d = object.is_public) != null ? _d : false;\n    return message;\n  }\n};\nfunction createBaseChannelMessageAck() {\n  return {\n    channel_id: \"\",\n    message_id: \"\",\n    code: void 0,\n    username: \"\",\n    create_time: void 0,\n    update_time: void 0,\n    persistent: void 0,\n    clan_logo: \"\",\n    category_name: \"\"\n  };\n}\nvar ChannelMessageAck = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(18).string(message.message_id);\n    }\n    if (message.code !== void 0) {\n      Int32Value.encode({ value: message.code }, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.username !== \"\") {\n      writer.uint32(34).string(message.username);\n    }\n    if (message.create_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.create_time), writer.uint32(42).fork()).ldelim();\n    }\n    if (message.update_time !== void 0) {\n      Timestamp.encode(toTimestamp2(message.update_time), writer.uint32(50).fork()).ldelim();\n    }\n    if (message.persistent !== void 0) {\n      BoolValue.encode({ value: message.persistent }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(66).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(74).string(message.category_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageAck();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.code = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.create_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.update_time = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.persistent = BoolValue.decode(reader, reader.uint32()).value;\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      code: isSet4(object.code) ? Number(object.code) : void 0,\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      create_time: isSet4(object.create_time) ? fromJsonTimestamp2(object.create_time) : void 0,\n      update_time: isSet4(object.update_time) ? fromJsonTimestamp2(object.update_time) : void 0,\n      persistent: isSet4(object.persistent) ? Boolean(object.persistent) : void 0,\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.code !== void 0) {\n      obj.code = message.code;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.create_time !== void 0) {\n      obj.create_time = message.create_time.toISOString();\n    }\n    if (message.update_time !== void 0) {\n      obj.update_time = message.update_time.toISOString();\n    }\n    if (message.persistent !== void 0) {\n      obj.persistent = message.persistent;\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageAck.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseChannelMessageAck();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.message_id = (_b = object.message_id) != null ? _b : \"\";\n    message.code = (_c = object.code) != null ? _c : void 0;\n    message.username = (_d = object.username) != null ? _d : \"\";\n    message.create_time = (_e = object.create_time) != null ? _e : void 0;\n    message.update_time = (_f = object.update_time) != null ? _f : void 0;\n    message.persistent = (_g = object.persistent) != null ? _g : void 0;\n    message.clan_logo = (_h = object.clan_logo) != null ? _h : \"\";\n    message.category_name = (_i = object.category_name) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction createBaseEphemeralMessageSend() {\n  return { message: void 0, receiver_id: \"\" };\n}\nvar EphemeralMessageSend = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.message !== void 0) {\n      ChannelMessageSend.encode(message.message, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.receiver_id !== \"\") {\n      writer.uint32(18).string(message.receiver_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEphemeralMessageSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.message = ChannelMessageSend.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.receiver_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message: isSet4(object.message) ? ChannelMessageSend.fromJSON(object.message) : void 0,\n      receiver_id: isSet4(object.receiver_id) ? globalThis.String(object.receiver_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.message !== void 0) {\n      obj.message = ChannelMessageSend.toJSON(message.message);\n    }\n    if (message.receiver_id !== \"\") {\n      obj.receiver_id = message.receiver_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return EphemeralMessageSend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseEphemeralMessageSend();\n    message.message = object.message !== void 0 && object.message !== null ? ChannelMessageSend.fromPartial(object.message) : void 0;\n    message.receiver_id = (_a = object.receiver_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceReactionSend() {\n  return { emojis: [], channel_id: \"\", sender_id: \"\", media_type: 0 };\n}\nvar VoiceReactionSend = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.emojis) {\n      writer.uint32(10).string(v);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(26).string(message.sender_id);\n    }\n    if (message.media_type !== 0) {\n      writer.uint32(32).int32(message.media_type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceReactionSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.emojis.push(reader.string());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.media_type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      emojis: globalThis.Array.isArray(object == null ? void 0 : object.emojis) ? object.emojis.map((e) => globalThis.String(e)) : [],\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      sender_id: isSet4(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      media_type: isSet4(object.media_type) ? globalThis.Number(object.media_type) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.emojis) == null ? void 0 : _a.length) {\n      obj.emojis = message.emojis;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.media_type !== 0) {\n      obj.media_type = Math.round(message.media_type);\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceReactionSend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseVoiceReactionSend();\n    message.emojis = ((_a = object.emojis) == null ? void 0 : _a.map((e) => e)) || [];\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.sender_id = (_c = object.sender_id) != null ? _c : \"\";\n    message.media_type = (_d = object.media_type) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseMarkAsRead() {\n  return { channel_id: \"\", category_id: \"\", clan_id: \"\" };\n}\nvar MarkAsRead = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMarkAsRead();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return MarkAsRead.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseMarkAsRead();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelMessageSend() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    content: \"\",\n    mentions: [],\n    attachments: [],\n    references: [],\n    mode: 0,\n    anonymous_message: false,\n    mention_everyone: false,\n    avatar: \"\",\n    is_public: false,\n    code: 0,\n    topic_id: \"\"\n  };\n}\nvar ChannelMessageSend = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(26).string(message.content);\n    }\n    for (const v of message.mentions) {\n      MessageMention.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    for (const v of message.attachments) {\n      MessageAttachment.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    for (const v of message.references) {\n      MessageRef.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.mode !== 0) {\n      writer.uint32(56).int32(message.mode);\n    }\n    if (message.anonymous_message !== false) {\n      writer.uint32(64).bool(message.anonymous_message);\n    }\n    if (message.mention_everyone !== false) {\n      writer.uint32(72).bool(message.mention_everyone);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(82).string(message.avatar);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(88).bool(message.is_public);\n    }\n    if (message.code !== 0) {\n      writer.uint32(96).int32(message.code);\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(106).string(message.topic_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageSend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.mentions.push(MessageMention.decode(reader, reader.uint32()));\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.references.push(MessageRef.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.anonymous_message = reader.bool();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.mention_everyone = reader.bool();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 12:\n          if (tag !== 96) {\n            break;\n          }\n          message.code = reader.int32();\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      content: isSet4(object.content) ? globalThis.String(object.content) : \"\",\n      mentions: globalThis.Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => MessageMention.fromJSON(e)) : [],\n      attachments: globalThis.Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => MessageAttachment.fromJSON(e)) : [],\n      references: globalThis.Array.isArray(object == null ? void 0 : object.references) ? object.references.map((e) => MessageRef.fromJSON(e)) : [],\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      anonymous_message: isSet4(object.anonymous_message) ? globalThis.Boolean(object.anonymous_message) : false,\n      mention_everyone: isSet4(object.mention_everyone) ? globalThis.Boolean(object.mention_everyone) : false,\n      avatar: isSet4(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      code: isSet4(object.code) ? globalThis.Number(object.code) : 0,\n      topic_id: isSet4(object.topic_id) ? globalThis.String(object.topic_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if ((_a = message.mentions) == null ? void 0 : _a.length) {\n      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));\n    }\n    if ((_b = message.attachments) == null ? void 0 : _b.length) {\n      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));\n    }\n    if ((_c = message.references) == null ? void 0 : _c.length) {\n      obj.references = message.references.map((e) => MessageRef.toJSON(e));\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.anonymous_message !== false) {\n      obj.anonymous_message = message.anonymous_message;\n    }\n    if (message.mention_everyone !== false) {\n      obj.mention_everyone = message.mention_everyone;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.code !== 0) {\n      obj.code = Math.round(message.code);\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageSend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;\n    const message = createBaseChannelMessageSend();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.content = (_c = object.content) != null ? _c : \"\";\n    message.mentions = ((_d = object.mentions) == null ? void 0 : _d.map((e) => MessageMention.fromPartial(e))) || [];\n    message.attachments = ((_e = object.attachments) == null ? void 0 : _e.map((e) => MessageAttachment.fromPartial(e))) || [];\n    message.references = ((_f = object.references) == null ? void 0 : _f.map((e) => MessageRef.fromPartial(e))) || [];\n    message.mode = (_g = object.mode) != null ? _g : 0;\n    message.anonymous_message = (_h = object.anonymous_message) != null ? _h : false;\n    message.mention_everyone = (_i = object.mention_everyone) != null ? _i : false;\n    message.avatar = (_j = object.avatar) != null ? _j : \"\";\n    message.is_public = (_k = object.is_public) != null ? _k : false;\n    message.code = (_l = object.code) != null ? _l : 0;\n    message.topic_id = (_m = object.topic_id) != null ? _m : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelMessageUpdate() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    content: \"\",\n    mentions: [],\n    attachments: [],\n    mode: 0,\n    is_public: false,\n    hide_editted: false,\n    topic_id: \"\",\n    is_update_msg_topic: false\n  };\n}\nvar ChannelMessageUpdate = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(34).string(message.content);\n    }\n    for (const v of message.mentions) {\n      MessageMention.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    for (const v of message.attachments) {\n      MessageAttachment.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.mode !== 0) {\n      writer.uint32(56).int32(message.mode);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(64).bool(message.is_public);\n    }\n    if (message.hide_editted !== false) {\n      writer.uint32(72).bool(message.hide_editted);\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(82).string(message.topic_id);\n    }\n    if (message.is_update_msg_topic !== false) {\n      writer.uint32(88).bool(message.is_update_msg_topic);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.content = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.mentions.push(MessageMention.decode(reader, reader.uint32()));\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.hide_editted = reader.bool();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.is_update_msg_topic = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      content: isSet4(object.content) ? globalThis.String(object.content) : \"\",\n      mentions: globalThis.Array.isArray(object == null ? void 0 : object.mentions) ? object.mentions.map((e) => MessageMention.fromJSON(e)) : [],\n      attachments: globalThis.Array.isArray(object == null ? void 0 : object.attachments) ? object.attachments.map((e) => MessageAttachment.fromJSON(e)) : [],\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      hide_editted: isSet4(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,\n      topic_id: isSet4(object.topic_id) ? globalThis.String(object.topic_id) : \"\",\n      is_update_msg_topic: isSet4(object.is_update_msg_topic) ? globalThis.Boolean(object.is_update_msg_topic) : false\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    if ((_a = message.mentions) == null ? void 0 : _a.length) {\n      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));\n    }\n    if ((_b = message.attachments) == null ? void 0 : _b.length) {\n      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.hide_editted !== false) {\n      obj.hide_editted = message.hide_editted;\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    if (message.is_update_msg_topic !== false) {\n      obj.is_update_msg_topic = message.is_update_msg_topic;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseChannelMessageUpdate();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.content = (_d = object.content) != null ? _d : \"\";\n    message.mentions = ((_e = object.mentions) == null ? void 0 : _e.map((e) => MessageMention.fromPartial(e))) || [];\n    message.attachments = ((_f = object.attachments) == null ? void 0 : _f.map((e) => MessageAttachment.fromPartial(e))) || [];\n    message.mode = (_g = object.mode) != null ? _g : 0;\n    message.is_public = (_h = object.is_public) != null ? _h : false;\n    message.hide_editted = (_i = object.hide_editted) != null ? _i : false;\n    message.topic_id = (_j = object.topic_id) != null ? _j : \"\";\n    message.is_update_msg_topic = (_k = object.is_update_msg_topic) != null ? _k : false;\n    return message;\n  }\n};\nfunction createBaseChannelMessageRemove() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    mode: 0,\n    is_public: false,\n    has_attachment: false,\n    topic_id: \"\"\n  };\n}\nvar ChannelMessageRemove = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(40).bool(message.is_public);\n    }\n    if (message.has_attachment !== false) {\n      writer.uint32(48).bool(message.has_attachment);\n    }\n    if (message.topic_id !== \"\") {\n      writer.uint32(58).string(message.topic_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelMessageRemove();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.has_attachment = reader.bool();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.topic_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      has_attachment: isSet4(object.has_attachment) ? globalThis.Boolean(object.has_attachment) : false,\n      topic_id: isSet4(object.topic_id) ? globalThis.String(object.topic_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.has_attachment !== false) {\n      obj.has_attachment = message.has_attachment;\n    }\n    if (message.topic_id !== \"\") {\n      obj.topic_id = message.topic_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelMessageRemove.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseChannelMessageRemove();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.is_public = (_e = object.is_public) != null ? _e : false;\n    message.has_attachment = (_f = object.has_attachment) != null ? _f : false;\n    message.topic_id = (_g = object.topic_id) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelPresenceEvent() {\n  return { channel_id: \"\", joins: [], leaves: [], clan_logo: \"\", category_name: \"\", mode: 0 };\n}\nvar ChannelPresenceEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.clan_logo !== \"\") {\n      writer.uint32(34).string(message.clan_logo);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(42).string(message.category_name);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(48).int32(message.mode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_logo = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      joins: globalThis.Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: globalThis.Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : [],\n      clan_logo: isSet4(object.clan_logo) ? globalThis.String(object.clan_logo) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.joins) == null ? void 0 : _a.length) {\n      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));\n    }\n    if ((_b = message.leaves) == null ? void 0 : _b.length) {\n      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));\n    }\n    if (message.clan_logo !== \"\") {\n      obj.clan_logo = message.clan_logo;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseChannelPresenceEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.joins = ((_b = object.joins) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_c = object.leaves) == null ? void 0 : _c.map((e) => UserPresence.fromPartial(e))) || [];\n    message.clan_logo = (_d = object.clan_logo) != null ? _d : \"\";\n    message.category_name = (_e = object.category_name) != null ? _e : \"\";\n    message.mode = (_f = object.mode) != null ? _f : 0;\n    return message;\n  }\n};\nfunction createBaseError() {\n  return { code: 0, message: \"\", context: {} };\n}\nvar Error2 = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).int32(message.code);\n    }\n    if (message.message !== \"\") {\n      writer.uint32(18).string(message.message);\n    }\n    Object.entries(message.context).forEach(([key, value]) => {\n      Error_ContextEntry.encode({ key, value }, writer.uint32(26).fork()).ldelim();\n    });\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseError();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.code = reader.int32();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          const entry3 = Error_ContextEntry.decode(reader, reader.uint32());\n          if (entry3.value !== void 0) {\n            message.context[entry3.key] = entry3.value;\n          }\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      code: isSet4(object.code) ? globalThis.Number(object.code) : 0,\n      message: isSet4(object.message) ? globalThis.String(object.message) : \"\",\n      context: isObject(object.context) ? Object.entries(object.context).reduce((acc, [key, value]) => {\n        acc[key] = String(value);\n        return acc;\n      }, {}) : {}\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.code !== 0) {\n      obj.code = Math.round(message.code);\n    }\n    if (message.message !== \"\") {\n      obj.message = message.message;\n    }\n    if (message.context) {\n      const entries = Object.entries(message.context);\n      if (entries.length > 0) {\n        obj.context = {};\n        entries.forEach(([k, v]) => {\n          obj.context[k] = v;\n        });\n      }\n    }\n    return obj;\n  },\n  create(base) {\n    return Error2.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseError();\n    message.code = (_a = object.code) != null ? _a : 0;\n    message.message = (_b = object.message) != null ? _b : \"\";\n    message.context = Object.entries((_c = object.context) != null ? _c : {}).reduce((acc, [key, value]) => {\n      if (value !== void 0) {\n        acc[key] = globalThis.String(value);\n      }\n      return acc;\n    }, {});\n    return message;\n  }\n};\nfunction createBaseError_ContextEntry() {\n  return { key: \"\", value: \"\" };\n}\nvar Error_ContextEntry = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseError_ContextEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.key = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.value = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      key: isSet4(object.key) ? globalThis.String(object.key) : \"\",\n      value: isSet4(object.value) ? globalThis.String(object.value) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.key !== \"\") {\n      obj.key = message.key;\n    }\n    if (message.value !== \"\") {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n  create(base) {\n    return Error_ContextEntry.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseError_ContextEntry();\n    message.key = (_a = object.key) != null ? _a : \"\";\n    message.value = (_b = object.value) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseNotifications() {\n  return { notifications: [] };\n}\nvar Notifications = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.notifications) {\n      Notification.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseNotifications();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.notifications.push(Notification.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      notifications: globalThis.Array.isArray(object == null ? void 0 : object.notifications) ? object.notifications.map((e) => Notification.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.notifications) == null ? void 0 : _a.length) {\n      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return Notifications.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseNotifications();\n    message.notifications = ((_a = object.notifications) == null ? void 0 : _a.map((e) => Notification.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseRemoveFriend() {\n  return { user_id: \"\" };\n}\nvar RemoveFriend = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRemoveFriend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return RemoveFriend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseRemoveFriend();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseBlockFriend() {\n  return { user_id: \"\" };\n}\nvar BlockFriend = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseBlockFriend();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return BlockFriend.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseBlockFriend();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBasePing() {\n  return {};\n}\nvar Ping = {\n  encode(_, writer = import_minimal5.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePing();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return Ping.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBasePing();\n    return message;\n  }\n};\nfunction createBasePong() {\n  return {};\n}\nvar Pong = {\n  encode(_, writer = import_minimal5.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePong();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(_) {\n    return {};\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  create(base) {\n    return Pong.fromPartial(base != null ? base : {});\n  },\n  fromPartial(_) {\n    const message = createBasePong();\n    return message;\n  }\n};\nfunction createBaseStatus() {\n  return { presences: [] };\n}\nvar Status = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.presences) {\n      UserPresence.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatus();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.presences.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      presences: globalThis.Array.isArray(object == null ? void 0 : object.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.presences) == null ? void 0 : _a.length) {\n      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return Status.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatus();\n    message.presences = ((_a = object.presences) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseStatusFollow() {\n  return { user_ids: [], usernames: [] };\n}\nvar StatusFollow = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.user_ids) {\n      writer.uint32(10).string(v);\n    }\n    for (const v of message.usernames) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusFollow();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.usernames.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      usernames: globalThis.Array.isArray(object == null ? void 0 : object.usernames) ? object.usernames.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if ((_b = message.usernames) == null ? void 0 : _b.length) {\n      obj.usernames = message.usernames;\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusFollow.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStatusFollow();\n    message.user_ids = ((_a = object.user_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    message.usernames = ((_b = object.usernames) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseStatusPresenceEvent() {\n  return { joins: [], leaves: [] };\n}\nvar StatusPresenceEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      joins: globalThis.Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: globalThis.Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if ((_a = message.joins) == null ? void 0 : _a.length) {\n      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));\n    }\n    if ((_b = message.leaves) == null ? void 0 : _b.length) {\n      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStatusPresenceEvent();\n    message.joins = ((_a = object.joins) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_b = object.leaves) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseLastPinMessageEvent() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    mode: 0,\n    user_id: \"\",\n    timestamp_seconds: 0,\n    operation: 0,\n    is_public: false\n  };\n}\nvar LastPinMessageEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.timestamp_seconds !== 0) {\n      writer.uint32(48).uint32(message.timestamp_seconds);\n    }\n    if (message.operation !== 0) {\n      writer.uint32(56).int32(message.operation);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(64).bool(message.is_public);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseLastPinMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.timestamp_seconds = reader.uint32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.operation = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      timestamp_seconds: isSet4(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,\n      operation: isSet4(object.operation) ? globalThis.Number(object.operation) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.timestamp_seconds !== 0) {\n      obj.timestamp_seconds = Math.round(message.timestamp_seconds);\n    }\n    if (message.operation !== 0) {\n      obj.operation = Math.round(message.operation);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    return obj;\n  },\n  create(base) {\n    return LastPinMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseLastPinMessageEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.timestamp_seconds = (_f = object.timestamp_seconds) != null ? _f : 0;\n    message.operation = (_g = object.operation) != null ? _g : 0;\n    message.is_public = (_h = object.is_public) != null ? _h : false;\n    return message;\n  }\n};\nfunction createBaseLastSeenMessageEvent() {\n  return { clan_id: \"\", channel_id: \"\", message_id: \"\", mode: 0, timestamp_seconds: 0, badge_count: 0 };\n}\nvar LastSeenMessageEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(26).string(message.message_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.timestamp_seconds !== 0) {\n      writer.uint32(40).uint32(message.timestamp_seconds);\n    }\n    if (message.badge_count !== 0) {\n      writer.uint32(48).int32(message.badge_count);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseLastSeenMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.timestamp_seconds = reader.uint32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.badge_count = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      timestamp_seconds: isSet4(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,\n      badge_count: isSet4(object.badge_count) ? globalThis.Number(object.badge_count) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.timestamp_seconds !== 0) {\n      obj.timestamp_seconds = Math.round(message.timestamp_seconds);\n    }\n    if (message.badge_count !== 0) {\n      obj.badge_count = Math.round(message.badge_count);\n    }\n    return obj;\n  },\n  create(base) {\n    return LastSeenMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseLastSeenMessageEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.message_id = (_c = object.message_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.timestamp_seconds = (_e = object.timestamp_seconds) != null ? _e : 0;\n    message.badge_count = (_f = object.badge_count) != null ? _f : 0;\n    return message;\n  }\n};\nfunction createBaseMessageTypingEvent() {\n  return {\n    clan_id: \"\",\n    channel_id: \"\",\n    sender_id: \"\",\n    mode: 0,\n    is_public: false,\n    sender_username: \"\",\n    sender_display_name: \"\"\n  };\n}\nvar MessageTypingEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(26).string(message.sender_id);\n    }\n    if (message.mode !== 0) {\n      writer.uint32(32).int32(message.mode);\n    }\n    if (message.is_public !== false) {\n      writer.uint32(40).bool(message.is_public);\n    }\n    if (message.sender_username !== \"\") {\n      writer.uint32(50).string(message.sender_username);\n    }\n    if (message.sender_display_name !== \"\") {\n      writer.uint32(58).string(message.sender_display_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageTypingEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.is_public = reader.bool();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.sender_username = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.sender_display_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      sender_id: isSet4(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      is_public: isSet4(object.is_public) ? globalThis.Boolean(object.is_public) : false,\n      sender_username: isSet4(object.sender_username) ? globalThis.String(object.sender_username) : \"\",\n      sender_display_name: isSet4(object.sender_display_name) ? globalThis.String(object.sender_display_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.is_public !== false) {\n      obj.is_public = message.is_public;\n    }\n    if (message.sender_username !== \"\") {\n      obj.sender_username = message.sender_username;\n    }\n    if (message.sender_display_name !== \"\") {\n      obj.sender_display_name = message.sender_display_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageTypingEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseMessageTypingEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.sender_id = (_c = object.sender_id) != null ? _c : \"\";\n    message.mode = (_d = object.mode) != null ? _d : 0;\n    message.is_public = (_e = object.is_public) != null ? _e : false;\n    message.sender_username = (_f = object.sender_username) != null ? _f : \"\";\n    message.sender_display_name = (_g = object.sender_display_name) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceLeavedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\", voice_user_id: \"\" };\n}\nvar VoiceLeavedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    if (message.voice_user_id !== \"\") {\n      writer.uint32(34).string(message.voice_user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceLeavedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.voice_user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\",\n      voice_user_id: isSet4(object.voice_user_id) ? globalThis.String(object.voice_user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    if (message.voice_user_id !== \"\") {\n      obj.voice_user_id = message.voice_user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceLeavedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseVoiceLeavedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    message.voice_user_id = (_d = object.voice_user_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceJoinedEvent() {\n  return {\n    clan_id: \"\",\n    clan_name: \"\",\n    id: \"\",\n    participant: \"\",\n    user_id: \"\",\n    voice_channel_label: \"\",\n    voice_channel_id: \"\",\n    last_screenshot: \"\"\n  };\n}\nvar VoiceJoinedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.participant !== \"\") {\n      writer.uint32(34).string(message.participant);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.voice_channel_label !== \"\") {\n      writer.uint32(50).string(message.voice_channel_label);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(58).string(message.voice_channel_id);\n    }\n    if (message.last_screenshot !== \"\") {\n      writer.uint32(66).string(message.last_screenshot);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceJoinedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.participant = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.voice_channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.last_screenshot = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      participant: isSet4(object.participant) ? globalThis.String(object.participant) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      voice_channel_label: isSet4(object.voice_channel_label) ? globalThis.String(object.voice_channel_label) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\",\n      last_screenshot: isSet4(object.last_screenshot) ? globalThis.String(object.last_screenshot) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.participant !== \"\") {\n      obj.participant = message.participant;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.voice_channel_label !== \"\") {\n      obj.voice_channel_label = message.voice_channel_label;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    if (message.last_screenshot !== \"\") {\n      obj.last_screenshot = message.last_screenshot;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceJoinedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseVoiceJoinedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.id = (_c = object.id) != null ? _c : \"\";\n    message.participant = (_d = object.participant) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.voice_channel_label = (_f = object.voice_channel_label) != null ? _f : \"\";\n    message.voice_channel_id = (_g = object.voice_channel_id) != null ? _g : \"\";\n    message.last_screenshot = (_h = object.last_screenshot) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceStartedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\n}\nvar VoiceStartedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceStartedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseVoiceStartedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseVoiceEndedEvent() {\n  return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\n}\nvar VoiceEndedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.voice_channel_id !== \"\") {\n      writer.uint32(26).string(message.voice_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseVoiceEndedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.voice_channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      voice_channel_id: isSet4(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.voice_channel_id !== \"\") {\n      obj.voice_channel_id = message.voice_channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return VoiceEndedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseVoiceEndedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.voice_channel_id = (_c = object.voice_channel_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamingLeavedEvent() {\n  return { id: \"\", clan_id: \"\", streaming_channel_id: \"\", streaming_user_id: \"\" };\n}\nvar StreamingLeavedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.streaming_channel_id !== \"\") {\n      writer.uint32(26).string(message.streaming_channel_id);\n    }\n    if (message.streaming_user_id !== \"\") {\n      writer.uint32(34).string(message.streaming_user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingLeavedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.streaming_channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.streaming_user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      streaming_channel_id: isSet4(object.streaming_channel_id) ? globalThis.String(object.streaming_channel_id) : \"\",\n      streaming_user_id: isSet4(object.streaming_user_id) ? globalThis.String(object.streaming_user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.streaming_channel_id !== \"\") {\n      obj.streaming_channel_id = message.streaming_channel_id;\n    }\n    if (message.streaming_user_id !== \"\") {\n      obj.streaming_user_id = message.streaming_user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingLeavedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStreamingLeavedEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.streaming_channel_id = (_c = object.streaming_channel_id) != null ? _c : \"\";\n    message.streaming_user_id = (_d = object.streaming_user_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamingJoinedEvent() {\n  return {\n    clan_id: \"\",\n    clan_name: \"\",\n    id: \"\",\n    participant: \"\",\n    user_id: \"\",\n    streaming_channel_label: \"\",\n    streaming_channel_id: \"\"\n  };\n}\nvar StreamingJoinedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(26).string(message.id);\n    }\n    if (message.participant !== \"\") {\n      writer.uint32(34).string(message.participant);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.streaming_channel_label !== \"\") {\n      writer.uint32(50).string(message.streaming_channel_label);\n    }\n    if (message.streaming_channel_id !== \"\") {\n      writer.uint32(58).string(message.streaming_channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingJoinedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.participant = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.streaming_channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.streaming_channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      participant: isSet4(object.participant) ? globalThis.String(object.participant) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      streaming_channel_label: isSet4(object.streaming_channel_label) ? globalThis.String(object.streaming_channel_label) : \"\",\n      streaming_channel_id: isSet4(object.streaming_channel_id) ? globalThis.String(object.streaming_channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.participant !== \"\") {\n      obj.participant = message.participant;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.streaming_channel_label !== \"\") {\n      obj.streaming_channel_label = message.streaming_channel_label;\n    }\n    if (message.streaming_channel_id !== \"\") {\n      obj.streaming_channel_id = message.streaming_channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingJoinedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseStreamingJoinedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.id = (_c = object.id) != null ? _c : \"\";\n    message.participant = (_d = object.participant) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.streaming_channel_label = (_f = object.streaming_channel_label) != null ? _f : \"\";\n    message.streaming_channel_id = (_g = object.streaming_channel_id) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamingStartedEvent() {\n  return { clan_id: \"\", channel_id: \"\", streaming_url: \"\", is_streaming: false };\n}\nvar StreamingStartedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.streaming_url !== \"\") {\n      writer.uint32(26).string(message.streaming_url);\n    }\n    if (message.is_streaming !== false) {\n      writer.uint32(32).bool(message.is_streaming);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.streaming_url = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.is_streaming = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      streaming_url: isSet4(object.streaming_url) ? globalThis.String(object.streaming_url) : \"\",\n      is_streaming: isSet4(object.is_streaming) ? globalThis.Boolean(object.is_streaming) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.streaming_url !== \"\") {\n      obj.streaming_url = message.streaming_url;\n    }\n    if (message.is_streaming !== false) {\n      obj.is_streaming = message.is_streaming;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingStartedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStreamingStartedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.streaming_url = (_c = object.streaming_url) != null ? _c : \"\";\n    message.is_streaming = (_d = object.is_streaming) != null ? _d : false;\n    return message;\n  }\n};\nfunction createBaseStreamingEndedEvent() {\n  return { clan_id: \"\", channel_id: \"\" };\n}\nvar StreamingEndedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamingEndedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamingEndedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamingEndedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelCreatedEvent() {\n  return {\n    clan_id: \"\",\n    category_id: \"\",\n    creator_id: \"\",\n    parent_id: \"\",\n    channel_id: \"\",\n    channel_label: \"\",\n    channel_private: 0,\n    channel_type: void 0,\n    status: 0,\n    app_id: \"\",\n    clan_name: \"\"\n  };\n}\nvar ChannelCreatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(26).string(message.creator_id);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(34).string(message.parent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(50).string(message.channel_label);\n    }\n    if (message.channel_private !== 0) {\n      writer.uint32(56).int32(message.channel_private);\n    }\n    if (message.channel_type !== void 0) {\n      Int32Value.encode({ value: message.channel_type }, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(72).int32(message.status);\n    }\n    if (message.app_id !== \"\") {\n      writer.uint32(82).string(message.app_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(90).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelCreatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.channel_private = reader.int32();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.app_id = reader.string();\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      channel_private: isSet4(object.channel_private) ? globalThis.Number(object.channel_private) : 0,\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : void 0,\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      app_id: isSet4(object.app_id) ? globalThis.String(object.app_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.channel_private !== 0) {\n      obj.channel_private = Math.round(message.channel_private);\n    }\n    if (message.channel_type !== void 0) {\n      obj.channel_type = message.channel_type;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.app_id !== \"\") {\n      obj.app_id = message.app_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelCreatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const message = createBaseChannelCreatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.creator_id = (_c = object.creator_id) != null ? _c : \"\";\n    message.parent_id = (_d = object.parent_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.channel_label = (_f = object.channel_label) != null ? _f : \"\";\n    message.channel_private = (_g = object.channel_private) != null ? _g : 0;\n    message.channel_type = (_h = object.channel_type) != null ? _h : void 0;\n    message.status = (_i = object.status) != null ? _i : 0;\n    message.app_id = (_j = object.app_id) != null ? _j : \"\";\n    message.clan_name = (_k = object.clan_name) != null ? _k : \"\";\n    return message;\n  }\n};\nfunction createBaseCategoryEvent() {\n  return { creator_id: \"\", clan_id: \"\", category_name: \"\", id: \"\", status: 0 };\n}\nvar CategoryEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.creator_id !== \"\") {\n      writer.uint32(10).string(message.creator_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.category_name !== \"\") {\n      writer.uint32(26).string(message.category_name);\n    }\n    if (message.id !== \"\") {\n      writer.uint32(34).string(message.id);\n    }\n    if (message.status !== 0) {\n      writer.uint32(40).int32(message.status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCategoryEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.category_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_name: isSet4(object.category_name) ? globalThis.String(object.category_name) : \"\",\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_name !== \"\") {\n      obj.category_name = message.category_name;\n    }\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    return obj;\n  },\n  create(base) {\n    return CategoryEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseCategoryEvent();\n    message.creator_id = (_a = object.creator_id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.category_name = (_c = object.category_name) != null ? _c : \"\";\n    message.id = (_d = object.id) != null ? _d : \"\";\n    message.status = (_e = object.status) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseRoleEvent() {\n  return {\n    role: void 0,\n    status: 0,\n    user_id: \"\",\n    user_add_ids: [],\n    user_remove_ids: [],\n    active_permission_ids: [],\n    remove_permission_ids: []\n  };\n}\nvar RoleEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.role !== void 0) {\n      Role.encode(message.role, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(16).int32(message.status);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    for (const v of message.user_add_ids) {\n      writer.uint32(34).string(v);\n    }\n    for (const v of message.user_remove_ids) {\n      writer.uint32(42).string(v);\n    }\n    for (const v of message.active_permission_ids) {\n      writer.uint32(50).string(v);\n    }\n    for (const v of message.remove_permission_ids) {\n      writer.uint32(58).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseRoleEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.role = Role.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 16) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.user_add_ids.push(reader.string());\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_remove_ids.push(reader.string());\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.active_permission_ids.push(reader.string());\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.remove_permission_ids.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      role: isSet4(object.role) ? Role.fromJSON(object.role) : void 0,\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      user_add_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_add_ids) ? object.user_add_ids.map((e) => globalThis.String(e)) : [],\n      user_remove_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_remove_ids) ? object.user_remove_ids.map((e) => globalThis.String(e)) : [],\n      active_permission_ids: globalThis.Array.isArray(object == null ? void 0 : object.active_permission_ids) ? object.active_permission_ids.map((e) => globalThis.String(e)) : [],\n      remove_permission_ids: globalThis.Array.isArray(object == null ? void 0 : object.remove_permission_ids) ? object.remove_permission_ids.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c, _d;\n    const obj = {};\n    if (message.role !== void 0) {\n      obj.role = Role.toJSON(message.role);\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if ((_a = message.user_add_ids) == null ? void 0 : _a.length) {\n      obj.user_add_ids = message.user_add_ids;\n    }\n    if ((_b = message.user_remove_ids) == null ? void 0 : _b.length) {\n      obj.user_remove_ids = message.user_remove_ids;\n    }\n    if ((_c = message.active_permission_ids) == null ? void 0 : _c.length) {\n      obj.active_permission_ids = message.active_permission_ids;\n    }\n    if ((_d = message.remove_permission_ids) == null ? void 0 : _d.length) {\n      obj.remove_permission_ids = message.remove_permission_ids;\n    }\n    return obj;\n  },\n  create(base) {\n    return RoleEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseRoleEvent();\n    message.role = object.role !== void 0 && object.role !== null ? Role.fromPartial(object.role) : void 0;\n    message.status = (_a = object.status) != null ? _a : 0;\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.user_add_ids = ((_c = object.user_add_ids) == null ? void 0 : _c.map((e) => e)) || [];\n    message.user_remove_ids = ((_d = object.user_remove_ids) == null ? void 0 : _d.map((e) => e)) || [];\n    message.active_permission_ids = ((_e = object.active_permission_ids) == null ? void 0 : _e.map((e) => e)) || [];\n    message.remove_permission_ids = ((_f = object.remove_permission_ids) == null ? void 0 : _f.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseChannelDeletedEvent() {\n  return { clan_id: \"\", category_id: \"\", parent_id: \"\", channel_id: \"\", deletor: \"\" };\n}\nvar ChannelDeletedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(26).string(message.parent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.deletor !== \"\") {\n      writer.uint32(42).string(message.deletor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelDeletedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.deletor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      deletor: isSet4(object.deletor) ? globalThis.String(object.deletor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.deletor !== \"\") {\n      obj.deletor = message.deletor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelDeletedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannelDeletedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.parent_id = (_c = object.parent_id) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.deletor = (_e = object.deletor) != null ? _e : \"\";\n    return message;\n  }\n};\nfunction createBaseClanDeletedEvent() {\n  return { clan_id: \"\", deletor: \"\" };\n}\nvar ClanDeletedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.deletor !== \"\") {\n      writer.uint32(18).string(message.deletor);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanDeletedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.deletor = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      deletor: isSet4(object.deletor) ? globalThis.String(object.deletor) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.deletor !== \"\") {\n      obj.deletor = message.deletor;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanDeletedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseClanDeletedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.deletor = (_b = object.deletor) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseStickerCreateEvent() {\n  return {\n    clan_id: \"\",\n    source: \"\",\n    shortname: \"\",\n    category: \"\",\n    creator_id: \"\",\n    sticker_id: \"\",\n    logo: \"\",\n    clan_name: \"\"\n  };\n}\nvar StickerCreateEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(18).string(message.source);\n    }\n    if (message.shortname !== \"\") {\n      writer.uint32(26).string(message.shortname);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(34).string(message.category);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(42).string(message.creator_id);\n    }\n    if (message.sticker_id !== \"\") {\n      writer.uint32(50).string(message.sticker_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(58).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(66).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerCreateEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.source = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.sticker_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      source: isSet4(object.source) ? globalThis.String(object.source) : \"\",\n      shortname: isSet4(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      category: isSet4(object.category) ? globalThis.String(object.category) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      sticker_id: isSet4(object.sticker_id) ? globalThis.String(object.sticker_id) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.source !== \"\") {\n      obj.source = message.source;\n    }\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.sticker_id !== \"\") {\n      obj.sticker_id = message.sticker_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerCreateEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseStickerCreateEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.source = (_b = object.source) != null ? _b : \"\";\n    message.shortname = (_c = object.shortname) != null ? _c : \"\";\n    message.category = (_d = object.category) != null ? _d : \"\";\n    message.creator_id = (_e = object.creator_id) != null ? _e : \"\";\n    message.sticker_id = (_f = object.sticker_id) != null ? _f : \"\";\n    message.logo = (_g = object.logo) != null ? _g : \"\";\n    message.clan_name = (_h = object.clan_name) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseStickerUpdateEvent() {\n  return { shortname: \"\", sticker_id: \"\", user_id: \"\" };\n}\nvar StickerUpdateEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.shortname !== \"\") {\n      writer.uint32(10).string(message.shortname);\n    }\n    if (message.sticker_id !== \"\") {\n      writer.uint32(18).string(message.sticker_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerUpdateEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.shortname = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sticker_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      shortname: isSet4(object.shortname) ? globalThis.String(object.shortname) : \"\",\n      sticker_id: isSet4(object.sticker_id) ? globalThis.String(object.sticker_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.shortname !== \"\") {\n      obj.shortname = message.shortname;\n    }\n    if (message.sticker_id !== \"\") {\n      obj.sticker_id = message.sticker_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerUpdateEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseStickerUpdateEvent();\n    message.shortname = (_a = object.shortname) != null ? _a : \"\";\n    message.sticker_id = (_b = object.sticker_id) != null ? _b : \"\";\n    message.user_id = (_c = object.user_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseStickerDeleteEvent() {\n  return { sticker_id: \"\", user_id: \"\" };\n}\nvar StickerDeleteEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.sticker_id !== \"\") {\n      writer.uint32(18).string(message.sticker_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStickerDeleteEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sticker_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      sticker_id: isSet4(object.sticker_id) ? globalThis.String(object.sticker_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.sticker_id !== \"\") {\n      obj.sticker_id = message.sticker_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return StickerDeleteEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStickerDeleteEvent();\n    message.sticker_id = (_a = object.sticker_id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseChannelUpdatedEvent() {\n  return {\n    clan_id: \"\",\n    category_id: \"\",\n    creator_id: \"\",\n    parent_id: \"\",\n    channel_id: \"\",\n    channel_label: \"\",\n    channel_type: void 0,\n    status: 0,\n    meeting_code: \"\",\n    is_error: false,\n    channel_private: false,\n    app_id: \"\",\n    e2ee: 0,\n    topic: \"\",\n    age_restricted: 0,\n    active: 0,\n    count_mess_unread: 0\n  };\n}\nvar ChannelUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.creator_id !== \"\") {\n      writer.uint32(26).string(message.creator_id);\n    }\n    if (message.parent_id !== \"\") {\n      writer.uint32(34).string(message.parent_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.channel_label !== \"\") {\n      writer.uint32(50).string(message.channel_label);\n    }\n    if (message.channel_type !== void 0) {\n      Int32Value.encode({ value: message.channel_type }, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.status !== 0) {\n      writer.uint32(64).int32(message.status);\n    }\n    if (message.meeting_code !== \"\") {\n      writer.uint32(74).string(message.meeting_code);\n    }\n    if (message.is_error !== false) {\n      writer.uint32(80).bool(message.is_error);\n    }\n    if (message.channel_private !== false) {\n      writer.uint32(88).bool(message.channel_private);\n    }\n    if (message.app_id !== \"\") {\n      writer.uint32(98).string(message.app_id);\n    }\n    if (message.e2ee !== 0) {\n      writer.uint32(104).int32(message.e2ee);\n    }\n    if (message.topic !== \"\") {\n      writer.uint32(114).string(message.topic);\n    }\n    if (message.age_restricted !== 0) {\n      writer.uint32(120).int32(message.age_restricted);\n    }\n    if (message.active !== 0) {\n      writer.uint32(128).int32(message.active);\n    }\n    if (message.count_mess_unread !== 0) {\n      writer.uint32(136).int32(message.count_mess_unread);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.creator_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.parent_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.channel_label = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;\n          continue;\n        case 8:\n          if (tag !== 64) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.meeting_code = reader.string();\n          continue;\n        case 10:\n          if (tag !== 80) {\n            break;\n          }\n          message.is_error = reader.bool();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.channel_private = reader.bool();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.app_id = reader.string();\n          continue;\n        case 13:\n          if (tag !== 104) {\n            break;\n          }\n          message.e2ee = reader.int32();\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.topic = reader.string();\n          continue;\n        case 15:\n          if (tag !== 120) {\n            break;\n          }\n          message.age_restricted = reader.int32();\n          continue;\n        case 16:\n          if (tag !== 128) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n        case 17:\n          if (tag !== 136) {\n            break;\n          }\n          message.count_mess_unread = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      creator_id: isSet4(object.creator_id) ? globalThis.String(object.creator_id) : \"\",\n      parent_id: isSet4(object.parent_id) ? globalThis.String(object.parent_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      channel_label: isSet4(object.channel_label) ? globalThis.String(object.channel_label) : \"\",\n      channel_type: isSet4(object.channel_type) ? Number(object.channel_type) : void 0,\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      meeting_code: isSet4(object.meeting_code) ? globalThis.String(object.meeting_code) : \"\",\n      is_error: isSet4(object.is_error) ? globalThis.Boolean(object.is_error) : false,\n      channel_private: isSet4(object.channel_private) ? globalThis.Boolean(object.channel_private) : false,\n      app_id: isSet4(object.app_id) ? globalThis.String(object.app_id) : \"\",\n      e2ee: isSet4(object.e2ee) ? globalThis.Number(object.e2ee) : 0,\n      topic: isSet4(object.topic) ? globalThis.String(object.topic) : \"\",\n      age_restricted: isSet4(object.age_restricted) ? globalThis.Number(object.age_restricted) : 0,\n      active: isSet4(object.active) ? globalThis.Number(object.active) : 0,\n      count_mess_unread: isSet4(object.count_mess_unread) ? globalThis.Number(object.count_mess_unread) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.creator_id !== \"\") {\n      obj.creator_id = message.creator_id;\n    }\n    if (message.parent_id !== \"\") {\n      obj.parent_id = message.parent_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.channel_label !== \"\") {\n      obj.channel_label = message.channel_label;\n    }\n    if (message.channel_type !== void 0) {\n      obj.channel_type = message.channel_type;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.meeting_code !== \"\") {\n      obj.meeting_code = message.meeting_code;\n    }\n    if (message.is_error !== false) {\n      obj.is_error = message.is_error;\n    }\n    if (message.channel_private !== false) {\n      obj.channel_private = message.channel_private;\n    }\n    if (message.app_id !== \"\") {\n      obj.app_id = message.app_id;\n    }\n    if (message.e2ee !== 0) {\n      obj.e2ee = Math.round(message.e2ee);\n    }\n    if (message.topic !== \"\") {\n      obj.topic = message.topic;\n    }\n    if (message.age_restricted !== 0) {\n      obj.age_restricted = Math.round(message.age_restricted);\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    if (message.count_mess_unread !== 0) {\n      obj.count_mess_unread = Math.round(message.count_mess_unread);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;\n    const message = createBaseChannelUpdatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.creator_id = (_c = object.creator_id) != null ? _c : \"\";\n    message.parent_id = (_d = object.parent_id) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.channel_label = (_f = object.channel_label) != null ? _f : \"\";\n    message.channel_type = (_g = object.channel_type) != null ? _g : void 0;\n    message.status = (_h = object.status) != null ? _h : 0;\n    message.meeting_code = (_i = object.meeting_code) != null ? _i : \"\";\n    message.is_error = (_j = object.is_error) != null ? _j : false;\n    message.channel_private = (_k = object.channel_private) != null ? _k : false;\n    message.app_id = (_l = object.app_id) != null ? _l : \"\";\n    message.e2ee = (_m = object.e2ee) != null ? _m : 0;\n    message.topic = (_n = object.topic) != null ? _n : \"\";\n    message.age_restricted = (_o = object.age_restricted) != null ? _o : 0;\n    message.active = (_p = object.active) != null ? _p : 0;\n    message.count_mess_unread = (_q = object.count_mess_unread) != null ? _q : 0;\n    return message;\n  }\n};\nfunction createBaseStatusUnfollow() {\n  return { user_ids: [] };\n}\nvar StatusUnfollow = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.user_ids) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusUnfollow();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusUnfollow.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatusUnfollow();\n    message.user_ids = ((_a = object.user_ids) == null ? void 0 : _a.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseStatusUpdate() {\n  return { status: void 0 };\n}\nvar StatusUpdate = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.status !== void 0) {\n      StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStatusUpdate();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.status = StringValue.decode(reader, reader.uint32()).value;\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { status: isSet4(object.status) ? String(object.status) : void 0 };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.status !== void 0) {\n      obj.status = message.status;\n    }\n    return obj;\n  },\n  create(base) {\n    return StatusUpdate.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseStatusUpdate();\n    message.status = (_a = object.status) != null ? _a : void 0;\n    return message;\n  }\n};\nfunction createBaseStream() {\n  return { mode: 0, channel_id: \"\", clan_id: \"\", label: \"\" };\n}\nvar Stream = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.mode !== 0) {\n      writer.uint32(8).int32(message.mode);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(34).string(message.label);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStream();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 8) {\n            break;\n          }\n          message.mode = reader.int32();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.label = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      mode: isSet4(object.mode) ? globalThis.Number(object.mode) : 0,\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      label: isSet4(object.label) ? globalThis.String(object.label) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.mode !== 0) {\n      obj.mode = Math.round(message.mode);\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.label !== \"\") {\n      obj.label = message.label;\n    }\n    return obj;\n  },\n  create(base) {\n    return Stream.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseStream();\n    message.mode = (_a = object.mode) != null ? _a : 0;\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.label = (_d = object.label) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseStreamData() {\n  return { stream: void 0, sender: void 0, data: \"\", reliable: false };\n}\nvar StreamData = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.stream !== void 0) {\n      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.sender !== void 0) {\n      UserPresence.encode(message.sender, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.data !== \"\") {\n      writer.uint32(26).string(message.data);\n    }\n    if (message.reliable !== false) {\n      writer.uint32(32).bool(message.reliable);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.stream = Stream.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.sender = UserPresence.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.data = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.reliable = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stream: isSet4(object.stream) ? Stream.fromJSON(object.stream) : void 0,\n      sender: isSet4(object.sender) ? UserPresence.fromJSON(object.sender) : void 0,\n      data: isSet4(object.data) ? globalThis.String(object.data) : \"\",\n      reliable: isSet4(object.reliable) ? globalThis.Boolean(object.reliable) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.stream !== void 0) {\n      obj.stream = Stream.toJSON(message.stream);\n    }\n    if (message.sender !== void 0) {\n      obj.sender = UserPresence.toJSON(message.sender);\n    }\n    if (message.data !== \"\") {\n      obj.data = message.data;\n    }\n    if (message.reliable !== false) {\n      obj.reliable = message.reliable;\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamData.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamData();\n    message.stream = object.stream !== void 0 && object.stream !== null ? Stream.fromPartial(object.stream) : void 0;\n    message.sender = object.sender !== void 0 && object.sender !== null ? UserPresence.fromPartial(object.sender) : void 0;\n    message.data = (_a = object.data) != null ? _a : \"\";\n    message.reliable = (_b = object.reliable) != null ? _b : false;\n    return message;\n  }\n};\nfunction createBaseStreamPresenceEvent() {\n  return { stream: void 0, joins: [], leaves: [] };\n}\nvar StreamPresenceEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.stream !== void 0) {\n      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.joins) {\n      UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.leaves) {\n      UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseStreamPresenceEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.stream = Stream.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.joins.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.leaves.push(UserPresence.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      stream: isSet4(object.stream) ? Stream.fromJSON(object.stream) : void 0,\n      joins: globalThis.Array.isArray(object == null ? void 0 : object.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\n      leaves: globalThis.Array.isArray(object == null ? void 0 : object.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.stream !== void 0) {\n      obj.stream = Stream.toJSON(message.stream);\n    }\n    if ((_a = message.joins) == null ? void 0 : _a.length) {\n      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));\n    }\n    if ((_b = message.leaves) == null ? void 0 : _b.length) {\n      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return StreamPresenceEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseStreamPresenceEvent();\n    message.stream = object.stream !== void 0 && object.stream !== null ? Stream.fromPartial(object.stream) : void 0;\n    message.joins = ((_a = object.joins) == null ? void 0 : _a.map((e) => UserPresence.fromPartial(e))) || [];\n    message.leaves = ((_b = object.leaves) == null ? void 0 : _b.map((e) => UserPresence.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseUserPresence() {\n  return {\n    user_id: \"\",\n    session_id: \"\",\n    username: \"\",\n    persistence: false,\n    status: void 0,\n    is_mobile: false,\n    metadata: \"\"\n  };\n}\nvar UserPresence = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.session_id !== \"\") {\n      writer.uint32(18).string(message.session_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.persistence !== false) {\n      writer.uint32(32).bool(message.persistence);\n    }\n    if (message.status !== void 0) {\n      StringValue.encode({ value: message.status }, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.is_mobile !== false) {\n      writer.uint32(48).bool(message.is_mobile);\n    }\n    if (message.metadata !== \"\") {\n      writer.uint32(58).string(message.metadata);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserPresence();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.session_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.persistence = reader.bool();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.status = StringValue.decode(reader, reader.uint32()).value;\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.is_mobile = reader.bool();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.metadata = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      session_id: isSet4(object.session_id) ? globalThis.String(object.session_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      persistence: isSet4(object.persistence) ? globalThis.Boolean(object.persistence) : false,\n      status: isSet4(object.status) ? String(object.status) : void 0,\n      is_mobile: isSet4(object.is_mobile) ? globalThis.Boolean(object.is_mobile) : false,\n      metadata: isSet4(object.metadata) ? globalThis.String(object.metadata) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.session_id !== \"\") {\n      obj.session_id = message.session_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.persistence !== false) {\n      obj.persistence = message.persistence;\n    }\n    if (message.status !== void 0) {\n      obj.status = message.status;\n    }\n    if (message.is_mobile !== false) {\n      obj.is_mobile = message.is_mobile;\n    }\n    if (message.metadata !== \"\") {\n      obj.metadata = message.metadata;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserPresence.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseUserPresence();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.session_id = (_b = object.session_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.persistence = (_d = object.persistence) != null ? _d : false;\n    message.status = (_e = object.status) != null ? _e : void 0;\n    message.is_mobile = (_f = object.is_mobile) != null ? _f : false;\n    message.metadata = (_g = object.metadata) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseCustomStatusEvent() {\n  return { clan_id: \"\", user_id: \"\", username: \"\", status: \"\", time_reset: 0, no_clear: false };\n}\nvar CustomStatusEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(18).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(26).string(message.username);\n    }\n    if (message.status !== \"\") {\n      writer.uint32(34).string(message.status);\n    }\n    if (message.time_reset !== 0) {\n      writer.uint32(40).int32(message.time_reset);\n    }\n    if (message.no_clear !== false) {\n      writer.uint32(48).bool(message.no_clear);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCustomStatusEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.status = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.time_reset = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.no_clear = reader.bool();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      status: isSet4(object.status) ? globalThis.String(object.status) : \"\",\n      time_reset: isSet4(object.time_reset) ? globalThis.Number(object.time_reset) : 0,\n      no_clear: isSet4(object.no_clear) ? globalThis.Boolean(object.no_clear) : false\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.status !== \"\") {\n      obj.status = message.status;\n    }\n    if (message.time_reset !== 0) {\n      obj.time_reset = Math.round(message.time_reset);\n    }\n    if (message.no_clear !== false) {\n      obj.no_clear = message.no_clear;\n    }\n    return obj;\n  },\n  create(base) {\n    return CustomStatusEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseCustomStatusEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user_id = (_b = object.user_id) != null ? _b : \"\";\n    message.username = (_c = object.username) != null ? _c : \"\";\n    message.status = (_d = object.status) != null ? _d : \"\";\n    message.time_reset = (_e = object.time_reset) != null ? _e : 0;\n    message.no_clear = (_f = object.no_clear) != null ? _f : false;\n    return message;\n  }\n};\nfunction createBaseUserChannelAdded() {\n  return {\n    channel_desc: void 0,\n    users: [],\n    status: \"\",\n    clan_id: \"\",\n    caller: void 0,\n    create_time_second: 0,\n    active: 0\n  };\n}\nvar UserChannelAdded = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_desc !== void 0) {\n      ChannelDescription.encode(message.channel_desc, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.users) {\n      UserProfileRedis.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.status !== \"\") {\n      writer.uint32(26).string(message.status);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    if (message.caller !== void 0) {\n      UserProfileRedis.encode(message.caller, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.create_time_second !== 0) {\n      writer.uint32(48).uint32(message.create_time_second);\n    }\n    if (message.active !== 0) {\n      writer.uint32(56).int32(message.active);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserChannelAdded();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_desc = ChannelDescription.decode(reader, reader.uint32());\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.users.push(UserProfileRedis.decode(reader, reader.uint32()));\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.status = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.caller = UserProfileRedis.decode(reader, reader.uint32());\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.create_time_second = reader.uint32();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.active = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_desc: isSet4(object.channel_desc) ? ChannelDescription.fromJSON(object.channel_desc) : void 0,\n      users: globalThis.Array.isArray(object == null ? void 0 : object.users) ? object.users.map((e) => UserProfileRedis.fromJSON(e)) : [],\n      status: isSet4(object.status) ? globalThis.String(object.status) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      caller: isSet4(object.caller) ? UserProfileRedis.fromJSON(object.caller) : void 0,\n      create_time_second: isSet4(object.create_time_second) ? globalThis.Number(object.create_time_second) : 0,\n      active: isSet4(object.active) ? globalThis.Number(object.active) : 0\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.channel_desc !== void 0) {\n      obj.channel_desc = ChannelDescription.toJSON(message.channel_desc);\n    }\n    if ((_a = message.users) == null ? void 0 : _a.length) {\n      obj.users = message.users.map((e) => UserProfileRedis.toJSON(e));\n    }\n    if (message.status !== \"\") {\n      obj.status = message.status;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.caller !== void 0) {\n      obj.caller = UserProfileRedis.toJSON(message.caller);\n    }\n    if (message.create_time_second !== 0) {\n      obj.create_time_second = Math.round(message.create_time_second);\n    }\n    if (message.active !== 0) {\n      obj.active = Math.round(message.active);\n    }\n    return obj;\n  },\n  create(base) {\n    return UserChannelAdded.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseUserChannelAdded();\n    message.channel_desc = object.channel_desc !== void 0 && object.channel_desc !== null ? ChannelDescription.fromPartial(object.channel_desc) : void 0;\n    message.users = ((_a = object.users) == null ? void 0 : _a.map((e) => UserProfileRedis.fromPartial(e))) || [];\n    message.status = (_b = object.status) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.caller = object.caller !== void 0 && object.caller !== null ? UserProfileRedis.fromPartial(object.caller) : void 0;\n    message.create_time_second = (_d = object.create_time_second) != null ? _d : 0;\n    message.active = (_e = object.active) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseUserChannelRemoved() {\n  return { channel_id: \"\", user_ids: [], channel_type: 0, clan_id: \"\", badge_counts: [] };\n}\nvar UserChannelRemoved = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    if (message.channel_type !== 0) {\n      writer.uint32(24).int32(message.channel_type);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    writer.uint32(50).fork();\n    for (const v of message.badge_counts) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserChannelRemoved();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.channel_type = reader.int32();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 6:\n          if (tag === 48) {\n            message.badge_counts.push(reader.int32());\n            continue;\n          }\n          if (tag === 50) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.badge_counts.push(reader.int32());\n            }\n            continue;\n          }\n          break;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : [],\n      channel_type: isSet4(object.channel_type) ? globalThis.Number(object.channel_type) : 0,\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      badge_counts: globalThis.Array.isArray(object == null ? void 0 : object.badge_counts) ? object.badge_counts.map((e) => globalThis.Number(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    if (message.channel_type !== 0) {\n      obj.channel_type = Math.round(message.channel_type);\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if ((_b = message.badge_counts) == null ? void 0 : _b.length) {\n      obj.badge_counts = message.badge_counts.map((e) => Math.round(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return UserChannelRemoved.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseUserChannelRemoved();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    message.channel_type = (_c = object.channel_type) != null ? _c : 0;\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    message.badge_counts = ((_e = object.badge_counts) == null ? void 0 : _e.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseUserClanRemoved() {\n  return { clan_id: \"\", user_ids: [] };\n}\nvar UserClanRemoved = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    for (const v of message.user_ids) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserClanRemoved();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.user_ids.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      user_ids: globalThis.Array.isArray(object == null ? void 0 : object.user_ids) ? object.user_ids.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if ((_a = message.user_ids) == null ? void 0 : _a.length) {\n      obj.user_ids = message.user_ids;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserClanRemoved.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserClanRemoved();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.user_ids = ((_b = object.user_ids) == null ? void 0 : _b.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseClanUpdatedEvent() {\n  return {\n    clan_id: \"\",\n    clan_name: \"\",\n    logo: \"\",\n    banner: \"\",\n    status: 0,\n    is_onboarding: false,\n    welcome_channel_id: \"\",\n    onboarding_banner: \"\"\n  };\n}\nvar ClanUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(18).string(message.clan_name);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(26).string(message.logo);\n    }\n    if (message.banner !== \"\") {\n      writer.uint32(34).string(message.banner);\n    }\n    if (message.status !== 0) {\n      writer.uint32(40).int32(message.status);\n    }\n    if (message.is_onboarding !== false) {\n      writer.uint32(48).bool(message.is_onboarding);\n    }\n    if (message.welcome_channel_id !== \"\") {\n      writer.uint32(58).string(message.welcome_channel_id);\n    }\n    if (message.onboarding_banner !== \"\") {\n      writer.uint32(66).string(message.onboarding_banner);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.banner = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.status = reader.int32();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.is_onboarding = reader.bool();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.welcome_channel_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.onboarding_banner = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      banner: isSet4(object.banner) ? globalThis.String(object.banner) : \"\",\n      status: isSet4(object.status) ? globalThis.Number(object.status) : 0,\n      is_onboarding: isSet4(object.is_onboarding) ? globalThis.Boolean(object.is_onboarding) : false,\n      welcome_channel_id: isSet4(object.welcome_channel_id) ? globalThis.String(object.welcome_channel_id) : \"\",\n      onboarding_banner: isSet4(object.onboarding_banner) ? globalThis.String(object.onboarding_banner) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.banner !== \"\") {\n      obj.banner = message.banner;\n    }\n    if (message.status !== 0) {\n      obj.status = Math.round(message.status);\n    }\n    if (message.is_onboarding !== false) {\n      obj.is_onboarding = message.is_onboarding;\n    }\n    if (message.welcome_channel_id !== \"\") {\n      obj.welcome_channel_id = message.welcome_channel_id;\n    }\n    if (message.onboarding_banner !== \"\") {\n      obj.onboarding_banner = message.onboarding_banner;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const message = createBaseClanUpdatedEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.clan_name = (_b = object.clan_name) != null ? _b : \"\";\n    message.logo = (_c = object.logo) != null ? _c : \"\";\n    message.banner = (_d = object.banner) != null ? _d : \"\";\n    message.status = (_e = object.status) != null ? _e : 0;\n    message.is_onboarding = (_f = object.is_onboarding) != null ? _f : false;\n    message.welcome_channel_id = (_g = object.welcome_channel_id) != null ? _g : \"\";\n    message.onboarding_banner = (_h = object.onboarding_banner) != null ? _h : \"\";\n    return message;\n  }\n};\nfunction createBaseClanProfileUpdatedEvent() {\n  return { user_id: \"\", clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\n}\nvar ClanProfileUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.clan_nick !== \"\") {\n      writer.uint32(18).string(message.clan_nick);\n    }\n    if (message.clan_avatar !== \"\") {\n      writer.uint32(26).string(message.clan_avatar);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseClanProfileUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_nick = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_avatar = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      clan_nick: isSet4(object.clan_nick) ? globalThis.String(object.clan_nick) : \"\",\n      clan_avatar: isSet4(object.clan_avatar) ? globalThis.String(object.clan_avatar) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.clan_nick !== \"\") {\n      obj.clan_nick = message.clan_nick;\n    }\n    if (message.clan_avatar !== \"\") {\n      obj.clan_avatar = message.clan_avatar;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return ClanProfileUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseClanProfileUpdatedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.clan_nick = (_b = object.clan_nick) != null ? _b : \"\";\n    message.clan_avatar = (_c = object.clan_avatar) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseUserProfileUpdatedEvent() {\n  return {\n    user_id: \"\",\n    display_name: \"\",\n    avatar: \"\",\n    about_me: \"\",\n    channel_id: \"\",\n    clan_id: \"\",\n    encrypt_private_key: \"\"\n  };\n}\nvar UserProfileUpdatedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(18).string(message.display_name);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(26).string(message.avatar);\n    }\n    if (message.about_me !== \"\") {\n      writer.uint32(34).string(message.about_me);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(42).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(50).string(message.clan_id);\n    }\n    if (message.encrypt_private_key !== \"\") {\n      writer.uint32(58).string(message.encrypt_private_key);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserProfileUpdatedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.about_me = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.encrypt_private_key = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      display_name: isSet4(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      avatar: isSet4(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      about_me: isSet4(object.about_me) ? globalThis.String(object.about_me) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      encrypt_private_key: isSet4(object.encrypt_private_key) ? globalThis.String(object.encrypt_private_key) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.about_me !== \"\") {\n      obj.about_me = message.about_me;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.encrypt_private_key !== \"\") {\n      obj.encrypt_private_key = message.encrypt_private_key;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserProfileUpdatedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const message = createBaseUserProfileUpdatedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.display_name = (_b = object.display_name) != null ? _b : \"\";\n    message.avatar = (_c = object.avatar) != null ? _c : \"\";\n    message.about_me = (_d = object.about_me) != null ? _d : \"\";\n    message.channel_id = (_e = object.channel_id) != null ? _e : \"\";\n    message.clan_id = (_f = object.clan_id) != null ? _f : \"\";\n    message.encrypt_private_key = (_g = object.encrypt_private_key) != null ? _g : \"\";\n    return message;\n  }\n};\nfunction createBaseUserProfileRedis() {\n  return {\n    user_id: \"\",\n    username: \"\",\n    avatar: \"\",\n    display_name: \"\",\n    about_me: \"\",\n    custom_status: \"\",\n    create_time_second: 0,\n    fcm_tokens: [],\n    online: false,\n    metadata: \"\",\n    is_disabled: false,\n    joined_clans: [],\n    pubkey: \"\",\n    mezon_id: \"\",\n    app_token: \"\",\n    app_url: \"\",\n    is_bot: false,\n    voip_token: \"\"\n  };\n}\nvar UserProfileRedis = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.avatar !== \"\") {\n      writer.uint32(26).string(message.avatar);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(34).string(message.display_name);\n    }\n    if (message.about_me !== \"\") {\n      writer.uint32(42).string(message.about_me);\n    }\n    if (message.custom_status !== \"\") {\n      writer.uint32(50).string(message.custom_status);\n    }\n    if (message.create_time_second !== 0) {\n      writer.uint32(56).uint32(message.create_time_second);\n    }\n    for (const v of message.fcm_tokens) {\n      FCMTokens.encode(v, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.online !== false) {\n      writer.uint32(72).bool(message.online);\n    }\n    if (message.metadata !== \"\") {\n      writer.uint32(82).string(message.metadata);\n    }\n    if (message.is_disabled !== false) {\n      writer.uint32(88).bool(message.is_disabled);\n    }\n    for (const v of message.joined_clans) {\n      writer.uint32(98).string(v);\n    }\n    if (message.pubkey !== \"\") {\n      writer.uint32(106).string(message.pubkey);\n    }\n    if (message.mezon_id !== \"\") {\n      writer.uint32(114).string(message.mezon_id);\n    }\n    if (message.app_token !== \"\") {\n      writer.uint32(122).string(message.app_token);\n    }\n    if (message.app_url !== \"\") {\n      writer.uint32(130).string(message.app_url);\n    }\n    if (message.is_bot !== false) {\n      writer.uint32(136).bool(message.is_bot);\n    }\n    if (message.voip_token !== \"\") {\n      writer.uint32(146).string(message.voip_token);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserProfileRedis();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.avatar = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.about_me = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.custom_status = reader.string();\n          continue;\n        case 7:\n          if (tag !== 56) {\n            break;\n          }\n          message.create_time_second = reader.uint32();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.fcm_tokens.push(FCMTokens.decode(reader, reader.uint32()));\n          continue;\n        case 9:\n          if (tag !== 72) {\n            break;\n          }\n          message.online = reader.bool();\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.metadata = reader.string();\n          continue;\n        case 11:\n          if (tag !== 88) {\n            break;\n          }\n          message.is_disabled = reader.bool();\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.joined_clans.push(reader.string());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.pubkey = reader.string();\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.mezon_id = reader.string();\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.app_token = reader.string();\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.app_url = reader.string();\n          continue;\n        case 17:\n          if (tag !== 136) {\n            break;\n          }\n          message.is_bot = reader.bool();\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.voip_token = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      avatar: isSet4(object.avatar) ? globalThis.String(object.avatar) : \"\",\n      display_name: isSet4(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      about_me: isSet4(object.about_me) ? globalThis.String(object.about_me) : \"\",\n      custom_status: isSet4(object.custom_status) ? globalThis.String(object.custom_status) : \"\",\n      create_time_second: isSet4(object.create_time_second) ? globalThis.Number(object.create_time_second) : 0,\n      fcm_tokens: globalThis.Array.isArray(object == null ? void 0 : object.fcm_tokens) ? object.fcm_tokens.map((e) => FCMTokens.fromJSON(e)) : [],\n      online: isSet4(object.online) ? globalThis.Boolean(object.online) : false,\n      metadata: isSet4(object.metadata) ? globalThis.String(object.metadata) : \"\",\n      is_disabled: isSet4(object.is_disabled) ? globalThis.Boolean(object.is_disabled) : false,\n      joined_clans: globalThis.Array.isArray(object == null ? void 0 : object.joined_clans) ? object.joined_clans.map((e) => globalThis.String(e)) : [],\n      pubkey: isSet4(object.pubkey) ? globalThis.String(object.pubkey) : \"\",\n      mezon_id: isSet4(object.mezon_id) ? globalThis.String(object.mezon_id) : \"\",\n      app_token: isSet4(object.app_token) ? globalThis.String(object.app_token) : \"\",\n      app_url: isSet4(object.app_url) ? globalThis.String(object.app_url) : \"\",\n      is_bot: isSet4(object.is_bot) ? globalThis.Boolean(object.is_bot) : false,\n      voip_token: isSet4(object.voip_token) ? globalThis.String(object.voip_token) : \"\"\n    };\n  },\n  toJSON(message) {\n    var _a, _b;\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.avatar !== \"\") {\n      obj.avatar = message.avatar;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.about_me !== \"\") {\n      obj.about_me = message.about_me;\n    }\n    if (message.custom_status !== \"\") {\n      obj.custom_status = message.custom_status;\n    }\n    if (message.create_time_second !== 0) {\n      obj.create_time_second = Math.round(message.create_time_second);\n    }\n    if ((_a = message.fcm_tokens) == null ? void 0 : _a.length) {\n      obj.fcm_tokens = message.fcm_tokens.map((e) => FCMTokens.toJSON(e));\n    }\n    if (message.online !== false) {\n      obj.online = message.online;\n    }\n    if (message.metadata !== \"\") {\n      obj.metadata = message.metadata;\n    }\n    if (message.is_disabled !== false) {\n      obj.is_disabled = message.is_disabled;\n    }\n    if ((_b = message.joined_clans) == null ? void 0 : _b.length) {\n      obj.joined_clans = message.joined_clans;\n    }\n    if (message.pubkey !== \"\") {\n      obj.pubkey = message.pubkey;\n    }\n    if (message.mezon_id !== \"\") {\n      obj.mezon_id = message.mezon_id;\n    }\n    if (message.app_token !== \"\") {\n      obj.app_token = message.app_token;\n    }\n    if (message.app_url !== \"\") {\n      obj.app_url = message.app_url;\n    }\n    if (message.is_bot !== false) {\n      obj.is_bot = message.is_bot;\n    }\n    if (message.voip_token !== \"\") {\n      obj.voip_token = message.voip_token;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserProfileRedis.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    const message = createBaseUserProfileRedis();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.avatar = (_c = object.avatar) != null ? _c : \"\";\n    message.display_name = (_d = object.display_name) != null ? _d : \"\";\n    message.about_me = (_e = object.about_me) != null ? _e : \"\";\n    message.custom_status = (_f = object.custom_status) != null ? _f : \"\";\n    message.create_time_second = (_g = object.create_time_second) != null ? _g : 0;\n    message.fcm_tokens = ((_h = object.fcm_tokens) == null ? void 0 : _h.map((e) => FCMTokens.fromPartial(e))) || [];\n    message.online = (_i = object.online) != null ? _i : false;\n    message.metadata = (_j = object.metadata) != null ? _j : \"\";\n    message.is_disabled = (_k = object.is_disabled) != null ? _k : false;\n    message.joined_clans = ((_l = object.joined_clans) == null ? void 0 : _l.map((e) => e)) || [];\n    message.pubkey = (_m = object.pubkey) != null ? _m : \"\";\n    message.mezon_id = (_n = object.mezon_id) != null ? _n : \"\";\n    message.app_token = (_o = object.app_token) != null ? _o : \"\";\n    message.app_url = (_p = object.app_url) != null ? _p : \"\";\n    message.is_bot = (_q = object.is_bot) != null ? _q : false;\n    message.voip_token = (_r = object.voip_token) != null ? _r : \"\";\n    return message;\n  }\n};\nfunction createBaseFCMTokens() {\n  return { device_id: \"\", token_id: \"\", platform: \"\" };\n}\nvar FCMTokens = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.device_id !== \"\") {\n      writer.uint32(10).string(message.device_id);\n    }\n    if (message.token_id !== \"\") {\n      writer.uint32(18).string(message.token_id);\n    }\n    if (message.platform !== \"\") {\n      writer.uint32(26).string(message.platform);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseFCMTokens();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.device_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.token_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.platform = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      device_id: isSet4(object.device_id) ? globalThis.String(object.device_id) : \"\",\n      token_id: isSet4(object.token_id) ? globalThis.String(object.token_id) : \"\",\n      platform: isSet4(object.platform) ? globalThis.String(object.platform) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.device_id !== \"\") {\n      obj.device_id = message.device_id;\n    }\n    if (message.token_id !== \"\") {\n      obj.token_id = message.token_id;\n    }\n    if (message.platform !== \"\") {\n      obj.platform = message.platform;\n    }\n    return obj;\n  },\n  create(base) {\n    return FCMTokens.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseFCMTokens();\n    message.device_id = (_a = object.device_id) != null ? _a : \"\";\n    message.token_id = (_b = object.token_id) != null ? _b : \"\";\n    message.platform = (_c = object.platform) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseCheckNameExistedEvent() {\n  return { name: \"\", condition_id: \"\", exist: false, type: 0 };\n}\nvar CheckNameExistedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.condition_id !== \"\") {\n      writer.uint32(18).string(message.condition_id);\n    }\n    if (message.exist !== false) {\n      writer.uint32(24).bool(message.exist);\n    }\n    if (message.type !== 0) {\n      writer.uint32(32).int32(message.type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseCheckNameExistedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.name = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.condition_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 24) {\n            break;\n          }\n          message.exist = reader.bool();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.type = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      name: isSet4(object.name) ? globalThis.String(object.name) : \"\",\n      condition_id: isSet4(object.condition_id) ? globalThis.String(object.condition_id) : \"\",\n      exist: isSet4(object.exist) ? globalThis.Boolean(object.exist) : false,\n      type: isSet4(object.type) ? globalThis.Number(object.type) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.name !== \"\") {\n      obj.name = message.name;\n    }\n    if (message.condition_id !== \"\") {\n      obj.condition_id = message.condition_id;\n    }\n    if (message.exist !== false) {\n      obj.exist = message.exist;\n    }\n    if (message.type !== 0) {\n      obj.type = Math.round(message.type);\n    }\n    return obj;\n  },\n  create(base) {\n    return CheckNameExistedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseCheckNameExistedEvent();\n    message.name = (_a = object.name) != null ? _a : \"\";\n    message.condition_id = (_b = object.condition_id) != null ? _b : \"\";\n    message.exist = (_c = object.exist) != null ? _c : false;\n    message.type = (_d = object.type) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseEventEmoji() {\n  return {\n    id: \"\",\n    clan_id: \"\",\n    short_name: \"\",\n    source: \"\",\n    category: \"\",\n    action: 0,\n    user_id: \"\",\n    logo: \"\",\n    clan_name: \"\"\n  };\n}\nvar EventEmoji = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.short_name !== \"\") {\n      writer.uint32(26).string(message.short_name);\n    }\n    if (message.source !== \"\") {\n      writer.uint32(34).string(message.source);\n    }\n    if (message.category !== \"\") {\n      writer.uint32(42).string(message.category);\n    }\n    if (message.action !== 0) {\n      writer.uint32(48).int32(message.action);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(58).string(message.user_id);\n    }\n    if (message.logo !== \"\") {\n      writer.uint32(66).string(message.logo);\n    }\n    if (message.clan_name !== \"\") {\n      writer.uint32(74).string(message.clan_name);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseEventEmoji();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.short_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.source = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.category = reader.string();\n          continue;\n        case 6:\n          if (tag !== 48) {\n            break;\n          }\n          message.action = reader.int32();\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.logo = reader.string();\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.clan_name = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      short_name: isSet4(object.short_name) ? globalThis.String(object.short_name) : \"\",\n      source: isSet4(object.source) ? globalThis.String(object.source) : \"\",\n      category: isSet4(object.category) ? globalThis.String(object.category) : \"\",\n      action: isSet4(object.action) ? globalThis.Number(object.action) : 0,\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      logo: isSet4(object.logo) ? globalThis.String(object.logo) : \"\",\n      clan_name: isSet4(object.clan_name) ? globalThis.String(object.clan_name) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.short_name !== \"\") {\n      obj.short_name = message.short_name;\n    }\n    if (message.source !== \"\") {\n      obj.source = message.source;\n    }\n    if (message.category !== \"\") {\n      obj.category = message.category;\n    }\n    if (message.action !== 0) {\n      obj.action = Math.round(message.action);\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.logo !== \"\") {\n      obj.logo = message.logo;\n    }\n    if (message.clan_name !== \"\") {\n      obj.clan_name = message.clan_name;\n    }\n    return obj;\n  },\n  create(base) {\n    return EventEmoji.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const message = createBaseEventEmoji();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.short_name = (_c = object.short_name) != null ? _c : \"\";\n    message.source = (_d = object.source) != null ? _d : \"\";\n    message.category = (_e = object.category) != null ? _e : \"\";\n    message.action = (_f = object.action) != null ? _f : 0;\n    message.user_id = (_g = object.user_id) != null ? _g : \"\";\n    message.logo = (_h = object.logo) != null ? _h : \"\";\n    message.clan_name = (_i = object.clan_name) != null ? _i : \"\";\n    return message;\n  }\n};\nfunction createBasePermissionSetEvent() {\n  return { caller: \"\", role_id: \"\", user_id: \"\", channel_id: \"\", permission_updates: [] };\n}\nvar PermissionSetEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.caller !== \"\") {\n      writer.uint32(10).string(message.caller);\n    }\n    if (message.role_id !== \"\") {\n      writer.uint32(18).string(message.role_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(26).string(message.user_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    for (const v of message.permission_updates) {\n      PermissionUpdate.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionSetEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.caller = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.role_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.permission_updates.push(PermissionUpdate.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      caller: isSet4(object.caller) ? globalThis.String(object.caller) : \"\",\n      role_id: isSet4(object.role_id) ? globalThis.String(object.role_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      permission_updates: globalThis.Array.isArray(object == null ? void 0 : object.permission_updates) ? object.permission_updates.map((e) => PermissionUpdate.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.caller !== \"\") {\n      obj.caller = message.caller;\n    }\n    if (message.role_id !== \"\") {\n      obj.role_id = message.role_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.permission_updates) == null ? void 0 : _a.length) {\n      obj.permission_updates = message.permission_updates.map((e) => PermissionUpdate.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionSetEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBasePermissionSetEvent();\n    message.caller = (_a = object.caller) != null ? _a : \"\";\n    message.role_id = (_b = object.role_id) != null ? _b : \"\";\n    message.user_id = (_c = object.user_id) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.permission_updates = ((_e = object.permission_updates) == null ? void 0 : _e.map((e) => PermissionUpdate.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBasePermissionChangedEvent() {\n  return { user_id: \"\", channel_id: \"\", add_permissions: [], remove_permissions: [], default_permissions: [] };\n}\nvar PermissionChangedEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    for (const v of message.add_permissions) {\n      PermissionUpdate.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.remove_permissions) {\n      PermissionUpdate.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    for (const v of message.default_permissions) {\n      PermissionUpdate.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBasePermissionChangedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.add_permissions.push(PermissionUpdate.decode(reader, reader.uint32()));\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.remove_permissions.push(PermissionUpdate.decode(reader, reader.uint32()));\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.default_permissions.push(PermissionUpdate.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      add_permissions: globalThis.Array.isArray(object == null ? void 0 : object.add_permissions) ? object.add_permissions.map((e) => PermissionUpdate.fromJSON(e)) : [],\n      remove_permissions: globalThis.Array.isArray(object == null ? void 0 : object.remove_permissions) ? object.remove_permissions.map((e) => PermissionUpdate.fromJSON(e)) : [],\n      default_permissions: globalThis.Array.isArray(object == null ? void 0 : object.default_permissions) ? object.default_permissions.map((e) => PermissionUpdate.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a, _b, _c;\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if ((_a = message.add_permissions) == null ? void 0 : _a.length) {\n      obj.add_permissions = message.add_permissions.map((e) => PermissionUpdate.toJSON(e));\n    }\n    if ((_b = message.remove_permissions) == null ? void 0 : _b.length) {\n      obj.remove_permissions = message.remove_permissions.map((e) => PermissionUpdate.toJSON(e));\n    }\n    if ((_c = message.default_permissions) == null ? void 0 : _c.length) {\n      obj.default_permissions = message.default_permissions.map((e) => PermissionUpdate.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return PermissionChangedEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBasePermissionChangedEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.add_permissions = ((_c = object.add_permissions) == null ? void 0 : _c.map((e) => PermissionUpdate.fromPartial(e))) || [];\n    message.remove_permissions = ((_d = object.remove_permissions) == null ? void 0 : _d.map((e) => PermissionUpdate.fromPartial(e))) || [];\n    message.default_permissions = ((_e = object.default_permissions) == null ? void 0 : _e.map((e) => PermissionUpdate.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseMessageButtonClicked() {\n  return { message_id: \"\", channel_id: \"\", button_id: \"\", sender_id: \"\", user_id: \"\", extra_data: \"\" };\n}\nvar MessageButtonClicked = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.message_id !== \"\") {\n      writer.uint32(10).string(message.message_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.button_id !== \"\") {\n      writer.uint32(26).string(message.button_id);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(34).string(message.sender_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.extra_data !== \"\") {\n      writer.uint32(50).string(message.extra_data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMessageButtonClicked();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.button_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.extra_data = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      button_id: isSet4(object.button_id) ? globalThis.String(object.button_id) : \"\",\n      sender_id: isSet4(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      extra_data: isSet4(object.extra_data) ? globalThis.String(object.extra_data) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.button_id !== \"\") {\n      obj.button_id = message.button_id;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.extra_data !== \"\") {\n      obj.extra_data = message.extra_data;\n    }\n    return obj;\n  },\n  create(base) {\n    return MessageButtonClicked.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseMessageButtonClicked();\n    message.message_id = (_a = object.message_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.button_id = (_c = object.button_id) != null ? _c : \"\";\n    message.sender_id = (_d = object.sender_id) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.extra_data = (_f = object.extra_data) != null ? _f : \"\";\n    return message;\n  }\n};\nfunction createBaseUnmuteEvent() {\n  return { channel_id: \"\", category_id: \"\", clan_id: \"\" };\n}\nvar UnmuteEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.channel_id !== \"\") {\n      writer.uint32(10).string(message.channel_id);\n    }\n    if (message.category_id !== \"\") {\n      writer.uint32(18).string(message.category_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUnmuteEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.category_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      category_id: isSet4(object.category_id) ? globalThis.String(object.category_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.category_id !== \"\") {\n      obj.category_id = message.category_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return UnmuteEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseUnmuteEvent();\n    message.channel_id = (_a = object.channel_id) != null ? _a : \"\";\n    message.category_id = (_b = object.category_id) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseListActivity() {\n  return { acts: [] };\n}\nvar ListActivity = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    for (const v of message.acts) {\n      UserActivity.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListActivity();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.acts.push(UserActivity.decode(reader, reader.uint32()));\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      acts: globalThis.Array.isArray(object == null ? void 0 : object.acts) ? object.acts.map((e) => UserActivity.fromJSON(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if ((_a = message.acts) == null ? void 0 : _a.length) {\n      obj.acts = message.acts.map((e) => UserActivity.toJSON(e));\n    }\n    return obj;\n  },\n  create(base) {\n    return ListActivity.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListActivity();\n    message.acts = ((_a = object.acts) == null ? void 0 : _a.map((e) => UserActivity.fromPartial(e))) || [];\n    return message;\n  }\n};\nfunction createBaseDropdownBoxSelected() {\n  return { message_id: \"\", channel_id: \"\", selectbox_id: \"\", sender_id: \"\", user_id: \"\", values: [] };\n}\nvar DropdownBoxSelected = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.message_id !== \"\") {\n      writer.uint32(10).string(message.message_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.selectbox_id !== \"\") {\n      writer.uint32(26).string(message.selectbox_id);\n    }\n    if (message.sender_id !== \"\") {\n      writer.uint32(34).string(message.sender_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    for (const v of message.values) {\n      writer.uint32(50).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseDropdownBoxSelected();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.selectbox_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.sender_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.values.push(reader.string());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      selectbox_id: isSet4(object.selectbox_id) ? globalThis.String(object.selectbox_id) : \"\",\n      sender_id: isSet4(object.sender_id) ? globalThis.String(object.sender_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      values: globalThis.Array.isArray(object == null ? void 0 : object.values) ? object.values.map((e) => globalThis.String(e)) : []\n    };\n  },\n  toJSON(message) {\n    var _a;\n    const obj = {};\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.selectbox_id !== \"\") {\n      obj.selectbox_id = message.selectbox_id;\n    }\n    if (message.sender_id !== \"\") {\n      obj.sender_id = message.sender_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if ((_a = message.values) == null ? void 0 : _a.length) {\n      obj.values = message.values;\n    }\n    return obj;\n  },\n  create(base) {\n    return DropdownBoxSelected.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e, _f;\n    const message = createBaseDropdownBoxSelected();\n    message.message_id = (_a = object.message_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.selectbox_id = (_c = object.selectbox_id) != null ? _c : \"\";\n    message.sender_id = (_d = object.sender_id) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.values = ((_f = object.values) == null ? void 0 : _f.map((e) => e)) || [];\n    return message;\n  }\n};\nfunction createBaseSdTopicEvent() {\n  return {\n    id: \"\",\n    clan_id: \"\",\n    channel_id: \"\",\n    message_id: \"\",\n    user_id: \"\",\n    last_sent_message: void 0,\n    message: void 0\n  };\n}\nvar SdTopicEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(18).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(34).string(message.message_id);\n    }\n    if (message.user_id !== \"\") {\n      writer.uint32(42).string(message.user_id);\n    }\n    if (message.last_sent_message !== void 0) {\n      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.message !== void 0) {\n      ChannelMessage.encode(message.message, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseSdTopicEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.message = ChannelMessage.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      last_sent_message: isSet4(object.last_sent_message) ? ChannelMessageHeader.fromJSON(object.last_sent_message) : void 0,\n      message: isSet4(object.message) ? ChannelMessage.fromJSON(object.message) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.last_sent_message !== void 0) {\n      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);\n    }\n    if (message.message !== void 0) {\n      obj.message = ChannelMessage.toJSON(message.message);\n    }\n    return obj;\n  },\n  create(base) {\n    return SdTopicEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseSdTopicEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.clan_id = (_b = object.clan_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.message_id = (_d = object.message_id) != null ? _d : \"\";\n    message.user_id = (_e = object.user_id) != null ? _e : \"\";\n    message.last_sent_message = object.last_sent_message !== void 0 && object.last_sent_message !== null ? ChannelMessageHeader.fromPartial(object.last_sent_message) : void 0;\n    message.message = object.message !== void 0 && object.message !== null ? ChannelMessage.fromPartial(object.message) : void 0;\n    return message;\n  }\n};\nfunction createBaseChannelAppEvent() {\n  return { user_id: \"\", username: \"\", clan_id: \"\", channel_id: \"\", action: 0 };\n}\nvar ChannelAppEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(26).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(34).string(message.channel_id);\n    }\n    if (message.action !== 0) {\n      writer.uint32(40).int32(message.action);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseChannelAppEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 5:\n          if (tag !== 40) {\n            break;\n          }\n          message.action = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      action: isSet4(object.action) ? globalThis.Number(object.action) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.action !== 0) {\n      obj.action = Math.round(message.action);\n    }\n    return obj;\n  },\n  create(base) {\n    return ChannelAppEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d, _e;\n    const message = createBaseChannelAppEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.clan_id = (_c = object.clan_id) != null ? _c : \"\";\n    message.channel_id = (_d = object.channel_id) != null ? _d : \"\";\n    message.action = (_e = object.action) != null ? _e : 0;\n    return message;\n  }\n};\nfunction createBaseUserStatusEvent() {\n  return { user_id: \"\", custom_status: \"\" };\n}\nvar UserStatusEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.custom_status !== \"\") {\n      writer.uint32(18).string(message.custom_status);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUserStatusEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.custom_status = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      custom_status: isSet4(object.custom_status) ? globalThis.String(object.custom_status) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.custom_status !== \"\") {\n      obj.custom_status = message.custom_status;\n    }\n    return obj;\n  },\n  create(base) {\n    return UserStatusEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b;\n    const message = createBaseUserStatusEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.custom_status = (_b = object.custom_status) != null ? _b : \"\";\n    return message;\n  }\n};\nfunction createBaseJoinChannelAppData() {\n  return { user_id: \"\", username: \"\", hash: \"\" };\n}\nvar JoinChannelAppData = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    if (message.username !== \"\") {\n      writer.uint32(18).string(message.username);\n    }\n    if (message.hash !== \"\") {\n      writer.uint32(26).string(message.hash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseJoinChannelAppData();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.username = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.hash = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\",\n      username: isSet4(object.username) ? globalThis.String(object.username) : \"\",\n      hash: isSet4(object.hash) ? globalThis.String(object.hash) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    if (message.username !== \"\") {\n      obj.username = message.username;\n    }\n    if (message.hash !== \"\") {\n      obj.hash = message.hash;\n    }\n    return obj;\n  },\n  create(base) {\n    return JoinChannelAppData.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c;\n    const message = createBaseJoinChannelAppData();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    message.username = (_b = object.username) != null ? _b : \"\";\n    message.hash = (_c = object.hash) != null ? _c : \"\";\n    return message;\n  }\n};\nfunction createBaseUnpinMessageEvent() {\n  return { id: \"\", message_id: \"\", channel_id: \"\", clan_id: \"\" };\n}\nvar UnpinMessageEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.message_id !== \"\") {\n      writer.uint32(18).string(message.message_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(26).string(message.channel_id);\n    }\n    if (message.clan_id !== \"\") {\n      writer.uint32(34).string(message.clan_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseUnpinMessageEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.message_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      id: isSet4(object.id) ? globalThis.String(object.id) : \"\",\n      message_id: isSet4(object.message_id) ? globalThis.String(object.message_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\"\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.id !== \"\") {\n      obj.id = message.id;\n    }\n    if (message.message_id !== \"\") {\n      obj.message_id = message.message_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return UnpinMessageEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseUnpinMessageEvent();\n    message.id = (_a = object.id) != null ? _a : \"\";\n    message.message_id = (_b = object.message_id) != null ? _b : \"\";\n    message.channel_id = (_c = object.channel_id) != null ? _c : \"\";\n    message.clan_id = (_d = object.clan_id) != null ? _d : \"\";\n    return message;\n  }\n};\nfunction createBaseHandleParticipantMeetStateEvent() {\n  return { clan_id: \"\", channel_id: \"\", display_name: \"\", state: 0 };\n}\nvar HandleParticipantMeetStateEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.clan_id !== \"\") {\n      writer.uint32(10).string(message.clan_id);\n    }\n    if (message.channel_id !== \"\") {\n      writer.uint32(18).string(message.channel_id);\n    }\n    if (message.display_name !== \"\") {\n      writer.uint32(26).string(message.display_name);\n    }\n    if (message.state !== 0) {\n      writer.uint32(32).int32(message.state);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseHandleParticipantMeetStateEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.clan_id = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.channel_id = reader.string();\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.display_name = reader.string();\n          continue;\n        case 4:\n          if (tag !== 32) {\n            break;\n          }\n          message.state = reader.int32();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      clan_id: isSet4(object.clan_id) ? globalThis.String(object.clan_id) : \"\",\n      channel_id: isSet4(object.channel_id) ? globalThis.String(object.channel_id) : \"\",\n      display_name: isSet4(object.display_name) ? globalThis.String(object.display_name) : \"\",\n      state: isSet4(object.state) ? globalThis.Number(object.state) : 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.clan_id !== \"\") {\n      obj.clan_id = message.clan_id;\n    }\n    if (message.channel_id !== \"\") {\n      obj.channel_id = message.channel_id;\n    }\n    if (message.display_name !== \"\") {\n      obj.display_name = message.display_name;\n    }\n    if (message.state !== 0) {\n      obj.state = Math.round(message.state);\n    }\n    return obj;\n  },\n  create(base) {\n    return HandleParticipantMeetStateEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a, _b, _c, _d;\n    const message = createBaseHandleParticipantMeetStateEvent();\n    message.clan_id = (_a = object.clan_id) != null ? _a : \"\";\n    message.channel_id = (_b = object.channel_id) != null ? _b : \"\";\n    message.display_name = (_c = object.display_name) != null ? _c : \"\";\n    message.state = (_d = object.state) != null ? _d : 0;\n    return message;\n  }\n};\nfunction createBaseDeleteAccountEvent() {\n  return { user_id: \"\" };\n}\nvar DeleteAccountEvent = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.user_id !== \"\") {\n      writer.uint32(10).string(message.user_id);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseDeleteAccountEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.user_id = reader.string();\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return { user_id: isSet4(object.user_id) ? globalThis.String(object.user_id) : \"\" };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.user_id !== \"\") {\n      obj.user_id = message.user_id;\n    }\n    return obj;\n  },\n  create(base) {\n    return DeleteAccountEvent.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseDeleteAccountEvent();\n    message.user_id = (_a = object.user_id) != null ? _a : \"\";\n    return message;\n  }\n};\nfunction createBaseListDataSocket() {\n  return {\n    api_name: \"\",\n    list_clan_req: void 0,\n    clan_desc_list: void 0,\n    list_thread_req: void 0,\n    channel_desc_list: void 0,\n    list_channel_users_uc_req: void 0,\n    channel_users_uc_list: void 0,\n    list_channel_detail_req: void 0,\n    channel_desc: void 0,\n    list_channel_req: void 0,\n    list_channel_message_req: void 0,\n    channel_message_list: void 0,\n    list_channel_users_req: void 0,\n    voice_user_list: void 0,\n    channel_user_list: void 0,\n    list_channel_attachment_req: void 0,\n    channel_attachment_list: void 0,\n    hashtag_dm_req: void 0,\n    hashtag_dm_list: void 0,\n    channel_setting_req: void 0,\n    channel_setting_list: void 0,\n    favorite_channel_req: void 0,\n    favorite_channel_list: void 0,\n    search_thread_req: void 0,\n    notification_channel: void 0,\n    notificaion_user_channel: void 0,\n    notification_category: void 0,\n    notification_clan: void 0,\n    notification_setting: void 0,\n    notification_message: void 0,\n    noti_channel_cat_setting_list: void 0,\n    list_notification_req: void 0,\n    notification_list: void 0,\n    sticker_list: void 0,\n    emoji_recent_list: void 0,\n    clan_webhook_req: void 0,\n    clan_webhook_list: void 0,\n    webhook_list_req: void 0,\n    webhook_list: void 0,\n    permission_list_req: void 0,\n    permission_list: void 0,\n    role_user_req: void 0,\n    role_user_list: void 0,\n    permission_user_req: void 0,\n    role_list: void 0,\n    role_list_event_req: void 0,\n    role_event_list: void 0,\n    user_permission_req: void 0,\n    user_permission_list: void 0,\n    permission_role_req: void 0,\n    permission_role_list: void 0,\n    emoji_list: void 0\n  };\n}\nvar ListDataSocket = {\n  encode(message, writer = import_minimal5.default.Writer.create()) {\n    if (message.api_name !== \"\") {\n      writer.uint32(10).string(message.api_name);\n    }\n    if (message.list_clan_req !== void 0) {\n      ListClanDescRequest.encode(message.list_clan_req, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.clan_desc_list !== void 0) {\n      ClanDescList.encode(message.clan_desc_list, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.list_thread_req !== void 0) {\n      ListThreadRequest.encode(message.list_thread_req, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.channel_desc_list !== void 0) {\n      ChannelDescList.encode(message.channel_desc_list, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.list_channel_users_uc_req !== void 0) {\n      AllUsersAddChannelRequest.encode(message.list_channel_users_uc_req, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.channel_users_uc_list !== void 0) {\n      AllUsersAddChannelResponse.encode(message.channel_users_uc_list, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.list_channel_detail_req !== void 0) {\n      ListChannelDetailRequest.encode(message.list_channel_detail_req, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.channel_desc !== void 0) {\n      ChannelDescription.encode(message.channel_desc, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.list_channel_req !== void 0) {\n      ListChannelDescsRequest.encode(message.list_channel_req, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.list_channel_message_req !== void 0) {\n      ListChannelMessagesRequest.encode(message.list_channel_message_req, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.channel_message_list !== void 0) {\n      ChannelMessageList.encode(message.channel_message_list, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.list_channel_users_req !== void 0) {\n      ListChannelUsersRequest.encode(message.list_channel_users_req, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.voice_user_list !== void 0) {\n      VoiceChannelUserList.encode(message.voice_user_list, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.channel_user_list !== void 0) {\n      ChannelUserList.encode(message.channel_user_list, writer.uint32(122).fork()).ldelim();\n    }\n    if (message.list_channel_attachment_req !== void 0) {\n      ListChannelAttachmentRequest.encode(message.list_channel_attachment_req, writer.uint32(130).fork()).ldelim();\n    }\n    if (message.channel_attachment_list !== void 0) {\n      ChannelAttachmentList.encode(message.channel_attachment_list, writer.uint32(138).fork()).ldelim();\n    }\n    if (message.hashtag_dm_req !== void 0) {\n      HashtagDmListRequest.encode(message.hashtag_dm_req, writer.uint32(146).fork()).ldelim();\n    }\n    if (message.hashtag_dm_list !== void 0) {\n      HashtagDmList.encode(message.hashtag_dm_list, writer.uint32(154).fork()).ldelim();\n    }\n    if (message.channel_setting_req !== void 0) {\n      ChannelSettingListRequest.encode(message.channel_setting_req, writer.uint32(162).fork()).ldelim();\n    }\n    if (message.channel_setting_list !== void 0) {\n      ChannelSettingListResponse.encode(message.channel_setting_list, writer.uint32(170).fork()).ldelim();\n    }\n    if (message.favorite_channel_req !== void 0) {\n      ListFavoriteChannelRequest.encode(message.favorite_channel_req, writer.uint32(178).fork()).ldelim();\n    }\n    if (message.favorite_channel_list !== void 0) {\n      ListFavoriteChannelResponse.encode(message.favorite_channel_list, writer.uint32(186).fork()).ldelim();\n    }\n    if (message.search_thread_req !== void 0) {\n      SearchThreadRequest.encode(message.search_thread_req, writer.uint32(194).fork()).ldelim();\n    }\n    if (message.notification_channel !== void 0) {\n      NotificationChannel.encode(message.notification_channel, writer.uint32(202).fork()).ldelim();\n    }\n    if (message.notificaion_user_channel !== void 0) {\n      NotificationUserChannel.encode(message.notificaion_user_channel, writer.uint32(210).fork()).ldelim();\n    }\n    if (message.notification_category !== void 0) {\n      DefaultNotificationCategory.encode(message.notification_category, writer.uint32(218).fork()).ldelim();\n    }\n    if (message.notification_clan !== void 0) {\n      NotificationClan.encode(message.notification_clan, writer.uint32(226).fork()).ldelim();\n    }\n    if (message.notification_setting !== void 0) {\n      NotificationSetting.encode(message.notification_setting, writer.uint32(234).fork()).ldelim();\n    }\n    if (message.notification_message !== void 0) {\n      NotifiReactMessage.encode(message.notification_message, writer.uint32(242).fork()).ldelim();\n    }\n    if (message.noti_channel_cat_setting_list !== void 0) {\n      NotificationChannelCategorySettingList.encode(message.noti_channel_cat_setting_list, writer.uint32(250).fork()).ldelim();\n    }\n    if (message.list_notification_req !== void 0) {\n      ListNotificationsRequest.encode(message.list_notification_req, writer.uint32(258).fork()).ldelim();\n    }\n    if (message.notification_list !== void 0) {\n      NotificationList.encode(message.notification_list, writer.uint32(266).fork()).ldelim();\n    }\n    if (message.sticker_list !== void 0) {\n      StickerListedResponse.encode(message.sticker_list, writer.uint32(274).fork()).ldelim();\n    }\n    if (message.emoji_recent_list !== void 0) {\n      EmojiRecentList.encode(message.emoji_recent_list, writer.uint32(282).fork()).ldelim();\n    }\n    if (message.clan_webhook_req !== void 0) {\n      ListClanWebhookRequest.encode(message.clan_webhook_req, writer.uint32(290).fork()).ldelim();\n    }\n    if (message.clan_webhook_list !== void 0) {\n      ListClanWebhookResponse.encode(message.clan_webhook_list, writer.uint32(298).fork()).ldelim();\n    }\n    if (message.webhook_list_req !== void 0) {\n      WebhookListRequest.encode(message.webhook_list_req, writer.uint32(306).fork()).ldelim();\n    }\n    if (message.webhook_list !== void 0) {\n      WebhookListResponse.encode(message.webhook_list, writer.uint32(314).fork()).ldelim();\n    }\n    if (message.permission_list_req !== void 0) {\n      ListPermissionsRequest.encode(message.permission_list_req, writer.uint32(322).fork()).ldelim();\n    }\n    if (message.permission_list !== void 0) {\n      PermissionList.encode(message.permission_list, writer.uint32(330).fork()).ldelim();\n    }\n    if (message.role_user_req !== void 0) {\n      ListRoleUsersRequest.encode(message.role_user_req, writer.uint32(338).fork()).ldelim();\n    }\n    if (message.role_user_list !== void 0) {\n      RoleUserList.encode(message.role_user_list, writer.uint32(346).fork()).ldelim();\n    }\n    if (message.permission_user_req !== void 0) {\n      ListPermissionOfUsersRequest.encode(message.permission_user_req, writer.uint32(354).fork()).ldelim();\n    }\n    if (message.role_list !== void 0) {\n      RoleList.encode(message.role_list, writer.uint32(362).fork()).ldelim();\n    }\n    if (message.role_list_event_req !== void 0) {\n      RoleListEventRequest.encode(message.role_list_event_req, writer.uint32(370).fork()).ldelim();\n    }\n    if (message.role_event_list !== void 0) {\n      RoleListEventResponse.encode(message.role_event_list, writer.uint32(378).fork()).ldelim();\n    }\n    if (message.user_permission_req !== void 0) {\n      UserPermissionInChannelListRequest.encode(message.user_permission_req, writer.uint32(386).fork()).ldelim();\n    }\n    if (message.user_permission_list !== void 0) {\n      UserPermissionInChannelListResponse.encode(message.user_permission_list, writer.uint32(394).fork()).ldelim();\n    }\n    if (message.permission_role_req !== void 0) {\n      PermissionRoleChannelListEventRequest.encode(message.permission_role_req, writer.uint32(402).fork()).ldelim();\n    }\n    if (message.permission_role_list !== void 0) {\n      PermissionRoleChannelListEventResponse.encode(message.permission_role_list, writer.uint32(410).fork()).ldelim();\n    }\n    if (message.emoji_list !== void 0) {\n      EmojiListedResponse.encode(message.emoji_list, writer.uint32(418).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_minimal5.default.Reader ? input : import_minimal5.default.Reader.create(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseListDataSocket();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if (tag !== 10) {\n            break;\n          }\n          message.api_name = reader.string();\n          continue;\n        case 2:\n          if (tag !== 18) {\n            break;\n          }\n          message.list_clan_req = ListClanDescRequest.decode(reader, reader.uint32());\n          continue;\n        case 3:\n          if (tag !== 26) {\n            break;\n          }\n          message.clan_desc_list = ClanDescList.decode(reader, reader.uint32());\n          continue;\n        case 4:\n          if (tag !== 34) {\n            break;\n          }\n          message.list_thread_req = ListThreadRequest.decode(reader, reader.uint32());\n          continue;\n        case 5:\n          if (tag !== 42) {\n            break;\n          }\n          message.channel_desc_list = ChannelDescList.decode(reader, reader.uint32());\n          continue;\n        case 6:\n          if (tag !== 50) {\n            break;\n          }\n          message.list_channel_users_uc_req = AllUsersAddChannelRequest.decode(reader, reader.uint32());\n          continue;\n        case 7:\n          if (tag !== 58) {\n            break;\n          }\n          message.channel_users_uc_list = AllUsersAddChannelResponse.decode(reader, reader.uint32());\n          continue;\n        case 8:\n          if (tag !== 66) {\n            break;\n          }\n          message.list_channel_detail_req = ListChannelDetailRequest.decode(reader, reader.uint32());\n          continue;\n        case 9:\n          if (tag !== 74) {\n            break;\n          }\n          message.channel_desc = ChannelDescription.decode(reader, reader.uint32());\n          continue;\n        case 10:\n          if (tag !== 82) {\n            break;\n          }\n          message.list_channel_req = ListChannelDescsRequest.decode(reader, reader.uint32());\n          continue;\n        case 11:\n          if (tag !== 90) {\n            break;\n          }\n          message.list_channel_message_req = ListChannelMessagesRequest.decode(reader, reader.uint32());\n          continue;\n        case 12:\n          if (tag !== 98) {\n            break;\n          }\n          message.channel_message_list = ChannelMessageList.decode(reader, reader.uint32());\n          continue;\n        case 13:\n          if (tag !== 106) {\n            break;\n          }\n          message.list_channel_users_req = ListChannelUsersRequest.decode(reader, reader.uint32());\n          continue;\n        case 14:\n          if (tag !== 114) {\n            break;\n          }\n          message.voice_user_list = VoiceChannelUserList.decode(reader, reader.uint32());\n          continue;\n        case 15:\n          if (tag !== 122) {\n            break;\n          }\n          message.channel_user_list = ChannelUserList.decode(reader, reader.uint32());\n          continue;\n        case 16:\n          if (tag !== 130) {\n            break;\n          }\n          message.list_channel_attachment_req = ListChannelAttachmentRequest.decode(reader, reader.uint32());\n          continue;\n        case 17:\n          if (tag !== 138) {\n            break;\n          }\n          message.channel_attachment_list = ChannelAttachmentList.decode(reader, reader.uint32());\n          continue;\n        case 18:\n          if (tag !== 146) {\n            break;\n          }\n          message.hashtag_dm_req = HashtagDmListRequest.decode(reader, reader.uint32());\n          continue;\n        case 19:\n          if (tag !== 154) {\n            break;\n          }\n          message.hashtag_dm_list = HashtagDmList.decode(reader, reader.uint32());\n          continue;\n        case 20:\n          if (tag !== 162) {\n            break;\n          }\n          message.channel_setting_req = ChannelSettingListRequest.decode(reader, reader.uint32());\n          continue;\n        case 21:\n          if (tag !== 170) {\n            break;\n          }\n          message.channel_setting_list = ChannelSettingListResponse.decode(reader, reader.uint32());\n          continue;\n        case 22:\n          if (tag !== 178) {\n            break;\n          }\n          message.favorite_channel_req = ListFavoriteChannelRequest.decode(reader, reader.uint32());\n          continue;\n        case 23:\n          if (tag !== 186) {\n            break;\n          }\n          message.favorite_channel_list = ListFavoriteChannelResponse.decode(reader, reader.uint32());\n          continue;\n        case 24:\n          if (tag !== 194) {\n            break;\n          }\n          message.search_thread_req = SearchThreadRequest.decode(reader, reader.uint32());\n          continue;\n        case 25:\n          if (tag !== 202) {\n            break;\n          }\n          message.notification_channel = NotificationChannel.decode(reader, reader.uint32());\n          continue;\n        case 26:\n          if (tag !== 210) {\n            break;\n          }\n          message.notificaion_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\n          continue;\n        case 27:\n          if (tag !== 218) {\n            break;\n          }\n          message.notification_category = DefaultNotificationCategory.decode(reader, reader.uint32());\n          continue;\n        case 28:\n          if (tag !== 226) {\n            break;\n          }\n          message.notification_clan = NotificationClan.decode(reader, reader.uint32());\n          continue;\n        case 29:\n          if (tag !== 234) {\n            break;\n          }\n          message.notification_setting = NotificationSetting.decode(reader, reader.uint32());\n          continue;\n        case 30:\n          if (tag !== 242) {\n            break;\n          }\n          message.notification_message = NotifiReactMessage.decode(reader, reader.uint32());\n          continue;\n        case 31:\n          if (tag !== 250) {\n            break;\n          }\n          message.noti_channel_cat_setting_list = NotificationChannelCategorySettingList.decode(\n            reader,\n            reader.uint32()\n          );\n          continue;\n        case 32:\n          if (tag !== 258) {\n            break;\n          }\n          message.list_notification_req = ListNotificationsRequest.decode(reader, reader.uint32());\n          continue;\n        case 33:\n          if (tag !== 266) {\n            break;\n          }\n          message.notification_list = NotificationList.decode(reader, reader.uint32());\n          continue;\n        case 34:\n          if (tag !== 274) {\n            break;\n          }\n          message.sticker_list = StickerListedResponse.decode(reader, reader.uint32());\n          continue;\n        case 35:\n          if (tag !== 282) {\n            break;\n          }\n          message.emoji_recent_list = EmojiRecentList.decode(reader, reader.uint32());\n          continue;\n        case 36:\n          if (tag !== 290) {\n            break;\n          }\n          message.clan_webhook_req = ListClanWebhookRequest.decode(reader, reader.uint32());\n          continue;\n        case 37:\n          if (tag !== 298) {\n            break;\n          }\n          message.clan_webhook_list = ListClanWebhookResponse.decode(reader, reader.uint32());\n          continue;\n        case 38:\n          if (tag !== 306) {\n            break;\n          }\n          message.webhook_list_req = WebhookListRequest.decode(reader, reader.uint32());\n          continue;\n        case 39:\n          if (tag !== 314) {\n            break;\n          }\n          message.webhook_list = WebhookListResponse.decode(reader, reader.uint32());\n          continue;\n        case 40:\n          if (tag !== 322) {\n            break;\n          }\n          message.permission_list_req = ListPermissionsRequest.decode(reader, reader.uint32());\n          continue;\n        case 41:\n          if (tag !== 330) {\n            break;\n          }\n          message.permission_list = PermissionList.decode(reader, reader.uint32());\n          continue;\n        case 42:\n          if (tag !== 338) {\n            break;\n          }\n          message.role_user_req = ListRoleUsersRequest.decode(reader, reader.uint32());\n          continue;\n        case 43:\n          if (tag !== 346) {\n            break;\n          }\n          message.role_user_list = RoleUserList.decode(reader, reader.uint32());\n          continue;\n        case 44:\n          if (tag !== 354) {\n            break;\n          }\n          message.permission_user_req = ListPermissionOfUsersRequest.decode(reader, reader.uint32());\n          continue;\n        case 45:\n          if (tag !== 362) {\n            break;\n          }\n          message.role_list = RoleList.decode(reader, reader.uint32());\n          continue;\n        case 46:\n          if (tag !== 370) {\n            break;\n          }\n          message.role_list_event_req = RoleListEventRequest.decode(reader, reader.uint32());\n          continue;\n        case 47:\n          if (tag !== 378) {\n            break;\n          }\n          message.role_event_list = RoleListEventResponse.decode(reader, reader.uint32());\n          continue;\n        case 48:\n          if (tag !== 386) {\n            break;\n          }\n          message.user_permission_req = UserPermissionInChannelListRequest.decode(reader, reader.uint32());\n          continue;\n        case 49:\n          if (tag !== 394) {\n            break;\n          }\n          message.user_permission_list = UserPermissionInChannelListResponse.decode(reader, reader.uint32());\n          continue;\n        case 50:\n          if (tag !== 402) {\n            break;\n          }\n          message.permission_role_req = PermissionRoleChannelListEventRequest.decode(reader, reader.uint32());\n          continue;\n        case 51:\n          if (tag !== 410) {\n            break;\n          }\n          message.permission_role_list = PermissionRoleChannelListEventResponse.decode(reader, reader.uint32());\n          continue;\n        case 52:\n          if (tag !== 418) {\n            break;\n          }\n          message.emoji_list = EmojiListedResponse.decode(reader, reader.uint32());\n          continue;\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skipType(tag & 7);\n    }\n    return message;\n  },\n  fromJSON(object) {\n    return {\n      api_name: isSet4(object.api_name) ? globalThis.String(object.api_name) : \"\",\n      list_clan_req: isSet4(object.list_clan_req) ? ListClanDescRequest.fromJSON(object.list_clan_req) : void 0,\n      clan_desc_list: isSet4(object.clan_desc_list) ? ClanDescList.fromJSON(object.clan_desc_list) : void 0,\n      list_thread_req: isSet4(object.list_thread_req) ? ListThreadRequest.fromJSON(object.list_thread_req) : void 0,\n      channel_desc_list: isSet4(object.channel_desc_list) ? ChannelDescList.fromJSON(object.channel_desc_list) : void 0,\n      list_channel_users_uc_req: isSet4(object.list_channel_users_uc_req) ? AllUsersAddChannelRequest.fromJSON(object.list_channel_users_uc_req) : void 0,\n      channel_users_uc_list: isSet4(object.channel_users_uc_list) ? AllUsersAddChannelResponse.fromJSON(object.channel_users_uc_list) : void 0,\n      list_channel_detail_req: isSet4(object.list_channel_detail_req) ? ListChannelDetailRequest.fromJSON(object.list_channel_detail_req) : void 0,\n      channel_desc: isSet4(object.channel_desc) ? ChannelDescription.fromJSON(object.channel_desc) : void 0,\n      list_channel_req: isSet4(object.list_channel_req) ? ListChannelDescsRequest.fromJSON(object.list_channel_req) : void 0,\n      list_channel_message_req: isSet4(object.list_channel_message_req) ? ListChannelMessagesRequest.fromJSON(object.list_channel_message_req) : void 0,\n      channel_message_list: isSet4(object.channel_message_list) ? ChannelMessageList.fromJSON(object.channel_message_list) : void 0,\n      list_channel_users_req: isSet4(object.list_channel_users_req) ? ListChannelUsersRequest.fromJSON(object.list_channel_users_req) : void 0,\n      voice_user_list: isSet4(object.voice_user_list) ? VoiceChannelUserList.fromJSON(object.voice_user_list) : void 0,\n      channel_user_list: isSet4(object.channel_user_list) ? ChannelUserList.fromJSON(object.channel_user_list) : void 0,\n      list_channel_attachment_req: isSet4(object.list_channel_attachment_req) ? ListChannelAttachmentRequest.fromJSON(object.list_channel_attachment_req) : void 0,\n      channel_attachment_list: isSet4(object.channel_attachment_list) ? ChannelAttachmentList.fromJSON(object.channel_attachment_list) : void 0,\n      hashtag_dm_req: isSet4(object.hashtag_dm_req) ? HashtagDmListRequest.fromJSON(object.hashtag_dm_req) : void 0,\n      hashtag_dm_list: isSet4(object.hashtag_dm_list) ? HashtagDmList.fromJSON(object.hashtag_dm_list) : void 0,\n      channel_setting_req: isSet4(object.channel_setting_req) ? ChannelSettingListRequest.fromJSON(object.channel_setting_req) : void 0,\n      channel_setting_list: isSet4(object.channel_setting_list) ? ChannelSettingListResponse.fromJSON(object.channel_setting_list) : void 0,\n      favorite_channel_req: isSet4(object.favorite_channel_req) ? ListFavoriteChannelRequest.fromJSON(object.favorite_channel_req) : void 0,\n      favorite_channel_list: isSet4(object.favorite_channel_list) ? ListFavoriteChannelResponse.fromJSON(object.favorite_channel_list) : void 0,\n      search_thread_req: isSet4(object.search_thread_req) ? SearchThreadRequest.fromJSON(object.search_thread_req) : void 0,\n      notification_channel: isSet4(object.notification_channel) ? NotificationChannel.fromJSON(object.notification_channel) : void 0,\n      notificaion_user_channel: isSet4(object.notificaion_user_channel) ? NotificationUserChannel.fromJSON(object.notificaion_user_channel) : void 0,\n      notification_category: isSet4(object.notification_category) ? DefaultNotificationCategory.fromJSON(object.notification_category) : void 0,\n      notification_clan: isSet4(object.notification_clan) ? NotificationClan.fromJSON(object.notification_clan) : void 0,\n      notification_setting: isSet4(object.notification_setting) ? NotificationSetting.fromJSON(object.notification_setting) : void 0,\n      notification_message: isSet4(object.notification_message) ? NotifiReactMessage.fromJSON(object.notification_message) : void 0,\n      noti_channel_cat_setting_list: isSet4(object.noti_channel_cat_setting_list) ? NotificationChannelCategorySettingList.fromJSON(object.noti_channel_cat_setting_list) : void 0,\n      list_notification_req: isSet4(object.list_notification_req) ? ListNotificationsRequest.fromJSON(object.list_notification_req) : void 0,\n      notification_list: isSet4(object.notification_list) ? NotificationList.fromJSON(object.notification_list) : void 0,\n      sticker_list: isSet4(object.sticker_list) ? StickerListedResponse.fromJSON(object.sticker_list) : void 0,\n      emoji_recent_list: isSet4(object.emoji_recent_list) ? EmojiRecentList.fromJSON(object.emoji_recent_list) : void 0,\n      clan_webhook_req: isSet4(object.clan_webhook_req) ? ListClanWebhookRequest.fromJSON(object.clan_webhook_req) : void 0,\n      clan_webhook_list: isSet4(object.clan_webhook_list) ? ListClanWebhookResponse.fromJSON(object.clan_webhook_list) : void 0,\n      webhook_list_req: isSet4(object.webhook_list_req) ? WebhookListRequest.fromJSON(object.webhook_list_req) : void 0,\n      webhook_list: isSet4(object.webhook_list) ? WebhookListResponse.fromJSON(object.webhook_list) : void 0,\n      permission_list_req: isSet4(object.permission_list_req) ? ListPermissionsRequest.fromJSON(object.permission_list_req) : void 0,\n      permission_list: isSet4(object.permission_list) ? PermissionList.fromJSON(object.permission_list) : void 0,\n      role_user_req: isSet4(object.role_user_req) ? ListRoleUsersRequest.fromJSON(object.role_user_req) : void 0,\n      role_user_list: isSet4(object.role_user_list) ? RoleUserList.fromJSON(object.role_user_list) : void 0,\n      permission_user_req: isSet4(object.permission_user_req) ? ListPermissionOfUsersRequest.fromJSON(object.permission_user_req) : void 0,\n      role_list: isSet4(object.role_list) ? RoleList.fromJSON(object.role_list) : void 0,\n      role_list_event_req: isSet4(object.role_list_event_req) ? RoleListEventRequest.fromJSON(object.role_list_event_req) : void 0,\n      role_event_list: isSet4(object.role_event_list) ? RoleListEventResponse.fromJSON(object.role_event_list) : void 0,\n      user_permission_req: isSet4(object.user_permission_req) ? UserPermissionInChannelListRequest.fromJSON(object.user_permission_req) : void 0,\n      user_permission_list: isSet4(object.user_permission_list) ? UserPermissionInChannelListResponse.fromJSON(object.user_permission_list) : void 0,\n      permission_role_req: isSet4(object.permission_role_req) ? PermissionRoleChannelListEventRequest.fromJSON(object.permission_role_req) : void 0,\n      permission_role_list: isSet4(object.permission_role_list) ? PermissionRoleChannelListEventResponse.fromJSON(object.permission_role_list) : void 0,\n      emoji_list: isSet4(object.emoji_list) ? EmojiListedResponse.fromJSON(object.emoji_list) : void 0\n    };\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.api_name !== \"\") {\n      obj.api_name = message.api_name;\n    }\n    if (message.list_clan_req !== void 0) {\n      obj.list_clan_req = ListClanDescRequest.toJSON(message.list_clan_req);\n    }\n    if (message.clan_desc_list !== void 0) {\n      obj.clan_desc_list = ClanDescList.toJSON(message.clan_desc_list);\n    }\n    if (message.list_thread_req !== void 0) {\n      obj.list_thread_req = ListThreadRequest.toJSON(message.list_thread_req);\n    }\n    if (message.channel_desc_list !== void 0) {\n      obj.channel_desc_list = ChannelDescList.toJSON(message.channel_desc_list);\n    }\n    if (message.list_channel_users_uc_req !== void 0) {\n      obj.list_channel_users_uc_req = AllUsersAddChannelRequest.toJSON(message.list_channel_users_uc_req);\n    }\n    if (message.channel_users_uc_list !== void 0) {\n      obj.channel_users_uc_list = AllUsersAddChannelResponse.toJSON(message.channel_users_uc_list);\n    }\n    if (message.list_channel_detail_req !== void 0) {\n      obj.list_channel_detail_req = ListChannelDetailRequest.toJSON(message.list_channel_detail_req);\n    }\n    if (message.channel_desc !== void 0) {\n      obj.channel_desc = ChannelDescription.toJSON(message.channel_desc);\n    }\n    if (message.list_channel_req !== void 0) {\n      obj.list_channel_req = ListChannelDescsRequest.toJSON(message.list_channel_req);\n    }\n    if (message.list_channel_message_req !== void 0) {\n      obj.list_channel_message_req = ListChannelMessagesRequest.toJSON(message.list_channel_message_req);\n    }\n    if (message.channel_message_list !== void 0) {\n      obj.channel_message_list = ChannelMessageList.toJSON(message.channel_message_list);\n    }\n    if (message.list_channel_users_req !== void 0) {\n      obj.list_channel_users_req = ListChannelUsersRequest.toJSON(message.list_channel_users_req);\n    }\n    if (message.voice_user_list !== void 0) {\n      obj.voice_user_list = VoiceChannelUserList.toJSON(message.voice_user_list);\n    }\n    if (message.channel_user_list !== void 0) {\n      obj.channel_user_list = ChannelUserList.toJSON(message.channel_user_list);\n    }\n    if (message.list_channel_attachment_req !== void 0) {\n      obj.list_channel_attachment_req = ListChannelAttachmentRequest.toJSON(message.list_channel_attachment_req);\n    }\n    if (message.channel_attachment_list !== void 0) {\n      obj.channel_attachment_list = ChannelAttachmentList.toJSON(message.channel_attachment_list);\n    }\n    if (message.hashtag_dm_req !== void 0) {\n      obj.hashtag_dm_req = HashtagDmListRequest.toJSON(message.hashtag_dm_req);\n    }\n    if (message.hashtag_dm_list !== void 0) {\n      obj.hashtag_dm_list = HashtagDmList.toJSON(message.hashtag_dm_list);\n    }\n    if (message.channel_setting_req !== void 0) {\n      obj.channel_setting_req = ChannelSettingListRequest.toJSON(message.channel_setting_req);\n    }\n    if (message.channel_setting_list !== void 0) {\n      obj.channel_setting_list = ChannelSettingListResponse.toJSON(message.channel_setting_list);\n    }\n    if (message.favorite_channel_req !== void 0) {\n      obj.favorite_channel_req = ListFavoriteChannelRequest.toJSON(message.favorite_channel_req);\n    }\n    if (message.favorite_channel_list !== void 0) {\n      obj.favorite_channel_list = ListFavoriteChannelResponse.toJSON(message.favorite_channel_list);\n    }\n    if (message.search_thread_req !== void 0) {\n      obj.search_thread_req = SearchThreadRequest.toJSON(message.search_thread_req);\n    }\n    if (message.notification_channel !== void 0) {\n      obj.notification_channel = NotificationChannel.toJSON(message.notification_channel);\n    }\n    if (message.notificaion_user_channel !== void 0) {\n      obj.notificaion_user_channel = NotificationUserChannel.toJSON(message.notificaion_user_channel);\n    }\n    if (message.notification_category !== void 0) {\n      obj.notification_category = DefaultNotificationCategory.toJSON(message.notification_category);\n    }\n    if (message.notification_clan !== void 0) {\n      obj.notification_clan = NotificationClan.toJSON(message.notification_clan);\n    }\n    if (message.notification_setting !== void 0) {\n      obj.notification_setting = NotificationSetting.toJSON(message.notification_setting);\n    }\n    if (message.notification_message !== void 0) {\n      obj.notification_message = NotifiReactMessage.toJSON(message.notification_message);\n    }\n    if (message.noti_channel_cat_setting_list !== void 0) {\n      obj.noti_channel_cat_setting_list = NotificationChannelCategorySettingList.toJSON(\n        message.noti_channel_cat_setting_list\n      );\n    }\n    if (message.list_notification_req !== void 0) {\n      obj.list_notification_req = ListNotificationsRequest.toJSON(message.list_notification_req);\n    }\n    if (message.notification_list !== void 0) {\n      obj.notification_list = NotificationList.toJSON(message.notification_list);\n    }\n    if (message.sticker_list !== void 0) {\n      obj.sticker_list = StickerListedResponse.toJSON(message.sticker_list);\n    }\n    if (message.emoji_recent_list !== void 0) {\n      obj.emoji_recent_list = EmojiRecentList.toJSON(message.emoji_recent_list);\n    }\n    if (message.clan_webhook_req !== void 0) {\n      obj.clan_webhook_req = ListClanWebhookRequest.toJSON(message.clan_webhook_req);\n    }\n    if (message.clan_webhook_list !== void 0) {\n      obj.clan_webhook_list = ListClanWebhookResponse.toJSON(message.clan_webhook_list);\n    }\n    if (message.webhook_list_req !== void 0) {\n      obj.webhook_list_req = WebhookListRequest.toJSON(message.webhook_list_req);\n    }\n    if (message.webhook_list !== void 0) {\n      obj.webhook_list = WebhookListResponse.toJSON(message.webhook_list);\n    }\n    if (message.permission_list_req !== void 0) {\n      obj.permission_list_req = ListPermissionsRequest.toJSON(message.permission_list_req);\n    }\n    if (message.permission_list !== void 0) {\n      obj.permission_list = PermissionList.toJSON(message.permission_list);\n    }\n    if (message.role_user_req !== void 0) {\n      obj.role_user_req = ListRoleUsersRequest.toJSON(message.role_user_req);\n    }\n    if (message.role_user_list !== void 0) {\n      obj.role_user_list = RoleUserList.toJSON(message.role_user_list);\n    }\n    if (message.permission_user_req !== void 0) {\n      obj.permission_user_req = ListPermissionOfUsersRequest.toJSON(message.permission_user_req);\n    }\n    if (message.role_list !== void 0) {\n      obj.role_list = RoleList.toJSON(message.role_list);\n    }\n    if (message.role_list_event_req !== void 0) {\n      obj.role_list_event_req = RoleListEventRequest.toJSON(message.role_list_event_req);\n    }\n    if (message.role_event_list !== void 0) {\n      obj.role_event_list = RoleListEventResponse.toJSON(message.role_event_list);\n    }\n    if (message.user_permission_req !== void 0) {\n      obj.user_permission_req = UserPermissionInChannelListRequest.toJSON(message.user_permission_req);\n    }\n    if (message.user_permission_list !== void 0) {\n      obj.user_permission_list = UserPermissionInChannelListResponse.toJSON(message.user_permission_list);\n    }\n    if (message.permission_role_req !== void 0) {\n      obj.permission_role_req = PermissionRoleChannelListEventRequest.toJSON(message.permission_role_req);\n    }\n    if (message.permission_role_list !== void 0) {\n      obj.permission_role_list = PermissionRoleChannelListEventResponse.toJSON(message.permission_role_list);\n    }\n    if (message.emoji_list !== void 0) {\n      obj.emoji_list = EmojiListedResponse.toJSON(message.emoji_list);\n    }\n    return obj;\n  },\n  create(base) {\n    return ListDataSocket.fromPartial(base != null ? base : {});\n  },\n  fromPartial(object) {\n    var _a;\n    const message = createBaseListDataSocket();\n    message.api_name = (_a = object.api_name) != null ? _a : \"\";\n    message.list_clan_req = object.list_clan_req !== void 0 && object.list_clan_req !== null ? ListClanDescRequest.fromPartial(object.list_clan_req) : void 0;\n    message.clan_desc_list = object.clan_desc_list !== void 0 && object.clan_desc_list !== null ? ClanDescList.fromPartial(object.clan_desc_list) : void 0;\n    message.list_thread_req = object.list_thread_req !== void 0 && object.list_thread_req !== null ? ListThreadRequest.fromPartial(object.list_thread_req) : void 0;\n    message.channel_desc_list = object.channel_desc_list !== void 0 && object.channel_desc_list !== null ? ChannelDescList.fromPartial(object.channel_desc_list) : void 0;\n    message.list_channel_users_uc_req = object.list_channel_users_uc_req !== void 0 && object.list_channel_users_uc_req !== null ? AllUsersAddChannelRequest.fromPartial(object.list_channel_users_uc_req) : void 0;\n    message.channel_users_uc_list = object.channel_users_uc_list !== void 0 && object.channel_users_uc_list !== null ? AllUsersAddChannelResponse.fromPartial(object.channel_users_uc_list) : void 0;\n    message.list_channel_detail_req = object.list_channel_detail_req !== void 0 && object.list_channel_detail_req !== null ? ListChannelDetailRequest.fromPartial(object.list_channel_detail_req) : void 0;\n    message.channel_desc = object.channel_desc !== void 0 && object.channel_desc !== null ? ChannelDescription.fromPartial(object.channel_desc) : void 0;\n    message.list_channel_req = object.list_channel_req !== void 0 && object.list_channel_req !== null ? ListChannelDescsRequest.fromPartial(object.list_channel_req) : void 0;\n    message.list_channel_message_req = object.list_channel_message_req !== void 0 && object.list_channel_message_req !== null ? ListChannelMessagesRequest.fromPartial(object.list_channel_message_req) : void 0;\n    message.channel_message_list = object.channel_message_list !== void 0 && object.channel_message_list !== null ? ChannelMessageList.fromPartial(object.channel_message_list) : void 0;\n    message.list_channel_users_req = object.list_channel_users_req !== void 0 && object.list_channel_users_req !== null ? ListChannelUsersRequest.fromPartial(object.list_channel_users_req) : void 0;\n    message.voice_user_list = object.voice_user_list !== void 0 && object.voice_user_list !== null ? VoiceChannelUserList.fromPartial(object.voice_user_list) : void 0;\n    message.channel_user_list = object.channel_user_list !== void 0 && object.channel_user_list !== null ? ChannelUserList.fromPartial(object.channel_user_list) : void 0;\n    message.list_channel_attachment_req = object.list_channel_attachment_req !== void 0 && object.list_channel_attachment_req !== null ? ListChannelAttachmentRequest.fromPartial(object.list_channel_attachment_req) : void 0;\n    message.channel_attachment_list = object.channel_attachment_list !== void 0 && object.channel_attachment_list !== null ? ChannelAttachmentList.fromPartial(object.channel_attachment_list) : void 0;\n    message.hashtag_dm_req = object.hashtag_dm_req !== void 0 && object.hashtag_dm_req !== null ? HashtagDmListRequest.fromPartial(object.hashtag_dm_req) : void 0;\n    message.hashtag_dm_list = object.hashtag_dm_list !== void 0 && object.hashtag_dm_list !== null ? HashtagDmList.fromPartial(object.hashtag_dm_list) : void 0;\n    message.channel_setting_req = object.channel_setting_req !== void 0 && object.channel_setting_req !== null ? ChannelSettingListRequest.fromPartial(object.channel_setting_req) : void 0;\n    message.channel_setting_list = object.channel_setting_list !== void 0 && object.channel_setting_list !== null ? ChannelSettingListResponse.fromPartial(object.channel_setting_list) : void 0;\n    message.favorite_channel_req = object.favorite_channel_req !== void 0 && object.favorite_channel_req !== null ? ListFavoriteChannelRequest.fromPartial(object.favorite_channel_req) : void 0;\n    message.favorite_channel_list = object.favorite_channel_list !== void 0 && object.favorite_channel_list !== null ? ListFavoriteChannelResponse.fromPartial(object.favorite_channel_list) : void 0;\n    message.search_thread_req = object.search_thread_req !== void 0 && object.search_thread_req !== null ? SearchThreadRequest.fromPartial(object.search_thread_req) : void 0;\n    message.notification_channel = object.notification_channel !== void 0 && object.notification_channel !== null ? NotificationChannel.fromPartial(object.notification_channel) : void 0;\n    message.notificaion_user_channel = object.notificaion_user_channel !== void 0 && object.notificaion_user_channel !== null ? NotificationUserChannel.fromPartial(object.notificaion_user_channel) : void 0;\n    message.notification_category = object.notification_category !== void 0 && object.notification_category !== null ? DefaultNotificationCategory.fromPartial(object.notification_category) : void 0;\n    message.notification_clan = object.notification_clan !== void 0 && object.notification_clan !== null ? NotificationClan.fromPartial(object.notification_clan) : void 0;\n    message.notification_setting = object.notification_setting !== void 0 && object.notification_setting !== null ? NotificationSetting.fromPartial(object.notification_setting) : void 0;\n    message.notification_message = object.notification_message !== void 0 && object.notification_message !== null ? NotifiReactMessage.fromPartial(object.notification_message) : void 0;\n    message.noti_channel_cat_setting_list = object.noti_channel_cat_setting_list !== void 0 && object.noti_channel_cat_setting_list !== null ? NotificationChannelCategorySettingList.fromPartial(object.noti_channel_cat_setting_list) : void 0;\n    message.list_notification_req = object.list_notification_req !== void 0 && object.list_notification_req !== null ? ListNotificationsRequest.fromPartial(object.list_notification_req) : void 0;\n    message.notification_list = object.notification_list !== void 0 && object.notification_list !== null ? NotificationList.fromPartial(object.notification_list) : void 0;\n    message.sticker_list = object.sticker_list !== void 0 && object.sticker_list !== null ? StickerListedResponse.fromPartial(object.sticker_list) : void 0;\n    message.emoji_recent_list = object.emoji_recent_list !== void 0 && object.emoji_recent_list !== null ? EmojiRecentList.fromPartial(object.emoji_recent_list) : void 0;\n    message.clan_webhook_req = object.clan_webhook_req !== void 0 && object.clan_webhook_req !== null ? ListClanWebhookRequest.fromPartial(object.clan_webhook_req) : void 0;\n    message.clan_webhook_list = object.clan_webhook_list !== void 0 && object.clan_webhook_list !== null ? ListClanWebhookResponse.fromPartial(object.clan_webhook_list) : void 0;\n    message.webhook_list_req = object.webhook_list_req !== void 0 && object.webhook_list_req !== null ? WebhookListRequest.fromPartial(object.webhook_list_req) : void 0;\n    message.webhook_list = object.webhook_list !== void 0 && object.webhook_list !== null ? WebhookListResponse.fromPartial(object.webhook_list) : void 0;\n    message.permission_list_req = object.permission_list_req !== void 0 && object.permission_list_req !== null ? ListPermissionsRequest.fromPartial(object.permission_list_req) : void 0;\n    message.permission_list = object.permission_list !== void 0 && object.permission_list !== null ? PermissionList.fromPartial(object.permission_list) : void 0;\n    message.role_user_req = object.role_user_req !== void 0 && object.role_user_req !== null ? ListRoleUsersRequest.fromPartial(object.role_user_req) : void 0;\n    message.role_user_list = object.role_user_list !== void 0 && object.role_user_list !== null ? RoleUserList.fromPartial(object.role_user_list) : void 0;\n    message.permission_user_req = object.permission_user_req !== void 0 && object.permission_user_req !== null ? ListPermissionOfUsersRequest.fromPartial(object.permission_user_req) : void 0;\n    message.role_list = object.role_list !== void 0 && object.role_list !== null ? RoleList.fromPartial(object.role_list) : void 0;\n    message.role_list_event_req = object.role_list_event_req !== void 0 && object.role_list_event_req !== null ? RoleListEventRequest.fromPartial(object.role_list_event_req) : void 0;\n    message.role_event_list = object.role_event_list !== void 0 && object.role_event_list !== null ? RoleListEventResponse.fromPartial(object.role_event_list) : void 0;\n    message.user_permission_req = object.user_permission_req !== void 0 && object.user_permission_req !== null ? UserPermissionInChannelListRequest.fromPartial(object.user_permission_req) : void 0;\n    message.user_permission_list = object.user_permission_list !== void 0 && object.user_permission_list !== null ? UserPermissionInChannelListResponse.fromPartial(object.user_permission_list) : void 0;\n    message.permission_role_req = object.permission_role_req !== void 0 && object.permission_role_req !== null ? PermissionRoleChannelListEventRequest.fromPartial(object.permission_role_req) : void 0;\n    message.permission_role_list = object.permission_role_list !== void 0 && object.permission_role_list !== null ? PermissionRoleChannelListEventResponse.fromPartial(object.permission_role_list) : void 0;\n    message.emoji_list = object.emoji_list !== void 0 && object.emoji_list !== null ? EmojiListedResponse.fromPartial(object.emoji_list) : void 0;\n    return message;\n  }\n};\nfunction toTimestamp2(date) {\n  const seconds = Math.trunc(date.getTime() / 1e3);\n  const nanos = date.getTime() % 1e3 * 1e6;\n  return { seconds, nanos };\n}\nfunction fromTimestamp2(t) {\n  let millis = (t.seconds || 0) * 1e3;\n  millis += (t.nanos || 0) / 1e6;\n  return new globalThis.Date(millis);\n}\nfunction fromJsonTimestamp2(o) {\n  if (o instanceof globalThis.Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new globalThis.Date(o);\n  } else {\n    return fromTimestamp2(Timestamp.fromJSON(o));\n  }\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction isSet4(value) {\n  return value !== null && value !== void 0;\n}\n\n// web_socket_adapter_pb.ts\nvar WebSocketAdapterPb = class {\n  constructor() {\n  }\n  get onClose() {\n    return this._socket.onclose;\n  }\n  set onClose(value) {\n    this._socket.onclose = value;\n  }\n  get onError() {\n    return this._socket.onerror;\n  }\n  set onError(value) {\n    this._socket.onerror = value;\n  }\n  get onMessage() {\n    return this._socket.onmessage;\n  }\n  set onMessage(value) {\n    if (value) {\n      this._socket.onmessage = (evt) => {\n        const buffer = evt.data;\n        const uintBuffer = new Uint8Array(buffer);\n        const envelope = Envelope.decode(uintBuffer);\n        if (envelope.channel_message) {\n          if (envelope.channel_message.code == void 0) {\n            envelope.channel_message.code = 0;\n          }\n        }\n        value(envelope);\n      };\n    } else {\n      value = null;\n    }\n  }\n  get onOpen() {\n    return this._socket.onopen;\n  }\n  set onOpen(value) {\n    this._socket.onopen = value;\n  }\n  isOpen() {\n    var _a;\n    return ((_a = this._socket) == null ? void 0 : _a.readyState) == WebSocket.OPEN;\n  }\n  close() {\n    var _a;\n    (_a = this._socket) == null ? void 0 : _a.close();\n    this._socket = void 0;\n  }\n  connect(scheme, host, port, createStatus, token, platform, signal) {\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        this.close();\n      });\n    }\n    const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(\n      createStatus.toString()\n    )}&token=${encodeURIComponent(\n      token\n    )}&format=protobuf&platform=${encodeURIComponent(platform)}`;\n    this._socket = new WebSocket(url);\n    this._socket.binaryType = \"arraybuffer\";\n  }\n  send(msg) {\n    if (msg.match_data_send) {\n      let payload = msg.match_data_send.data;\n      if (typeof payload == \"string\") {\n        msg.match_data_send.data = new TextEncoder().encode(payload);\n      }\n    } else if (msg.party_data_send) {\n      let payload = msg.party_data_send.data;\n      if (typeof payload == \"string\") {\n        msg.party_data_send.data = new TextEncoder().encode(payload);\n      }\n    }\n    const envelopeWriter = Envelope.encode(\n      Envelope.fromPartial(msg)\n    );\n    const encodedMsg = envelopeWriter.finish();\n    this._socket.send(encodedMsg);\n  }\n};\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js?");

/***/ }),

/***/ "../mezon-js/dist/mezon-js.cjs.js":
/*!****************************************!*\
  !*** ../mezon-js/dist/mezon-js.cjs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// index.ts\nvar index_exports = {};\n__export(index_exports, {\n  ChannelStreamMode: () => ChannelStreamMode,\n  ChannelType: () => ChannelType,\n  Client: () => Client,\n  DefaultSocket: () => DefaultSocket,\n  NotificationType: () => NotificationType,\n  Session: () => Session,\n  WebSocketAdapterText: () => WebSocketAdapterText,\n  WebrtcSignalingType: () => WebrtcSignalingType,\n  b64DecodeUnicode: () => b64DecodeUnicode,\n  b64EncodeUnicode: () => b64EncodeUnicode,\n  buildFetchOptions: () => buildFetchOptions,\n  safeJSONParse: () => safeJSONParse\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// ../../node_modules/whatwg-fetch/fetch.js\nvar g = typeof globalThis !== \"undefined\" && globalThis || typeof self !== \"undefined\" && self || // eslint-disable-next-line no-undef\ntypeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g || {};\nvar support = {\n  searchParams: \"URLSearchParams\" in g,\n  iterable: \"Symbol\" in g && \"iterator\" in Symbol,\n  blob: \"FileReader\" in g && \"Blob\" in g && function() {\n    try {\n      new Blob();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(),\n  formData: \"FormData\" in g,\n  arrayBuffer: \"ArrayBuffer\" in g\n};\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj);\n}\nif (support.arrayBuffer) {\n  viewClasses = [\n    \"[object Int8Array]\",\n    \"[object Uint8Array]\",\n    \"[object Uint8ClampedArray]\",\n    \"[object Int16Array]\",\n    \"[object Uint16Array]\",\n    \"[object Int32Array]\",\n    \"[object Uint32Array]\",\n    \"[object Float32Array]\",\n    \"[object Float64Array]\"\n  ];\n  isArrayBufferView = ArrayBuffer.isView || function(obj) {\n    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n  };\n}\nvar viewClasses;\nvar isArrayBufferView;\nfunction normalizeName(name) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === \"\") {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"');\n  }\n  return name.toLowerCase();\n}\nfunction normalizeValue(value) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift();\n      return { done: value === void 0, value };\n    }\n  };\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator;\n    };\n  }\n  return iterator;\n}\nfunction Headers(headers) {\n  this.map = {};\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value);\n    }, this);\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      if (header.length != 2) {\n        throw new TypeError(\"Headers constructor: expected name/value pair to be length 2, found\" + header.length);\n      }\n      this.append(header[0], header[1]);\n    }, this);\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name]);\n    }, this);\n  }\n}\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name);\n  value = normalizeValue(value);\n  var oldValue = this.map[name];\n  this.map[name] = oldValue ? oldValue + \", \" + value : value;\n};\nHeaders.prototype[\"delete\"] = function(name) {\n  delete this.map[normalizeName(name)];\n};\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name);\n  return this.has(name) ? this.map[name] : null;\n};\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name));\n};\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value);\n};\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this);\n    }\n  }\n};\nHeaders.prototype.keys = function() {\n  var items = [];\n  this.forEach(function(value, name) {\n    items.push(name);\n  });\n  return iteratorFor(items);\n};\nHeaders.prototype.values = function() {\n  var items = [];\n  this.forEach(function(value) {\n    items.push(value);\n  });\n  return iteratorFor(items);\n};\nHeaders.prototype.entries = function() {\n  var items = [];\n  this.forEach(function(value, name) {\n    items.push([name, value]);\n  });\n  return iteratorFor(items);\n};\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n}\nfunction consumed(body) {\n  if (body._noBody) return;\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError(\"Already read\"));\n  }\n  body.bodyUsed = true;\n}\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result);\n    };\n    reader.onerror = function() {\n      reject(reader.error);\n    };\n  });\n}\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  reader.readAsArrayBuffer(blob);\n  return promise;\n}\nfunction readBlobAsText(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);\n  var encoding = match ? match[1] : \"utf-8\";\n  reader.readAsText(blob, encoding);\n  return promise;\n}\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf);\n  var chars2 = new Array(view.length);\n  for (var i = 0; i < view.length; i++) {\n    chars2[i] = String.fromCharCode(view[i]);\n  }\n  return chars2.join(\"\");\n}\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0);\n  } else {\n    var view = new Uint8Array(buf.byteLength);\n    view.set(new Uint8Array(buf));\n    return view.buffer;\n  }\n}\nfunction Body() {\n  this.bodyUsed = false;\n  this._initBody = function(body) {\n    this.bodyUsed = this.bodyUsed;\n    this._bodyInit = body;\n    if (!body) {\n      this._noBody = true;\n      this._bodyText = \"\";\n    } else if (typeof body === \"string\") {\n      this._bodyText = body;\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body;\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body;\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString();\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer);\n      this._bodyInit = new Blob([this._bodyArrayBuffer]);\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body);\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body);\n    }\n    if (!this.headers.get(\"content-type\")) {\n      if (typeof body === \"string\") {\n        this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set(\"content-type\", this._bodyBlob.type);\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n      }\n    }\n  };\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected;\n      }\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob);\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n      } else if (this._bodyFormData) {\n        throw new Error(\"could not read FormData body as blob\");\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]));\n      }\n    };\n  }\n  this.arrayBuffer = function() {\n    if (this._bodyArrayBuffer) {\n      var isConsumed = consumed(this);\n      if (isConsumed) {\n        return isConsumed;\n      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        return Promise.resolve(\n          this._bodyArrayBuffer.buffer.slice(\n            this._bodyArrayBuffer.byteOffset,\n            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n          )\n        );\n      } else {\n        return Promise.resolve(this._bodyArrayBuffer);\n      }\n    } else if (support.blob) {\n      return this.blob().then(readBlobAsArrayBuffer);\n    } else {\n      throw new Error(\"could not read as ArrayBuffer\");\n    }\n  };\n  this.text = function() {\n    var rejected = consumed(this);\n    if (rejected) {\n      return rejected;\n    }\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob);\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n    } else if (this._bodyFormData) {\n      throw new Error(\"could not read FormData body as text\");\n    } else {\n      return Promise.resolve(this._bodyText);\n    }\n  };\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode);\n    };\n  }\n  this.json = function() {\n    return this.text().then(JSON.parse);\n  };\n  return this;\n}\nvar methods = [\"CONNECT\", \"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\", \"TRACE\"];\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase();\n  return methods.indexOf(upcased) > -1 ? upcased : method;\n}\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n  }\n  options = options || {};\n  var body = options.body;\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError(\"Already read\");\n    }\n    this.url = input.url;\n    this.credentials = input.credentials;\n    if (!options.headers) {\n      this.headers = new Headers(input.headers);\n    }\n    this.method = input.method;\n    this.mode = input.mode;\n    this.signal = input.signal;\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit;\n      input.bodyUsed = true;\n    }\n  } else {\n    this.url = String(input);\n  }\n  this.credentials = options.credentials || this.credentials || \"same-origin\";\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers);\n  }\n  this.method = normalizeMethod(options.method || this.method || \"GET\");\n  this.mode = options.mode || this.mode || null;\n  this.signal = options.signal || this.signal || function() {\n    if (\"AbortController\" in g) {\n      var ctrl = new AbortController();\n      return ctrl.signal;\n    }\n  }();\n  this.referrer = null;\n  if ((this.method === \"GET\" || this.method === \"HEAD\") && body) {\n    throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n  }\n  this._initBody(body);\n  if (this.method === \"GET\" || this.method === \"HEAD\") {\n    if (options.cache === \"no-store\" || options.cache === \"no-cache\") {\n      var reParamSearch = /([?&])_=[^&]*/;\n      if (reParamSearch.test(this.url)) {\n        this.url = this.url.replace(reParamSearch, \"$1_=\" + (/* @__PURE__ */ new Date()).getTime());\n      } else {\n        var reQueryString = /\\?/;\n        this.url += (reQueryString.test(this.url) ? \"&\" : \"?\") + \"_=\" + (/* @__PURE__ */ new Date()).getTime();\n      }\n    }\n  }\n}\nRequest.prototype.clone = function() {\n  return new Request(this, { body: this._bodyInit });\n};\nfunction decode(body) {\n  var form = new FormData();\n  body.trim().split(\"&\").forEach(function(bytes) {\n    if (bytes) {\n      var split = bytes.split(\"=\");\n      var name = split.shift().replace(/\\+/g, \" \");\n      var value = split.join(\"=\").replace(/\\+/g, \" \");\n      form.append(decodeURIComponent(name), decodeURIComponent(value));\n    }\n  });\n  return form;\n}\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers();\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \" \");\n  preProcessedHeaders.split(\"\\r\").map(function(header) {\n    return header.indexOf(\"\\n\") === 0 ? header.substr(1, header.length) : header;\n  }).forEach(function(line) {\n    var parts = line.split(\":\");\n    var key = parts.shift().trim();\n    if (key) {\n      var value = parts.join(\":\").trim();\n      try {\n        headers.append(key, value);\n      } catch (error) {\n        console.warn(\"Response \" + error.message);\n      }\n    }\n  });\n  return headers;\n}\nBody.call(Request.prototype);\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n  }\n  if (!options) {\n    options = {};\n  }\n  this.type = \"default\";\n  this.status = options.status === void 0 ? 200 : options.status;\n  if (this.status < 200 || this.status > 599) {\n    throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\");\n  }\n  this.ok = this.status >= 200 && this.status < 300;\n  this.statusText = options.statusText === void 0 ? \"\" : \"\" + options.statusText;\n  this.headers = new Headers(options.headers);\n  this.url = options.url || \"\";\n  this._initBody(bodyInit);\n}\nBody.call(Response.prototype);\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  });\n};\nResponse.error = function() {\n  var response = new Response(null, { status: 200, statusText: \"\" });\n  response.ok = false;\n  response.status = 0;\n  response.type = \"error\";\n  return response;\n};\nvar redirectStatuses = [301, 302, 303, 307, 308];\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError(\"Invalid status code\");\n  }\n  return new Response(null, { status, headers: { location: url } });\n};\nvar DOMException = g.DOMException;\ntry {\n  new DOMException();\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message;\n    this.name = name;\n    var error = Error(message);\n    this.stack = error.stack;\n  };\n  DOMException.prototype = Object.create(Error.prototype);\n  DOMException.prototype.constructor = DOMException;\n}\nfunction fetch2(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init);\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException(\"Aborted\", \"AbortError\"));\n    }\n    var xhr = new XMLHttpRequest();\n    function abortXhr() {\n      xhr.abort();\n    }\n    xhr.onload = function() {\n      var options = {\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || \"\")\n      };\n      if (request.url.indexOf(\"file://\") === 0 && (xhr.status < 200 || xhr.status > 599)) {\n        options.status = 200;\n      } else {\n        options.status = xhr.status;\n      }\n      options.url = \"responseURL\" in xhr ? xhr.responseURL : options.headers.get(\"X-Request-URL\");\n      var body = \"response\" in xhr ? xhr.response : xhr.responseText;\n      setTimeout(function() {\n        resolve(new Response(body, options));\n      }, 0);\n    };\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError(\"Network request failed\"));\n      }, 0);\n    };\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError(\"Network request timed out\"));\n      }, 0);\n    };\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException(\"Aborted\", \"AbortError\"));\n      }, 0);\n    };\n    function fixUrl(url) {\n      try {\n        return url === \"\" && g.location.href ? g.location.href : url;\n      } catch (e) {\n        return url;\n      }\n    }\n    xhr.open(request.method, fixUrl(request.url), true);\n    if (request.credentials === \"include\") {\n      xhr.withCredentials = true;\n    } else if (request.credentials === \"omit\") {\n      xhr.withCredentials = false;\n    }\n    if (\"responseType\" in xhr) {\n      if (support.blob) {\n        xhr.responseType = \"blob\";\n      } else if (support.arrayBuffer) {\n        xhr.responseType = \"arraybuffer\";\n      }\n    }\n    if (init && typeof init.headers === \"object\" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {\n      var names = [];\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        names.push(normalizeName(name));\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n      });\n      request.headers.forEach(function(value, name) {\n        if (names.indexOf(name) === -1) {\n          xhr.setRequestHeader(name, value);\n        }\n      });\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n    }\n    if (request.signal) {\n      request.signal.addEventListener(\"abort\", abortXhr);\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener(\"abort\", abortXhr);\n        }\n      };\n    }\n    xhr.send(typeof request._bodyInit === \"undefined\" ? null : request._bodyInit);\n  });\n}\nfetch2.polyfill = true;\nif (!g.fetch) {\n  g.fetch = fetch2;\n  g.Headers = Headers;\n  g.Request = Request;\n  g.Response = Response;\n}\n\n// ../../node_modules/js-base64/base64.mjs\nvar _hasBuffer = typeof Buffer === \"function\";\nvar _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : void 0;\nvar _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : void 0;\nvar b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar b64chs = Array.prototype.slice.call(b64ch);\nvar b64tab = ((a) => {\n  let tab = {};\n  a.forEach((c, i) => tab[c] = i);\n  return tab;\n})(b64chs);\nvar b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nvar _fromCC = String.fromCharCode.bind(String);\nvar _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nvar _mkUriSafe = (src) => src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0) => m0 == \"+\" ? \"-\" : \"_\");\nvar _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\nvar btoaPolyfill = (bin) => {\n  let u32, c0, c1, c2, asc = \"\";\n  const pad = bin.length % 3;\n  for (let i = 0; i < bin.length; ) {\n    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)\n      throw new TypeError(\"invalid character found\");\n    u32 = c0 << 16 | c1 << 8 | c2;\n    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n  }\n  return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\nvar _btoa = typeof btoa === \"function\" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\nvar _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString(\"base64\") : (u8a) => {\n  const maxargs = 4096;\n  let strs = [];\n  for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n  }\n  return _btoa(strs.join(\"\"));\n};\nvar cb_utob = (c) => {\n  if (c.length < 2) {\n    var cc = c.charCodeAt(0);\n    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  } else {\n    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);\n    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);\n  }\n};\nvar re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\nvar utob = (u) => u.replace(re_utob, cb_utob);\nvar _encode = _hasBuffer ? (s) => Buffer.from(s, \"utf8\").toString(\"base64\") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));\nvar encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);\nvar re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nvar cb_btou = (cccc) => {\n  switch (cccc.length) {\n    case 4:\n      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;\n      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);\n    case 3:\n      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));\n    default:\n      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));\n  }\n};\nvar btou = (b) => b.replace(re_btou, cb_btou);\nvar atobPolyfill = (asc) => {\n  asc = asc.replace(/\\s+/g, \"\");\n  if (!b64re.test(asc))\n    throw new TypeError(\"malformed base64.\");\n  asc += \"==\".slice(2 - (asc.length & 3));\n  let u24, bin = \"\", r1, r2;\n  for (let i = 0; i < asc.length; ) {\n    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n  }\n  return bin;\n};\nvar _atob = typeof atob === \"function\" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\nvar _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, \"base64\")) : (a) => _U8Afrom(_atob(a).split(\"\").map((c) => c.charCodeAt(0)));\nvar _decode = _hasBuffer ? (a) => Buffer.from(a, \"base64\").toString(\"utf8\") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));\nvar _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == \"-\" ? \"+\" : \"/\"));\nvar decode2 = (src) => _decode(_unURI(src));\n\n// utils.ts\nfunction buildFetchOptions(method, options, bodyJson) {\n  const fetchOptions = __spreadValues(__spreadValues({}, { method }), options);\n  fetchOptions.headers = __spreadValues({}, options.headers);\n  if (typeof XMLHttpRequest !== \"undefined\") {\n    const descriptor = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, \"withCredentials\");\n    if (!(descriptor == null ? void 0 : descriptor.set)) {\n      fetchOptions.credentials = \"cocos-ignore\";\n    }\n  }\n  if (!Object.keys(fetchOptions.headers).includes(\"Accept\")) {\n    fetchOptions.headers[\"Accept\"] = \"application/json\";\n  }\n  if (!Object.keys(fetchOptions.headers).includes(\"Content-Type\")) {\n    fetchOptions.headers[\"Content-Type\"] = \"application/json\";\n  }\n  Object.keys(fetchOptions.headers).forEach((key) => {\n    if (!fetchOptions.headers[key]) {\n      delete fetchOptions.headers[key];\n    }\n  });\n  if (bodyJson) {\n    fetchOptions.body = bodyJson;\n  }\n  return fetchOptions;\n}\nfunction b64EncodeUnicode(str) {\n  return encode(encodeURIComponent(str).replace(\n    /%([0-9A-F]{2})/g,\n    function toSolidBytes(_match, p1) {\n      return String.fromCharCode(Number(\"0x\" + p1));\n    }\n  ));\n}\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(decode2(str).split(\"\").map(function(c) {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"));\n}\nfunction safeJSONParse(jsonStr) {\n  try {\n    const parsedData = JSON.parse(jsonStr);\n    return parsedData;\n  } catch (error) {\n    if (jsonStr !== \"\") {\n      console.error(\"Error parsing JSON:\", jsonStr, error);\n    }\n    return null;\n  }\n}\n\n// api.gen.ts\nvar MezonApi = class {\n  constructor(serverKey, timeoutMs, basePath) {\n    this.serverKey = serverKey;\n    this.timeoutMs = timeoutMs;\n    this.basePath = basePath;\n  }\n  setBasePath(basePath) {\n    this.basePath = basePath;\n  }\n  /** A healthcheck which load balancers can use to check the service. */\n  healthcheck(bearerToken, options = {}) {\n    const urlPath = \"/healthcheck\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete the current user's account. */\n  deleteAccount(bearerToken, options = {}) {\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch the current user's account. */\n  getAccount(bearerToken, options = {}) {\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in the current user's account. */\n  updateAccount(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  checkLoginRequest(basicAuthUsername, basicAuthPassword, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/checklogin\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  confirmLogin(bearerToken, basePath, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/confirmlogin\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  createQRLogin(basicAuthUsername, basicAuthPassword, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/authenticate/createqrlogin\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an email+password against the server. */\n  authenticateEmail(basicAuthUsername, basicAuthPassword, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with Mezon against the server. */\n  authenticateMezon(basicAuthUsername, basicAuthPassword, account, create, username, isRemember, options = {}) {\n    if (account === null || account === void 0) {\n      throw new Error(\"'account' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/authenticate/mezon\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"create\", create);\n    queryParams.set(\"username\", username);\n    queryParams.set(\"is_remember\", isRemember);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(account || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an email+password to the social profiles on the current user's account. */\n  linkEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/link/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a mezon ID to the social profiles on the current user's account. */\n  linkMezon(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/link/mezon\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Authenticate a user with an email+password against the server. */\n  registrationEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/registry\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\n  sessionRefresh(basicAuthUsername, basicAuthPassword, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/session/refresh\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the email+password from the social profiles on the current user's account. */\n  unlinkEmail(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/account/unlink/email\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Remove the mezon ID from the social profiles on the current user's account. */\n  unlinkMezon(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/account/unlink/mezon\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List activity */\n  listActivity(bearerToken, options = {}) {\n    const urlPath = \"/v2/activity\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create user activity */\n  createActiviy(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/activity\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a new apps. */\n  addApp(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/apps/add\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List (and optionally filter) accounts. */\n  listApps(bearerToken, filter, tombstones, cursor, options = {}) {\n    const urlPath = \"/v2/apps/app\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"filter\", filter);\n    queryParams.set(\"tombstones\", tombstones);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add an app to clan. */\n  addAppToClan(bearerToken, appId, clanId, options = {}) {\n    if (appId === null || appId === void 0) {\n      throw new Error(\n        \"'appId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/apps/app/{appId}/clan/{clanId}\".replace(\"{appId}\", encodeURIComponent(String(appId))).replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete all information stored for an app. */\n  deleteApp(bearerToken, id, recordDeletion, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"record_deletion\", recordDeletion);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get detailed app information. */\n  getApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update one or more fields on a app. */\n  updateApp(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}\".replace(\"{id}\", encodeURIComponent(String(id)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Ban a app. */\n  banApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}/ban\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Unban an app. */\n  unbanApp(bearerToken, id, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/apps/app/{id}/unban\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  listAuditLog(bearerToken, actionLog, userId, clanId, dateLog, options = {}) {\n    const urlPath = \"/v2/audit_log\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"action_log\", actionLog);\n    queryParams.set(\"user_id\", userId);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"date_log\", dateLog);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateCategoryOrder(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/category/orders\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  listCategoryDescs(bearerToken, clanId, creatorId, categoryName, categoryId, categoryOrder, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/categorydesc/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"creator_id\", creatorId);\n    queryParams.set(\"category_name\", categoryName);\n    queryParams.set(\"category_id\", categoryId);\n    queryParams.set(\"category_order\", categoryOrder);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List channel apps. */\n  listChannelApps(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/channel-apps\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getChannelCanvasList(bearerToken, channelId, clanId, limit, page, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel-canvases/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"page\", page);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  addChannelFavorite(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/favorite\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  removeChannelFavorite(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/favorite/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getListFavoriteChannel(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/favorite/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List a channel's message history. */\n  listChannelMessages(bearerToken, clanId, channelId, messageId, direction, limit, topicId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"message_id\", messageId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"direction\", direction);\n    queryParams.set(\"topic_id\", topicId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  addChannelUsers(bearerToken, channelId, userIds, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/add\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all attachment that are part of a channel. */\n  listChannelAttachment(bearerToken, channelId, clanId, fileType, limit, state, cursor, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/attachment\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"file_type\", fileType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get channel encryption method */\n  getChanEncryptionMethod(bearerToken, channelId, method, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/encrypt_method\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"method\", method);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** store channel encryption method */\n  setChanEncryptionMethod(bearerToken, channelId, body, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/encrypt_method\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Leave a channel the user is a member of. */\n  leaveThread(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/leave\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Kick a set of users from a channel. */\n  removeChannelUsers(bearerToken, channelId, userIds, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/remove\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listChannelUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/{channelId}/user\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user channels */\n  listChannelDescs(bearerToken, limit, state, cursor, clanId, channelType, options = {}) {\n    const urlPath = \"/v2/channeldesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_type\", channelType);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new channel with the current user as the owner. */\n  createChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channeldesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list user add channel by channel ids */\n  listChannelUsersUC(bearerToken, channelId, limit, options = {}) {\n    const urlPath = \"/v2/channeldesc/users\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"limit\", limit);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a channel by ID. */\n  deleteChannelDesc(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given channel. */\n  updateChannelDesc(bearerToken, channelId, body, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List channel setting */\n  listChannelSetting(bearerToken, clanId, parentId, categoryId, privateChannel, active, status, type, limit, page, channelLabel, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channelsetting/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"parent_id\", parentId);\n    queryParams.set(\"category_id\", categoryId);\n    queryParams.set(\"private_channel\", privateChannel);\n    queryParams.set(\"active\", active);\n    queryParams.set(\"status\", status);\n    queryParams.set(\"type\", type);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"page\", page);\n    queryParams.set(\"channel_label\", channelLabel);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listChannelVoiceUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/channelvoice\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List clans */\n  listClanDescs(bearerToken, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/clandesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a clan */\n  createClanDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a clan desc by ID. */\n  deleteClanDesc(bearerToken, clanDescId, options = {}) {\n    if (clanDescId === null || clanDescId === void 0) {\n      throw new Error(\n        \"'clanDescId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanDescId}\".replace(\n      \"{clanDescId}\",\n      encodeURIComponent(String(clanDescId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given clan. */\n  updateClanDesc(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Kick a set of users from a clan. */\n  removeClanUsers(bearerToken, clanId, userIds, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanId}/kick\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a clan. */\n  listClanUsers(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanId}/user\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** check duplicate clan name */\n  checkDuplicateClanName(bearerToken, clanName, options = {}) {\n    if (clanName === null || clanName === void 0) {\n      throw new Error(\n        \"'clanName' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandesc/{clanName}\".replace(\n      \"{clanName}\",\n      encodeURIComponent(String(clanName))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get a clan desc profile */\n  getClanDescProfile(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandescprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given clan profile. */\n  updateClanDescProfile(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clandescprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  createCategoryDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/createcategory\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteCategoryDesc(bearerToken, categoryId, clanId, categoryLabel, options = {}) {\n    if (categoryId === null || categoryId === void 0) {\n      throw new Error(\n        \"'categoryId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/deletecategory/category_id/{categoryId}/clan_id/{clanId}\".replace(\"{categoryId}\", encodeURIComponent(String(categoryId))).replace(\"{clanId}\", encodeURIComponent(String(clanId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"category_label\", categoryLabel);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteCategoryOrder(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/deletecategoryorder/clan_id/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** regist fcm device token */\n  registFCMDeviceToken(bearerToken, token, deviceId, platform, voipToken, options = {}) {\n    const urlPath = \"/v2/devicetoken\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"token\", token);\n    queryParams.set(\"device_id\", deviceId);\n    queryParams.set(\"platform\", platform);\n    queryParams.set(\"voip_token\", voipToken);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** close direct message. */\n  closeDirectMess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/direct/close\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** open direct message. */\n  openDirectMess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/direct/open\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Post clan Emoji  /v2/emoji/create */\n  createClanEmoji(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/emoji/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a emoji by ID. */\n  deleteClanEmojiById(bearerToken, id, clanId, emojiLabel, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/emoji/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"emoji_label\", emojiLabel);\n    const body = { clan_id: clanId };\n    let bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update ClanEmoj By id */\n  updateClanEmojiById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/emoji/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get list emoji recent by user id */\n  emojiRecentList(bearerToken, options = {}) {\n    const urlPath = \"/v2/emojirecents\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get list emoji by user id */\n  getListEmojisByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/emojis\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Search message from elasticsearch service. */\n  searchMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/es/search\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Submit an event for processing in the server's registered runtime custom events handler. */\n  event(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/event\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user events */\n  listEvents(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/eventmanagement\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new event for clan. */\n  createEvent(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given event. */\n  updateEventUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/user\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a event by ID. */\n  deleteEvent(bearerToken, eventId, clanId, creatorId, eventLabel, channelId, options = {}) {\n    if (eventId === null || eventId === void 0) {\n      throw new Error(\n        \"'eventId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/{eventId}\".replace(\n      \"{eventId}\",\n      encodeURIComponent(String(eventId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"creator_id\", creatorId);\n    queryParams.set(\"event_label\", eventLabel);\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given event. */\n  updateEvent(bearerToken, eventId, body, options = {}) {\n    if (eventId === null || eventId === void 0) {\n      throw new Error(\n        \"'eventId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/eventmanagement/{eventId}\".replace(\n      \"{eventId}\",\n      encodeURIComponent(String(eventId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete one or more users by ID or username. */\n  deleteFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all friends for the current user. */\n  listFriends(bearerToken, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add friends by ID or username to a user's account. */\n  addFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Block one or more users by ID or username. */\n  blockFriends(bearerToken, ids, usernames, options = {}) {\n    const urlPath = \"/v2/friend/block\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetChannelCategoryNotiSettingsList */\n  getChannelCategoryNotiSettingsList(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/getchannelcategorynotisettingslist\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getUserProfileOnClan(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/getclanprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationChannel */\n  getNotificationCategory(bearerToken, categoryId, options = {}) {\n    const urlPath = \"/v2/getnotificationcategory\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"category_id\", categoryId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationChannel */\n  getNotificationChannel(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/getnotificationchannel\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationClan */\n  getNotificationClan(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/getnotificationclan\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List GetNotificationReactMessage */\n  getNotificationReactMessage(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/getnotificationreactmessage\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Give a coffee */\n  giveMeACoffee(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/givecoffee\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get key server */\n  getKeyServer(bearerToken, options = {}) {\n    const urlPath = \"/v2/e2ee/key_server\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List HashtagDMList */\n  hashtagDMList(bearerToken, userId, limit, options = {}) {\n    const urlPath = \"/v2/hashtagdmlist\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_id\", userId);\n    queryParams.set(\"limit\", limit);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  createLinkInviteUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/invite\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  getLinkInvite(bearerToken, inviteId, options = {}) {\n    if (inviteId === null || inviteId === void 0) {\n      throw new Error(\n        \"'inviteId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/invite/{inviteId}\".replace(\n      \"{inviteId}\",\n      encodeURIComponent(String(inviteId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add users to a channel. */\n  inviteUser(bearerToken, inviteId, options = {}) {\n    if (inviteId === null || inviteId === void 0) {\n      throw new Error(\n        \"'inviteId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/invite/{inviteId}\".replace(\n      \"{inviteId}\",\n      encodeURIComponent(String(inviteId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List HashtagDMList */\n  listChannelByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/listchannelbyuserid\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Mark as read */\n  markAsRead(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/markasread\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List mezon OAuth client */\n  listMezonOauthClient(bearerToken, options = {}) {\n    const urlPath = \"/v2/mznoauthclient\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set mute notification user channel. */\n  setMuteNotificationCategory(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/mutenotificationcategory/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set mute notification user channel. */\n  setMuteNotificationChannel(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/mutenotificationchannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete one or more notifications for the current user. */\n  deleteNotifications(bearerToken, ids, category, options = {}) {\n    const urlPath = \"/v2/notification\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"category\", category);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch list of notifications. */\n  listNotifications(bearerToken, limit, clanId, notificationId, category, direction, options = {}) {\n    const urlPath = \"/v2/notification\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"notification_id\", notificationId);\n    queryParams.set(\"category\", category);\n    queryParams.set(\"direction\", direction);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationChannelSetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notificationchannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationClanSetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notificationclan/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  setNotificationCategorySetting(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notificationucategory/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotificationCategorySetting(bearerToken, categoryId, options = {}) {\n    const urlPath = \"/v2/notificationusercategory/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"category_id\", categoryId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotificationChannel(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/notificationuserchannel/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteNotiReactMessage(bearerToken, channelId, options = {}) {\n    const urlPath = \"/v2/notifireactmessage/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  setNotificationReactMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/notifireactmessage/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Stream http callback. */\n  streamingServerCallback(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/stream/callback\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set permission role channel. */\n  setRoleChannelPermission(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/permissionrolechannel/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get permission list */\n  getListPermission(bearerToken, options = {}) {\n    const urlPath = \"/v2/permissions\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** GetPermissionByRoleIdChannelId */\n  getPermissionByRoleIdChannelId(bearerToken, roleId, channelId, userId, options = {}) {\n    const urlPath = \"/v2/permissions/roles/channels/users\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"role_id\", roleId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"user_id\", userId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deletePinMessage(bearerToken, messageId, options = {}) {\n    const urlPath = \"/v2/pinmessage/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"message_id\", messageId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getPinMessagesList(bearerToken, messageId, channelId, clanId, options = {}) {\n    const urlPath = \"/v2/pinmessage/get\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"message_id\", messageId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** create message to inbox. */\n  createMessage2Inbox(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/pinmessage/inbox\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** set notification user channel. */\n  createPinMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/pinmessage/set\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get pubkey */\n  getPubKeys(bearerToken, userIds, options = {}) {\n    const urlPath = \"/v2/pubkey\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"user_ids\", userIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** store pubkey for e2ee */\n  pushPubKey(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/pubkey/push\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  addRolesChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rolechannel/addrole\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update the category of a channel */\n  changeChannelCategory(bearerToken, newCategoryId, body, options = {}) {\n    if (newCategoryId === null || newCategoryId === void 0) {\n      throw new Error(\n        \"'newCategoryId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/channel/category/{newCategoryId}\".replace(\n      \"{newCategoryId}\",\n      encodeURIComponent(String(newCategoryId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a role when Delete a role by ID. */\n  deleteRoleChannelDesc(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rolechannel/delete\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** ListRoles */\n  listRoles(bearerToken, clanId, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/roles\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a new role for clan. */\n  createRole(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a role when Delete a role by ID. */\n  updateRoleDelete(bearerToken, roleId, body, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/delete/{roleId}\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a role by ID. */\n  deleteRole(bearerToken, roleId, channelId, clanId, roleLabel, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"role_label\", roleLabel);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given role. */\n  updateRole(bearerToken, roleId, body, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List role permissions */\n  listRolePermissions(bearerToken, roleId, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}/permissions\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List role permissions */\n  listRoleUsers(bearerToken, roleId, limit, cursor, options = {}) {\n    if (roleId === null || roleId === void 0) {\n      throw new Error(\n        \"'roleId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roles/{roleId}/users\".replace(\n      \"{roleId}\",\n      encodeURIComponent(String(roleId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getRoleOfUserInTheClan(bearerToken, clanId, channelId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/roleuserinclan/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Execute a Lua function on the server. */\n  rpcFunc2(bearerToken, basicAuthUsername, basicAuthPassword, id, payload, httpKey, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/rpc/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"payload\", payload);\n    queryParams.set(\"http_key\", httpKey);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Execute a Lua function on the server. */\n  rpcFunc(bearerToken, basicAuthUsername, basicAuthPassword, id, payload, httpKey, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (payload === null || payload === void 0) {\n      throw new Error(\n        \"'payload' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/rpc/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"http_key\", httpKey);\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(payload || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  searchThread(bearerToken, clanId, channelId, label, options = {}) {\n    const urlPath = \"/v2/searchthread\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"label\", label);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** UpdateWallets */\n  sendToken(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/sendtoken\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\n  sessionLogout(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/session/logout\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add a new sticker */\n  addClanSticker(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/sticker\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a sticker by ID */\n  deleteClanStickerById(bearerToken, id, clanId, stickerLabel, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/sticker/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"sticker_label\", stickerLabel);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a sticker by ID */\n  updateClanStickerById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/sticker/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get list sticker by user id */\n  getListStickersByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/stickers\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List streaming channels. */\n  listStreamingChannels(bearerToken, clanId, options = {}) {\n    const urlPath = \"/v2/streaming-channels\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Register streaming in channel ( for bot - get streaming key) */\n  registerStreamingChannel(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/streaming-channels\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List all users that are part of a channel. */\n  listStreamingChannelUsers(bearerToken, clanId, channelId, channelType, limit, state, cursor, options = {}) {\n    const urlPath = \"/v2/streaming-channels/users\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    queryParams.set(\"channel_type\", channelType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"cursor\", cursor);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get the list of system messages. */\n  getSystemMessagesList(bearerToken, options = {}) {\n    const urlPath = \"/v2/systemmessages\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create a system messages. */\n  createSystemMessage(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List Sd Topic */\n  listSdTopic(bearerToken, clanId, limit, options = {}) {\n    const urlPath = \"/v2/sdmtopic\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"limit\", limit);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create Sd Topic */\n  createSdTopic(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/sdmtopic\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete a specific system messages. */\n  deleteSystemMessage(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get details of a specific system messages. */\n  getSystemMessageByClanId(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update a system messages. */\n  updateSystemMessage(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/systemmessages/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List user channels */\n  listThreadDescs(bearerToken, channelId, limit, state, clanId, threadId, page, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/thread/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"state\", state);\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"thread_id\", threadId);\n    queryParams.set(\"page\", page);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update fields in a given category. */\n  updateCategory(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/updatecategory/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update channel private. */\n  updateChannelPrivate(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/updatechannelprivate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateUserProfileByClan(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/updateclanprofile/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Upload attachment */\n  uploadAttachmentFile(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/uploadattachmentfile\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Fetch zero or more users by ID and/or username. */\n  getUsers(bearerToken, ids, usernames, facebookIds, options = {}) {\n    const urlPath = \"/v2/user\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"ids\", ids);\n    queryParams.set(\"usernames\", usernames);\n    queryParams.set(\"facebook_ids\", facebookIds);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateUser(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/user/update\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** ListUserClansByUserId */\n  listUserClansByUserId(bearerToken, options = {}) {\n    const urlPath = \"/v2/users/clans\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** ListUserPermissionInChannel */\n  listUserPermissionInChannel(bearerToken, clanId, channelId, options = {}) {\n    const urlPath = \"/v2/users/clans/channels\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get user status */\n  getUserStatus(bearerToken, options = {}) {\n    const urlPath = \"/v2/userstatus\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update user status */\n  updateUserStatus(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/userstatus\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list transaction detail */\n  listTransactionDetail(bearerToken, transId, options = {}) {\n    if (transId === null || transId === void 0) {\n      throw new Error(\"'transId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/transaction/{transId}\".replace(\"{transId}\", encodeURIComponent(String(transId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Get user status */\n  listWalletLedger(bearerToken, limit, filter, transactionId, page, options = {}) {\n    const urlPath = \"/v2/walletledger\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"filter\", filter);\n    queryParams.set(\"transaction_id\", transactionId);\n    queryParams.set(\"page\", page);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** create webhook */\n  generateWebhook(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/generate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update webhook name by id */\n  updateWebhookById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/update/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list webhook belong to the channel */\n  listWebhookByChannelId(bearerToken, channelId, clanId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\n        \"'channelId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/{channelId}\".replace(\n      \"{channelId}\",\n      encodeURIComponent(String(channelId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** disabled webhook */\n  deleteWebhookById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/webhooks/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  buildFullUrl(basePath, fragment, queryParams) {\n    let fullPath = basePath + fragment + \"?\";\n    for (let [k, v] of queryParams) {\n      if (v instanceof Array) {\n        fullPath += v.reduce((prev, curr) => {\n          return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\n        }, \"\");\n      } else {\n        if (v != null) {\n          fullPath += encodeURIComponent(k) + \"=\" + encodeURIComponent(v) + \"&\";\n        }\n      }\n    }\n    return fullPath;\n  }\n  /** Channel canvas editor */\n  editChannelCanvases(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/canvases/editor\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  getChannelCanvasDetail(bearerToken, id, clanId, channelId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/canvases/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteChannelCanvas(bearerToken, canvasId, clanId, channelId, options = {}) {\n    if (canvasId === null || canvasId === void 0) {\n      throw new Error(\n        \"'canvasId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/canvases/{canvasId}\".replace(\n      \"{canvasId}\",\n      encodeURIComponent(String(canvasId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** list onboarding. */\n  listOnboarding(bearerToken, clanId, guideType, limit, page, options = {}) {\n    const urlPath = \"/v2/onboarding\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"guide_type\", guideType);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"page\", page);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** create onboarding. */\n  createOnboarding(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/onboarding\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** delete onboarding. */\n  deleteOnboarding(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/onboarding/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** get detailed onboarding information. */\n  getOnboardingDetail(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/onboarding/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update onboarding. */\n  updateOnboarding(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/onboarding/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Generate clan webhook. */\n  generateClanWebhook(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clanwebhooks\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List clan webhook. */\n  listClanWebhook(bearerToken, clanId, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clanwebhooks/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Disabled clan webhook. */\n  deleteClanWebhookById(bearerToken, id, clanId, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clanwebhooks/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update clan webhook by id. */\n  updateClanWebhookById(bearerToken, id, body, options = {}) {\n    if (id === null || id === void 0) {\n      throw new Error(\"'id' is a required parameter but is null or undefined.\");\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/clanwebhooks/{id}\".replace(\n      \"{id}\",\n      encodeURIComponent(String(id))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Sd Topic */\n  getTopicDetail(bearerToken, topicId, options = {}) {\n    const urlPath = \"/v2/sdmtopic/detail\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"topic_id\", topicId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List onboarding step. */\n  listOnboardingStep(bearerToken, clanId, limit, page, options = {}) {\n    const urlPath = \"/v2/onboardingsteps\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"limit\", limit);\n    queryParams.set(\"page\", page);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Update onboarding step. */\n  updateOnboardingStepByClanId(bearerToken, clanId, body, options = {}) {\n    if (clanId === null || clanId === void 0) {\n      throw new Error(\n        \"'clanId' is a required parameter but is null or undefined.\"\n      );\n    }\n    if (body === null || body === void 0) {\n      throw new Error(\n        \"'body' is a required parameter but is null or undefined.\"\n      );\n    }\n    const urlPath = \"/v2/onboardingsteps/{clanId}\".replace(\n      \"{clanId}\",\n      encodeURIComponent(String(clanId))\n    );\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** create meeting room */\n  createRoomChannelApps(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channel-apps/createroom\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Generate Meet Token */\n  generateMeetToken(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/meet/generate\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create mezon OAuth client */\n  getMezonOauthClient(bearerToken, clientId, clientName, options = {}) {\n    const urlPath = \"/v2/mznoauthclient\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"client_id\", clientId);\n    queryParams.set(\"client_name\", clientName);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** update mezon OAuth */\n  updateMezonOauthClient(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/mznoauthclient\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PATCH\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  generateHashChannelApps(bearerToken, appId, options = {}) {\n    const urlPath = \"/v2/channel-apps/hash\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"app_id\", appId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Add user event */\n  addUserEvent(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/userevent\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Delete user event */\n  deleteUserEvent(bearerToken, clanId, eventId, options = {}) {\n    const urlPath = \"/v2/userevent\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"clan_id\", clanId);\n    queryParams.set(\"event_id\", eventId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateRoleOrder(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/role/orders\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Create external Mezon meet */\n  createExternalMezonMeet(bearerToken, options = {}) {\n    const urlPath = \"/v2/meet/external/create\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** handler external mezon meet */\n  generateMeetTokenExternal(bearerToken, basePath, token, displayName, isGuest, options = {}) {\n    if (token === null || token === void 0) {\n      throw new Error(\"'token' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/meet/external/{token}\".replace(\"{token}\", encodeURIComponent(String(token)));\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"display_name\", displayName);\n    queryParams.set(\"is_guest\", isGuest);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** List channels detail */\n  listChannelDetail(bearerToken, channelId, options = {}) {\n    if (channelId === null || channelId === void 0) {\n      throw new Error(\"'channelId' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/channeldesc/{channelId}\".replace(\"{channelId}\", encodeURIComponent(String(channelId)));\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateClanOrder(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/updateclanorder\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** Discover mezon clan. */\n  clanDiscover(basicAuthUsername, basicAuthPassword, basePath, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/clan/discover\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (basicAuthUsername) {\n      fetchOptions.headers[\"Authorization\"] = \"Basic \" + encode(basicAuthUsername + \":\" + basicAuthPassword);\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  deleteQuickMenuAccess(bearerToken, id, menuName, background, actionMsg, options = {}) {\n    const urlPath = \"/v2/quickmenuaccess\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"id\", id);\n    queryParams.set(\"menu_name\", menuName);\n    queryParams.set(\"background\", background);\n    queryParams.set(\"action_msg\", actionMsg);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"DELETE\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  listQuickMenuAccess(bearerToken, botId, channelId, options = {}) {\n    const urlPath = \"/v2/quickmenuaccess\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"bot_id\", botId);\n    queryParams.set(\"channel_id\", channelId);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  addQuickMenuAccess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/quickmenuaccess\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /**  */\n  updateQuickMenuAccess(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/quickmenuaccess\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"PUT\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** UnlockItem */\n  unlockItem(bearerToken, body, options = {}) {\n    if (body === null || body === void 0) {\n      throw new Error(\"'body' is a required parameter but is null or undefined.\");\n    }\n    const urlPath = \"/v2/unlockitem\";\n    const queryParams = /* @__PURE__ */ new Map();\n    let bodyJson = \"\";\n    bodyJson = JSON.stringify(body || {});\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"POST\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n  /** For sale items */\n  listForSaleItems(bearerToken, page, options = {}) {\n    const urlPath = \"/v2/forsale\";\n    const queryParams = /* @__PURE__ */ new Map();\n    queryParams.set(\"page\", page);\n    let bodyJson = \"\";\n    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\n    const fetchOptions = buildFetchOptions(\"GET\", options, bodyJson);\n    if (bearerToken) {\n      fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\n    }\n    return Promise.race([\n      fetch(fullUrl, fetchOptions).then((response) => {\n        if (response.status == 204) {\n          return response;\n        } else if (response.status >= 200 && response.status < 300) {\n          return response.json();\n        } else {\n          throw response;\n        }\n      }),\n      new Promise(\n        (_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")\n      )\n    ]);\n  }\n};\n\n// session.ts\nvar Session = class _Session {\n  constructor(token, refresh_token, created, api_url, is_remember) {\n    this.created = created;\n    this.api_url = api_url;\n    this.token = token;\n    this.refresh_token = refresh_token;\n    this.created_at = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);\n    this.is_remember = is_remember;\n    this.update(token, refresh_token, is_remember);\n  }\n  isexpired(currenttime) {\n    return this.expires_at - currenttime < 0;\n  }\n  isrefreshexpired(currenttime) {\n    return this.refresh_expires_at - currenttime < 0;\n  }\n  update(token, refreshToken, isRemember) {\n    const tokenParts = token.split(\".\");\n    if (tokenParts.length != 3) {\n      throw \"jwt is not valid.\";\n    }\n    const tokenDecoded = JSON.parse(_atob(tokenParts[1]));\n    const tokenExpiresAt = Math.floor(parseInt(tokenDecoded[\"exp\"]));\n    if (refreshToken) {\n      const refreshTokenParts = refreshToken.split(\".\");\n      if (refreshTokenParts.length != 3) {\n        throw \"refresh jwt is not valid.\";\n      }\n      const refreshTokenDecoded = JSON.parse(_atob(refreshTokenParts[1]));\n      const refreshTokenExpiresAt = Math.floor(parseInt(refreshTokenDecoded[\"exp\"]));\n      this.refresh_expires_at = refreshTokenExpiresAt;\n      this.refresh_token = refreshToken;\n      this.is_remember = isRemember;\n    }\n    this.token = token;\n    this.expires_at = tokenExpiresAt;\n    this.username = tokenDecoded[\"usn\"];\n    this.user_id = tokenDecoded[\"uid\"];\n    this.vars = tokenDecoded[\"vrs\"];\n  }\n  static restore(token, refreshToken, api_url, isRemember) {\n    return new _Session(token, refreshToken, false, api_url, isRemember);\n  }\n};\n\n// ../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\nvar i;\nvar encode2 = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = \"\";\n  for (i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nvar decode3 = function(base64) {\n  var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\n\n// web_socket_adapter.ts\nvar WebSocketAdapterText = class {\n  get onClose() {\n    return this._socket.onclose;\n  }\n  set onClose(value) {\n    this._socket.onclose = value;\n  }\n  get onError() {\n    return this._socket.onerror;\n  }\n  set onError(value) {\n    this._socket.onerror = value;\n  }\n  get onMessage() {\n    return this._socket.onmessage;\n  }\n  set onMessage(value) {\n    if (value) {\n      this._socket.onmessage = (evt) => {\n        const message = safeJSONParse(evt.data);\n        if (message.party_data && message.party_data.data) {\n          message.party_data.data = new Uint8Array(\n            decode3(message.party_data.data)\n          );\n        }\n        value(message);\n      };\n    } else {\n      value = null;\n    }\n  }\n  get onOpen() {\n    return this._socket.onopen;\n  }\n  set onOpen(value) {\n    this._socket.onopen = value;\n  }\n  isOpen() {\n    var _a;\n    return ((_a = this._socket) == null ? void 0 : _a.readyState) == WebSocket.OPEN;\n  }\n  connect(scheme, host, port, createStatus, token, platform, signal) {\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        this.close();\n      });\n    }\n    const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(\n      createStatus.toString()\n    )}&token=${encodeURIComponent(token)}&paltform=${encodeURIComponent(\n      platform\n    )}`;\n    this._socket = new WebSocket(url);\n  }\n  close() {\n    var _a;\n    (_a = this._socket) == null ? void 0 : _a.close();\n    this._socket = void 0;\n  }\n  send(msg) {\n    if (msg.party_data_send) {\n      msg.party_data_send.op_code = msg.party_data_send.op_code.toString();\n      let payload = msg.party_data_send.data;\n      if (payload && payload instanceof Uint8Array) {\n        msg.party_data_send.data = encode2(payload.buffer);\n      } else if (payload) {\n        msg.party_data_send.data = _btoa(payload);\n      }\n    }\n    this._socket.send(JSON.stringify(msg));\n  }\n};\n\n// socket.ts\nfunction CreateChannelMessageFromEvent(message) {\n  var content, reactions, mentions, attachments, references, referencedMessags;\n  try {\n    content = safeJSONParse(message.channel_message.content);\n  } catch (e2) {\n    console.log(\"content is invalid\", e2);\n  }\n  try {\n    reactions = safeJSONParse(message.channel_message.reactions);\n  } catch (e2) {\n    console.log(\"reactions is invalid\", e2);\n  }\n  try {\n    mentions = safeJSONParse(message.channel_message.mentions);\n  } catch (e2) {\n    console.log(\"mentions is invalid\", e2);\n  }\n  try {\n    attachments = safeJSONParse(message.channel_message.attachments);\n  } catch (e2) {\n    console.log(\"attachments is invalid\", e2);\n  }\n  try {\n    references = safeJSONParse(message.channel_message.references);\n  } catch (e2) {\n    console.log(\"references is invalid\", e2);\n  }\n  try {\n    referencedMessags = safeJSONParse(message.channel_message.referenced_message);\n  } catch (e2) {\n    console.log(\"referenced messages is invalid\", e2);\n  }\n  var e = {\n    id: message.id || message.channel_message.message_id,\n    avatar: message.channel_message.avatar,\n    channel_id: message.channel_message.channel_id,\n    mode: message.channel_message.mode,\n    channel_label: message.channel_message.channel_label,\n    clan_id: message.channel_message.clan_id,\n    code: message.channel_message.code,\n    create_time: message.channel_message.create_time,\n    message_id: message.channel_message.message_id,\n    sender_id: message.channel_message.sender_id,\n    update_time: message.channel_message.update_time,\n    clan_logo: message.channel_message.clan_logo,\n    category_name: message.channel_message.category_name,\n    username: message.channel_message.username,\n    clan_nick: message.channel_message.clan_nick,\n    clan_avatar: message.channel_message.clan_avatar,\n    display_name: message.channel_message.display_name,\n    content,\n    reactions,\n    mentions,\n    attachments,\n    referenced_message: referencedMessags,\n    references,\n    hide_editted: message.channel_message.hide_editted,\n    is_public: message.channel_message.is_public,\n    create_time_seconds: message.channel_message.create_time_seconds,\n    update_time_seconds: message.channel_message.update_time_seconds,\n    topic_id: message.channel_message.topic_id\n  };\n  return e;\n}\nvar _DefaultSocket = class _DefaultSocket {\n  constructor(host, port, useSSL = false, verbose = false, adapter = new WebSocketAdapterText(), sendTimeoutMs = _DefaultSocket.DefaultSendTimeoutMs) {\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    this.verbose = verbose;\n    this.adapter = adapter;\n    this.sendTimeoutMs = sendTimeoutMs;\n    this.cIds = {};\n    this.nextCid = 1;\n    this._heartbeatTimeoutMs = _DefaultSocket.DefaultHeartbeatTimeoutMs;\n  }\n  generatecid() {\n    const cid = this.nextCid.toString();\n    ++this.nextCid;\n    return cid;\n  }\n  isOpen() {\n    return this.adapter.isOpen();\n  }\n  connect(session, createStatus = false, platform = \"\", connectTimeoutMs = _DefaultSocket.DefaultConnectTimeoutMs, signal) {\n    if (this.adapter.isOpen()) {\n      return Promise.resolve(session);\n    }\n    const scheme = this.useSSL ? \"wss://\" : \"ws://\";\n    this.adapter.connect(\n      scheme,\n      this.host,\n      this.port,\n      createStatus,\n      session.token,\n      platform,\n      signal\n    );\n    this.adapter.onClose = (evt) => {\n      this.ondisconnect(evt);\n    };\n    this.adapter.onError = (evt) => {\n      this.onerror(evt);\n    };\n    this.adapter.onMessage = (message) => __async(this, null, function* () {\n      if (this.verbose && window && window.console) {\n        console.log(\"Response: %o\", JSON.stringify(message));\n      }\n      if (!message.cid) {\n        if (message.notifications) {\n          message.notifications.notifications.forEach((n) => {\n            n.content = n.content ? safeJSONParse(n.content) : void 0;\n            this.onnotification(n);\n          });\n        } else if (message.voice_started_event) {\n          this.onvoicestarted(message.voice_started_event);\n        } else if (message.voice_ended_event) {\n          this.onvoiceended(message.voice_ended_event);\n        } else if (message.voice_joined_event) {\n          this.onvoicejoined(message.voice_joined_event);\n        } else if (message.voice_leaved_event) {\n          this.onvoiceleaved(message.voice_leaved_event);\n        } else if (message.channel_created_event) {\n          this.onchannelcreated(message.channel_created_event);\n        } else if (message.category_event) {\n          this.oncategoryevent(message.category_event);\n        } else if (message.role_event) {\n          this.onroleevent(message.role_event);\n        } else if (message.event_emoji) {\n          this.oneventemoji(message.event_emoji);\n        } else if (message.noti_user_channel) {\n          this.oneventnotiuserchannel(message.noti_user_channel);\n        } else if (message.webhook_event) {\n          this.oneventwebhook(message.webhook_event);\n        } else if (message.channel_deleted_event) {\n          this.onchanneldeleted(message.channel_deleted_event);\n        } else if (message.clan_deleted_event) {\n          this.onclandeleted(message.clan_deleted_event);\n        } else if (message.sticker_create_event) {\n          this.onstickercreated(message.sticker_create_event);\n        } else if (message.sticker_update_event) {\n          this.onstickerupdated(message.sticker_update_event);\n        } else if (message.sticker_delete_event) {\n          this.onstickerdeleted(message.sticker_delete_event);\n        } else if (message.channel_updated_event) {\n          this.onchannelupdated(message.channel_updated_event);\n        } else if (message.delete_account_event) {\n          this.ondeleteaccount(message.delete_account_event);\n        } else if (message.clan_profile_updated_event) {\n          this.onclanprofileupdated(message.clan_profile_updated_event);\n        } else if (message.clan_updated_event) {\n          this.onclanupdated(message.clan_updated_event);\n        } else if (message.last_seen_message_event) {\n          this.onlastseenupdated(message.last_seen_message_event);\n        } else if (message.status_presence_event) {\n          this.onstatuspresence(\n            message.status_presence_event\n          );\n        } else if (message.stream_presence_event) {\n          this.onstreampresence(\n            message.stream_presence_event\n          );\n        } else if (message.stream_data) {\n          this.onstreamdata(message.stream_data);\n        } else if (message.channel_message) {\n          const channelMessage = CreateChannelMessageFromEvent(message);\n          this.onchannelmessage(channelMessage);\n        } else if (message.message_typing_event) {\n          this.onmessagetyping(\n            message.message_typing_event\n          );\n        } else if (message.message_reaction_event) {\n          this.onmessagereaction(\n            message.message_reaction_event\n          );\n        } else if (message.channel_presence_event) {\n          this.onchannelpresence(\n            message.channel_presence_event\n          );\n        } else if (message.last_pin_message_event) {\n          this.onpinmessage(\n            message.last_pin_message_event\n          );\n        } else if (message.custom_status_event) {\n          this.oncustomstatus(message.custom_status_event);\n        } else if (message.canvas_event) {\n          this.oncanvasevent(message.canvas_event);\n        } else if (message.user_channel_added_event) {\n          this.onuserchanneladded(\n            message.user_channel_added_event\n          );\n        } else if (message.add_clan_user_event) {\n          this.onuserclanadded(message.add_clan_user_event);\n        } else if (message.user_profile_updated_event) {\n          this.onuserprofileupdate(\n            message.user_profile_updated_event\n          );\n        } else if (message.user_channel_removed_event) {\n          this.onuserchannelremoved(\n            message.user_channel_removed_event\n          );\n        } else if (message.block_friend) {\n          this.onblockfriend(message.block_friend);\n        } else if (message.remove_friend) {\n          this.onremovefriend(message.remove_friend);\n        } else if (message.user_clan_removed_event) {\n          this.onuserclanremoved(\n            message.user_clan_removed_event\n          );\n        } else if (message.clan_event_created) {\n          this.oneventcreated(message.clan_event_created);\n        } else if (message.give_coffee_event) {\n          this.oncoffeegiven(message.give_coffee_event);\n        } else if (message.role_assign_event) {\n          this.onroleassign(message.role_assign_event);\n        } else if (message.streaming_started_event) {\n          this.onstreamingchannelstarted(\n            message.streaming_started_event\n          );\n        } else if (message.streaming_ended_event) {\n          this.onstreamingchannelended(\n            message.streaming_ended_event\n          );\n        } else if (message.streaming_joined_event) {\n          this.onstreamingchanneljoined(\n            message.streaming_joined_event\n          );\n        } else if (message.streaming_leaved_event) {\n          this.onstreamingchannelleaved(\n            message.streaming_leaved_event\n          );\n        } else if (message.permission_set_event) {\n          this.onpermissionset(message.permission_set_event);\n        } else if (message.permission_changed_event) {\n          this.onpermissionchanged(\n            message.permission_changed_event\n          );\n        } else if (message.unmute_event) {\n          this.onunmuteevent(message.unmute_event);\n        } else if (message.token_sent_event) {\n          this.ontokensent(message.token_sent_event);\n        } else if (message.message_button_clicked) {\n          this.onmessagebuttonclicked(\n            message.message_button_clicked\n          );\n        } else if (message.dropdown_box_selected) {\n          this.onmessagedropdownboxselected(\n            message.dropdown_box_selected\n          );\n        } else if (message.mark_as_read) {\n          this.onmarkasread(\n            message.mark_as_read\n          );\n        } else if (message.voice_reaction_send) {\n          this.onvoicereactionmessage(\n            message.voice_reaction_send\n          );\n        } else if (message.webrtc_signaling_fwd) {\n          this.onwebrtcsignalingfwd(\n            message.webrtc_signaling_fwd\n          );\n        } else if (message.list_activity) {\n          this.onactivityupdated(message.list_activity);\n        } else if (message.sd_topic_event) {\n          this.onsdtopicevent(message.sd_topic_event);\n        } else if (message.channel_app_event) {\n          this.onchannelappevent(message.channel_app_event);\n        } else if (message.user_status_event) {\n          this.onuserstatusevent(message.user_status_event);\n        } else if (message.join_channel_app_data) {\n          this.onJoinChannelAppEvent(message.join_channel_app_data);\n        } else if (message.unpin_message_event) {\n          this.onUnpinMessageEvent(message.unpin_message_event);\n        } else {\n          if (this.verbose && window && window.console) {\n            console.log(\"Unrecognized message received: %o\", message);\n          }\n        }\n      } else {\n        const executor = this.cIds[message.cid];\n        if (!executor) {\n          if (this.verbose && window && window.console) {\n            console.error(\"No promise executor for message: %o\", message);\n          }\n          return;\n        }\n        delete this.cIds[message.cid];\n        if (message.error) {\n          executor.reject(message.error);\n        } else {\n          executor.resolve(message);\n        }\n      }\n    });\n    return new Promise((resolve, reject) => {\n      this.adapter.onOpen = (evt) => {\n        if (this.verbose && window && window.console) {\n          console.log(evt);\n        }\n        this.pingPong();\n        resolve(session);\n      };\n      this.adapter.onError = (evt) => {\n        reject(evt);\n        this.adapter.close();\n      };\n      setTimeout(() => {\n        reject(\"The socket timed out when trying to connect.\");\n      }, connectTimeoutMs);\n    });\n  }\n  disconnect(fireDisconnectEvent = true) {\n    if (this.adapter.isOpen()) {\n      this.adapter.close();\n    }\n    if (fireDisconnectEvent) {\n      this.ondisconnect({});\n    }\n  }\n  setHeartbeatTimeoutMs(ms) {\n    this._heartbeatTimeoutMs = ms;\n  }\n  getHeartbeatTimeoutMs() {\n    return this._heartbeatTimeoutMs;\n  }\n  ondisconnect(evt) {\n    if (this.verbose && window && window.console) {\n      console.log(evt);\n    }\n  }\n  onerror(evt) {\n    if (this.verbose && window && window.console) {\n      console.log(evt);\n    }\n  }\n  onmessagetyping(messagetyping) {\n    if (this.verbose && window && window.console) {\n      console.log(messagetyping);\n    }\n  }\n  onmessagereaction(messagereaction) {\n    if (this.verbose && window && window.console) {\n      console.log(messagereaction);\n    }\n  }\n  onchannelmessage(channelMessage) {\n    if (this.verbose && window && window.console) {\n      console.log(channelMessage);\n    }\n  }\n  onchannelpresence(channelPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(channelPresence);\n    }\n  }\n  onuserchanneladded(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserclanadded(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserprofileupdate(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserchannelremoved(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onremovefriend(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onblockfriend(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onuserclanremoved(user) {\n    if (this.verbose && window && window.console) {\n      console.log(user);\n    }\n  }\n  onnotification(notification) {\n    if (this.verbose && window && window.console) {\n      console.log(notification);\n    }\n  }\n  onstatuspresence(statusPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(statusPresence);\n    }\n  }\n  onpinmessage(pin) {\n    if (this.verbose && window && window.console) {\n      console.log(pin);\n    }\n  }\n  onvoiceended(voice) {\n    if (this.verbose && window && window.console) {\n      console.log(voice);\n    }\n  }\n  onvoicestarted(voice) {\n    if (this.verbose && window && window.console) {\n      console.log(voice);\n    }\n  }\n  onvoicejoined(voiceParticipant) {\n    if (this.verbose && window && window.console) {\n      console.log(voiceParticipant);\n    }\n  }\n  onvoiceleaved(voiceParticipant) {\n    if (this.verbose && window && window.console) {\n      console.log(voiceParticipant);\n    }\n  }\n  onchannelcreated(channelCreated) {\n    if (this.verbose && window && window.console) {\n      console.log(channelCreated);\n    }\n  }\n  oncategoryevent(categoryEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(categoryEvent);\n    }\n  }\n  onroleevent(roleEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(roleEvent);\n    }\n  }\n  oneventemoji(eventEmoji) {\n    if (this.verbose && window && window.console) {\n      console.log(eventEmoji);\n    }\n  }\n  oneventnotiuserchannel(notiUserChannel) {\n    if (this.verbose && window && window.console) {\n      console.log(notiUserChannel);\n    }\n  }\n  oneventwebhook(webhook_event) {\n    if (this.verbose && window && window.console) {\n      console.log(webhook_event);\n    }\n  }\n  onchanneldeleted(channelDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(channelDeleted);\n    }\n  }\n  onclandeleted(clanDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(clanDeleted);\n    }\n  }\n  onstickercreated(stickerCreated) {\n    if (this.verbose && window && window.console) {\n      console.log(stickerCreated);\n    }\n  }\n  onstickerdeleted(stickerDeleted) {\n    if (this.verbose && window && window.console) {\n      console.log(stickerDeleted);\n    }\n  }\n  onstickerupdated(stickerUpdated) {\n    if (this.verbose && window && window.console) {\n      console.log(stickerUpdated);\n    }\n  }\n  onchannelupdated(channelUpdated) {\n    if (this.verbose && window && window.console) {\n      console.log(channelUpdated);\n    }\n  }\n  ondeleteaccount(deleteAccountEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(deleteAccountEvent);\n    }\n  }\n  onclanprofileupdated(clanprofile) {\n    if (this.verbose && window && window.console) {\n      console.log(clanprofile);\n    }\n  }\n  onclanupdated(clan) {\n    if (this.verbose && window && window.console) {\n      console.log(clan);\n    }\n  }\n  onlastseenupdated(event) {\n    if (this.verbose && window && window.console) {\n      console.log(event);\n    }\n  }\n  onstreampresence(streamPresence) {\n    if (this.verbose && window && window.console) {\n      console.log(streamPresence);\n    }\n  }\n  onstreamdata(streamData) {\n    if (this.verbose && window && window.console) {\n      console.log(streamData);\n    }\n  }\n  onheartbeattimeout() {\n    if (this.verbose && window && window.console) {\n      console.log(\"Heartbeat timeout.\");\n    }\n  }\n  oncustomstatus(statusEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(statusEvent);\n    }\n  }\n  oncanvasevent(canvasEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(canvasEvent);\n    }\n  }\n  oneventcreated(clan_event_created) {\n    if (this.verbose && window && window.console) {\n      console.log(clan_event_created);\n    }\n  }\n  oncoffeegiven(give_coffee_event) {\n    if (this.verbose && window && window.console) {\n      console.log(give_coffee_event);\n    }\n  }\n  onroleassign(role_assign_event) {\n    if (this.verbose && window && window.console) {\n      console.log(role_assign_event);\n    }\n  }\n  onstreamingchannelstarted(streaming_started_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_started_event);\n    }\n  }\n  onstreamingchannelended(streaming_ended_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_ended_event);\n    }\n  }\n  onstreamingchanneljoined(streaming_joined_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_joined_event);\n    }\n  }\n  onstreamingchannelleaved(streaming_leaved_event) {\n    if (this.verbose && window && window.console) {\n      console.log(streaming_leaved_event);\n    }\n  }\n  onpermissionset(permission_set_event) {\n    if (this.verbose && window && window.console) {\n      console.log(permission_set_event);\n    }\n  }\n  onpermissionchanged(permission_changed_event) {\n    if (this.verbose && window && window.console) {\n      console.log(permission_changed_event);\n    }\n  }\n  onunmuteevent(unmute_event) {\n    if (this.verbose && window && window.console) {\n      console.log(unmute_event);\n    }\n  }\n  ontokensent(tokenSentEvent) {\n    if (this.verbose && window && window.console) {\n      console.log(tokenSentEvent);\n    }\n  }\n  onmessagebuttonclicked(messageButtonClicked) {\n    if (this.verbose && window && window.console) {\n      console.log(messageButtonClicked);\n    }\n  }\n  onmessagedropdownboxselected(msg) {\n    if (this.verbose && window && window.console) {\n      console.log(msg);\n    }\n  }\n  onmarkasread(event) {\n    if (this.verbose && window && window.console) {\n      console.log(event);\n    }\n  }\n  onvoicereactionmessage(event) {\n    if (this.verbose && window && window.console) {\n      console.log(event);\n    }\n  }\n  onwebrtcsignalingfwd(event) {\n    if (this.verbose && window && window.console) {\n      console.log(event);\n    }\n  }\n  onactivityupdated(list_activity) {\n    if (this.verbose && window && window.console) {\n      console.log(list_activity);\n    }\n  }\n  onsdtopicevent(sd_topic_event) {\n    if (this.verbose && window && window.console) {\n      console.log(sd_topic_event);\n    }\n  }\n  onchannelappevent(event) {\n    if (this.verbose && window && window.console) {\n      console.log(event);\n    }\n  }\n  onuserstatusevent(user_status_event) {\n    if (this.verbose && window && window.console) {\n      console.log(user_status_event);\n    }\n  }\n  onJoinChannelAppEvent(join_channel_app_data) {\n    if (this.verbose && window && window.console) {\n      console.log(join_channel_app_data);\n    }\n  }\n  onUnpinMessageEvent(unpin_message_event) {\n    if (this.verbose && window && window.console) {\n      console.log(unpin_message_event);\n    }\n  }\n  send(message, sendTimeout = _DefaultSocket.DefaultSendTimeoutMs) {\n    const untypedMessage = message;\n    return new Promise((resolve, reject) => {\n      var _a;\n      if (!this.adapter.isOpen()) {\n        reject(\"Socket connection has not been established yet.\");\n      } else {\n        if (untypedMessage.channel_message_send) {\n          untypedMessage.channel_message_send.content = JSON.stringify(\n            untypedMessage.channel_message_send.content\n          );\n        } else if (untypedMessage.channel_message_update) {\n          untypedMessage.channel_message_update.content = JSON.stringify(\n            untypedMessage.channel_message_update.content\n          );\n        } else if (untypedMessage.ephemeral_message_send) {\n          untypedMessage.ephemeral_message_send.message.content = JSON.stringify(\n            (_a = untypedMessage.ephemeral_message_send.message) == null ? void 0 : _a.content\n          );\n        }\n        const cid = this.generatecid();\n        this.cIds[cid] = { resolve, reject };\n        setTimeout(() => {\n          reject(\"The socket timed out while waiting for a response.\");\n        }, sendTimeout);\n        untypedMessage.cid = cid;\n        this.adapter.send(untypedMessage);\n      }\n    });\n  }\n  followUsers(userIds) {\n    return __async(this, null, function* () {\n      const response = yield this.send({ status_follow: { user_ids: userIds } });\n      return response.status;\n    });\n  }\n  joinClanChat(clan_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        clan_join: {\n          clan_id\n        }\n      });\n      return response.clan_join;\n    });\n  }\n  follower() {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        follow_event: {}\n      });\n      return response.follow_event;\n    });\n  }\n  joinChat(clan_id, channel_id, channel_type, is_public) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        channel_join: {\n          clan_id,\n          channel_id,\n          channel_type,\n          is_public\n        }\n      });\n      return response.channel;\n    });\n  }\n  handleParticipantMeetState(clan_id, channel_id, display_name, state) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        handle_participant_meet_state_event: {\n          clan_id,\n          channel_id,\n          display_name,\n          state\n        }\n      });\n      return response.handle_participant_meet_state_event;\n    });\n  }\n  leaveChat(clan_id, channel_id, channel_type, is_public) {\n    return this.send({\n      channel_leave: {\n        clan_id,\n        channel_id,\n        channel_type,\n        is_public\n      }\n    });\n  }\n  removeChatMessage(clan_id, channel_id, mode, is_public, message_id, has_attachment, topic_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        channel_message_remove: {\n          clan_id,\n          channel_id,\n          mode,\n          message_id,\n          is_public,\n          has_attachment,\n          topic_id\n        }\n      });\n      return response.channel_message_ack;\n    });\n  }\n  rpc(id, payload, http_key) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        rpc: {\n          id,\n          payload,\n          http_key\n        }\n      });\n      return response.rpc;\n    });\n  }\n  unfollowUsers(user_ids) {\n    return this.send({ status_unfollow: { user_ids } });\n  }\n  updateChatMessage(clan_id, channel_id, mode, is_public, message_id, content, mentions, attachments, hideEditted, topic_id, is_update_msg_topic) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        channel_message_update: {\n          clan_id,\n          channel_id,\n          message_id,\n          content,\n          mentions,\n          attachments,\n          mode,\n          is_public,\n          hide_editted: hideEditted,\n          topic_id,\n          is_update_msg_topic\n        }\n      });\n      return response.channel_message_ack;\n    });\n  }\n  updateStatus(status) {\n    return this.send({ status_update: { status } });\n  }\n  writeEphemeralMessage(receiver_id, clan_id, channel_id, mode, is_public, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar, code, topic_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        ephemeral_message_send: {\n          receiver_id,\n          message: {\n            clan_id,\n            channel_id,\n            mode,\n            is_public,\n            content,\n            mentions,\n            attachments,\n            references,\n            anonymous_message,\n            mention_everyone,\n            avatar,\n            code,\n            topic_id\n          }\n        }\n      });\n      return response.ephemeral_message_send;\n    });\n  }\n  writeChatMessage(clan_id, channel_id, mode, is_public, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar, code, topic_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        channel_message_send: {\n          clan_id,\n          channel_id,\n          mode,\n          is_public,\n          content,\n          mentions,\n          attachments,\n          references,\n          anonymous_message,\n          mention_everyone,\n          avatar,\n          code,\n          topic_id\n        }\n      });\n      return response.channel_message_ack;\n    });\n  }\n  writeMessageReaction(id, clan_id, channel_id, mode, is_public, message_id, emoji_id, emoji, count, message_sender_id, action_delete, topic_id, emoji_recent_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        message_reaction_event: {\n          id,\n          clan_id,\n          channel_id,\n          mode,\n          is_public,\n          message_id,\n          emoji_id,\n          emoji,\n          count,\n          message_sender_id,\n          action: action_delete,\n          topic_id,\n          emoji_recent_id\n        }\n      });\n      return response.message_reaction_event;\n    });\n  }\n  writeMessageTyping(clan_id, channel_id, mode, is_public, sender_display_name) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        message_typing_event: {\n          clan_id,\n          channel_id,\n          mode,\n          is_public,\n          sender_display_name\n        }\n      });\n      return response.message_typing_event;\n    });\n  }\n  writeLastSeenMessage(clan_id, channel_id, mode, message_id, timestamp_seconds, badge_count) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        last_seen_message_event: {\n          clan_id,\n          channel_id,\n          mode,\n          message_id,\n          timestamp_seconds,\n          badge_count\n        }\n      });\n      return response.last_seen_message_event;\n    });\n  }\n  writeLastPinMessage(clan_id, channel_id, mode, is_public, message_id, timestamp_seconds, operation) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        last_pin_message_event: {\n          clan_id,\n          channel_id,\n          mode,\n          is_public,\n          message_id,\n          timestamp_seconds,\n          operation\n        }\n      });\n      return response.last_pin_message_event;\n    });\n  }\n  writeCustomStatus(clan_id, status, time_reset, no_clear) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        custom_status_event: {\n          clan_id,\n          status,\n          time_reset,\n          no_clear\n        }\n      });\n      return response.custom_status_event;\n    });\n  }\n  checkDuplicateName(name, condition_id, type) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        check_name_existed_event: {\n          name,\n          condition_id,\n          type\n        }\n      });\n      return response.check_name_existed_event;\n    });\n  }\n  writeVoiceReaction(emojis, channel_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        voice_reaction_send: {\n          emojis,\n          channel_id\n        }\n      });\n      return response.voice_reaction_send;\n    });\n  }\n  forwardWebrtcSignaling(receiver_id, data_type, json_data, channel_id, caller_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        webrtc_signaling_fwd: {\n          receiver_id,\n          data_type,\n          json_data,\n          channel_id,\n          caller_id\n        }\n      });\n      return response.webrtc_signaling_fwd;\n    });\n  }\n  makeCallPush(receiver_id, json_data, channel_id, caller_id) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        incoming_call_push: {\n          receiver_id,\n          json_data,\n          channel_id,\n          caller_id\n        }\n      });\n      return response.incoming_call_push;\n    });\n  }\n  handleDropdownBoxSelected(message_id, channel_id, selectbox_id, sender_id, user_id, value) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        dropdown_box_selected: {\n          message_id,\n          channel_id,\n          selectbox_id,\n          sender_id,\n          user_id,\n          value\n        }\n      });\n      return response.dropdown_box_selected;\n    });\n  }\n  handleMessageButtonClick(message_id, channel_id, button_id, sender_id, user_id, extra_data) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        message_button_clicked: {\n          message_id,\n          channel_id,\n          button_id,\n          sender_id,\n          user_id,\n          extra_data\n        }\n      });\n      return response.webrtc_signaling_fwd;\n    });\n  }\n  writeChannelAppEvent(clan_id, channel_id, action) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        channel_app_event: {\n          clan_id,\n          channel_id,\n          action\n        }\n      });\n      return response.channel_app_event;\n    });\n  }\n  listDataSocket(request) {\n    return __async(this, null, function* () {\n      const response = yield this.send({\n        list_data_socket: request\n      });\n      return response.list_data_socket;\n    });\n  }\n  pingPong() {\n    return __async(this, null, function* () {\n      if (!this.adapter.isOpen()) {\n        return;\n      }\n      try {\n        yield this.send({ ping: {} }, this._heartbeatTimeoutMs);\n      } catch (e) {\n        if (this.adapter.isOpen()) {\n          if (window && window.console) {\n            console.error(\"Server unreachable from heartbeat.\");\n          }\n          this.onheartbeattimeout();\n          this.adapter.close();\n        }\n        return;\n      }\n      setTimeout(() => this.pingPong(), this._heartbeatTimeoutMs);\n    });\n  }\n};\n_DefaultSocket.DefaultHeartbeatTimeoutMs = 1e4;\n_DefaultSocket.DefaultSendTimeoutMs = 1e4;\n_DefaultSocket.DefaultConnectTimeoutMs = 3e4;\nvar DefaultSocket = _DefaultSocket;\n\n// client.ts\nvar DEFAULT_HOST = \"127.0.0.1\";\nvar DEFAULT_PORT = \"7350\";\nvar DEFAULT_SERVER_KEY = \"defaultkey\";\nvar DEFAULT_TIMEOUT_MS = 3e4;\nvar ChannelType = /* @__PURE__ */ ((ChannelType2) => {\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_CHANNEL\"] = 1] = \"CHANNEL_TYPE_CHANNEL\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_GROUP\"] = 2] = \"CHANNEL_TYPE_GROUP\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_DM\"] = 3] = \"CHANNEL_TYPE_DM\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_GMEET_VOICE\"] = 4] = \"CHANNEL_TYPE_GMEET_VOICE\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_FORUM\"] = 5] = \"CHANNEL_TYPE_FORUM\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_STREAMING\"] = 6] = \"CHANNEL_TYPE_STREAMING\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_THREAD\"] = 7] = \"CHANNEL_TYPE_THREAD\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_APP\"] = 8] = \"CHANNEL_TYPE_APP\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_ANNOUNCEMENT\"] = 9] = \"CHANNEL_TYPE_ANNOUNCEMENT\";\n  ChannelType2[ChannelType2[\"CHANNEL_TYPE_MEZON_VOICE\"] = 10] = \"CHANNEL_TYPE_MEZON_VOICE\";\n  return ChannelType2;\n})(ChannelType || {});\nvar ChannelStreamMode = /* @__PURE__ */ ((ChannelStreamMode2) => {\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_CHANNEL\"] = 2] = \"STREAM_MODE_CHANNEL\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_GROUP\"] = 3] = \"STREAM_MODE_GROUP\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_DM\"] = 4] = \"STREAM_MODE_DM\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_CLAN\"] = 5] = \"STREAM_MODE_CLAN\";\n  ChannelStreamMode2[ChannelStreamMode2[\"STREAM_MODE_THREAD\"] = 6] = \"STREAM_MODE_THREAD\";\n  return ChannelStreamMode2;\n})(ChannelStreamMode || {});\nvar NotificationType = /* @__PURE__ */ ((NotificationType2) => {\n  NotificationType2[NotificationType2[\"ALL_MESSAGE\"] = 1] = \"ALL_MESSAGE\";\n  NotificationType2[NotificationType2[\"MENTION_MESSAGE\"] = 2] = \"MENTION_MESSAGE\";\n  NotificationType2[NotificationType2[\"NOTHING_MESSAGE\"] = 3] = \"NOTHING_MESSAGE\";\n  return NotificationType2;\n})(NotificationType || {});\nvar WebrtcSignalingType = /* @__PURE__ */ ((WebrtcSignalingType2) => {\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_INIT\"] = 0] = \"WEBRTC_SDP_INIT\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_OFFER\"] = 1] = \"WEBRTC_SDP_OFFER\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_ANSWER\"] = 2] = \"WEBRTC_SDP_ANSWER\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_ICE_CANDIDATE\"] = 3] = \"WEBRTC_ICE_CANDIDATE\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_QUIT\"] = 4] = \"WEBRTC_SDP_QUIT\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_TIMEOUT\"] = 5] = \"WEBRTC_SDP_TIMEOUT\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_NOT_AVAILABLE\"] = 6] = \"WEBRTC_SDP_NOT_AVAILABLE\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_JOINED_OTHER_CALL\"] = 7] = \"WEBRTC_SDP_JOINED_OTHER_CALL\";\n  WebrtcSignalingType2[WebrtcSignalingType2[\"WEBRTC_SDP_STATUS_REMOTE_MEDIA\"] = 8] = \"WEBRTC_SDP_STATUS_REMOTE_MEDIA\";\n  return WebrtcSignalingType2;\n})(WebrtcSignalingType || {});\nvar Client = class {\n  constructor(serverkey = DEFAULT_SERVER_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = false, timeout = DEFAULT_TIMEOUT_MS, autoRefreshSession = true) {\n    this.serverkey = serverkey;\n    this.timeout = timeout;\n    this.autoRefreshSession = autoRefreshSession;\n    /** thre refreshTokenPromise */\n    this.refreshTokenPromise = null;\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    const scheme = useSSL ? \"https://\" : \"http://\";\n    const basePath = `${scheme}${host}:${port}`;\n    this.apiClient = new MezonApi(serverkey, timeout, basePath);\n  }\n  /** check session isexpired */\n  isexpired(session) {\n    return session.isexpired(Date.now() / 1e3);\n  }\n  /** Authenticate a user with a custom id against the server. */\n  authenticateMezon(token, create, username, isRemember, vars = {}, options = {}) {\n    const request = {\n      token,\n      vars\n    };\n    return this.apiClient.authenticateMezon(\n      this.serverkey,\n      \"\",\n      request,\n      create,\n      username,\n      isRemember,\n      options\n    ).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false,\n        apiSession.api_url || \"\",\n        false\n      );\n    });\n  }\n  /** Authenticate a user with an email+password against the server. */\n  authenticateEmail(email, password, username, vars) {\n    const request = {\n      username,\n      account: {\n        email,\n        password,\n        vars\n      }\n    };\n    return this.apiClient.authenticateEmail(this.serverkey, \"\", request, username).then((apiSession) => {\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false,\n        apiSession.api_url || \"\",\n        false\n      );\n    });\n  }\n  /** set base path */\n  setBasePath(host, port, useSSL) {\n    this.host = host;\n    this.port = port;\n    this.useSSL = useSSL;\n    const scheme = useSSL ? \"https://\" : \"http://\";\n    const basePath = `${scheme}${host}:${port}`;\n    return this.apiClient.setBasePath(basePath);\n  }\n  /** Add users to a channel, or accept their join requests. */\n  addChannelUsers(session, channelId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addChannelUsers(session.token, channelId, ids).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add friends by ID or username to a user's account. */\n  addFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addFriends(session.token, ids, usernames).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Block one or more users by ID or username. */\n  blockFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.blockFriends(session.token, ids, usernames).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Create a new group with the current user as the creator and superadmin. */\n  uploadAttachmentFile(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.uploadAttachmentFile(session.token, request);\n    });\n  }\n  /** Create a channel within clan */\n  createChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createChannelDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a clan */\n  createClanDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createClanDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /**  */\n  createCategoryDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createCategoryDesc(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a new role for clan. */\n  createRole(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createRole(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Create a new event for clan. */\n  createEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createEvent(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** add role for channel. */\n  addRolesChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addRolesChannelDesc(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update action role when delete role */\n  deleteRoleChannelDesc(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteRoleChannelDesc(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteApp(session, appId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteApp(session.token, appId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** A socket created with the client's configuration. */\n  createSocket(useSSL = false, verbose = false, adapter = new WebSocketAdapterText(), sendTimeoutMs = DefaultSocket.DefaultSendTimeoutMs) {\n    return new DefaultSocket(\n      this.host,\n      this.port,\n      useSSL,\n      verbose,\n      adapter,\n      sendTimeoutMs\n    );\n  }\n  /** Delete one or more users by ID or username. */\n  deleteFriends(session, ids, usernames) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteFriends(session.token, ids, usernames).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a channel by ID. */\n  deleteChannelDesc(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteChannelDesc(session.token, channelId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a clan desc by ID. */\n  deleteClanDesc(session, clanDescId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanDesc(session.token, clanDescId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a category by ID. */\n  deleteCategoryDesc(session, categoryId, clanId, categoryLabel) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteCategoryDesc(session.token, categoryId, clanId, categoryLabel).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete one or more notifications */\n  deleteNotifications(session, ids, category) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotifications(session.token, ids, category).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Delete a role by ID. */\n  deleteRole(session, roleId, clanId, roleLabel) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteRole(session.token, roleId, \"\", clanId, roleLabel).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete a event by ID. */\n  deleteEvent(session, eventId, clanId, creatorId, eventLabel, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteEvent(\n        session.token,\n        eventId,\n        clanId,\n        creatorId,\n        eventLabel,\n        channelId\n      ).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** update user a event by ID. */\n  updateEventUser(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateEventUser(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Submit an event for processing in the server's registered runtime custom events handler. */\n  emitEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.event(session.token, request).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Fetch the current user's account. */\n  getAccount(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getAccount(session.token);\n    });\n  }\n  /** Fetch zero or more users by ID and/or username. */\n  getUsers(session, ids, usernames, facebookIds) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUsers(session.token, ids, usernames, facebookIds).then((response) => {\n        var result = {\n          users: []\n        };\n        if (response.users == null) {\n          return Promise.resolve(result);\n        }\n        response.users.forEach((u) => {\n          result.users.push({\n            avatar_url: u.avatar_url,\n            create_time: u.create_time,\n            display_name: u.display_name,\n            edge_count: u.edge_count ? Number(u.edge_count) : 0,\n            facebook_id: u.facebook_id,\n            gamecenter_id: u.gamecenter_id,\n            google_id: u.google_id,\n            id: u.id,\n            lang_tag: u.lang_tag,\n            location: u.location,\n            online: u.online,\n            steam_id: u.steam_id,\n            timezone: u.timezone,\n            update_time: u.update_time,\n            username: u.username,\n            metadata: u.metadata ? safeJSONParse(u.metadata) : void 0\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Kick a set of users from a clan. */\n  removeClanUsers(session, clanId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeClanUsers(session.token, clanId, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** Kick users from a channel, or decline their join requests. */\n  removeChannelUsers(session, channelId, ids) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeChannelUsers(session.token, channelId, ids).then((response) => {\n        return Promise.resolve(response != void 0);\n      });\n    });\n  }\n  /** List a channel's message history. */\n  listChannelMessages(session, clanId, channelId, messageId, direction, limit, topicId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelMessages(\n        session.token,\n        clanId,\n        channelId,\n        messageId,\n        direction,\n        limit,\n        topicId\n      ).then((response) => {\n        var result = {\n          messages: [],\n          last_seen_message: response.last_seen_message,\n          last_sent_message: response.last_sent_message\n        };\n        if (response.messages == null) {\n          return Promise.resolve(result);\n        }\n        response.messages.forEach((m) => {\n          var content, reactions, mentions, attachments, references;\n          try {\n            content = safeJSONParse(m.content);\n          } catch (e) {\n            console.log(\"error parse content\", e);\n          }\n          try {\n            reactions = safeJSONParse(m.reactions || \"[]\");\n          } catch (e) {\n            console.log(\"error parse reactions\", e);\n          }\n          try {\n            mentions = safeJSONParse(m.mentions || \"[]\");\n          } catch (e) {\n            console.log(\"error parse mentions\", e);\n          }\n          try {\n            attachments = safeJSONParse(m.attachments || \"[]\");\n          } catch (e) {\n            console.log(\"error parse attachments\", e);\n          }\n          try {\n            references = safeJSONParse(m.references || \"[]\");\n          } catch (e) {\n            console.log(\"error parse references\", e);\n          }\n          result.messages.push({\n            channel_id: m.channel_id,\n            code: m.code ? Number(m.code) : 0,\n            create_time: m.create_time || \"\",\n            id: m.message_id,\n            sender_id: m.sender_id,\n            update_time: m.update_time,\n            username: m.username,\n            display_name: m.display_name,\n            avatar: m.avatar,\n            content,\n            channel_label: m.channel_label,\n            clan_logo: m.clan_logo,\n            category_name: m.category_name,\n            clan_nick: m.clan_nick,\n            clan_avatar: m.clan_avatar,\n            attachments,\n            mentions,\n            reactions,\n            references,\n            clan_id: m.clan_id,\n            create_time_seconds: m.create_time_seconds,\n            update_time_seconds: m.update_time_seconds,\n            hide_editted: m.hide_editted\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelVoiceUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelVoiceUsers(\n        session.token,\n        clanId,\n        channelId,\n        channelType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          voice_channel_users: []\n        };\n        if (response.voice_channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.voice_channel_users.forEach((gu) => {\n          result.voice_channel_users.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            user_id: gu.user_id,\n            participant: gu.participant\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelUsers(\n        session.token,\n        clanId,\n        channelId,\n        channelType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          channel_users: [],\n          cursor: response.cursor,\n          channel_id: response.channel_id\n        };\n        if (response.channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.channel_users.forEach((gu) => {\n          result.channel_users.push({\n            user_id: gu.user_id,\n            role_id: gu.role_id,\n            thread_id: gu.thread_id,\n            clan_avatar: gu.clan_avatar,\n            clan_nick: gu.clan_nick,\n            id: gu.id,\n            clan_id: gu.clan_id\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's attachment. */\n  listChannelAttachments(session, clanId, channelId, fileType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelAttachment(\n        session.token,\n        clanId,\n        channelId,\n        fileType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          attachments: []\n        };\n        if (response.attachments == null) {\n          return Promise.resolve(result);\n        }\n        response.attachments.forEach((at) => {\n          result.attachments.push({\n            filename: at.filename,\n            filesize: at.filesize,\n            filetype: at.filetype,\n            id: at.id,\n            uploader: at.uploader,\n            url: at.url,\n            message_id: at.message_id,\n            create_time: at.create_time,\n            width: at.width,\n            height: at.height\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listClanUsers(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanUsers(session.token, clanId).then((response) => {\n        var result = {\n          clan_users: [],\n          cursor: response.cursor,\n          clan_id: response.clan_id\n        };\n        if (response.clan_users == null) {\n          return Promise.resolve(result);\n        }\n        response.clan_users.forEach((gu) => {\n          var _a;\n          result.clan_users.push({\n            user: {\n              avatar_url: gu.user.avatar_url,\n              create_time: gu.user.create_time,\n              display_name: gu.user.display_name,\n              edge_count: gu.user.edge_count ? Number(gu.user.edge_count) : 0,\n              facebook_id: gu.user.facebook_id,\n              gamecenter_id: gu.user.gamecenter_id,\n              google_id: gu.user.google_id,\n              id: gu.user.id,\n              lang_tag: gu.user.lang_tag,\n              location: gu.user.location,\n              online: gu.user.online,\n              is_mobile: (_a = gu.user) == null ? void 0 : _a.is_mobile,\n              steam_id: gu.user.steam_id,\n              timezone: gu.user.timezone,\n              update_time: gu.user.update_time,\n              username: gu.user.username,\n              metadata: gu.user.metadata ? safeJSONParse(gu.user.metadata) : void 0\n            },\n            role_id: gu.role_id,\n            clan_nick: gu.clan_nick,\n            clan_avatar: gu.clan_avatar\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List channels. */\n  listChannelDescs(session, limit, state, cursor, clanId, channelType) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelDescs(\n        session.token,\n        limit,\n        state,\n        cursor,\n        clanId,\n        channelType\n      ).then((response) => {\n        var result = {\n          channeldesc: [],\n          next_cursor: response.next_cursor,\n          prev_cursor: response.prev_cursor,\n          cacheable_cursor: response.cacheable_cursor\n        };\n        if (response.channeldesc == null) {\n          return Promise.resolve(result);\n        }\n        result.channeldesc = response.channeldesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List clans */\n  listClanDescs(session, limit, state, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanDescs(session.token, limit, state, cursor).then((response) => {\n        var result = {\n          clandesc: []\n        };\n        if (response.clandesc == null) {\n          return Promise.resolve(result);\n        }\n        result.clandesc = response.clandesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List categories. */\n  listCategoryDescs(session, clanId, creatorId, categoryName) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listCategoryDescs(session.token, clanId, creatorId, categoryName).then((response) => {\n        var result = {\n          categorydesc: []\n        };\n        if (response.categorydesc == null) {\n          return Promise.resolve(result);\n        }\n        result.categorydesc = response.categorydesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** List event */\n  listEvents(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listEvents(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List permission */\n  getListPermission(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListPermission(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List user roles */\n  listRolePermissions(session, roleId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRolePermissions(session.token, roleId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List user roles */\n  listRoleUsers(session, roleId, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRoleUsers(session.token, roleId, limit, cursor).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  registFCMDeviceToken(session, tokenId, deviceId, platform, voipToken) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.registFCMDeviceToken(session.token, tokenId, deviceId, platform, voipToken).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get a clan desc profile */\n  getClanDescProfile(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getClanDescProfile(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getUserProfileOnClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUserProfileOnClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //\n  closeDirectMess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.closeDirectMess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //\n  openDirectMess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.openDirectMess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add a custom ID to the social profiles on the current user's account. */\n  linkMezon(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkMezon(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Add an email+password to the social profiles on the current user's account. */\n  linkEmail(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.linkEmail(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** List all friends for the current user. */\n  listFriends(session, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listFriends(session.token, limit, state, cursor).then((response) => {\n        var result = {\n          friends: [],\n          cursor: response.cursor\n        };\n        if (response.friends == null) {\n          return Promise.resolve(result);\n        }\n        response.friends.forEach((f) => {\n          var _a;\n          result.friends.push({\n            user: {\n              avatar_url: f.user.avatar_url,\n              create_time: f.user.create_time,\n              display_name: f.user.display_name,\n              edge_count: f.user.edge_count ? Number(f.user.edge_count) : 0,\n              facebook_id: f.user.facebook_id,\n              gamecenter_id: f.user.gamecenter_id,\n              google_id: f.user.google_id,\n              id: f.user.id,\n              lang_tag: f.user.lang_tag,\n              location: f.user.location,\n              online: f.user.online,\n              steam_id: f.user.steam_id,\n              timezone: f.user.timezone,\n              update_time: f.user.update_time,\n              username: f.user.username,\n              is_mobile: (_a = f.user) == null ? void 0 : _a.is_mobile,\n              metadata: f.user.metadata ? safeJSONParse(f.user.metadata) : void 0\n            },\n            state: f.state,\n            source_id: f.source_id\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Fetch list of notifications. */\n  listNotifications(session, clanId, limit, notificationId, category, direction) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listNotifications(\n        session.token,\n        limit,\n        clanId,\n        notificationId,\n        category,\n        direction\n      ).then((response) => {\n        var result = {\n          cacheable_cursor: response.cacheable_cursor,\n          notifications: []\n        };\n        if (response.notifications == null) {\n          return Promise.resolve(result);\n        }\n        response.notifications.forEach((n) => {\n          result.notifications.push({\n            id: n.id,\n            subject: n.subject,\n            content: n.content ? safeJSONParse(n.content) : void 0,\n            code: n.code ? Number(n.code) : 0,\n            sender_id: n.sender_id,\n            create_time: n.create_time,\n            persistent: n.persistent,\n            category: n.category\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  /** Execute an RPC function on the server. */\n  rpc(session, basicAuthUsername, basicAuthPassword, id, input) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.rpcFunc(\n        session.token,\n        basicAuthUsername,\n        basicAuthPassword,\n        id,\n        JSON.stringify(input)\n      ).then((response) => {\n        return Promise.resolve({\n          id: response.id,\n          payload: !response.payload ? void 0 : safeJSONParse(response.payload)\n        });\n      });\n    });\n  }\n  /** Execute an RPC function on the server. */\n  rpcHttpKey(httpKey, id, input) {\n    return __async(this, null, function* () {\n      return this.apiClient.rpcFunc2(\"\", id, input && JSON.stringify(input) || \"\", httpKey).then((response) => {\n        return Promise.resolve({\n          id: response.id,\n          payload: !response.payload ? void 0 : safeJSONParse(response.payload)\n        });\n      }).catch((err) => {\n        throw err;\n      });\n    });\n  }\n  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\n  sessionLogout(session, token, refreshToken, deviceId, platform) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.sessionLogout(session.token, {\n        refresh_token: refreshToken,\n        token,\n        device_id: deviceId,\n        platform\n      }).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\n  sessionRefresh(_0) {\n    return __async(this, arguments, function* (session, vars = {}) {\n      if (!session) {\n        console.error(\"Cannot refresh a null session.\");\n        return session;\n      }\n      if (session.created && session.expires_at - session.created_at < 70) {\n        console.warn(\n          \"Session lifetime too short, please set '--session.token_expiry_sec' option. See the documentation for more info: https://mezon.vn/docs/mezon/getting-started/configuration/#session\"\n        );\n      }\n      if (session.created && session.refresh_expires_at - session.created_at < 3700) {\n        console.warn(\n          \"Session refresh lifetime too short, please set '--session.refresh_token_expiry_sec' option. See the documentation for more info: https://mezon.vn/docs/mezon/getting-started/configuration/#session\"\n        );\n      }\n      if (this.refreshTokenPromise) {\n        return this.refreshTokenPromise;\n      }\n      this.refreshTokenPromise = new Promise((resolve, reject) => __async(this, null, function* () {\n        try {\n          const apiSession = yield this.apiClient.sessionRefresh(\n            this.serverkey,\n            \"\",\n            {\n              token: session.refresh_token,\n              vars,\n              is_remember: session.is_remember\n            }\n          );\n          session.update(apiSession.token, apiSession.refresh_token, apiSession.is_remember || false);\n          resolve(session);\n        } catch (error) {\n          console.error(\"Session refresh failed:\", error);\n          reject(error);\n        } finally {\n          this.refreshTokenPromise = null;\n        }\n      }));\n      return this.refreshTokenPromise;\n    });\n  }\n  /** Remove custom ID from the social profiles on the current user's account. */\n  unlinkCustom(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkMezon(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Remove an email+password from the social profiles on the current user's account. */\n  unlinkEmail(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlinkEmail(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in the current user's account. */\n  updateAccount(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateAccount(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given channel */\n  updateChannelDesc(session, channelId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateChannelDesc(session.token, channelId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan. */\n  updateClanDesc(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanDesc(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given category. */\n  updateCategory(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateCategory(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given clan profile. */\n  updateClanDescProfile(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanDescProfile(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  updateUserProfileByClan(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateUserProfileByClan(session.token, clanId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given role. */\n  updateRole(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateRole(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given event. */\n  updateEvent(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateEvent(session.token, roleId, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Update fields in a given event. */\n  updateApp(session, roleId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateApp(session.token, roleId, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Update fields in a given clan profile. */\n  createLinkInviteUser(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createLinkInviteUser(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get link invite user */\n  getLinkInvite(session, inviteId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getLinkInvite(session.token, inviteId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Get permission of user in the clan */\n  GetRoleOfUserInTheClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getRoleOfUserInTheClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** invite user */\n  inviteUser(session, inviteId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.inviteUser(session.token, inviteId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Set default notification clan*/\n  setNotificationClan(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationClanSetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification channel*/\n  setNotificationChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationChannelSetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification category*/\n  setMuteNotificationCategory(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setMuteNotificationCategory(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set notification channel*/\n  setMuteNotificationChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setMuteNotificationChannel(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** update channel private*/\n  updateChannelPrivate(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateChannelPrivate(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Set default notification category*/\n  setNotificationCategory(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationCategorySetting(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteNotificationCategory(session, category_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotificationCategorySetting(session.token, category_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteNotificationChannel(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotificationChannel(session.token, channel_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** */\n  setNotificationReactMessage(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setNotificationReactMessage(session.token, { channel_id }).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //** */\n  deleteNotiReactMessage(session, channel_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteNotiReactMessage(session.token, channel_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** query message in elasticsearch */\n  searchMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.searchMessage(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** */\n  createMessage2Inbox(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createMessage2Inbox(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** */\n  createPinMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createPinMessage(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  pinMessagesList(session, messageId, channelId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPinMessagesList(session.token, messageId, channelId, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //** */\n  deletePinMessage(session, message_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deletePinMessage(session.token, message_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** create clan emoji */\n  createClanEmoji(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createClanEmoji(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**update clan emoji by id */\n  updateClanEmojiById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanEmojiById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**delete clan emoji by id */\n  deleteByIdClanEmoji(session, id, clan_id, emojiLabel) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanEmojiById(session.token, id, clan_id, emojiLabel).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**create webhook for chaneel */\n  generateWebhookLink(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.generateWebhook(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list webhook belong to the channel */\n  listWebhookByChannelId(session, channel_id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listWebhookByChannelId(session.token, channel_id, clan_id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**update webhook name by id */\n  updateWebhookById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateWebhookById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**disabled webhook by id */\n  deleteWebhookById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteWebhookById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**check duplicate clan name */\n  checkDuplicateClanName(session, clan_name) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.checkDuplicateClanName(session.token, clan_name).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**Add a new sticker */\n  addClanSticker(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addClanSticker(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**Delete a sticker by ID*/\n  deleteClanStickerById(session, id, clan_id, stickerLabel) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanStickerById(session.token, id, clan_id, stickerLabel).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**Update a sticker by ID*/\n  updateClanStickerById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanStickerById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //** update the category of a channel */\n  changeChannelCategory(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.changeChannelCategory(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** */\n  setRoleChannelPermission(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setRoleChannelPermission(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  addApp(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addApp(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getApp(session, id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getApp(session.token, id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listApps(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listApps(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  addAppToClan(session, appId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addAppToClan(session.token, appId, clanId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  getSystemMessagesList(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getSystemMessagesList(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getSystemMessageByClanId(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getSystemMessageByClanId(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  createSystemMessage(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createSystemMessage(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  updateSystemMessage(session, clanId, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateSystemMessage(session.token, clanId, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteSystemMessage(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteSystemMessage(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  updateCategoryOrder(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateCategoryOrder(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteCategoryOrder(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteCategoryOrder(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  givecoffee(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.giveMeACoffee(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  sendToken(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.sendToken(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  listStreamingChannels(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listStreamingChannels(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List a channel's users. */\n  listStreamingChannelUsers(session, clanId, channelId, channelType, state, limit, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listStreamingChannelUsers(\n        session.token,\n        clanId,\n        channelId,\n        channelType,\n        limit,\n        state,\n        cursor\n      ).then((response) => {\n        var result = {\n          streaming_channel_users: []\n        };\n        if (response.streaming_channel_users == null) {\n          return Promise.resolve(result);\n        }\n        response.streaming_channel_users.forEach((gu) => {\n          result.streaming_channel_users.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            user_id: gu.user_id,\n            participant: gu.participant\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  registerStreamingChannel(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.registerStreamingChannel(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** List a channel's users. */\n  listChannelApps(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelApps(session.token, clanId).then((response) => {\n        var result = {\n          channel_apps: []\n        };\n        if (response.channel_apps == null) {\n          return Promise.resolve(result);\n        }\n        response.channel_apps.forEach((gu) => {\n          result.channel_apps.push({\n            id: gu.id,\n            channel_id: gu.channel_id,\n            app_id: gu.app_id,\n            clan_id: gu.clan_id,\n            app_url: gu.app_url\n          });\n        });\n        return Promise.resolve(result);\n      });\n    });\n  }\n  getChannelCategoryNotiSettingsList(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getChannelCategoryNotiSettingsList(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationCategory(session, categoryId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationCategory(session.token, categoryId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationChannel(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationChannel(session.token, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationClan(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationClan(session.token, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getNotificationReactMessage(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getNotificationReactMessage(session.token, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  hashtagDMList(session, userId, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.hashtagDMList(session.token, userId, limit).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listChannelByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listChannelUsersUC(session, channel_id, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelUsersUC(session.token, channel_id, limit).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getListEmojisByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListEmojisByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  emojiRecentList(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.emojiRecentList(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getListStickersByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListStickersByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listUserClansByUserId(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listUserClansByUserId(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listRoles(session, clanId, limit, state, cursor) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listRoles(session.token, clanId, limit, state, cursor).then((response) => {\n        var result = {\n          clan_id: clanId,\n          roles: response.roles\n        };\n        return Promise.resolve(result);\n      });\n    });\n  }\n  listUserPermissionInChannel(session, clanId, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listUserPermissionInChannel(session.token, clanId, channelId).then((response) => {\n        var result = {\n          clan_id: clanId,\n          channel_id: channelId,\n          permissions: response.permissions\n        };\n        return Promise.resolve(result);\n      });\n    });\n  }\n  getPermissionByRoleIdChannelId(session, roleId, channelId, userId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPermissionByRoleIdChannelId(session.token, roleId, channelId, userId).then((response) => {\n        var result = {\n          role_id: roleId,\n          channel_id: channelId,\n          permission_role_channel: response.permission_role_channel,\n          user_id: userId\n        };\n        return Promise.resolve(result);\n      });\n    });\n  }\n  markAsRead(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.markAsRead(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** List Threads. */\n  listThreadDescs(session, channelId, limit, state, clanId, threadId, page) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listThreadDescs(\n        session.token,\n        channelId,\n        limit,\n        state,\n        clanId,\n        threadId,\n        page\n      ).then((response) => {\n        var result = {\n          channeldesc: []\n        };\n        if (response.channeldesc == null) {\n          return Promise.resolve(result);\n        }\n        result.channeldesc = response.channeldesc;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  leaveThread(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.leaveThread(session.token, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getChannelSettingInClan(session, clanId, parentId, categoryId, privateChannel, active, status, type, limit, page, channelLabel) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listChannelSetting(\n        session.token,\n        clanId,\n        parentId,\n        categoryId,\n        privateChannel,\n        active,\n        status,\n        type,\n        limit,\n        page,\n        channelLabel\n      ).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getChannelCanvasList(session, channelId, clanId, limit, page) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getChannelCanvasList(session.token, channelId, clanId, limit, page).then((response) => {\n        var result = {\n          channel_canvases: []\n        };\n        if (response.channel_canvases == null) {\n          return Promise.resolve(result);\n        }\n        result.clan_id = response.clan_id;\n        result.channel_id = response.channel_id;\n        result.channel_canvases = response.channel_canvases;\n        result.count = response.count;\n        return Promise.resolve(result);\n      });\n    });\n  }\n  getChannelCanvasDetail(session, id, clanId, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getChannelCanvasDetail(session.token, id, clanId, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  editChannelCanvases(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.editChannelCanvases(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //** */\n  deleteChannelCanvas(session, canvasId, clanId, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteChannelCanvas(session.token, canvasId, clanId, channelId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  addFavoriteChannel(session, channelId, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addChannelFavorite(session.token, {\n        channel_id: channelId,\n        clan_id: clanId\n      }).then((response) => {\n        return response;\n      });\n    });\n  }\n  removeFavoriteChannel(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.removeChannelFavorite(session.token, channelId).then((response) => {\n        return response;\n      });\n    });\n  }\n  getListFavoriteChannel(session, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getListFavoriteChannel(session.token, clanId).then((response) => {\n        return response;\n      });\n    });\n  }\n  /** List activity */\n  listActivity(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listActivity(session.token).then((response) => {\n        return response;\n      });\n    });\n  }\n  createActiviy(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createActiviy(session.token, request).then((response) => {\n        return response;\n      });\n    });\n  }\n  createQRLogin(requet) {\n    return __async(this, null, function* () {\n      const apiSession = yield this.apiClient.createQRLogin(\n        this.serverkey,\n        \"\",\n        requet\n      );\n      const response = {\n        login_id: apiSession.login_id,\n        create_time_second: apiSession.create_time_second\n      };\n      return response;\n    });\n  }\n  checkLoginRequest(requet) {\n    return __async(this, null, function* () {\n      const apiSession = yield this.apiClient.checkLoginRequest(\n        this.serverkey,\n        \"\",\n        requet\n      );\n      if (!(apiSession == null ? void 0 : apiSession.token)) {\n        return null;\n      }\n      return new Session(\n        apiSession.token || \"\",\n        apiSession.refresh_token || \"\",\n        apiSession.created || false,\n        apiSession.api_url || \"\",\n        apiSession.is_remember || false\n      );\n    });\n  }\n  confirmLogin(session, basePath, body) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.confirmLogin(session.token, basePath, body).then((response) => {\n        return response;\n      });\n    });\n  }\n  getChanEncryptionMethod(session, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getChanEncryptionMethod(session.token, channelId).then((response) => {\n        return response;\n      });\n    });\n  }\n  setChanEncryptionMethod(session, channelId, method) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.setChanEncryptionMethod(session.token, channelId, { method }).then((response) => {\n        return response;\n      });\n    });\n  }\n  getPubKeys(session, userIds) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getPubKeys(session.token, userIds).then((response) => {\n        return response;\n      });\n    });\n  }\n  pushPubKey(session, PK) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.pushPubKey(session.token, { PK }).then((response) => {\n        return response;\n      });\n    });\n  }\n  getKeyServer(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getKeyServer(session.token).then((response) => {\n        return response;\n      });\n    });\n  }\n  listAuditLog(session, actionLog, userId, clanId, date_log) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listAuditLog(session.token, actionLog, userId, clanId, date_log).then((response) => {\n        return response;\n      });\n    });\n  }\n  listOnboarding(session, clanId, guideType, limit, page) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listOnboarding(session.token, clanId, guideType, limit, page).then((response) => {\n        return response;\n      });\n    });\n  }\n  getOnboardingDetail(session, id, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getOnboardingDetail(session.token, id, clanId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  createOnboarding(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createOnboarding(session.token, request).then((response) => {\n        return response;\n      });\n    });\n  }\n  updateOnboarding(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateOnboarding(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  deleteOnboarding(session, id, clanId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteOnboarding(session.token, id, clanId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**create webhook for clan */\n  generateClanWebhook(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.generateClanWebhook(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list webhook belong to the clan */\n  listClanWebhook(session, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listClanWebhook(session.token, clan_id).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**disabled webhook by id */\n  deleteClanWebhookById(session, id, clan_id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteClanWebhookById(session.token, id, clan_id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**update webhook name by id */\n  updateClanWebhookById(session, id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanWebhookById(session.token, id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**list onboarding step */\n  listOnboardingStep(session, clan_id, limit, page) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listOnboardingStep(session.token, clan_id, limit, page).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**update onboarding step by id */\n  updateOnboardingStepByClanId(session, clan_id, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateOnboardingStepByClanId(session.token, clan_id, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**update status */\n  updateUserStatus(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateUserStatus(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  //**get user status */\n  getUserStatus(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getUserStatus(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** list transaction detail */\n  listTransactionDetail(session, transId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listTransactionDetail(session.token, transId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list wallet ledger */\n  listWalletLedger(session, limit, filter, transactionId, page) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listWalletLedger(session.token, limit, filter, transactionId, page).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list sd topic */\n  listSdTopic(session, clanId, limit) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listSdTopic(session.token, clanId, limit).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**post sd topic */\n  createSdTopic(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createSdTopic(session.token, request).then((response) => {\n        return response;\n      });\n    });\n  }\n  //**list sd topic */\n  getTopicDetail(session, topicId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getTopicDetail(session.token, topicId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**create room channel apps */\n  createRoomChannelApps(session, body) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createRoomChannelApps(session.token, body).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Generate Meet Token */\n  generateMeetToken(session, body) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.generateMeetToken(session.token, body).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**list webhook belong to the clan */\n  listMezonOauthClient(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listMezonOauthClient(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  getMezonOauthClient(session, clientId, clientName) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.getMezonOauthClient(session.token, clientId, clientName).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  updateMezonOauthClient(session, body) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateMezonOauthClient(session.token, body).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**search thread */\n  searchThread(session, clanId, channelId, label) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.searchThread(session.token, clanId, channelId, label).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  //**Generate Hash */\n  generateHashChannelApps(session, appId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.generateHashChannelApps(session.token, appId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  registrationPassword(session, email, password) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.registrationEmail(session.token, {\n        email,\n        password\n      }).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Add user event */\n  addUserEvent(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addUserEvent(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** Delete user event */\n  deleteUserEvent(session, clanId, eventId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteUserEvent(session.token, clanId, eventId).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  updateRoleOrder(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateRoleOrder(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteAccount(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteAccount(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  createExternalMezonMeet(session) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.createExternalMezonMeet(session.token).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  generateMeetTokenExternal(basePath, token, displayName, isGuest) {\n    return __async(this, null, function* () {\n      return this.apiClient.generateMeetTokenExternal(\"\", basePath, token, displayName, isGuest).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  /** Update clan order to view. */\n  updateClanOrder(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateClanOrder(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  /** list clan discover. */\n  listClanDiscover(basePath, request) {\n    return __async(this, null, function* () {\n      return this.apiClient.clanDiscover(this.serverkey, \"\", basePath, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listQuickMenuAccess(session, botId, channelId) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listQuickMenuAccess(session.token, botId, channelId).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  deleteQuickMenuAccess(session, id) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.deleteQuickMenuAccess(session.token, id).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  addQuickMenuAccess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.addQuickMenuAccess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  updateQuickMenuAccess(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.updateQuickMenuAccess(session.token, request).then((response) => {\n        return response !== void 0;\n      });\n    });\n  }\n  unlockItem(session, request) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.unlockItem(session.token, request).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n  listForSaleItems(session, page) {\n    return __async(this, null, function* () {\n      if (this.autoRefreshSession && session.refresh_token && session.isexpired(Date.now() / 1e3)) {\n        yield this.sessionRefresh(session);\n      }\n      return this.apiClient.listForSaleItems(session.token, page).then((response) => {\n        return Promise.resolve(response);\n      });\n    });\n  }\n};\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/../mezon-js/dist/mezon-js.cjs.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Copyright 2021 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nexports.__esModule = true;\r\nvar mezon_js_1 = __webpack_require__(/*! mezon-js */ \"../mezon-js/dist/mezon-js.cjs.js\");\r\nvar mezon_js_protobuf_1 = __webpack_require__(/*! mezon-js-protobuf */ \"../mezon-js-protobuf/dist/mezon-js-protobuf.cjs.js\");\r\nvar useSSL = true; // Enable if server is run with an SSL certificate.\r\nvar clientgw = new mezon_js_1.Client(\"defaultkey\", \"dev-mezon.nccsoft.vn\", \"8088\", useSSL);\r\nvar client = new mezon_js_1.Client(\"defaultkey\", \"172.16.11.90\", \"7350\", false);\r\nclientgw.authenticateEmail(\"pocolomos@gmail.com\", \"C0nandoiner123$\").then(function (session) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var socket, session2, resp;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                console.log(\"authenticated.\", session);\r\n                socket = client.createSocket(false, true, new mezon_js_protobuf_1.WebSocketAdapterPb());\r\n                return [4 /*yield*/, socket.connect(session, true, \"desktop\")];\r\n            case 1:\r\n                session2 = _a.sent();\r\n                console.log(\"session\", session2);\r\n                return [4 /*yield*/, socket.listDataSocket({\r\n                        api_name: \"ListClanDescs\",\r\n                        list_clan_req: {\r\n                            limit: { value: 100 },\r\n                            state: { value: 1 }\r\n                        }\r\n                    })];\r\n            case 2:\r\n                resp = _a.sent();\r\n                console.log('resp', resp);\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}); })[\"catch\"](function (e) {\r\n    console.log(\"error authenticating.\");\r\n});\r\n\n\n//# sourceURL=webpack://mezon-js-webpack-example/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;