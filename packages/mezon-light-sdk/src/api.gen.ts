// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { buildFetchOptions } from "./utils";
import * as tsproto from "./proto/api";
import { encode } from "js-base64";

/** A message sent on a channel. */
export interface ChannelMessage {
  //The unique ID of this message.
  id: string;
  //
  avatar?: string;
  //The channel this message belongs to.
  channel_id: string;
  //The name of the chat room, or an empty string if this message was not sent through a chat room.
  channel_label: string;
  //The clan this message belong to.
  clan_id?: string;
  //The code representing a message type or category.
  code: number;
  //The content payload.
  content: string;
  //
  attachments?: Array<ApiMessageAttachment>;
  //
  referenced_message?: string[];
  //True if the message was persisted to the channel's history, false otherwise.
  persistent?: boolean;
  //Message sender, usually a user ID.
  sender_id: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  clan_logo?: string;
  //The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  category_name?: string;
  //The username of the message sender, if any.
  username?: string;
  // The clan nick name
  clan_nick?: string;
  // The clan avatar
  clan_avatar?: string;
  //
  display_name?: string;
  //
  create_time_seconds?: number;
  //
  update_time_seconds?: number;
  //
  mode?: number;
  //
  message_id?: string;
  //
  hide_editted?: boolean;
  //
  is_public?: boolean;
  //
  topic_id?: string;
}

/**  */
export interface ApiMessageAttachment {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  url?: string;
  //
  width?: number;
  //
  thumbnail?: string;
  // The channel this message belongs to.
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  // The message that user react
  message_id?: string;
  // Message sender, usually a user ID.
  sender_id?: string;
  // duration for video in seconds
  duration?: number;
  // create_time_seconds
  create_time_seconds?: number;
}

/** Authenticate against the server with a refresh token. */
export interface ApiSessionRefreshRequest {
  //Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  //Refresh token.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** A user's session used to authenticate messages. */
export interface ApiSession {
  //True if the corresponding account was just created, false otherwise.
  created?: boolean;
  //Refresh token that can be used for session token renewal.
  refresh_token?: string;
  //Authentication credentials.
  token?: string;
  // Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  // endpoint url that belong to user
  api_url?: string;
  // id token for zklogin
  id_token?: string;
}

/**  */
export interface ApiChannelDescription {
  //
  active?: number;
  //
  age_restricted?: number;
  //
  category_id?: string;
  //
  category_name?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  count_mess_unread?: number;
  //
  create_time_seconds?: number;
  //creator ID.
  creator_id?: string;
  //
  creator_name?: string;
  //
  e2ee?: number;
  //
  is_mute?: boolean;
  //
  last_pin_message?: string;
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  channel_avatar?: string;
  //The parent channel this message belongs to.
  parent_id?: string;
  //The channel type.
  type?: number;
  //
  update_time_seconds?: number;
  //
  app_id?: string;
  //
  topic?: string;
  //
  user_ids?: Array<string>;
  //
  usernames?: Array<string>;
  //
  display_names?: Array<string>;
  //
  onlines?: Array<boolean>;
  // DM status
  avatars?: Array<string>;
  // member count
  member_count?: number;
}

/**  */
export interface ApiChannelMessageHeader {
  //
  attachment?: Uint8Array;
  //
  content?: string;
  //
  id?: string;
  //
  mention?: Uint8Array;
  //
  reaction?: Uint8Array;
  //
  reference?: Uint8Array;
  //
  repliers?: Array<string>;
  //
  sender_id?: string;
  //
  timestamp_seconds?: number;
}

/** Create a channel within clan. */
export interface ApiCreateChannelDescRequest {
  //
  app_id?: string;
  //
  category_id?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //The parent channel this message belongs to.
  parent_id?: string;
  //The channel type.
  type?: number;
  //The users to add.
  user_ids?: Array<string>;
}

export interface ApiAuthenticationIdToken {
  /** ID token from identity provider */
  id_token: string;
  /** User ID associated with the token. */
  user_id: string;
  /** Username associated with the token. */
  username: string;
}

export interface AuthenticationIdTokenResponse {
  /** Authentication token */
  token: string;
  /** Refresh token for session renewal */
  refresh_token: string;
  /** API URL for the authenticated user */
  api_url: string;
  /** User ID of the authenticated user */
  user_id: string;
}

export class MezonApi {
  basePath: string;
  constructor(readonly serverKey: string, readonly timeoutMs: number, basePath: string) {
    this.basePath = basePath;
  }

  setBasePath(basePath: string) {
    this.basePath = basePath;
  }

  /** Create a new channel with the current user as the owner. */
  authenticateIdToken(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiAuthenticationIdToken,
    options: any = {},
  ): Promise<AuthenticationIdTokenResponse> {
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/idtoken";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) => setTimeout(reject, this.timeoutMs, "Request timed out.")),
    ]);
  }

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  sessionRefresh(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiSessionRefreshRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/SessionRefresh";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SessionRefreshRequest.encode(tsproto.SessionRefreshRequest.fromPartial(body));
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(new Uint8Array(buffer)) as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) => setTimeout(() => reject(new Error("Request timed out.")), this.timeoutMs)),
    ]);
  }

  /** Create a new channel with the current user as the owner. */
  createChannelDesc(
    bearerToken: string,
    body: ApiCreateChannelDescRequest,
    options: any = {},
  ): Promise<ApiChannelDescription> {
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/CreateChannelDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateChannelDescRequest.encode(tsproto.CreateChannelDescRequest.fromPartial(body));
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescription;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescription.decode(new Uint8Array(buffer)) as ApiChannelDescription;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) => setTimeout(() => reject(new Error("Request timed out.")), this.timeoutMs)),
    ]);
  }

  buildFullUrl(basePath: string, fragment: string, queryParams: Map<string, any>) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
      if (v instanceof Array) {
        fullPath += v.reduce((prev: any, curr: any) => {
          return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
        }, "");
      } else {
        if (v != null) {
          fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
        }
      }
    }

    return fullPath;
  }
}
