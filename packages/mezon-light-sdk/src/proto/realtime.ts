// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v4.25.2
// source: rtapi/realtime.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  ChannelMessage,
  MessageAttachment,
  MessageMention,
  MessageRef,
  ChannelMessageHeader,
} from "./api";
import { BoolValue, Int32Value, StringValue } from "../google/protobuf/wrappers";

export const protobufPackage = "mezon.realtime";

/** The realtime protocol for Mezon server. */
/** An envelope for a realtime message. */
export interface Envelope {
  cid: string;
  /** A response from a channel join operation. */
  channel?: Channel | undefined;
  /** Join a realtime chat channel. */
  channel_join?: ChannelJoin | undefined;
  /** Leave a realtime chat channel. */
  channel_leave?: ChannelLeave | undefined;
  /** An incoming message on a realtime chat channel. */
  channel_message?: ChannelMessage | undefined;
  /** An acknowledgement received in response to sending a message on a chat channel. */
  channel_message_ack?: ChannelMessageAck | undefined;
  /** Send a message to a realtime chat channel. */
  channel_message_send?: ChannelMessageSend | undefined;
  /** Describes an error which occurred on the server. */
  error?: Error | undefined;
  /** Application-level heartbeat and connection check. */
  ping?: Ping | undefined;
  /** Application-level heartbeat and connection check response. */
  pong?: Pong | undefined;
}

/** Channel description record */
export interface ChannelDescription {
  /** The clan of this channel */
  clan_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The channel type. */
  type: number | undefined;
  /** The channel lable */
  channel_label: string;
  /** The channel private */
  channel_private: number;
  /** meeting code */
  meeting_code: string;
  /**  */
  clan_name: string;
  /**  */
  parent_id: string;
  /**  */
  last_sent_message: ChannelMessageHeader | undefined;
}

/** A realtime chat channel. */
export interface Channel {
  /** The ID of the channel. */
  id: string;
  /** The users currently in the channel. */
  presences: UserPresence[];
  /** A reference to the current user's presence in the channel. */
  self: UserPresence | undefined;
  /** The name of the chat room, or an empty string if this message was not sent through a chat room. */
  chanel_label: string;
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
}

/** A user session associated to a stream, usually through a list operation or a join/leave event. */
export interface UserPresence {
  /** The user this presence belongs to. */
  user_id: string;
  /** A unique session ID identifying the particular connection, because the user may have many. */
  session_id: string;
  /** The username for display purposes. */
  username: string;
  /** A user-set status message for this stream, if applicable. */
  status: string | undefined;
  /**  */
  is_mobile: boolean;
  /** user_status */
  user_status: string;
}

/** Join operation for a realtime chat channel. */
export interface ChannelJoin {
  /** The clan id */
  clan_id: string;
  /** The id of channel or group */
  channel_id: string;
  /** channel type */
  channel_type: number;
  /** is public */
  is_public: boolean;
}

/** Leave a realtime channel. */
export interface ChannelLeave {
  /** The clan id */
  clan_id: string;
  /** The ID of the channel to leave. */
  channel_id: string;
  /** channel type */
  channel_type: number;
  /** is public channel */
  is_public: boolean;
}

/** A receipt reply from a channel message send operation. */
export interface ChannelMessageAck {
  /** The channel the message was sent to. */
  channel_id: string;
  /** The unique ID assigned to the message. */
  message_id: string;
  /** The code representing a message type or category. */
  code: number;
  /** Username of the message sender. */
  username: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time_seconds: number;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated. */
  update_time_seconds: number;
  /** True if the message was persisted to the channel's history, false otherwise. */
  persistent: boolean | undefined;
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
}

/** Send a message to a realtime channel. */
export interface ChannelMessageSend {
  /** The clan that channel belong to. */
  clan_id: string;
  /** The channel to sent to. */
  channel_id: string;
  /** Message content. */
  content: string;
  /** Message mention */
  mentions: MessageMention[];
  /** Message attachment */
  attachments: MessageAttachment[];
  /** Message reference */
  references: MessageRef[];
  /** Mode */
  mode: number;
  /** anonymous message */
  anonymous_message: boolean;
  /** mention everyone */
  mention_everyone: boolean;
  /** clan avatar */
  avatar: string;
  /** is public */
  is_public: boolean;
  /** code */
  code: number;
  /** topic id */
  topic_id: string;
  /** message id */
  id: string;
}

/** A logical error which may occur on the server. */
export interface Error {
  /** The error code which should be one of "Error.Code" enums. */
  code: number;
  /** A message in English to help developers debug the response. */
  message: string;
  /** Additional error details which may be different for each response. */
  context: { [key: string]: string };
}

/** The selection of possible error codes. */
export enum Error_Code {
  /** RUNTIME_EXCEPTION - An unexpected result from the server. */
  RUNTIME_EXCEPTION = 0,
  /** UNRECOGNIZED_PAYLOAD - The server received a message which is not recognised. */
  UNRECOGNIZED_PAYLOAD = 1,
  /** MISSING_PAYLOAD - A message was expected but contains no content. */
  MISSING_PAYLOAD = 2,
  /** BAD_INPUT - Fields in the message have an invalid format. */
  BAD_INPUT = 3,
  /** MATCH_NOT_FOUND - The match id was not found. */
  MATCH_NOT_FOUND = 4,
  /** MATCH_JOIN_REJECTED - The match join was rejected. */
  MATCH_JOIN_REJECTED = 5,
  /** RUNTIME_FUNCTION_NOT_FOUND - The runtime function does not exist on the server. */
  RUNTIME_FUNCTION_NOT_FOUND = 6,
  /** RUNTIME_FUNCTION_EXCEPTION - The runtime function executed with an error. */
  RUNTIME_FUNCTION_EXCEPTION = 7,
  UNRECOGNIZED = -1,
}

export function error_CodeFromJSON(object: any): Error_Code {
  switch (object) {
    case 0:
    case "RUNTIME_EXCEPTION":
      return Error_Code.RUNTIME_EXCEPTION;
    case 1:
    case "UNRECOGNIZED_PAYLOAD":
      return Error_Code.UNRECOGNIZED_PAYLOAD;
    case 2:
    case "MISSING_PAYLOAD":
      return Error_Code.MISSING_PAYLOAD;
    case 3:
    case "BAD_INPUT":
      return Error_Code.BAD_INPUT;
    case 4:
    case "MATCH_NOT_FOUND":
      return Error_Code.MATCH_NOT_FOUND;
    case 5:
    case "MATCH_JOIN_REJECTED":
      return Error_Code.MATCH_JOIN_REJECTED;
    case 6:
    case "RUNTIME_FUNCTION_NOT_FOUND":
      return Error_Code.RUNTIME_FUNCTION_NOT_FOUND;
    case 7:
    case "RUNTIME_FUNCTION_EXCEPTION":
      return Error_Code.RUNTIME_FUNCTION_EXCEPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Error_Code.UNRECOGNIZED;
  }
}

export function error_CodeToJSON(object: Error_Code): string {
  switch (object) {
    case Error_Code.RUNTIME_EXCEPTION:
      return "RUNTIME_EXCEPTION";
    case Error_Code.UNRECOGNIZED_PAYLOAD:
      return "UNRECOGNIZED_PAYLOAD";
    case Error_Code.MISSING_PAYLOAD:
      return "MISSING_PAYLOAD";
    case Error_Code.BAD_INPUT:
      return "BAD_INPUT";
    case Error_Code.MATCH_NOT_FOUND:
      return "MATCH_NOT_FOUND";
    case Error_Code.MATCH_JOIN_REJECTED:
      return "MATCH_JOIN_REJECTED";
    case Error_Code.RUNTIME_FUNCTION_NOT_FOUND:
      return "RUNTIME_FUNCTION_NOT_FOUND";
    case Error_Code.RUNTIME_FUNCTION_EXCEPTION:
      return "RUNTIME_FUNCTION_EXCEPTION";
    case Error_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Error_ContextEntry {
  key: string;
  value: string;
}

/** Application-level heartbeat and connection check. */
export interface Ping {}

/** Application-level heartbeat and connection check response. */
export interface Pong {}

function createBaseEnvelope(): Envelope {
  return {
    cid: "",
    channel: undefined,
    channel_join: undefined,
    channel_leave: undefined,
    channel_message: undefined,
    channel_message_ack: undefined,
    channel_message_send: undefined,
    error: undefined,
    ping: undefined,
    pong: undefined,
  };
}

export const Envelope = {
  encode(message: Envelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cid !== "") {
      writer.uint32(10).string(message.cid);
    }
    if (message.channel !== undefined) {
      Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
    }
    if (message.channel_join !== undefined) {
      ChannelJoin.encode(message.channel_join, writer.uint32(34).fork()).ldelim();
    }
    if (message.channel_leave !== undefined) {
      ChannelLeave.encode(message.channel_leave, writer.uint32(42).fork()).ldelim();
    }
    if (message.channel_message !== undefined) {
      ChannelMessage.encode(message.channel_message, writer.uint32(50).fork()).ldelim();
    }
    if (message.channel_message_ack !== undefined) {
      ChannelMessageAck.encode(message.channel_message_ack, writer.uint32(58).fork()).ldelim();
    }
    if (message.channel_message_send !== undefined) {
      ChannelMessageSend.encode(message.channel_message_send, writer.uint32(66).fork()).ldelim();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(98).fork()).ldelim();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(178).fork()).ldelim();
    }
    if (message.pong !== undefined) {
      Pong.encode(message.pong, writer.uint32(186).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel = Channel.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_join = ChannelJoin.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_leave = ChannelLeave.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_message = ChannelMessage.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.channel_message_ack = ChannelMessageAck.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.channel_message_send = ChannelMessageSend.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.pong = Pong.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Envelope {
    return {
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined,
      channel_join: isSet(object.channel_join) ? ChannelJoin.fromJSON(object.channel_join) : undefined,
      channel_leave: isSet(object.channel_leave) ? ChannelLeave.fromJSON(object.channel_leave) : undefined,
      channel_message: isSet(object.channel_message) ? ChannelMessage.fromJSON(object.channel_message) : undefined,
      channel_message_ack: isSet(object.channel_message_ack)
        ? ChannelMessageAck.fromJSON(object.channel_message_ack)
        : undefined,
      channel_message_send: isSet(object.channel_message_send)
        ? ChannelMessageSend.fromJSON(object.channel_message_send)
        : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      ping: isSet(object.ping) ? Ping.fromJSON(object.ping) : undefined,
      pong: isSet(object.pong) ? Pong.fromJSON(object.pong) : undefined,
    };
  },

  toJSON(message: Envelope): unknown {
    const obj: any = {};
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.channel !== undefined) {
      obj.channel = Channel.toJSON(message.channel);
    }
    if (message.channel_join !== undefined) {
      obj.channel_join = ChannelJoin.toJSON(message.channel_join);
    }
    if (message.channel_leave !== undefined) {
      obj.channel_leave = ChannelLeave.toJSON(message.channel_leave);
    }
    if (message.channel_message !== undefined) {
      obj.channel_message = ChannelMessage.toJSON(message.channel_message);
    }
    if (message.channel_message_ack !== undefined) {
      obj.channel_message_ack = ChannelMessageAck.toJSON(message.channel_message_ack);
    }
    if (message.channel_message_send !== undefined) {
      obj.channel_message_send = ChannelMessageSend.toJSON(message.channel_message_send);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.ping !== undefined) {
      obj.ping = Ping.toJSON(message.ping);
    }
    if (message.pong !== undefined) {
      obj.pong = Pong.toJSON(message.pong);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Envelope>, I>>(base?: I): Envelope {
    return Envelope.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Envelope>, I>>(object: I): Envelope {
    const message = createBaseEnvelope();
    message.cid = object.cid ?? "";
    message.channel =
      object.channel !== undefined && object.channel !== null ? Channel.fromPartial(object.channel) : undefined;
    message.channel_join =
      object.channel_join !== undefined && object.channel_join !== null
        ? ChannelJoin.fromPartial(object.channel_join)
        : undefined;
    message.channel_leave =
      object.channel_leave !== undefined && object.channel_leave !== null
        ? ChannelLeave.fromPartial(object.channel_leave)
        : undefined;
    message.channel_message =
      object.channel_message !== undefined && object.channel_message !== null
        ? ChannelMessage.fromPartial(object.channel_message)
        : undefined;
    message.channel_message_ack =
      object.channel_message_ack !== undefined && object.channel_message_ack !== null
        ? ChannelMessageAck.fromPartial(object.channel_message_ack)
        : undefined;
    message.channel_message_send =
      object.channel_message_send !== undefined && object.channel_message_send !== null
        ? ChannelMessageSend.fromPartial(object.channel_message_send)
        : undefined;
    message.error = object.error !== undefined && object.error !== null ? Error.fromPartial(object.error) : undefined;
    message.ping = object.ping !== undefined && object.ping !== null ? Ping.fromPartial(object.ping) : undefined;
    message.pong = object.pong !== undefined && object.pong !== null ? Pong.fromPartial(object.pong) : undefined;
    return message;
  },
};

function createBaseChannelDescription(): ChannelDescription {
  return {
    clan_id: "0",
    channel_id: "0",
    type: undefined,
    channel_label: "",
    channel_private: 0,
    meeting_code: "",
    clan_name: "",
    parent_id: "0",
    last_sent_message: undefined,
  };
}

export const ChannelDescription = {
  encode(message: ChannelDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(16).int64(message.channel_id);
    }
    if (message.type !== undefined) {
      Int32Value.encode({ value: message.type! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.channel_label !== "") {
      writer.uint32(34).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(40).int32(message.channel_private);
    }
    if (message.meeting_code !== "") {
      writer.uint32(50).string(message.meeting_code);
    }
    if (message.clan_name !== "") {
      writer.uint32(58).string(message.clan_name);
    }
    if (message.parent_id !== "0") {
      writer.uint32(64).int64(message.parent_id);
    }
    if (message.last_sent_message !== undefined) {
      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.parent_id = longToString(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDescription {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      type: isSet(object.type) ? Number(object.type) : undefined,
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      parent_id: isSet(object.parent_id) ? globalThis.String(object.parent_id) : "0",
      last_sent_message: isSet(object.last_sent_message)
        ? ChannelMessageHeader.fromJSON(object.last_sent_message)
        : undefined,
    };
  },

  toJSON(message: ChannelDescription): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.parent_id !== "0") {
      obj.parent_id = message.parent_id;
    }
    if (message.last_sent_message !== undefined) {
      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDescription>, I>>(base?: I): ChannelDescription {
    return ChannelDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDescription>, I>>(object: I): ChannelDescription {
    const message = createBaseChannelDescription();
    message.clan_id = object.clan_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.type = object.type ?? undefined;
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.meeting_code = object.meeting_code ?? "";
    message.clan_name = object.clan_name ?? "";
    message.parent_id = object.parent_id ?? "0";
    message.last_sent_message =
      object.last_sent_message !== undefined && object.last_sent_message !== null
        ? ChannelMessageHeader.fromPartial(object.last_sent_message)
        : undefined;
    return message;
  },
};

function createBaseChannel(): Channel {
  return { id: "0", presences: [], self: undefined, chanel_label: "", clan_logo: "", category_name: "" };
}

export const Channel = {
  encode(message: Channel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    for (const v of message.presences) {
      UserPresence.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.self !== undefined) {
      UserPresence.encode(message.self, writer.uint32(26).fork()).ldelim();
    }
    if (message.chanel_label !== "") {
      writer.uint32(34).string(message.chanel_label);
    }
    if (message.clan_logo !== "") {
      writer.uint32(42).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(50).string(message.category_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Channel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.presences.push(UserPresence.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.self = UserPresence.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chanel_label = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.category_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      presences: globalThis.Array.isArray(object?.presences)
        ? object.presences.map((e: any) => UserPresence.fromJSON(e))
        : [],
      self: isSet(object.self) ? UserPresence.fromJSON(object.self) : undefined,
      chanel_label: isSet(object.chanel_label) ? globalThis.String(object.chanel_label) : "",
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.presences?.length) {
      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));
    }
    if (message.self !== undefined) {
      obj.self = UserPresence.toJSON(message.self);
    }
    if (message.chanel_label !== "") {
      obj.chanel_label = message.chanel_label;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Channel>, I>>(base?: I): Channel {
    return Channel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel>, I>>(object: I): Channel {
    const message = createBaseChannel();
    message.id = object.id ?? "0";
    message.presences = object.presences?.map((e) => UserPresence.fromPartial(e)) || [];
    message.self =
      object.self !== undefined && object.self !== null ? UserPresence.fromPartial(object.self) : undefined;
    message.chanel_label = object.chanel_label ?? "";
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    return message;
  },
};

function createBaseChannelJoin(): ChannelJoin {
  return { clan_id: "0", channel_id: "0", channel_type: 0, is_public: false };
}

export const ChannelJoin = {
  encode(message: ChannelJoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(16).int64(message.channel_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(24).int32(message.channel_type);
    }
    if (message.is_public !== false) {
      writer.uint32(32).bool(message.is_public);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelJoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.is_public = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelJoin {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      is_public: isSet(object.is_public) ? globalThis.Boolean(object.is_public) : false,
    };
  },

  toJSON(message: ChannelJoin): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.is_public !== false) {
      obj.is_public = message.is_public;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelJoin>, I>>(base?: I): ChannelJoin {
    return ChannelJoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelJoin>, I>>(object: I): ChannelJoin {
    const message = createBaseChannelJoin();
    message.clan_id = object.clan_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.channel_type = object.channel_type ?? 0;
    message.is_public = object.is_public ?? false;
    return message;
  },
};

function createBaseChannelLeave(): ChannelLeave {
  return { clan_id: "0", channel_id: "0", channel_type: 0, is_public: false };
}

export const ChannelLeave = {
  encode(message: ChannelLeave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(16).int64(message.channel_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(24).int32(message.channel_type);
    }
    if (message.is_public !== false) {
      writer.uint32(32).bool(message.is_public);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelLeave {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelLeave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.is_public = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelLeave {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      is_public: isSet(object.is_public) ? globalThis.Boolean(object.is_public) : false,
    };
  },

  toJSON(message: ChannelLeave): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.is_public !== false) {
      obj.is_public = message.is_public;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelLeave>, I>>(base?: I): ChannelLeave {
    return ChannelLeave.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelLeave>, I>>(object: I): ChannelLeave {
    const message = createBaseChannelLeave();
    message.clan_id = object.clan_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.channel_type = object.channel_type ?? 0;
    message.is_public = object.is_public ?? false;
    return message;
  },
};

function createBaseChannelMessageAck(): ChannelMessageAck {
  return {
    channel_id: "0",
    message_id: "0",
    code: 0,
    username: "",
    create_time_seconds: 0,
    update_time_seconds: 0,
    persistent: undefined,
    clan_logo: "",
    category_name: "",
  };
}

export const ChannelMessageAck = {
  encode(message: ChannelMessageAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "0") {
      writer.uint32(8).int64(message.channel_id);
    }
    if (message.message_id !== "0") {
      writer.uint32(16).int64(message.message_id);
    }
    if (message.code !== 0) {
      writer.uint32(24).int32(message.code);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(40).uint32(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      writer.uint32(48).uint32(message.update_time_seconds);
    }
    if (message.persistent !== undefined) {
      BoolValue.encode({ value: message.persistent! }, writer.uint32(58).fork()).ldelim();
    }
    if (message.clan_logo !== "") {
      writer.uint32(66).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(74).string(message.category_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.message_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.update_time_seconds = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.persistent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.category_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageAck {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "0",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
      update_time_seconds: isSet(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,
      persistent: isSet(object.persistent) ? Boolean(object.persistent) : undefined,
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
    };
  },

  toJSON(message: ChannelMessageAck): unknown {
    const obj: any = {};
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "0") {
      obj.message_id = message.message_id;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      obj.update_time_seconds = Math.round(message.update_time_seconds);
    }
    if (message.persistent !== undefined) {
      obj.persistent = message.persistent;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageAck>, I>>(base?: I): ChannelMessageAck {
    return ChannelMessageAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageAck>, I>>(object: I): ChannelMessageAck {
    const message = createBaseChannelMessageAck();
    message.channel_id = object.channel_id ?? "0";
    message.message_id = object.message_id ?? "0";
    message.code = object.code ?? 0;
    message.username = object.username ?? "";
    message.create_time_seconds = object.create_time_seconds ?? 0;
    message.update_time_seconds = object.update_time_seconds ?? 0;
    message.persistent = object.persistent ?? undefined;
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    return message;
  },
};

function createBaseChannelMessageSend(): ChannelMessageSend {
  return {
    clan_id: "0",
    channel_id: "0",
    content: "",
    mentions: [],
    attachments: [],
    references: [],
    mode: 0,
    anonymous_message: false,
    mention_everyone: false,
    avatar: "",
    is_public: false,
    code: 0,
    topic_id: "0",
    id: "0",
  };
}

export const ChannelMessageSend = {
  encode(message: ChannelMessageSend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(16).int64(message.channel_id);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    for (const v of message.mentions) {
      MessageMention.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.attachments) {
      MessageAttachment.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.references) {
      MessageRef.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.mode !== 0) {
      writer.uint32(56).int32(message.mode);
    }
    if (message.anonymous_message !== false) {
      writer.uint32(64).bool(message.anonymous_message);
    }
    if (message.mention_everyone !== false) {
      writer.uint32(72).bool(message.mention_everyone);
    }
    if (message.avatar !== "") {
      writer.uint32(82).string(message.avatar);
    }
    if (message.is_public !== false) {
      writer.uint32(88).bool(message.is_public);
    }
    if (message.code !== 0) {
      writer.uint32(96).int32(message.code);
    }
    if (message.topic_id !== "0") {
      writer.uint32(104).int64(message.topic_id);
    }
    if (message.id !== "0") {
      writer.uint32(112).int64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageSend {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mentions.push(MessageMention.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.references.push(MessageRef.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.anonymous_message = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mention_everyone = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.is_public = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.topic_id = longToString(reader.int64() as Long);
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.id = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageSend {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      mentions: globalThis.Array.isArray(object?.mentions)
        ? object.mentions.map((e: any) => MessageMention.fromJSON(e))
        : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => MessageAttachment.fromJSON(e))
        : [],
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => MessageRef.fromJSON(e))
        : [],
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      anonymous_message: isSet(object.anonymous_message) ? globalThis.Boolean(object.anonymous_message) : false,
      mention_everyone: isSet(object.mention_everyone) ? globalThis.Boolean(object.mention_everyone) : false,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      is_public: isSet(object.is_public) ? globalThis.Boolean(object.is_public) : false,
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      topic_id: isSet(object.topic_id) ? globalThis.String(object.topic_id) : "0",
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
    };
  },

  toJSON(message: ChannelMessageSend): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.mentions?.length) {
      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => MessageRef.toJSON(e));
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.anonymous_message !== false) {
      obj.anonymous_message = message.anonymous_message;
    }
    if (message.mention_everyone !== false) {
      obj.mention_everyone = message.mention_everyone;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.is_public !== false) {
      obj.is_public = message.is_public;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.topic_id !== "0") {
      obj.topic_id = message.topic_id;
    }
    if (message.id !== "0") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageSend>, I>>(base?: I): ChannelMessageSend {
    return ChannelMessageSend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageSend>, I>>(object: I): ChannelMessageSend {
    const message = createBaseChannelMessageSend();
    message.clan_id = object.clan_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.content = object.content ?? "";
    message.mentions = object.mentions?.map((e) => MessageMention.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => MessageAttachment.fromPartial(e)) || [];
    message.references = object.references?.map((e) => MessageRef.fromPartial(e)) || [];
    message.mode = object.mode ?? 0;
    message.anonymous_message = object.anonymous_message ?? false;
    message.mention_everyone = object.mention_everyone ?? false;
    message.avatar = object.avatar ?? "";
    message.is_public = object.is_public ?? false;
    message.code = object.code ?? 0;
    message.topic_id = object.topic_id ?? "0";
    message.id = object.id ?? "0";
    return message;
  },
};

function createBaseError(): Error {
  return { code: 0, message: "", context: {} };
}

export const Error = {
  encode(message: Error, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.context).forEach(([key, value]) => {
      Error_ContextEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Error_ContextEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.context[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      context: isObject(object.context)
        ? Object.entries(object.context).reduce<{ [key: string]: string }>((acc, [key, value]) => {
            acc[key] = String(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.context) {
      const entries = Object.entries(message.context);
      if (entries.length > 0) {
        obj.context = {};
        entries.forEach(([k, v]) => {
          obj.context[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.context = Object.entries(object.context ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseError_ContextEntry(): Error_ContextEntry {
  return { key: "", value: "" };
}

export const Error_ContextEntry = {
  encode(message: Error_ContextEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error_ContextEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError_ContextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error_ContextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Error_ContextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error_ContextEntry>, I>>(base?: I): Error_ContextEntry {
    return Error_ContextEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error_ContextEntry>, I>>(object: I): Error_ContextEntry {
    const message = createBaseError_ContextEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePing(): Ping {
  return {};
}

export const Ping = {
  encode(_: Ping, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ping {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Ping {
    return {};
  },

  toJSON(_: Ping): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Ping>, I>>(base?: I): Ping {
    return Ping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ping>, I>>(_: I): Ping {
    const message = createBasePing();
    return message;
  },
};

function createBasePong(): Pong {
  return {};
}

export const Pong = {
  encode(_: Pong, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pong {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Pong {
    return {};
  },

  toJSON(_: Pong): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Pong>, I>>(base?: I): Pong {
    return Pong.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pong>, I>>(_: I): Pong {
    const message = createBasePong();
    return message;
  },
};

function createBaseUserPresence(): UserPresence {
  return { user_id: "0", session_id: "", username: "", status: undefined, is_mobile: false, user_status: "" };
}

export const UserPresence = {
  encode(message: UserPresence, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "0") {
      writer.uint32(8).int64(message.user_id);
    }
    if (message.session_id !== "") {
      writer.uint32(18).string(message.session_id);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.status !== undefined) {
      StringValue.encode({ value: message.status! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.is_mobile !== false) {
      writer.uint32(40).bool(message.is_mobile);
    }
    if (message.user_status !== "") {
      writer.uint32(50).string(message.user_status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserPresence {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPresence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.user_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.session_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_mobile = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.user_status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPresence {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "0",
      session_id: isSet(object.session_id) ? globalThis.String(object.session_id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      status: isSet(object.status) ? String(object.status) : undefined,
      is_mobile: isSet(object.is_mobile) ? globalThis.Boolean(object.is_mobile) : false,
      user_status: isSet(object.user_status) ? globalThis.String(object.user_status) : "",
    };
  },

  toJSON(message: UserPresence): unknown {
    const obj: any = {};
    if (message.user_id !== "0") {
      obj.user_id = message.user_id;
    }
    if (message.session_id !== "") {
      obj.session_id = message.session_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.is_mobile !== false) {
      obj.is_mobile = message.is_mobile;
    }
    if (message.user_status !== "") {
      obj.user_status = message.user_status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPresence>, I>>(base?: I): UserPresence {
    return UserPresence.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPresence>, I>>(object: I): UserPresence {
    const message = createBaseUserPresence();
    message.user_id = object.user_id ?? "0";
    message.session_id = object.session_id ?? "";
    message.username = object.username ?? "";
    message.status = object.status ?? undefined;
    message.is_mobile = object.is_mobile ?? false;
    message.user_status = object.user_status ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
