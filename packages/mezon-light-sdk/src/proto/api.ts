// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v4.25.2
// source: api/api.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "mezon.api";
/** A user's session used to authenticate messages. */
export interface Session {
  /** True if the corresponding account was just created, false otherwise. */
  created: boolean;
  /** Authentication credentials. */
  token: string;
  /** Refresh token that can be used for session token renewal. */
  refresh_token: string;
  /** User id */
  user_id: string;
  /** Whether to enable "Remember Me" for extended session duration. */
  is_remember: boolean;
  /** api url */
  api_url: string;
  /** id token for zklogin */
  id_token: string;
}

/** Authenticate against the server with a refresh token. */
export interface SessionRefreshRequest {
  /** Refresh token. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
  /** Whether to enable "Remember Me" for extended session duration. */
  is_remember: boolean;
}

export interface SessionRefreshRequest_VarsEntry {
  key: string;
  value: string;
}

/** Create a channel within clan. */
export interface CreateChannelDescRequest {
  /** The clan of this channel */
  clan_id: string;
  /** The parent channel this message belongs to. */
  parent_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The category of channel */
  category_id: string;
  /** The channel type. */
  type: number;
  /** The channel lable */
  channel_label: string;
  /** The channel private */
  channel_private: number;
  /** The users to add. */
  user_ids: string[];
  /** app url for channel type app */
  app_id: string;
}

/** Channel description record */
export interface ChannelDescription {
  /** The clan of this channel */
  clan_id: string;
  /** The parent channel this message belongs to. */
  parent_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The category of channel */
  category_id: string;
  /** The category name */
  category_name: string;
  /** The channel type. */
  type: number;
  /** creator ID. */
  creator_id: string;
  /** The channel lable */
  channel_label: string;
  /** The channel private */
  channel_private: number;
  /** DM avatars */
  avatars: string[];
  /** List DM user ids */
  user_ids: string[];
  /** last message id */
  last_sent_message:
    | ChannelMessageHeader
    | undefined;
  /** last seen message id */
  last_seen_message:
    | ChannelMessageHeader
    | undefined;
  /** DM status */
  onlines: boolean[];
  /** meeting code */
  meeting_code: string;
  /** count message unread */
  count_mess_unread: number;
  /** active channel */
  active: number;
  /** last pin message */
  last_pin_message: string;
  /** List DM usernames */
  usernames: string[];
  /** creator name */
  creator_name: string;
  /** create time ms */
  create_time_seconds: number;
  /** update time ms */
  update_time_seconds: number;
  /** List DM diplay names */
  display_names: string[];
  /** channel avatar */
  channel_avatar: string;
  /** clan_name */
  clan_name: string;
  /** app id */
  app_id: string;
  /** channel all message */
  is_mute: boolean;
  /** age restricted */
  age_restricted: number;
  /** channel description topic */
  topic: string;
  /** e2ee */
  e2ee: number;
  /** channel member count */
  member_count: number;
}

export interface ChannelMessageHeader {
  /** the message id */
  id: string;
  /** the time stamp */
  timestamp_seconds: number;
  /** the sender id */
  sender_id: string;
  /** the content */
  content: string;
}

/** A message sent on a channel. */
export interface ChannelMessage {
  /** The clan this message belong to. */
  clan_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The unique ID of this message. */
  message_id: string;
  /** The code representing a message type or category. */
  code: number;
  /** Message sender, usually a user ID. */
  sender_id: string;
  /** The username of the message sender, if any. */
  username: string;
  /** The avatar of user who send message */
  avatar: string;
  /** The content payload. */
  content: string;
  /** The name of the chat room, or an empty string if this message was not sent through a chat room. */
  channel_label: string;
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
  /** The clan nick name */
  display_name: string;
  /** The clan nick name */
  clan_nick: string;
  /** The clan avatar */
  clan_avatar: string;
  /** Emoji reaction */
  reactions: Uint8Array;
  /** Message mention */
  mentions: Uint8Array;
  /** Message attachment */
  attachments: Uint8Array;
  /** Message reference */
  references: Uint8Array;
  /** referenced message */
  referenced_message: Uint8Array;
  /** create time in ms */
  create_time_seconds: number;
  /** update time in ms */
  update_time_seconds: number;
  /** channel mode */
  mode: number;
  /** hide editted */
  hide_editted: boolean;
  /** is public */
  is_public: boolean;
  /** topic */
  topic_id: string;
}

/** Mention to message */
export interface MessageMention {
  /** Mention id */
  id: string;
  /** mention user id */
  user_id: string;
  /** mention username */
  username: string;
  /** role id */
  role_id: string;
  /** role name */
  rolename: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time_seconds: number;
  /** start position from text */
  s: number;
  /** end position from text */
  e: number;
}

/** Emoji reaction by user */
export interface MessageReaction {
  /** Reaction id */
  id: string;
  /** An emoji id */
  emoji_id: string;
  /** An emoji shortname */
  emoji: string;
  /** User react to message */
  sender_id: string;
  /** Sender name */
  sender_name: string;
  /** avatar */
  sender_avatar: string;
  /** Action reaction delete or add */
  action: boolean;
  /** count of emoji */
  count: number;
  /** channel id */
  channel_id: string;
  /** message id */
  message_id: string;
  /** clan id */
  clan_id: string;
  /** mode */
  mode: number;
  /** message sender id */
  message_sender_id: string;
  /** is public */
  is_public: boolean;
  /** topic id */
  topic_id: string;
  /** emoji_recent_id */
  emoji_recent_id: string;
}

/** Message attachment */
export interface MessageAttachment {
  /** Attachment file name */
  filename: string;
  /** Attachment file size */
  size: number;
  /** Attachment url */
  url: string;
  /** Attachment file type */
  filetype: string;
  /** Attachment width */
  width: number;
  /** Attachment width */
  height: number;
  /** thumbnail */
  thumbnail: string;
  /** duration for video */
  duration: number;
}

/** Message reference */
export interface MessageRef {
  /** A message source */
  message_id: string;
  /** A message reference to */
  message_ref_id: string;
  /** content reference */
  content: string;
  /** has attachment */
  has_attachment: boolean;
  /** Reference type. 0: reply */
  ref_type: number;
  /** original message sender */
  message_sender_id: string;
  /** original message sendre username */
  message_sender_username: string;
  /** original message sender avatar */
  mesages_sender_avatar: string;
  /** original sender clan nick name */
  message_sender_clan_nick: string;
  /** original sender display name */
  message_sender_display_name: string;
}

export interface MessageAttachmentList {
  attachments: MessageAttachment[];
}

function createBaseSession(): Session {
  return { created: false, token: "", refresh_token: "", user_id: "0", is_remember: false, api_url: "", id_token: "" };
}

export const Session = {
  encode(message: Session, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.created !== false) {
      writer.uint32(8).bool(message.created);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.refresh_token !== "") {
      writer.uint32(26).string(message.refresh_token);
    }
    if (message.user_id !== "0") {
      writer.uint32(32).int64(message.user_id);
    }
    if (message.is_remember !== false) {
      writer.uint32(40).bool(message.is_remember);
    }
    if (message.api_url !== "") {
      writer.uint32(50).string(message.api_url);
    }
    if (message.id_token !== "") {
      writer.uint32(58).string(message.id_token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Session {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.created = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.refresh_token = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.user_id = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_remember = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.api_url = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id_token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      created: isSet(object.created) ? globalThis.Boolean(object.created) : false,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      refresh_token: isSet(object.refresh_token) ? globalThis.String(object.refresh_token) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "0",
      is_remember: isSet(object.is_remember) ? globalThis.Boolean(object.is_remember) : false,
      api_url: isSet(object.api_url) ? globalThis.String(object.api_url) : "",
      id_token: isSet(object.id_token) ? globalThis.String(object.id_token) : "",
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.created !== false) {
      obj.created = message.created;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.refresh_token !== "") {
      obj.refresh_token = message.refresh_token;
    }
    if (message.user_id !== "0") {
      obj.user_id = message.user_id;
    }
    if (message.is_remember !== false) {
      obj.is_remember = message.is_remember;
    }
    if (message.api_url !== "") {
      obj.api_url = message.api_url;
    }
    if (message.id_token !== "") {
      obj.id_token = message.id_token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.created = object.created ?? false;
    message.token = object.token ?? "";
    message.refresh_token = object.refresh_token ?? "";
    message.user_id = object.user_id ?? "0";
    message.is_remember = object.is_remember ?? false;
    message.api_url = object.api_url ?? "";
    message.id_token = object.id_token ?? "";
    return message;
  },
};


function createBaseSessionRefreshRequest(): SessionRefreshRequest {
  return { token: "", vars: {}, is_remember: false };
}

export const SessionRefreshRequest = {
  encode(message: SessionRefreshRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      SessionRefreshRequest_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.is_remember !== false) {
      writer.uint32(24).bool(message.is_remember);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRefreshRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRefreshRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SessionRefreshRequest_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.is_remember = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRefreshRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      is_remember: isSet(object.is_remember) ? globalThis.Boolean(object.is_remember) : false,
    };
  },

  toJSON(message: SessionRefreshRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    if (message.is_remember !== false) {
      obj.is_remember = message.is_remember;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRefreshRequest>, I>>(base?: I): SessionRefreshRequest {
    return SessionRefreshRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionRefreshRequest>, I>>(object: I): SessionRefreshRequest {
    const message = createBaseSessionRefreshRequest();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.is_remember = object.is_remember ?? false;
    return message;
  },
};

function createBaseSessionRefreshRequest_VarsEntry(): SessionRefreshRequest_VarsEntry {
  return { key: "", value: "" };
}

export const SessionRefreshRequest_VarsEntry = {
  encode(message: SessionRefreshRequest_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRefreshRequest_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRefreshRequest_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRefreshRequest_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SessionRefreshRequest_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRefreshRequest_VarsEntry>, I>>(base?: I): SessionRefreshRequest_VarsEntry {
    return SessionRefreshRequest_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionRefreshRequest_VarsEntry>, I>>(
    object: I,
  ): SessionRefreshRequest_VarsEntry {
    const message = createBaseSessionRefreshRequest_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateChannelDescRequest(): CreateChannelDescRequest {
  return {
    clan_id: "0",
    parent_id: "0",
    channel_id: "0",
    category_id: "0",
    type: 0,
    channel_label: "",
    channel_private: 0,
    user_ids: [],
    app_id: "0",
  };
}

export const CreateChannelDescRequest = {
  encode(message: CreateChannelDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.parent_id !== "0") {
      writer.uint32(16).int64(message.parent_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(24).int64(message.channel_id);
    }
    if (message.category_id !== "0") {
      writer.uint32(32).int64(message.category_id);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.channel_label !== "") {
      writer.uint32(50).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(56).int32(message.channel_private);
    }
    writer.uint32(66).fork();
    for (const v of message.user_ids) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.app_id !== "0") {
      writer.uint32(72).int64(message.app_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateChannelDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.parent_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.category_id = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 8:
          if (tag === 64) {
            message.user_ids.push(longToString(reader.int64() as Long));

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.user_ids.push(longToString(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.app_id = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChannelDescRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      parent_id: isSet(object.parent_id) ? globalThis.String(object.parent_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "0",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      app_id: isSet(object.app_id) ? globalThis.String(object.app_id) : "0",
    };
  },

  toJSON(message: CreateChannelDescRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.parent_id !== "0") {
      obj.parent_id = message.parent_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.category_id !== "0") {
      obj.category_id = message.category_id;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.app_id !== "0") {
      obj.app_id = message.app_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateChannelDescRequest>, I>>(base?: I): CreateChannelDescRequest {
    return CreateChannelDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateChannelDescRequest>, I>>(object: I): CreateChannelDescRequest {
    const message = createBaseCreateChannelDescRequest();
    message.clan_id = object.clan_id ?? "0";
    message.parent_id = object.parent_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.category_id = object.category_id ?? "0";
    message.type = object.type ?? 0;
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.app_id = object.app_id ?? "0";
    return message;
  },
};

function createBaseChannelDescription(): ChannelDescription {
  return {
    clan_id: "0",
    parent_id: "0",
    channel_id: "0",
    category_id: "0",
    category_name: "",
    type: 0,
    creator_id: "0",
    channel_label: "",
    channel_private: 0,
    avatars: [],
    user_ids: [],
    last_sent_message: undefined,
    last_seen_message: undefined,
    onlines: [],
    meeting_code: "",
    count_mess_unread: 0,
    active: 0,
    last_pin_message: "",
    usernames: [],
    creator_name: "",
    create_time_seconds: 0,
    update_time_seconds: 0,
    display_names: [],
    channel_avatar: "",
    clan_name: "",
    app_id: "0",
    is_mute: false,
    age_restricted: 0,
    topic: "",
    e2ee: 0,
    member_count: 0,
  };
}

export const ChannelDescription = {
  encode(message: ChannelDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.parent_id !== "0") {
      writer.uint32(16).int64(message.parent_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(24).int64(message.channel_id);
    }
    if (message.category_id !== "0") {
      writer.uint32(32).int64(message.category_id);
    }
    if (message.category_name !== "") {
      writer.uint32(42).string(message.category_name);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.creator_id !== "0") {
      writer.uint32(56).int64(message.creator_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(66).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(72).int32(message.channel_private);
    }
    for (const v of message.avatars) {
      writer.uint32(82).string(v!);
    }
    writer.uint32(90).fork();
    for (const v of message.user_ids) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.last_sent_message !== undefined) {
      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();
    }
    if (message.last_seen_message !== undefined) {
      ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(106).fork()).ldelim();
    }
    writer.uint32(114).fork();
    for (const v of message.onlines) {
      writer.bool(v);
    }
    writer.ldelim();
    if (message.meeting_code !== "") {
      writer.uint32(122).string(message.meeting_code);
    }
    if (message.count_mess_unread !== 0) {
      writer.uint32(128).int32(message.count_mess_unread);
    }
    if (message.active !== 0) {
      writer.uint32(136).int32(message.active);
    }
    if (message.last_pin_message !== "") {
      writer.uint32(146).string(message.last_pin_message);
    }
    for (const v of message.usernames) {
      writer.uint32(154).string(v!);
    }
    if (message.creator_name !== "") {
      writer.uint32(162).string(message.creator_name);
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(168).uint32(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      writer.uint32(176).uint32(message.update_time_seconds);
    }
    for (const v of message.display_names) {
      writer.uint32(186).string(v!);
    }
    if (message.channel_avatar !== "") {
      writer.uint32(194).string(message.channel_avatar);
    }
    if (message.clan_name !== "") {
      writer.uint32(202).string(message.clan_name);
    }
    if (message.app_id !== "0") {
      writer.uint32(208).int64(message.app_id);
    }
    if (message.is_mute !== false) {
      writer.uint32(216).bool(message.is_mute);
    }
    if (message.age_restricted !== 0) {
      writer.uint32(224).int32(message.age_restricted);
    }
    if (message.topic !== "") {
      writer.uint32(234).string(message.topic);
    }
    if (message.e2ee !== 0) {
      writer.uint32(240).int32(message.e2ee);
    }
    if (message.member_count !== 0) {
      writer.uint32(248).int32(message.member_count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.parent_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.category_id = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.creator_id = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.avatars.push(reader.string());
          continue;
        case 11:
          if (tag === 88) {
            message.user_ids.push(longToString(reader.int64() as Long));

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.user_ids.push(longToString(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag === 112) {
            message.onlines.push(reader.bool());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.onlines.push(reader.bool());
            }

            continue;
          }

          break;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.count_mess_unread = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.last_pin_message = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.creator_name = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.update_time_seconds = reader.uint32();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.display_names.push(reader.string());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.channel_avatar = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.app_id = longToString(reader.int64() as Long);
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.is_mute = reader.bool();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.age_restricted = reader.int32();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.e2ee = reader.int32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.member_count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDescription {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      parent_id: isSet(object.parent_id) ? globalThis.String(object.parent_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "0",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "0",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      avatars: globalThis.Array.isArray(object?.avatars) ? object.avatars.map((e: any) => globalThis.String(e)) : [],
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      last_sent_message: isSet(object.last_sent_message)
        ? ChannelMessageHeader.fromJSON(object.last_sent_message)
        : undefined,
      last_seen_message: isSet(object.last_seen_message)
        ? ChannelMessageHeader.fromJSON(object.last_seen_message)
        : undefined,
      onlines: globalThis.Array.isArray(object?.onlines) ? object.onlines.map((e: any) => globalThis.Boolean(e)) : [],
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      count_mess_unread: isSet(object.count_mess_unread) ? globalThis.Number(object.count_mess_unread) : 0,
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      last_pin_message: isSet(object.last_pin_message) ? globalThis.String(object.last_pin_message) : "",
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
      creator_name: isSet(object.creator_name) ? globalThis.String(object.creator_name) : "",
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
      update_time_seconds: isSet(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,
      display_names: globalThis.Array.isArray(object?.display_names)
        ? object.display_names.map((e: any) => globalThis.String(e))
        : [],
      channel_avatar: isSet(object.channel_avatar) ? globalThis.String(object.channel_avatar) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      app_id: isSet(object.app_id) ? globalThis.String(object.app_id) : "0",
      is_mute: isSet(object.is_mute) ? globalThis.Boolean(object.is_mute) : false,
      age_restricted: isSet(object.age_restricted) ? globalThis.Number(object.age_restricted) : 0,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      e2ee: isSet(object.e2ee) ? globalThis.Number(object.e2ee) : 0,
      member_count: isSet(object.member_count) ? globalThis.Number(object.member_count) : 0,
    };
  },

  toJSON(message: ChannelDescription): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.parent_id !== "0") {
      obj.parent_id = message.parent_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.category_id !== "0") {
      obj.category_id = message.category_id;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.creator_id !== "0") {
      obj.creator_id = message.creator_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.avatars?.length) {
      obj.avatars = message.avatars;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.last_sent_message !== undefined) {
      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);
    }
    if (message.last_seen_message !== undefined) {
      obj.last_seen_message = ChannelMessageHeader.toJSON(message.last_seen_message);
    }
    if (message.onlines?.length) {
      obj.onlines = message.onlines;
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.count_mess_unread !== 0) {
      obj.count_mess_unread = Math.round(message.count_mess_unread);
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.last_pin_message !== "") {
      obj.last_pin_message = message.last_pin_message;
    }
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    if (message.creator_name !== "") {
      obj.creator_name = message.creator_name;
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      obj.update_time_seconds = Math.round(message.update_time_seconds);
    }
    if (message.display_names?.length) {
      obj.display_names = message.display_names;
    }
    if (message.channel_avatar !== "") {
      obj.channel_avatar = message.channel_avatar;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.app_id !== "0") {
      obj.app_id = message.app_id;
    }
    if (message.is_mute !== false) {
      obj.is_mute = message.is_mute;
    }
    if (message.age_restricted !== 0) {
      obj.age_restricted = Math.round(message.age_restricted);
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.e2ee !== 0) {
      obj.e2ee = Math.round(message.e2ee);
    }
    if (message.member_count !== 0) {
      obj.member_count = Math.round(message.member_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDescription>, I>>(base?: I): ChannelDescription {
    return ChannelDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDescription>, I>>(object: I): ChannelDescription {
    const message = createBaseChannelDescription();
    message.clan_id = object.clan_id ?? "0";
    message.parent_id = object.parent_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.category_id = object.category_id ?? "0";
    message.category_name = object.category_name ?? "";
    message.type = object.type ?? 0;
    message.creator_id = object.creator_id ?? "0";
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.avatars = object.avatars?.map((e) => e) || [];
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.last_sent_message = (object.last_sent_message !== undefined && object.last_sent_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_sent_message)
      : undefined;
    message.last_seen_message = (object.last_seen_message !== undefined && object.last_seen_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_seen_message)
      : undefined;
    message.onlines = object.onlines?.map((e) => e) || [];
    message.meeting_code = object.meeting_code ?? "";
    message.count_mess_unread = object.count_mess_unread ?? 0;
    message.active = object.active ?? 0;
    message.last_pin_message = object.last_pin_message ?? "";
    message.usernames = object.usernames?.map((e) => e) || [];
    message.creator_name = object.creator_name ?? "";
    message.create_time_seconds = object.create_time_seconds ?? 0;
    message.update_time_seconds = object.update_time_seconds ?? 0;
    message.display_names = object.display_names?.map((e) => e) || [];
    message.channel_avatar = object.channel_avatar ?? "";
    message.clan_name = object.clan_name ?? "";
    message.app_id = object.app_id ?? "0";
    message.is_mute = object.is_mute ?? false;
    message.age_restricted = object.age_restricted ?? 0;
    message.topic = object.topic ?? "";
    message.e2ee = object.e2ee ?? 0;
    message.member_count = object.member_count ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

function createBaseChannelMessage(): ChannelMessage {
  return {
    clan_id: "0",
    channel_id: "0",
    message_id: "0",
    code: 0,
    sender_id: "0",
    username: "",
    avatar: "",
    content: "",
    channel_label: "",
    clan_logo: "",
    category_name: "",
    display_name: "",
    clan_nick: "",
    clan_avatar: "",
    reactions: new Uint8Array(0),
    mentions: new Uint8Array(0),
    attachments: new Uint8Array(0),
    references: new Uint8Array(0),
    referenced_message: new Uint8Array(0),
    create_time_seconds: 0,
    update_time_seconds: 0,
    mode: 0,
    hide_editted: false,
    is_public: false,
    topic_id: "0",
  };
}

export const ChannelMessage = {
  encode(message: ChannelMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "0") {
      writer.uint32(8).int64(message.clan_id);
    }
    if (message.channel_id !== "0") {
      writer.uint32(16).int64(message.channel_id);
    }
    if (message.message_id !== "0") {
      writer.uint32(24).int64(message.message_id);
    }
    if (message.code !== 0) {
      writer.uint32(32).int32(message.code);
    }
    if (message.sender_id !== "0") {
      writer.uint32(40).int64(message.sender_id);
    }
    if (message.username !== "") {
      writer.uint32(50).string(message.username);
    }
    if (message.avatar !== "") {
      writer.uint32(58).string(message.avatar);
    }
    if (message.content !== "") {
      writer.uint32(66).string(message.content);
    }
    if (message.channel_label !== "") {
      writer.uint32(74).string(message.channel_label);
    }
    if (message.clan_logo !== "") {
      writer.uint32(82).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(90).string(message.category_name);
    }
    if (message.display_name !== "") {
      writer.uint32(98).string(message.display_name);
    }
    if (message.clan_nick !== "") {
      writer.uint32(106).string(message.clan_nick);
    }
    if (message.clan_avatar !== "") {
      writer.uint32(114).string(message.clan_avatar);
    }
    if (message.reactions.length !== 0) {
      writer.uint32(122).bytes(message.reactions);
    }
    if (message.mentions.length !== 0) {
      writer.uint32(130).bytes(message.mentions);
    }
    if (message.attachments.length !== 0) {
      writer.uint32(138).bytes(message.attachments);
    }
    if (message.references.length !== 0) {
      writer.uint32(146).bytes(message.references);
    }
    if (message.referenced_message.length !== 0) {
      writer.uint32(154).bytes(message.referenced_message);
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(160).uint32(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      writer.uint32(168).uint32(message.update_time_seconds);
    }
    if (message.mode !== 0) {
      writer.uint32(176).int32(message.mode);
    }
    if (message.hide_editted !== false) {
      writer.uint32(184).bool(message.hide_editted);
    }
    if (message.is_public !== false) {
      writer.uint32(192).bool(message.is_public);
    }
    if (message.topic_id !== "0") {
      writer.uint32(200).int64(message.topic_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clan_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.message_id = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sender_id = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.username = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.content = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.clan_nick = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.clan_avatar = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.reactions = reader.bytes();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.mentions = reader.bytes();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.attachments = reader.bytes();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.references = reader.bytes();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.referenced_message = reader.bytes();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.update_time_seconds = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.hide_editted = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.is_public = reader.bool();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.topic_id = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessage {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "0",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "0",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "0",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "0",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      clan_nick: isSet(object.clan_nick) ? globalThis.String(object.clan_nick) : "",
      clan_avatar: isSet(object.clan_avatar) ? globalThis.String(object.clan_avatar) : "",
      reactions: isSet(object.reactions) ? bytesFromBase64(object.reactions) : new Uint8Array(0),
      mentions: isSet(object.mentions) ? bytesFromBase64(object.mentions) : new Uint8Array(0),
      attachments: isSet(object.attachments) ? bytesFromBase64(object.attachments) : new Uint8Array(0),
      references: isSet(object.references) ? bytesFromBase64(object.references) : new Uint8Array(0),
      referenced_message: isSet(object.referenced_message)
        ? bytesFromBase64(object.referenced_message)
        : new Uint8Array(0),
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
      update_time_seconds: isSet(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      hide_editted: isSet(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,
      is_public: isSet(object.is_public) ? globalThis.Boolean(object.is_public) : false,
      topic_id: isSet(object.topic_id) ? globalThis.String(object.topic_id) : "0",
    };
  },

  toJSON(message: ChannelMessage): unknown {
    const obj: any = {};
    if (message.clan_id !== "0") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "0") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "0") {
      obj.message_id = message.message_id;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.sender_id !== "0") {
      obj.sender_id = message.sender_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.clan_nick !== "") {
      obj.clan_nick = message.clan_nick;
    }
    if (message.clan_avatar !== "") {
      obj.clan_avatar = message.clan_avatar;
    }
    if (message.reactions.length !== 0) {
      obj.reactions = base64FromBytes(message.reactions);
    }
    if (message.mentions.length !== 0) {
      obj.mentions = base64FromBytes(message.mentions);
    }
    if (message.attachments.length !== 0) {
      obj.attachments = base64FromBytes(message.attachments);
    }
    if (message.references.length !== 0) {
      obj.references = base64FromBytes(message.references);
    }
    if (message.referenced_message.length !== 0) {
      obj.referenced_message = base64FromBytes(message.referenced_message);
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      obj.update_time_seconds = Math.round(message.update_time_seconds);
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.hide_editted !== false) {
      obj.hide_editted = message.hide_editted;
    }
    if (message.is_public !== false) {
      obj.is_public = message.is_public;
    }
    if (message.topic_id !== "0") {
      obj.topic_id = message.topic_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessage>, I>>(base?: I): ChannelMessage {
    return ChannelMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessage>, I>>(object: I): ChannelMessage {
    const message = createBaseChannelMessage();
    message.clan_id = object.clan_id ?? "0";
    message.channel_id = object.channel_id ?? "0";
    message.message_id = object.message_id ?? "0";
    message.code = object.code ?? 0;
    message.sender_id = object.sender_id ?? "0";
    message.username = object.username ?? "";
    message.avatar = object.avatar ?? "";
    message.content = object.content ?? "";
    message.channel_label = object.channel_label ?? "";
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    message.display_name = object.display_name ?? "";
    message.clan_nick = object.clan_nick ?? "";
    message.clan_avatar = object.clan_avatar ?? "";
    message.reactions = object.reactions ?? new Uint8Array(0);
    message.mentions = object.mentions ?? new Uint8Array(0);
    message.attachments = object.attachments ?? new Uint8Array(0);
    message.references = object.references ?? new Uint8Array(0);
    message.referenced_message = object.referenced_message ?? new Uint8Array(0);
    message.create_time_seconds = object.create_time_seconds ?? 0;
    message.update_time_seconds = object.update_time_seconds ?? 0;
    message.mode = object.mode ?? 0;
    message.hide_editted = object.hide_editted ?? false;
    message.is_public = object.is_public ?? false;
    message.topic_id = object.topic_id ?? "0";
    return message;
  },
};


function createBaseChannelMessageHeader(): ChannelMessageHeader {
  return { id: "0", timestamp_seconds: 0, sender_id: "0", content: "" };
}

export const ChannelMessageHeader = {
  encode(message: ChannelMessageHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.timestamp_seconds !== 0) {
      writer.uint32(16).uint32(message.timestamp_seconds);
    }
    if (message.sender_id !== "0") {
      writer.uint32(24).int64(message.sender_id);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp_seconds = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sender_id = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageHeader {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      timestamp_seconds: isSet(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "0",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: ChannelMessageHeader): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.timestamp_seconds !== 0) {
      obj.timestamp_seconds = Math.round(message.timestamp_seconds);
    }
    if (message.sender_id !== "0") {
      obj.sender_id = message.sender_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageHeader>, I>>(base?: I): ChannelMessageHeader {
    return ChannelMessageHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageHeader>, I>>(object: I): ChannelMessageHeader {
    const message = createBaseChannelMessageHeader();
    message.id = object.id ?? "0";
    message.timestamp_seconds = object.timestamp_seconds ?? 0;
    message.sender_id = object.sender_id ?? "0";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseMessageMention(): MessageMention {
  return { id: "0", user_id: "0", username: "", role_id: "0", rolename: "", create_time_seconds: 0, s: 0, e: 0 };
}

export const MessageMention = {
  encode(message: MessageMention, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.user_id !== "0") {
      writer.uint32(16).int64(message.user_id);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.role_id !== "0") {
      writer.uint32(32).int64(message.role_id);
    }
    if (message.rolename !== "") {
      writer.uint32(42).string(message.rolename);
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(48).uint32(message.create_time_seconds);
    }
    if (message.s !== 0) {
      writer.uint32(56).int32(message.s);
    }
    if (message.e !== 0) {
      writer.uint32(64).int32(message.e);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageMention {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageMention();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.user_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.role_id = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rolename = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.s = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.e = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageMention {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "0",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "0",
      rolename: isSet(object.rolename) ? globalThis.String(object.rolename) : "",
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
      s: isSet(object.s) ? globalThis.Number(object.s) : 0,
      e: isSet(object.e) ? globalThis.Number(object.e) : 0,
    };
  },

  toJSON(message: MessageMention): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.user_id !== "0") {
      obj.user_id = message.user_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.role_id !== "0") {
      obj.role_id = message.role_id;
    }
    if (message.rolename !== "") {
      obj.rolename = message.rolename;
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    if (message.s !== 0) {
      obj.s = Math.round(message.s);
    }
    if (message.e !== 0) {
      obj.e = Math.round(message.e);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageMention>, I>>(base?: I): MessageMention {
    return MessageMention.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageMention>, I>>(object: I): MessageMention {
    const message = createBaseMessageMention();
    message.id = object.id ?? "0";
    message.user_id = object.user_id ?? "0";
    message.username = object.username ?? "";
    message.role_id = object.role_id ?? "0";
    message.rolename = object.rolename ?? "";
    message.create_time_seconds = object.create_time_seconds ?? 0;
    message.s = object.s ?? 0;
    message.e = object.e ?? 0;
    return message;
  },
};

function createBaseMessageAttachment(): MessageAttachment {
  return { filename: "", size: 0, url: "", filetype: "", width: 0, height: 0, thumbnail: "", duration: 0 };
}

export const MessageAttachment = {
  encode(message: MessageAttachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.size !== 0) {
      writer.uint32(16).int32(message.size);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.filetype !== "") {
      writer.uint32(34).string(message.filetype);
    }
    if (message.width !== 0) {
      writer.uint32(40).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(48).int32(message.height);
    }
    if (message.thumbnail !== "") {
      writer.uint32(58).string(message.thumbnail);
    }
    if (message.duration !== 0) {
      writer.uint32(64).int32(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.size = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filetype = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.thumbnail = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.duration = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageAttachment {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      filetype: isSet(object.filetype) ? globalThis.String(object.filetype) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      thumbnail: isSet(object.thumbnail) ? globalThis.String(object.thumbnail) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: MessageAttachment): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.filetype !== "") {
      obj.filetype = message.filetype;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.thumbnail !== "") {
      obj.thumbnail = message.thumbnail;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageAttachment>, I>>(base?: I): MessageAttachment {
    return MessageAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageAttachment>, I>>(object: I): MessageAttachment {
    const message = createBaseMessageAttachment();
    message.filename = object.filename ?? "";
    message.size = object.size ?? 0;
    message.url = object.url ?? "";
    message.filetype = object.filetype ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.thumbnail = object.thumbnail ?? "";
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseMessageRef(): MessageRef {
  return {
    message_id: "0",
    message_ref_id: "0",
    content: "",
    has_attachment: false,
    ref_type: 0,
    message_sender_id: "0",
    message_sender_username: "",
    mesages_sender_avatar: "",
    message_sender_clan_nick: "",
    message_sender_display_name: "",
  };
}

export const MessageRef = {
  encode(message: MessageRef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "0") {
      writer.uint32(8).int64(message.message_id);
    }
    if (message.message_ref_id !== "0") {
      writer.uint32(16).int64(message.message_ref_id);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.has_attachment !== false) {
      writer.uint32(32).bool(message.has_attachment);
    }
    if (message.ref_type !== 0) {
      writer.uint32(40).int32(message.ref_type);
    }
    if (message.message_sender_id !== "0") {
      writer.uint32(48).int64(message.message_sender_id);
    }
    if (message.message_sender_username !== "") {
      writer.uint32(58).string(message.message_sender_username);
    }
    if (message.mesages_sender_avatar !== "") {
      writer.uint32(66).string(message.mesages_sender_avatar);
    }
    if (message.message_sender_clan_nick !== "") {
      writer.uint32(74).string(message.message_sender_clan_nick);
    }
    if (message.message_sender_display_name !== "") {
      writer.uint32(82).string(message.message_sender_display_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageRef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.message_id = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.message_ref_id = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.has_attachment = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ref_type = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.message_sender_id = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.message_sender_username = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mesages_sender_avatar = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.message_sender_clan_nick = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.message_sender_display_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRef {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "0",
      message_ref_id: isSet(object.message_ref_id) ? globalThis.String(object.message_ref_id) : "0",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      has_attachment: isSet(object.has_attachment) ? globalThis.Boolean(object.has_attachment) : false,
      ref_type: isSet(object.ref_type) ? globalThis.Number(object.ref_type) : 0,
      message_sender_id: isSet(object.message_sender_id) ? globalThis.String(object.message_sender_id) : "0",
      message_sender_username: isSet(object.message_sender_username)
        ? globalThis.String(object.message_sender_username)
        : "",
      mesages_sender_avatar: isSet(object.mesages_sender_avatar) ? globalThis.String(object.mesages_sender_avatar) : "",
      message_sender_clan_nick: isSet(object.message_sender_clan_nick)
        ? globalThis.String(object.message_sender_clan_nick)
        : "",
      message_sender_display_name: isSet(object.message_sender_display_name)
        ? globalThis.String(object.message_sender_display_name)
        : "",
    };
  },

  toJSON(message: MessageRef): unknown {
    const obj: any = {};
    if (message.message_id !== "0") {
      obj.message_id = message.message_id;
    }
    if (message.message_ref_id !== "0") {
      obj.message_ref_id = message.message_ref_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.has_attachment !== false) {
      obj.has_attachment = message.has_attachment;
    }
    if (message.ref_type !== 0) {
      obj.ref_type = Math.round(message.ref_type);
    }
    if (message.message_sender_id !== "0") {
      obj.message_sender_id = message.message_sender_id;
    }
    if (message.message_sender_username !== "") {
      obj.message_sender_username = message.message_sender_username;
    }
    if (message.mesages_sender_avatar !== "") {
      obj.mesages_sender_avatar = message.mesages_sender_avatar;
    }
    if (message.message_sender_clan_nick !== "") {
      obj.message_sender_clan_nick = message.message_sender_clan_nick;
    }
    if (message.message_sender_display_name !== "") {
      obj.message_sender_display_name = message.message_sender_display_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageRef>, I>>(base?: I): MessageRef {
    return MessageRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageRef>, I>>(object: I): MessageRef {
    const message = createBaseMessageRef();
    message.message_id = object.message_id ?? "0";
    message.message_ref_id = object.message_ref_id ?? "0";
    message.content = object.content ?? "";
    message.has_attachment = object.has_attachment ?? false;
    message.ref_type = object.ref_type ?? 0;
    message.message_sender_id = object.message_sender_id ?? "0";
    message.message_sender_username = object.message_sender_username ?? "";
    message.mesages_sender_avatar = object.mesages_sender_avatar ?? "";
    message.message_sender_clan_nick = object.message_sender_clan_nick ?? "";
    message.message_sender_display_name = object.message_sender_display_name ?? "";
    return message;
  },
};

function createBaseMessageAttachmentList(): MessageAttachmentList {
  return { attachments: [] };
}

export const MessageAttachmentList = {
  encode(message: MessageAttachmentList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.attachments) {
      MessageAttachment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageAttachmentList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageAttachmentList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageAttachmentList {
    return {
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => MessageAttachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageAttachmentList): unknown {
    const obj: any = {};
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageAttachmentList>, I>>(base?: I): MessageAttachmentList {
    return MessageAttachmentList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageAttachmentList>, I>>(object: I): MessageAttachmentList {
    const message = createBaseMessageAttachmentList();
    message.attachments = object.attachments?.map((e) => MessageAttachment.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from((globalThis as any).Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return (globalThis as any).Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
