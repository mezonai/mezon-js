/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\n\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/long/src/long.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/api.js":
/*!************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/api.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MezonApi: () => (/* binding */ MezonApi)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/mezon-sdk/dist/esm/utils.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-base64 */ \"../../node_modules/js-base64/base64.mjs\");\n// tslint:disable\r\n/* Code generated by openapi-gen/main.go. DO NOT EDIT. */\r\n\r\n\r\nclass MezonApi {\r\n    apiKey;\r\n    basePath;\r\n    timeoutMs;\r\n    constructor(apiKey, basePath, timeoutMs) {\r\n        this.apiKey = apiKey;\r\n        this.basePath = basePath;\r\n        this.timeoutMs = timeoutMs;\r\n    }\r\n    /** A healthcheck which load balancers can use to check the service. */\r\n    mezonHealthcheck(bearerToken, options = {}) {\r\n        const urlPath = \"/healthcheck\";\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"GET\", options, bodyJson);\r\n        if (bearerToken) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** A readycheck which load balancers can use to check the service. */\r\n    mezonReadycheck(bearerToken, options = {}) {\r\n        const urlPath = \"/readycheck\";\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"GET\", options, bodyJson);\r\n        if (bearerToken) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** Authenticate a app with a token against the server. */\r\n    mezonAuthenticate(basicAuthUsername, basicAuthPassword, body, options = {}) {\r\n        if (body === null || body === undefined) {\r\n            throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n        }\r\n        const urlPath = \"/v2/apps/authenticate/token\";\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        bodyJson = JSON.stringify(body || {});\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"POST\", options, bodyJson);\r\n        if (basicAuthUsername) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Basic \" + (0,js_base64__WEBPACK_IMPORTED_MODULE_1__.encode)(basicAuthUsername + \":\" + basicAuthPassword);\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\r\n    mezonAuthenticateLogout(bearerToken, body, options = {}) {\r\n        if (body === null || body === undefined) {\r\n            throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n        }\r\n        const urlPath = \"/v2/apps/authenticate/logout\";\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        bodyJson = JSON.stringify(body || {});\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"POST\", options, bodyJson);\r\n        if (bearerToken) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\r\n    mezonAuthenticateRefresh(basicAuthUsername, basicAuthPassword, body, options = {}) {\r\n        if (body === null || body === undefined) {\r\n            throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n        }\r\n        const urlPath = \"/v2/apps/authenticate/refresh\";\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        bodyJson = JSON.stringify(body || {});\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"POST\", options, bodyJson);\r\n        if (basicAuthUsername) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Basic \" + (0,js_base64__WEBPACK_IMPORTED_MODULE_1__.encode)(basicAuthUsername + \":\" + basicAuthPassword);\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** Deletes a message for an identity. */\r\n    mezonDeleteMessage(bearerToken, id, options = {}) {\r\n        if (id === null || id === undefined) {\r\n            throw new Error(\"'id' is a required parameter but is null or undefined.\");\r\n        }\r\n        const urlPath = \"/v2/apps/message/{id}\"\r\n            .replace(\"{id}\", encodeURIComponent(String(id)));\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"DELETE\", options, bodyJson);\r\n        if (bearerToken) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** Updates a message for an identity. */\r\n    mezonUpdateMessage(bearerToken, id, body, options = {}) {\r\n        if (id === null || id === undefined) {\r\n            throw new Error(\"'id' is a required parameter but is null or undefined.\");\r\n        }\r\n        if (body === null || body === undefined) {\r\n            throw new Error(\"'body' is a required parameter but is null or undefined.\");\r\n        }\r\n        const urlPath = \"/v2/apps/message/{id}\"\r\n            .replace(\"{id}\", encodeURIComponent(String(id)));\r\n        const queryParams = new Map();\r\n        let bodyJson = \"\";\r\n        bodyJson = JSON.stringify(body || {});\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"PUT\", options, bodyJson);\r\n        if (bearerToken) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    /** List clans */\r\n    listClanDescs(bearerToken, limit, state, cursor, options = {}) {\r\n        const urlPath = \"/v2/clandesc\";\r\n        const queryParams = new Map();\r\n        queryParams.set(\"limit\", limit);\r\n        queryParams.set(\"state\", state);\r\n        queryParams.set(\"cursor\", cursor);\r\n        let bodyJson = \"\";\r\n        const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);\r\n        const fetchOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.buildFetchOptions)(\"GET\", options, bodyJson);\r\n        if (bearerToken) {\r\n            fetchOptions.headers[\"Authorization\"] = \"Bearer \" + bearerToken;\r\n        }\r\n        return Promise.race([\r\n            fetch(fullUrl, fetchOptions).then((response) => {\r\n                if (response.status == 204) {\r\n                    return response;\r\n                }\r\n                else if (response.status >= 200 && response.status < 300) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    throw response;\r\n                }\r\n            }),\r\n            new Promise((_, reject) => setTimeout(reject, this.timeoutMs, \"Request timed out.\")),\r\n        ]);\r\n    }\r\n    buildFullUrl(basePath, fragment, queryParams) {\r\n        let fullPath = basePath + fragment + \"?\";\r\n        for (let [k, v] of queryParams) {\r\n            if (v instanceof Array) {\r\n                fullPath += v.reduce((prev, curr) => {\r\n                    return prev + encodeURIComponent(k) + \"=\" + encodeURIComponent(curr) + \"&\";\r\n                }, \"\");\r\n            }\r\n            else {\r\n                if (v != null) {\r\n                    fullPath += encodeURIComponent(k) + \"=\" + encodeURIComponent(v) + \"&\";\r\n                }\r\n            }\r\n        }\r\n        return fullPath;\r\n    }\r\n}\r\n;\r\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/api.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/api/api.js":
/*!****************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/api/api.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountApp: () => (/* binding */ AccountApp),\n/* harmony export */   AccountApp_VarsEntry: () => (/* binding */ AccountApp_VarsEntry),\n/* harmony export */   AccountApple: () => (/* binding */ AccountApple),\n/* harmony export */   AccountApple_VarsEntry: () => (/* binding */ AccountApple_VarsEntry),\n/* harmony export */   AccountCustom: () => (/* binding */ AccountCustom),\n/* harmony export */   AccountCustom_VarsEntry: () => (/* binding */ AccountCustom_VarsEntry),\n/* harmony export */   AccountDevice: () => (/* binding */ AccountDevice),\n/* harmony export */   AccountDevice_VarsEntry: () => (/* binding */ AccountDevice_VarsEntry),\n/* harmony export */   AccountEmail: () => (/* binding */ AccountEmail),\n/* harmony export */   AccountEmail_VarsEntry: () => (/* binding */ AccountEmail_VarsEntry),\n/* harmony export */   AccountFacebook: () => (/* binding */ AccountFacebook),\n/* harmony export */   AccountFacebookInstantGame: () => (/* binding */ AccountFacebookInstantGame),\n/* harmony export */   AccountFacebookInstantGame_VarsEntry: () => (/* binding */ AccountFacebookInstantGame_VarsEntry),\n/* harmony export */   AccountFacebook_VarsEntry: () => (/* binding */ AccountFacebook_VarsEntry),\n/* harmony export */   AccountGameCenter: () => (/* binding */ AccountGameCenter),\n/* harmony export */   AccountGameCenter_VarsEntry: () => (/* binding */ AccountGameCenter_VarsEntry),\n/* harmony export */   AccountGoogle: () => (/* binding */ AccountGoogle),\n/* harmony export */   AccountGoogle_VarsEntry: () => (/* binding */ AccountGoogle_VarsEntry),\n/* harmony export */   AccountRefresh: () => (/* binding */ AccountRefresh),\n/* harmony export */   AccountRefresh_VarsEntry: () => (/* binding */ AccountRefresh_VarsEntry),\n/* harmony export */   AccountSteam: () => (/* binding */ AccountSteam),\n/* harmony export */   AccountSteam_VarsEntry: () => (/* binding */ AccountSteam_VarsEntry),\n/* harmony export */   AddAppRequest: () => (/* binding */ AddAppRequest),\n/* harmony export */   AddChannelUsersRequest: () => (/* binding */ AddChannelUsersRequest),\n/* harmony export */   AddFriendsRequest: () => (/* binding */ AddFriendsRequest),\n/* harmony export */   AddGroupUsersRequest: () => (/* binding */ AddGroupUsersRequest),\n/* harmony export */   AddRoleChannelDescRequest: () => (/* binding */ AddRoleChannelDescRequest),\n/* harmony export */   App: () => (/* binding */ App),\n/* harmony export */   AppClan: () => (/* binding */ AppClan),\n/* harmony export */   AppDeleteRequest: () => (/* binding */ AppDeleteRequest),\n/* harmony export */   AppId: () => (/* binding */ AppId),\n/* harmony export */   AppList: () => (/* binding */ AppList),\n/* harmony export */   AuthenticateAppleRequest: () => (/* binding */ AuthenticateAppleRequest),\n/* harmony export */   AuthenticateCustomRequest: () => (/* binding */ AuthenticateCustomRequest),\n/* harmony export */   AuthenticateDeviceRequest: () => (/* binding */ AuthenticateDeviceRequest),\n/* harmony export */   AuthenticateEmailRequest: () => (/* binding */ AuthenticateEmailRequest),\n/* harmony export */   AuthenticateFacebookInstantGameRequest: () => (/* binding */ AuthenticateFacebookInstantGameRequest),\n/* harmony export */   AuthenticateFacebookRequest: () => (/* binding */ AuthenticateFacebookRequest),\n/* harmony export */   AuthenticateGameCenterRequest: () => (/* binding */ AuthenticateGameCenterRequest),\n/* harmony export */   AuthenticateGoogleRequest: () => (/* binding */ AuthenticateGoogleRequest),\n/* harmony export */   AuthenticateRequest: () => (/* binding */ AuthenticateRequest),\n/* harmony export */   AuthenticateSteamRequest: () => (/* binding */ AuthenticateSteamRequest),\n/* harmony export */   BanGroupUsersRequest: () => (/* binding */ BanGroupUsersRequest),\n/* harmony export */   BlockFriendsRequest: () => (/* binding */ BlockFriendsRequest),\n/* harmony export */   CategoryDesc: () => (/* binding */ CategoryDesc),\n/* harmony export */   CategoryDescList: () => (/* binding */ CategoryDescList),\n/* harmony export */   ChangeChannelCategoryRequest: () => (/* binding */ ChangeChannelCategoryRequest),\n/* harmony export */   ChangeChannelPrivateRequest: () => (/* binding */ ChangeChannelPrivateRequest),\n/* harmony export */   ChannelAttachment: () => (/* binding */ ChannelAttachment),\n/* harmony export */   ChannelAttachmentList: () => (/* binding */ ChannelAttachmentList),\n/* harmony export */   ChannelDescList: () => (/* binding */ ChannelDescList),\n/* harmony export */   ChannelDescription: () => (/* binding */ ChannelDescription),\n/* harmony export */   ChannelMessage: () => (/* binding */ ChannelMessage),\n/* harmony export */   ChannelMessageHeader: () => (/* binding */ ChannelMessageHeader),\n/* harmony export */   ChannelMessageList: () => (/* binding */ ChannelMessageList),\n/* harmony export */   ChannelUserList: () => (/* binding */ ChannelUserList),\n/* harmony export */   ChannelUserList_ChannelUser: () => (/* binding */ ChannelUserList_ChannelUser),\n/* harmony export */   CheckDuplicateClanNameRequest: () => (/* binding */ CheckDuplicateClanNameRequest),\n/* harmony export */   CheckDuplicateClanNameResponse: () => (/* binding */ CheckDuplicateClanNameResponse),\n/* harmony export */   ClanDesc: () => (/* binding */ ClanDesc),\n/* harmony export */   ClanDescList: () => (/* binding */ ClanDescList),\n/* harmony export */   ClanDescProfile: () => (/* binding */ ClanDescProfile),\n/* harmony export */   ClanDescProfileRequest: () => (/* binding */ ClanDescProfileRequest),\n/* harmony export */   ClanEmojiCreateRequest: () => (/* binding */ ClanEmojiCreateRequest),\n/* harmony export */   ClanEmojiDeleteRequest: () => (/* binding */ ClanEmojiDeleteRequest),\n/* harmony export */   ClanEmojiGetByClanIdRequest: () => (/* binding */ ClanEmojiGetByClanIdRequest),\n/* harmony export */   ClanEmojiUpdateRequest: () => (/* binding */ ClanEmojiUpdateRequest),\n/* harmony export */   ClanProfile: () => (/* binding */ ClanProfile),\n/* harmony export */   ClanProfileRequest: () => (/* binding */ ClanProfileRequest),\n/* harmony export */   ClanStickerAddRequest: () => (/* binding */ ClanStickerAddRequest),\n/* harmony export */   ClanStickerDeleteRequest: () => (/* binding */ ClanStickerDeleteRequest),\n/* harmony export */   ClanStickerListByClanIdRequest: () => (/* binding */ ClanStickerListByClanIdRequest),\n/* harmony export */   ClanStickerUpdateByIdRequest: () => (/* binding */ ClanStickerUpdateByIdRequest),\n/* harmony export */   ClanUserList: () => (/* binding */ ClanUserList),\n/* harmony export */   ClanUserList_ClanUser: () => (/* binding */ ClanUserList_ClanUser),\n/* harmony export */   CreateCategoryDescRequest: () => (/* binding */ CreateCategoryDescRequest),\n/* harmony export */   CreateChannelDescRequest: () => (/* binding */ CreateChannelDescRequest),\n/* harmony export */   CreateClanDescRequest: () => (/* binding */ CreateClanDescRequest),\n/* harmony export */   CreateEventRequest: () => (/* binding */ CreateEventRequest),\n/* harmony export */   CreateGroupRequest: () => (/* binding */ CreateGroupRequest),\n/* harmony export */   CreateRoleRequest: () => (/* binding */ CreateRoleRequest),\n/* harmony export */   DefaultNotificationCategory: () => (/* binding */ DefaultNotificationCategory),\n/* harmony export */   DefaultNotificationClan: () => (/* binding */ DefaultNotificationClan),\n/* harmony export */   DeleteCategoryDescRequest: () => (/* binding */ DeleteCategoryDescRequest),\n/* harmony export */   DeleteChannelDescRequest: () => (/* binding */ DeleteChannelDescRequest),\n/* harmony export */   DeleteChannelMessagesRequest: () => (/* binding */ DeleteChannelMessagesRequest),\n/* harmony export */   DeleteChannelMessagesResponse: () => (/* binding */ DeleteChannelMessagesResponse),\n/* harmony export */   DeleteClanDescRequest: () => (/* binding */ DeleteClanDescRequest),\n/* harmony export */   DeleteEventRequest: () => (/* binding */ DeleteEventRequest),\n/* harmony export */   DeleteFriendsRequest: () => (/* binding */ DeleteFriendsRequest),\n/* harmony export */   DeleteGroupRequest: () => (/* binding */ DeleteGroupRequest),\n/* harmony export */   DeleteNotificationsRequest: () => (/* binding */ DeleteNotificationsRequest),\n/* harmony export */   DeletePinMessage: () => (/* binding */ DeletePinMessage),\n/* harmony export */   DeleteRoleRequest: () => (/* binding */ DeleteRoleRequest),\n/* harmony export */   DemoteGroupUsersRequest: () => (/* binding */ DemoteGroupUsersRequest),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   EventList: () => (/* binding */ EventList),\n/* harmony export */   EventManagement: () => (/* binding */ EventManagement),\n/* harmony export */   EventUserList: () => (/* binding */ EventUserList),\n/* harmony export */   EventUserList_EventUser: () => (/* binding */ EventUserList_EventUser),\n/* harmony export */   Event_PropertiesEntry: () => (/* binding */ Event_PropertiesEntry),\n/* harmony export */   FilterParam: () => (/* binding */ FilterParam),\n/* harmony export */   Friend: () => (/* binding */ Friend),\n/* harmony export */   FriendList: () => (/* binding */ FriendList),\n/* harmony export */   Friend_State: () => (/* binding */ Friend_State),\n/* harmony export */   GetUsersRequest: () => (/* binding */ GetUsersRequest),\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   GroupList: () => (/* binding */ GroupList),\n/* harmony export */   GroupUserList: () => (/* binding */ GroupUserList),\n/* harmony export */   GroupUserList_GroupUser: () => (/* binding */ GroupUserList_GroupUser),\n/* harmony export */   GroupUserList_GroupUser_State: () => (/* binding */ GroupUserList_GroupUser_State),\n/* harmony export */   ImportFacebookFriendsRequest: () => (/* binding */ ImportFacebookFriendsRequest),\n/* harmony export */   ImportSteamFriendsRequest: () => (/* binding */ ImportSteamFriendsRequest),\n/* harmony export */   InviteUserRequest: () => (/* binding */ InviteUserRequest),\n/* harmony export */   InviteUserRes: () => (/* binding */ InviteUserRes),\n/* harmony export */   JoinClanChannelRequest: () => (/* binding */ JoinClanChannelRequest),\n/* harmony export */   LeaveChannelRequest: () => (/* binding */ LeaveChannelRequest),\n/* harmony export */   LinkFacebookRequest: () => (/* binding */ LinkFacebookRequest),\n/* harmony export */   LinkInviteUser: () => (/* binding */ LinkInviteUser),\n/* harmony export */   LinkInviteUserRequest: () => (/* binding */ LinkInviteUserRequest),\n/* harmony export */   LinkSteamRequest: () => (/* binding */ LinkSteamRequest),\n/* harmony export */   ListAppsRequest: () => (/* binding */ ListAppsRequest),\n/* harmony export */   ListCategoryDescsRequest: () => (/* binding */ ListCategoryDescsRequest),\n/* harmony export */   ListChannelAttachmentRequest: () => (/* binding */ ListChannelAttachmentRequest),\n/* harmony export */   ListChannelDescsRequest: () => (/* binding */ ListChannelDescsRequest),\n/* harmony export */   ListChannelMessagesRequest: () => (/* binding */ ListChannelMessagesRequest),\n/* harmony export */   ListChannelUsersRequest: () => (/* binding */ ListChannelUsersRequest),\n/* harmony export */   ListClanDescRequest: () => (/* binding */ ListClanDescRequest),\n/* harmony export */   ListClanUsersRequest: () => (/* binding */ ListClanUsersRequest),\n/* harmony export */   ListEventsRequest: () => (/* binding */ ListEventsRequest),\n/* harmony export */   ListFriendsRequest: () => (/* binding */ ListFriendsRequest),\n/* harmony export */   ListGroupUsersRequest: () => (/* binding */ ListGroupUsersRequest),\n/* harmony export */   ListGroupsRequest: () => (/* binding */ ListGroupsRequest),\n/* harmony export */   ListMessageMentionRequest: () => (/* binding */ ListMessageMentionRequest),\n/* harmony export */   ListNotificationsRequest: () => (/* binding */ ListNotificationsRequest),\n/* harmony export */   ListPermissionOfUsersRequest: () => (/* binding */ ListPermissionOfUsersRequest),\n/* harmony export */   ListPermissionsRequest: () => (/* binding */ ListPermissionsRequest),\n/* harmony export */   ListRoleUsersRequest: () => (/* binding */ ListRoleUsersRequest),\n/* harmony export */   ListRolesRequest: () => (/* binding */ ListRolesRequest),\n/* harmony export */   ListUserGroupsRequest: () => (/* binding */ ListUserGroupsRequest),\n/* harmony export */   MessageAttachment: () => (/* binding */ MessageAttachment),\n/* harmony export */   MessageDeleted: () => (/* binding */ MessageDeleted),\n/* harmony export */   MessageMention: () => (/* binding */ MessageMention),\n/* harmony export */   MessageReaction: () => (/* binding */ MessageReaction),\n/* harmony export */   MessageRef: () => (/* binding */ MessageRef),\n/* harmony export */   NotifiReactMessage: () => (/* binding */ NotifiReactMessage),\n/* harmony export */   Notification: () => (/* binding */ Notification),\n/* harmony export */   NotificationChannel: () => (/* binding */ NotificationChannel),\n/* harmony export */   NotificationChannelCategoySetting: () => (/* binding */ NotificationChannelCategoySetting),\n/* harmony export */   NotificationChannelCategoySettingsList: () => (/* binding */ NotificationChannelCategoySettingsList),\n/* harmony export */   NotificationInfo: () => (/* binding */ NotificationInfo),\n/* harmony export */   NotificationList: () => (/* binding */ NotificationList),\n/* harmony export */   NotificationSetting: () => (/* binding */ NotificationSetting),\n/* harmony export */   NotificationSettingList: () => (/* binding */ NotificationSettingList),\n/* harmony export */   NotificationUserChannel: () => (/* binding */ NotificationUserChannel),\n/* harmony export */   Operator: () => (/* binding */ Operator),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   PermissionList: () => (/* binding */ PermissionList),\n/* harmony export */   PermissionUpdate: () => (/* binding */ PermissionUpdate),\n/* harmony export */   PinMessage: () => (/* binding */ PinMessage),\n/* harmony export */   PinMessageRequest: () => (/* binding */ PinMessageRequest),\n/* harmony export */   PinMessagesList: () => (/* binding */ PinMessagesList),\n/* harmony export */   PromoteGroupUsersRequest: () => (/* binding */ PromoteGroupUsersRequest),\n/* harmony export */   RegistFcmDeviceTokenRequest: () => (/* binding */ RegistFcmDeviceTokenRequest),\n/* harmony export */   RegistrationEmailRequest: () => (/* binding */ RegistrationEmailRequest),\n/* harmony export */   RegistrationEmailRequest_VarsEntry: () => (/* binding */ RegistrationEmailRequest_VarsEntry),\n/* harmony export */   RemoveChannelUsersRequest: () => (/* binding */ RemoveChannelUsersRequest),\n/* harmony export */   RemoveClanUsersRequest: () => (/* binding */ RemoveClanUsersRequest),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   RoleList: () => (/* binding */ RoleList),\n/* harmony export */   RoleUserList: () => (/* binding */ RoleUserList),\n/* harmony export */   RoleUserList_RoleUser: () => (/* binding */ RoleUserList_RoleUser),\n/* harmony export */   Rpc: () => (/* binding */ Rpc),\n/* harmony export */   SearchMessageDocument: () => (/* binding */ SearchMessageDocument),\n/* harmony export */   SearchMessageRequest: () => (/* binding */ SearchMessageRequest),\n/* harmony export */   SearchMessageResponse: () => (/* binding */ SearchMessageResponse),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SessionLogoutRequest: () => (/* binding */ SessionLogoutRequest),\n/* harmony export */   SessionRefreshRequest: () => (/* binding */ SessionRefreshRequest),\n/* harmony export */   SessionRefreshRequest_VarsEntry: () => (/* binding */ SessionRefreshRequest_VarsEntry),\n/* harmony export */   SetDefaultNotificationRequest: () => (/* binding */ SetDefaultNotificationRequest),\n/* harmony export */   SetMuteNotificationRequest: () => (/* binding */ SetMuteNotificationRequest),\n/* harmony export */   SetNotificationRequest: () => (/* binding */ SetNotificationRequest),\n/* harmony export */   SortParam: () => (/* binding */ SortParam),\n/* harmony export */   StoreEnvironment: () => (/* binding */ StoreEnvironment),\n/* harmony export */   StoreProvider: () => (/* binding */ StoreProvider),\n/* harmony export */   UpdateAccountRequest: () => (/* binding */ UpdateAccountRequest),\n/* harmony export */   UpdateAppRequest: () => (/* binding */ UpdateAppRequest),\n/* harmony export */   UpdateCategoryDescRequest: () => (/* binding */ UpdateCategoryDescRequest),\n/* harmony export */   UpdateChannelDescRequest: () => (/* binding */ UpdateChannelDescRequest),\n/* harmony export */   UpdateClanDescProfileRequest: () => (/* binding */ UpdateClanDescProfileRequest),\n/* harmony export */   UpdateClanDescRequest: () => (/* binding */ UpdateClanDescRequest),\n/* harmony export */   UpdateClanProfileRequest: () => (/* binding */ UpdateClanProfileRequest),\n/* harmony export */   UpdateEventRequest: () => (/* binding */ UpdateEventRequest),\n/* harmony export */   UpdateGroupRequest: () => (/* binding */ UpdateGroupRequest),\n/* harmony export */   UpdateRoleChannelRequest: () => (/* binding */ UpdateRoleChannelRequest),\n/* harmony export */   UpdateRoleRequest: () => (/* binding */ UpdateRoleRequest),\n/* harmony export */   UpdateUsersRequest: () => (/* binding */ UpdateUsersRequest),\n/* harmony export */   UploadAttachment: () => (/* binding */ UploadAttachment),\n/* harmony export */   UploadAttachmentRequest: () => (/* binding */ UploadAttachmentRequest),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserGroupList: () => (/* binding */ UserGroupList),\n/* harmony export */   UserGroupList_UserGroup: () => (/* binding */ UserGroupList_UserGroup),\n/* harmony export */   UserGroupList_UserGroup_State: () => (/* binding */ UserGroupList_UserGroup_State),\n/* harmony export */   Users: () => (/* binding */ Users),\n/* harmony export */   VoiceChannelUser: () => (/* binding */ VoiceChannelUser),\n/* harmony export */   VoiceChannelUserList: () => (/* binding */ VoiceChannelUserList),\n/* harmony export */   Webhook: () => (/* binding */ Webhook),\n/* harmony export */   WebhookCreateRequest: () => (/* binding */ WebhookCreateRequest),\n/* harmony export */   WebhookDeleteRequestById: () => (/* binding */ WebhookDeleteRequestById),\n/* harmony export */   WebhookGenerateResponse: () => (/* binding */ WebhookGenerateResponse),\n/* harmony export */   WebhookListRequest: () => (/* binding */ WebhookListRequest),\n/* harmony export */   WebhookListRequestById: () => (/* binding */ WebhookListRequestById),\n/* harmony export */   WebhookListResponse: () => (/* binding */ WebhookListResponse),\n/* harmony export */   WebhookUpdateRequestById: () => (/* binding */ WebhookUpdateRequestById),\n/* harmony export */   friend_StateFromJSON: () => (/* binding */ friend_StateFromJSON),\n/* harmony export */   friend_StateToJSON: () => (/* binding */ friend_StateToJSON),\n/* harmony export */   groupUserList_GroupUser_StateFromJSON: () => (/* binding */ groupUserList_GroupUser_StateFromJSON),\n/* harmony export */   groupUserList_GroupUser_StateToJSON: () => (/* binding */ groupUserList_GroupUser_StateToJSON),\n/* harmony export */   operatorFromJSON: () => (/* binding */ operatorFromJSON),\n/* harmony export */   operatorToJSON: () => (/* binding */ operatorToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage),\n/* harmony export */   storeEnvironmentFromJSON: () => (/* binding */ storeEnvironmentFromJSON),\n/* harmony export */   storeEnvironmentToJSON: () => (/* binding */ storeEnvironmentToJSON),\n/* harmony export */   storeProviderFromJSON: () => (/* binding */ storeProviderFromJSON),\n/* harmony export */   storeProviderToJSON: () => (/* binding */ storeProviderToJSON),\n/* harmony export */   userGroupList_UserGroup_StateFromJSON: () => (/* binding */ userGroupList_UserGroup_StateFromJSON),\n/* harmony export */   userGroupList_UserGroup_StateToJSON: () => (/* binding */ userGroupList_UserGroup_StateToJSON)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"./node_modules/long/src/long.js\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../google/protobuf/timestamp */ \"./node_modules/mezon-sdk/dist/esm/google/protobuf/timestamp.js\");\n/* harmony import */ var _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../google/protobuf/wrappers */ \"./node_modules/mezon-sdk/dist/esm/google/protobuf/wrappers.js\");\n/* eslint-disable */\r\n\r\n\r\n\r\n\r\nconst protobufPackage = \"mezon.api\";\r\n/** The Mezon server RPC protocol for games and apps. */\r\n/** Validation Provider, */\r\nvar StoreProvider;\r\n(function (StoreProvider) {\r\n    /** APPLE_APP_STORE - Apple App Store */\r\n    StoreProvider[StoreProvider[\"APPLE_APP_STORE\"] = 0] = \"APPLE_APP_STORE\";\r\n    /** GOOGLE_PLAY_STORE - Google Play Store */\r\n    StoreProvider[StoreProvider[\"GOOGLE_PLAY_STORE\"] = 1] = \"GOOGLE_PLAY_STORE\";\r\n    /** HUAWEI_APP_GALLERY - Huawei App Gallery */\r\n    StoreProvider[StoreProvider[\"HUAWEI_APP_GALLERY\"] = 2] = \"HUAWEI_APP_GALLERY\";\r\n    /** FACEBOOK_INSTANT_STORE - Facebook Instant Store */\r\n    StoreProvider[StoreProvider[\"FACEBOOK_INSTANT_STORE\"] = 3] = \"FACEBOOK_INSTANT_STORE\";\r\n    StoreProvider[StoreProvider[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(StoreProvider || (StoreProvider = {}));\r\nfunction storeProviderFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"APPLE_APP_STORE\":\r\n            return StoreProvider.APPLE_APP_STORE;\r\n        case 1:\r\n        case \"GOOGLE_PLAY_STORE\":\r\n            return StoreProvider.GOOGLE_PLAY_STORE;\r\n        case 2:\r\n        case \"HUAWEI_APP_GALLERY\":\r\n            return StoreProvider.HUAWEI_APP_GALLERY;\r\n        case 3:\r\n        case \"FACEBOOK_INSTANT_STORE\":\r\n            return StoreProvider.FACEBOOK_INSTANT_STORE;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return StoreProvider.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction storeProviderToJSON(object) {\r\n    switch (object) {\r\n        case StoreProvider.APPLE_APP_STORE:\r\n            return \"APPLE_APP_STORE\";\r\n        case StoreProvider.GOOGLE_PLAY_STORE:\r\n            return \"GOOGLE_PLAY_STORE\";\r\n        case StoreProvider.HUAWEI_APP_GALLERY:\r\n            return \"HUAWEI_APP_GALLERY\";\r\n        case StoreProvider.FACEBOOK_INSTANT_STORE:\r\n            return \"FACEBOOK_INSTANT_STORE\";\r\n        case StoreProvider.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\n/** Environment where a purchase/subscription took place, */\r\nvar StoreEnvironment;\r\n(function (StoreEnvironment) {\r\n    /** UNKNOWN - Unknown environment. */\r\n    StoreEnvironment[StoreEnvironment[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\r\n    /** SANDBOX - Sandbox/test environment. */\r\n    StoreEnvironment[StoreEnvironment[\"SANDBOX\"] = 1] = \"SANDBOX\";\r\n    /** PRODUCTION - Production environment. */\r\n    StoreEnvironment[StoreEnvironment[\"PRODUCTION\"] = 2] = \"PRODUCTION\";\r\n    StoreEnvironment[StoreEnvironment[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(StoreEnvironment || (StoreEnvironment = {}));\r\nfunction storeEnvironmentFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"UNKNOWN\":\r\n            return StoreEnvironment.UNKNOWN;\r\n        case 1:\r\n        case \"SANDBOX\":\r\n            return StoreEnvironment.SANDBOX;\r\n        case 2:\r\n        case \"PRODUCTION\":\r\n            return StoreEnvironment.PRODUCTION;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return StoreEnvironment.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction storeEnvironmentToJSON(object) {\r\n    switch (object) {\r\n        case StoreEnvironment.UNKNOWN:\r\n            return \"UNKNOWN\";\r\n        case StoreEnvironment.SANDBOX:\r\n            return \"SANDBOX\";\r\n        case StoreEnvironment.PRODUCTION:\r\n            return \"PRODUCTION\";\r\n        case StoreEnvironment.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\n/** Operator that can be used to override the one set in the leaderboard. */\r\nvar Operator;\r\n(function (Operator) {\r\n    /** NO_OVERRIDE - Do not override the leaderboard operator. */\r\n    Operator[Operator[\"NO_OVERRIDE\"] = 0] = \"NO_OVERRIDE\";\r\n    /** BEST - Override the leaderboard operator with BEST. */\r\n    Operator[Operator[\"BEST\"] = 1] = \"BEST\";\r\n    /** SET - Override the leaderboard operator with SET. */\r\n    Operator[Operator[\"SET\"] = 2] = \"SET\";\r\n    /** INCREMENT - Override the leaderboard operator with INCREMENT. */\r\n    Operator[Operator[\"INCREMENT\"] = 3] = \"INCREMENT\";\r\n    /** DECREMENT - Override the leaderboard operator with DECREMENT. */\r\n    Operator[Operator[\"DECREMENT\"] = 4] = \"DECREMENT\";\r\n    Operator[Operator[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(Operator || (Operator = {}));\r\nfunction operatorFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"NO_OVERRIDE\":\r\n            return Operator.NO_OVERRIDE;\r\n        case 1:\r\n        case \"BEST\":\r\n            return Operator.BEST;\r\n        case 2:\r\n        case \"SET\":\r\n            return Operator.SET;\r\n        case 3:\r\n        case \"INCREMENT\":\r\n            return Operator.INCREMENT;\r\n        case 4:\r\n        case \"DECREMENT\":\r\n            return Operator.DECREMENT;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return Operator.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction operatorToJSON(object) {\r\n    switch (object) {\r\n        case Operator.NO_OVERRIDE:\r\n            return \"NO_OVERRIDE\";\r\n        case Operator.BEST:\r\n            return \"BEST\";\r\n        case Operator.SET:\r\n            return \"SET\";\r\n        case Operator.INCREMENT:\r\n            return \"INCREMENT\";\r\n        case Operator.DECREMENT:\r\n            return \"DECREMENT\";\r\n        case Operator.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\n/** The friendship status. */\r\nvar Friend_State;\r\n(function (Friend_State) {\r\n    /** FRIEND - The user is a friend of the current user. */\r\n    Friend_State[Friend_State[\"FRIEND\"] = 0] = \"FRIEND\";\r\n    /** INVITE_SENT - The current user has sent an invite to the user. */\r\n    Friend_State[Friend_State[\"INVITE_SENT\"] = 1] = \"INVITE_SENT\";\r\n    /** INVITE_RECEIVED - The current user has received an invite from this user. */\r\n    Friend_State[Friend_State[\"INVITE_RECEIVED\"] = 2] = \"INVITE_RECEIVED\";\r\n    /** BLOCKED - The current user has blocked this user. */\r\n    Friend_State[Friend_State[\"BLOCKED\"] = 3] = \"BLOCKED\";\r\n    Friend_State[Friend_State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(Friend_State || (Friend_State = {}));\r\nfunction friend_StateFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"FRIEND\":\r\n            return Friend_State.FRIEND;\r\n        case 1:\r\n        case \"INVITE_SENT\":\r\n            return Friend_State.INVITE_SENT;\r\n        case 2:\r\n        case \"INVITE_RECEIVED\":\r\n            return Friend_State.INVITE_RECEIVED;\r\n        case 3:\r\n        case \"BLOCKED\":\r\n            return Friend_State.BLOCKED;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return Friend_State.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction friend_StateToJSON(object) {\r\n    switch (object) {\r\n        case Friend_State.FRIEND:\r\n            return \"FRIEND\";\r\n        case Friend_State.INVITE_SENT:\r\n            return \"INVITE_SENT\";\r\n        case Friend_State.INVITE_RECEIVED:\r\n            return \"INVITE_RECEIVED\";\r\n        case Friend_State.BLOCKED:\r\n            return \"BLOCKED\";\r\n        case Friend_State.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\n/** The group role status. */\r\nvar GroupUserList_GroupUser_State;\r\n(function (GroupUserList_GroupUser_State) {\r\n    /** SUPERADMIN - The user is a superadmin with full control of the group. */\r\n    GroupUserList_GroupUser_State[GroupUserList_GroupUser_State[\"SUPERADMIN\"] = 0] = \"SUPERADMIN\";\r\n    /** ADMIN - The user is an admin with additional privileges. */\r\n    GroupUserList_GroupUser_State[GroupUserList_GroupUser_State[\"ADMIN\"] = 1] = \"ADMIN\";\r\n    /** MEMBER - The user is a regular member. */\r\n    GroupUserList_GroupUser_State[GroupUserList_GroupUser_State[\"MEMBER\"] = 2] = \"MEMBER\";\r\n    /** JOIN_REQUEST - The user has requested to join the group */\r\n    GroupUserList_GroupUser_State[GroupUserList_GroupUser_State[\"JOIN_REQUEST\"] = 3] = \"JOIN_REQUEST\";\r\n    GroupUserList_GroupUser_State[GroupUserList_GroupUser_State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(GroupUserList_GroupUser_State || (GroupUserList_GroupUser_State = {}));\r\nfunction groupUserList_GroupUser_StateFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"SUPERADMIN\":\r\n            return GroupUserList_GroupUser_State.SUPERADMIN;\r\n        case 1:\r\n        case \"ADMIN\":\r\n            return GroupUserList_GroupUser_State.ADMIN;\r\n        case 2:\r\n        case \"MEMBER\":\r\n            return GroupUserList_GroupUser_State.MEMBER;\r\n        case 3:\r\n        case \"JOIN_REQUEST\":\r\n            return GroupUserList_GroupUser_State.JOIN_REQUEST;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return GroupUserList_GroupUser_State.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction groupUserList_GroupUser_StateToJSON(object) {\r\n    switch (object) {\r\n        case GroupUserList_GroupUser_State.SUPERADMIN:\r\n            return \"SUPERADMIN\";\r\n        case GroupUserList_GroupUser_State.ADMIN:\r\n            return \"ADMIN\";\r\n        case GroupUserList_GroupUser_State.MEMBER:\r\n            return \"MEMBER\";\r\n        case GroupUserList_GroupUser_State.JOIN_REQUEST:\r\n            return \"JOIN_REQUEST\";\r\n        case GroupUserList_GroupUser_State.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\n/** The group role status. */\r\nvar UserGroupList_UserGroup_State;\r\n(function (UserGroupList_UserGroup_State) {\r\n    /** SUPERADMIN - The user is a superadmin with full control of the group. */\r\n    UserGroupList_UserGroup_State[UserGroupList_UserGroup_State[\"SUPERADMIN\"] = 0] = \"SUPERADMIN\";\r\n    /** ADMIN - The user is an admin with additional privileges. */\r\n    UserGroupList_UserGroup_State[UserGroupList_UserGroup_State[\"ADMIN\"] = 1] = \"ADMIN\";\r\n    /** MEMBER - The user is a regular member. */\r\n    UserGroupList_UserGroup_State[UserGroupList_UserGroup_State[\"MEMBER\"] = 2] = \"MEMBER\";\r\n    /** JOIN_REQUEST - The user has requested to join the group */\r\n    UserGroupList_UserGroup_State[UserGroupList_UserGroup_State[\"JOIN_REQUEST\"] = 3] = \"JOIN_REQUEST\";\r\n    UserGroupList_UserGroup_State[UserGroupList_UserGroup_State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(UserGroupList_UserGroup_State || (UserGroupList_UserGroup_State = {}));\r\nfunction userGroupList_UserGroup_StateFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"SUPERADMIN\":\r\n            return UserGroupList_UserGroup_State.SUPERADMIN;\r\n        case 1:\r\n        case \"ADMIN\":\r\n            return UserGroupList_UserGroup_State.ADMIN;\r\n        case 2:\r\n        case \"MEMBER\":\r\n            return UserGroupList_UserGroup_State.MEMBER;\r\n        case 3:\r\n        case \"JOIN_REQUEST\":\r\n            return UserGroupList_UserGroup_State.JOIN_REQUEST;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return UserGroupList_UserGroup_State.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction userGroupList_UserGroup_StateToJSON(object) {\r\n    switch (object) {\r\n        case UserGroupList_UserGroup_State.SUPERADMIN:\r\n            return \"SUPERADMIN\";\r\n        case UserGroupList_UserGroup_State.ADMIN:\r\n            return \"ADMIN\";\r\n        case UserGroupList_UserGroup_State.MEMBER:\r\n            return \"MEMBER\";\r\n        case UserGroupList_UserGroup_State.JOIN_REQUEST:\r\n            return \"JOIN_REQUEST\";\r\n        case UserGroupList_UserGroup_State.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\nfunction createBaseAccount() {\r\n    return {\r\n        user: undefined,\r\n        wallet: \"\",\r\n        email: \"\",\r\n        devices: [],\r\n        custom_id: \"\",\r\n        verify_time: undefined,\r\n        disable_time: undefined,\r\n    };\r\n}\r\nconst Account = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user !== undefined) {\r\n            User.encode(message.user, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.wallet !== \"\") {\r\n            writer.uint32(18).string(message.wallet);\r\n        }\r\n        if (message.email !== \"\") {\r\n            writer.uint32(26).string(message.email);\r\n        }\r\n        for (const v of message.devices) {\r\n            AccountDevice.encode(v, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.custom_id !== \"\") {\r\n            writer.uint32(42).string(message.custom_id);\r\n        }\r\n        if (message.verify_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.verify_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.disable_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.disable_time), writer.uint32(58).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccount();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user = User.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.wallet = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.email = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.devices.push(AccountDevice.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 5:\r\n                    message.custom_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.verify_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.disable_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,\r\n            wallet: isSet(object.wallet) ? String(object.wallet) : \"\",\r\n            email: isSet(object.email) ? String(object.email) : \"\",\r\n            devices: Array.isArray(object?.devices) ? object.devices.map((e) => AccountDevice.fromJSON(e)) : [],\r\n            custom_id: isSet(object.custom_id) ? String(object.custom_id) : \"\",\r\n            verify_time: isSet(object.verify_time) ? fromJsonTimestamp(object.verify_time) : undefined,\r\n            disable_time: isSet(object.disable_time) ? fromJsonTimestamp(object.disable_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);\r\n        message.wallet !== undefined && (obj.wallet = message.wallet);\r\n        message.email !== undefined && (obj.email = message.email);\r\n        if (message.devices) {\r\n            obj.devices = message.devices.map((e) => e ? AccountDevice.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.devices = [];\r\n        }\r\n        message.custom_id !== undefined && (obj.custom_id = message.custom_id);\r\n        message.verify_time !== undefined && (obj.verify_time = message.verify_time.toISOString());\r\n        message.disable_time !== undefined && (obj.disable_time = message.disable_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Account.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccount();\r\n        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;\r\n        message.wallet = object.wallet ?? \"\";\r\n        message.email = object.email ?? \"\";\r\n        message.devices = object.devices?.map((e) => AccountDevice.fromPartial(e)) || [];\r\n        message.custom_id = object.custom_id ?? \"\";\r\n        message.verify_time = object.verify_time ?? undefined;\r\n        message.disable_time = object.disable_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountRefresh() {\r\n    return { token: \"\", vars: {} };\r\n}\r\nconst AccountRefresh = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountRefresh_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountRefresh();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountRefresh_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountRefresh.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountRefresh();\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountRefresh_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountRefresh_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountRefresh_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountRefresh_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountRefresh_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountApple() {\r\n    return { token: \"\", vars: {} };\r\n}\r\nconst AccountApple = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountApple_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountApple();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountApple_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountApple.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountApple();\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountApple_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountApple_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountApple_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountApple_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountApple_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountCustom() {\r\n    return { id: \"\", vars: {} };\r\n}\r\nconst AccountCustom = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountCustom_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountCustom();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountCustom_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountCustom.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountCustom();\r\n        message.id = object.id ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountCustom_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountCustom_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountCustom_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountCustom_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountCustom_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountDevice() {\r\n    return { id: \"\", vars: {} };\r\n}\r\nconst AccountDevice = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountDevice_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountDevice();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountDevice_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountDevice.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountDevice();\r\n        message.id = object.id ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountDevice_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountDevice_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountDevice_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountDevice_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountDevice_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountEmail() {\r\n    return { email: \"\", password: \"\", vars: {} };\r\n}\r\nconst AccountEmail = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.email !== \"\") {\r\n            writer.uint32(10).string(message.email);\r\n        }\r\n        if (message.password !== \"\") {\r\n            writer.uint32(18).string(message.password);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountEmail_VarsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountEmail();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.email = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.password = reader.string();\r\n                    break;\r\n                case 3:\r\n                    const entry3 = AccountEmail_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry3.value !== undefined) {\r\n                        message.vars[entry3.key] = entry3.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            email: isSet(object.email) ? String(object.email) : \"\",\r\n            password: isSet(object.password) ? String(object.password) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.email !== undefined && (obj.email = message.email);\r\n        message.password !== undefined && (obj.password = message.password);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountEmail.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountEmail();\r\n        message.email = object.email ?? \"\";\r\n        message.password = object.password ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountEmail_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountEmail_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountEmail_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountEmail_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountEmail_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountFacebook() {\r\n    return { token: \"\", vars: {} };\r\n}\r\nconst AccountFacebook = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountFacebook_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountFacebook();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountFacebook_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountFacebook.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountFacebook();\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountFacebook_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountFacebook_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountFacebook_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountFacebook_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountFacebook_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountFacebookInstantGame() {\r\n    return { signed_player_info: \"\", vars: {} };\r\n}\r\nconst AccountFacebookInstantGame = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.signed_player_info !== \"\") {\r\n            writer.uint32(10).string(message.signed_player_info);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountFacebookInstantGame_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountFacebookInstantGame();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.signed_player_info = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountFacebookInstantGame_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            signed_player_info: isSet(object.signed_player_info) ? String(object.signed_player_info) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.signed_player_info !== undefined && (obj.signed_player_info = message.signed_player_info);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountFacebookInstantGame.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountFacebookInstantGame();\r\n        message.signed_player_info = object.signed_player_info ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountFacebookInstantGame_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountFacebookInstantGame_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountFacebookInstantGame_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountFacebookInstantGame_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountFacebookInstantGame_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountGameCenter() {\r\n    return { player_id: \"\", bundle_id: \"\", timestamp_seconds: 0, salt: \"\", signature: \"\", public_key_url: \"\", vars: {} };\r\n}\r\nconst AccountGameCenter = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.player_id !== \"\") {\r\n            writer.uint32(10).string(message.player_id);\r\n        }\r\n        if (message.bundle_id !== \"\") {\r\n            writer.uint32(18).string(message.bundle_id);\r\n        }\r\n        if (message.timestamp_seconds !== 0) {\r\n            writer.uint32(24).int64(message.timestamp_seconds);\r\n        }\r\n        if (message.salt !== \"\") {\r\n            writer.uint32(34).string(message.salt);\r\n        }\r\n        if (message.signature !== \"\") {\r\n            writer.uint32(42).string(message.signature);\r\n        }\r\n        if (message.public_key_url !== \"\") {\r\n            writer.uint32(50).string(message.public_key_url);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountGameCenter_VarsEntry.encode({ key: key, value }, writer.uint32(58).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountGameCenter();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.player_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.bundle_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.timestamp_seconds = longToNumber(reader.int64());\r\n                    break;\r\n                case 4:\r\n                    message.salt = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.signature = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.public_key_url = reader.string();\r\n                    break;\r\n                case 7:\r\n                    const entry7 = AccountGameCenter_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry7.value !== undefined) {\r\n                        message.vars[entry7.key] = entry7.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            player_id: isSet(object.player_id) ? String(object.player_id) : \"\",\r\n            bundle_id: isSet(object.bundle_id) ? String(object.bundle_id) : \"\",\r\n            timestamp_seconds: isSet(object.timestamp_seconds) ? Number(object.timestamp_seconds) : 0,\r\n            salt: isSet(object.salt) ? String(object.salt) : \"\",\r\n            signature: isSet(object.signature) ? String(object.signature) : \"\",\r\n            public_key_url: isSet(object.public_key_url) ? String(object.public_key_url) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.player_id !== undefined && (obj.player_id = message.player_id);\r\n        message.bundle_id !== undefined && (obj.bundle_id = message.bundle_id);\r\n        message.timestamp_seconds !== undefined && (obj.timestamp_seconds = Math.round(message.timestamp_seconds));\r\n        message.salt !== undefined && (obj.salt = message.salt);\r\n        message.signature !== undefined && (obj.signature = message.signature);\r\n        message.public_key_url !== undefined && (obj.public_key_url = message.public_key_url);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountGameCenter.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountGameCenter();\r\n        message.player_id = object.player_id ?? \"\";\r\n        message.bundle_id = object.bundle_id ?? \"\";\r\n        message.timestamp_seconds = object.timestamp_seconds ?? 0;\r\n        message.salt = object.salt ?? \"\";\r\n        message.signature = object.signature ?? \"\";\r\n        message.public_key_url = object.public_key_url ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountGameCenter_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountGameCenter_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountGameCenter_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountGameCenter_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountGameCenter_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountGoogle() {\r\n    return { token: \"\", vars: {} };\r\n}\r\nconst AccountGoogle = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountGoogle_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountGoogle();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountGoogle_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountGoogle.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountGoogle();\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountGoogle_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountGoogle_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountGoogle_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountGoogle_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountGoogle_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountSteam() {\r\n    return { token: \"\", vars: {} };\r\n}\r\nconst AccountSteam = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountSteam_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountSteam();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = AccountSteam_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountSteam.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountSteam();\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountSteam_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountSteam_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountSteam_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountSteam_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountSteam_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAddFriendsRequest() {\r\n    return { ids: [], usernames: [] };\r\n}\r\nconst AddFriendsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        for (const v of message.usernames) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAddFriendsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.ids.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.usernames.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [],\r\n            usernames: Array.isArray(object?.usernames) ? object.usernames.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.ids) {\r\n            obj.ids = message.ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.ids = [];\r\n        }\r\n        if (message.usernames) {\r\n            obj.usernames = message.usernames.map((e) => e);\r\n        }\r\n        else {\r\n            obj.usernames = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AddFriendsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAddFriendsRequest();\r\n        message.ids = object.ids?.map((e) => e) || [];\r\n        message.usernames = object.usernames?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAddGroupUsersRequest() {\r\n    return { group_id: \"\", user_ids: [] };\r\n}\r\nconst AddGroupUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAddGroupUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_id: isSet(object.group_id) ? String(object.group_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AddGroupUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAddGroupUsersRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSessionRefreshRequest() {\r\n    return { token: \"\", vars: {} };\r\n}\r\nconst SessionRefreshRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            SessionRefreshRequest_VarsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSessionRefreshRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = SessionRefreshRequest_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.vars[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SessionRefreshRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSessionRefreshRequest();\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSessionRefreshRequest_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst SessionRefreshRequest_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSessionRefreshRequest_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SessionRefreshRequest_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSessionRefreshRequest_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSessionLogoutRequest() {\r\n    return { token: \"\", refresh_token: \"\" };\r\n}\r\nconst SessionLogoutRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        if (message.refresh_token !== \"\") {\r\n            writer.uint32(18).string(message.refresh_token);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSessionLogoutRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.refresh_token = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            refresh_token: isSet(object.refresh_token) ? String(object.refresh_token) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        message.refresh_token !== undefined && (obj.refresh_token = message.refresh_token);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SessionLogoutRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSessionLogoutRequest();\r\n        message.token = object.token ?? \"\";\r\n        message.refresh_token = object.refresh_token ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateAppleRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateAppleRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountApple.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateAppleRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountApple.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountApple.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined && (obj.account = message.account ? AccountApple.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateAppleRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateAppleRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountApple.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateCustomRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateCustomRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountCustom.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateCustomRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountCustom.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountCustom.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountCustom.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateCustomRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateCustomRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountCustom.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateDeviceRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateDeviceRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountDevice.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateDeviceRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountDevice.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountDevice.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountDevice.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateDeviceRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateDeviceRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountDevice.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateEmailRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateEmailRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountEmail.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateEmailRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountEmail.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountEmail.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined && (obj.account = message.account ? AccountEmail.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateEmailRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateEmailRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountEmail.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateFacebookRequest() {\r\n    return { account: undefined, create: undefined, username: \"\", sync: undefined };\r\n}\r\nconst AuthenticateFacebookRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        if (message.sync !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.sync }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateFacebookRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountFacebook.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.sync = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountFacebook.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            sync: isSet(object.sync) ? Boolean(object.sync) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountFacebook.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.sync !== undefined && (obj.sync = message.sync);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateFacebookRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateFacebookRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountFacebook.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        message.sync = object.sync ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateFacebookInstantGameRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateFacebookInstantGameRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountFacebookInstantGame.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateFacebookInstantGameRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountFacebookInstantGame.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountFacebookInstantGame.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountFacebookInstantGame.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateFacebookInstantGameRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateFacebookInstantGameRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountFacebookInstantGame.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateGameCenterRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateGameCenterRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountGameCenter.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateGameCenterRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountGameCenter.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountGameCenter.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountGameCenter.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateGameCenterRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateGameCenterRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountGameCenter.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateGoogleRequest() {\r\n    return { account: undefined, create: undefined, username: \"\" };\r\n}\r\nconst AuthenticateGoogleRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountGoogle.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateGoogleRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountGoogle.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountGoogle.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountGoogle.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateGoogleRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateGoogleRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountGoogle.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateSteamRequest() {\r\n    return { account: undefined, create: undefined, username: \"\", sync: undefined };\r\n}\r\nconst AuthenticateSteamRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.create !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.create }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        if (message.sync !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.sync }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateSteamRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountSteam.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.create = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.sync = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountSteam.fromJSON(object.account) : undefined,\r\n            create: isSet(object.create) ? Boolean(object.create) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            sync: isSet(object.sync) ? Boolean(object.sync) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined && (obj.account = message.account ? AccountSteam.toJSON(message.account) : undefined);\r\n        message.create !== undefined && (obj.create = message.create);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.sync !== undefined && (obj.sync = message.sync);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateSteamRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateSteamRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountSteam.fromPartial(object.account)\r\n            : undefined;\r\n        message.create = object.create ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        message.sync = object.sync ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseBanGroupUsersRequest() {\r\n    return { group_id: \"\", user_ids: [] };\r\n}\r\nconst BanGroupUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseBanGroupUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_id: isSet(object.group_id) ? String(object.group_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return BanGroupUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseBanGroupUsersRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseBlockFriendsRequest() {\r\n    return { ids: [], usernames: [] };\r\n}\r\nconst BlockFriendsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        for (const v of message.usernames) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseBlockFriendsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.ids.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.usernames.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [],\r\n            usernames: Array.isArray(object?.usernames) ? object.usernames.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.ids) {\r\n            obj.ids = message.ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.ids = [];\r\n        }\r\n        if (message.usernames) {\r\n            obj.usernames = message.usernames.map((e) => e);\r\n        }\r\n        else {\r\n            obj.usernames = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return BlockFriendsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseBlockFriendsRequest();\r\n        message.ids = object.ids?.map((e) => e) || [];\r\n        message.usernames = object.usernames?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessage() {\r\n    return {\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        message_id: \"\",\r\n        code: undefined,\r\n        sender_id: \"\",\r\n        username: \"\",\r\n        avatar: \"\",\r\n        content: \"\",\r\n        create_time: undefined,\r\n        update_time: undefined,\r\n        channel_label: \"\",\r\n        clan_logo: \"\",\r\n        category_name: \"\",\r\n        display_name: \"\",\r\n        clan_nick: \"\",\r\n        clan_avatar: \"\",\r\n        reactions: \"\",\r\n        mentions: \"\",\r\n        attachments: \"\",\r\n        references: \"\",\r\n        referenced_message: \"\",\r\n        create_time_ms: 0,\r\n        update_time_ms: 0,\r\n        mode: 0,\r\n        hide_editted: false,\r\n    };\r\n}\r\nconst ChannelMessage = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(26).string(message.message_id);\r\n        }\r\n        if (message.code !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.code }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.sender_id !== \"\") {\r\n            writer.uint32(42).string(message.sender_id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(50).string(message.username);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(58).string(message.avatar);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(66).string(message.content);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(74).fork()).ldelim();\r\n        }\r\n        if (message.update_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.update_time), writer.uint32(82).fork()).ldelim();\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(90).string(message.channel_label);\r\n        }\r\n        if (message.clan_logo !== \"\") {\r\n            writer.uint32(98).string(message.clan_logo);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(106).string(message.category_name);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(114).string(message.display_name);\r\n        }\r\n        if (message.clan_nick !== \"\") {\r\n            writer.uint32(122).string(message.clan_nick);\r\n        }\r\n        if (message.clan_avatar !== \"\") {\r\n            writer.uint32(130).string(message.clan_avatar);\r\n        }\r\n        if (message.reactions !== \"\") {\r\n            writer.uint32(138).string(message.reactions);\r\n        }\r\n        if (message.mentions !== \"\") {\r\n            writer.uint32(146).string(message.mentions);\r\n        }\r\n        if (message.attachments !== \"\") {\r\n            writer.uint32(154).string(message.attachments);\r\n        }\r\n        if (message.references !== \"\") {\r\n            writer.uint32(162).string(message.references);\r\n        }\r\n        if (message.referenced_message !== \"\") {\r\n            writer.uint32(170).string(message.referenced_message);\r\n        }\r\n        if (message.create_time_ms !== 0) {\r\n            writer.uint32(176).uint32(message.create_time_ms);\r\n        }\r\n        if (message.update_time_ms !== 0) {\r\n            writer.uint32(184).uint32(message.update_time_ms);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(192).int32(message.mode);\r\n        }\r\n        if (message.hide_editted === true) {\r\n            writer.uint32(200).bool(message.hide_editted);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessage();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.code = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.sender_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 10:\r\n                    message.update_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 11:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 12:\r\n                    message.clan_logo = reader.string();\r\n                    break;\r\n                case 13:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                case 14:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 15:\r\n                    message.clan_nick = reader.string();\r\n                    break;\r\n                case 16:\r\n                    message.clan_avatar = reader.string();\r\n                    break;\r\n                case 17:\r\n                    message.reactions = reader.string();\r\n                    break;\r\n                case 18:\r\n                    message.mentions = reader.string();\r\n                    break;\r\n                case 19:\r\n                    message.attachments = reader.string();\r\n                    break;\r\n                case 20:\r\n                    message.references = reader.string();\r\n                    break;\r\n                case 21:\r\n                    message.referenced_message = reader.string();\r\n                    break;\r\n                case 22:\r\n                    message.create_time_ms = reader.uint32();\r\n                    break;\r\n                case 23:\r\n                    message.update_time_ms = reader.uint32();\r\n                    break;\r\n                case 24:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 25:\r\n                    message.hide_editted = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            code: isSet(object.code) ? Number(object.code) : undefined,\r\n            sender_id: isSet(object.sender_id) ? String(object.sender_id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            clan_logo: isSet(object.clan_logo) ? String(object.clan_logo) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            clan_nick: isSet(object.clan_nick) ? String(object.clan_nick) : \"\",\r\n            clan_avatar: isSet(object.clan_avatar) ? String(object.clan_avatar) : \"\",\r\n            reactions: isSet(object.reactions) ? String(object.reactions) : \"\",\r\n            mentions: isSet(object.mentions) ? String(object.mentions) : \"\",\r\n            attachments: isSet(object.attachments) ? String(object.attachments) : \"\",\r\n            references: isSet(object.references) ? String(object.references) : \"\",\r\n            referenced_message: isSet(object.referenced_message) ? String(object.referenced_message) : \"\",\r\n            create_time_ms: isSet(object.create_time_ms) ? Number(object.create_time_ms) : 0,\r\n            update_time_ms: isSet(object.update_time_ms) ? Number(object.update_time_ms) : 0,\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            hide_editted: isSet(object.hide_editted) ? Boolean(object.hide_editted) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.code !== undefined && (obj.code = message.code);\r\n        message.sender_id !== undefined && (obj.sender_id = message.sender_id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.update_time !== undefined && (obj.update_time = message.update_time.toISOString());\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.clan_logo !== undefined && (obj.clan_logo = message.clan_logo);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.clan_nick !== undefined && (obj.clan_nick = message.clan_nick);\r\n        message.clan_avatar !== undefined && (obj.clan_avatar = message.clan_avatar);\r\n        message.reactions !== undefined && (obj.reactions = message.reactions);\r\n        message.mentions !== undefined && (obj.mentions = message.mentions);\r\n        message.attachments !== undefined && (obj.attachments = message.attachments);\r\n        message.references !== undefined && (obj.references = message.references);\r\n        message.referenced_message !== undefined && (obj.referenced_message = message.referenced_message);\r\n        message.create_time_ms !== undefined && (obj.create_time_ms = Math.round(message.create_time_ms));\r\n        message.update_time_ms !== undefined && (obj.update_time_ms = Math.round(message.update_time_ms));\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.hide_editted !== undefined && (obj.hide_editted = message.hide_editted);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessage.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessage();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.code = object.code ?? undefined;\r\n        message.sender_id = object.sender_id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.update_time = object.update_time ?? undefined;\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.clan_logo = object.clan_logo ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.clan_nick = object.clan_nick ?? \"\";\r\n        message.clan_avatar = object.clan_avatar ?? \"\";\r\n        message.reactions = object.reactions ?? \"\";\r\n        message.mentions = object.mentions ?? \"\";\r\n        message.attachments = object.attachments ?? \"\";\r\n        message.references = object.references ?? \"\";\r\n        message.referenced_message = object.referenced_message ?? \"\";\r\n        message.create_time_ms = object.create_time_ms ?? 0;\r\n        message.update_time_ms = object.update_time_ms ?? 0;\r\n        message.mode = object.mode ?? 0;\r\n        message.hide_editted = object.hide_editted ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseMessageMention() {\r\n    return { id: \"\", user_id: \"\", username: \"\", role_id: \"\", rolename: \"\", create_time: undefined, s: 0, e: 0 };\r\n}\r\nconst MessageMention = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(18).string(message.user_id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(34).string(message.role_id);\r\n        }\r\n        if (message.rolename !== \"\") {\r\n            writer.uint32(42).string(message.rolename);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.s !== 0) {\r\n            writer.uint32(56).int32(message.s);\r\n        }\r\n        if (message.e !== 0) {\r\n            writer.uint32(64).int32(message.e);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseMessageMention();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.rolename = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.s = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.e = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : \"\",\r\n            rolename: isSet(object.rolename) ? String(object.rolename) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            s: isSet(object.s) ? Number(object.s) : 0,\r\n            e: isSet(object.e) ? Number(object.e) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        message.rolename !== undefined && (obj.rolename = message.rolename);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.s !== undefined && (obj.s = Math.round(message.s));\r\n        message.e !== undefined && (obj.e = Math.round(message.e));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return MessageMention.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseMessageMention();\r\n        message.id = object.id ?? \"\";\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.role_id = object.role_id ?? \"\";\r\n        message.rolename = object.rolename ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.s = object.s ?? 0;\r\n        message.e = object.e ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationInfo() {\r\n    return {\r\n        username: \"\",\r\n        avatar: \"\",\r\n        clan_nick: \"\",\r\n        clan_avatar: \"\",\r\n        display_name: \"\",\r\n        channel_label: \"\",\r\n        channel_type: 0,\r\n        category_name: \"\",\r\n        clan_name: \"\",\r\n        clan_logo: \"\",\r\n    };\r\n}\r\nconst NotificationInfo = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.username !== \"\") {\r\n            writer.uint32(10).string(message.username);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(18).string(message.avatar);\r\n        }\r\n        if (message.clan_nick !== \"\") {\r\n            writer.uint32(26).string(message.clan_nick);\r\n        }\r\n        if (message.clan_avatar !== \"\") {\r\n            writer.uint32(34).string(message.clan_avatar);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(42).string(message.display_name);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(50).string(message.channel_label);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(56).int32(message.channel_type);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(66).string(message.category_name);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(74).string(message.clan_name);\r\n        }\r\n        if (message.clan_logo !== \"\") {\r\n            writer.uint32(82).string(message.clan_logo);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationInfo();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_nick = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_avatar = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.clan_logo = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n            clan_nick: isSet(object.clan_nick) ? String(object.clan_nick) : \"\",\r\n            clan_avatar: isSet(object.clan_avatar) ? String(object.clan_avatar) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            clan_logo: isSet(object.clan_logo) ? String(object.clan_logo) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        message.clan_nick !== undefined && (obj.clan_nick = message.clan_nick);\r\n        message.clan_avatar !== undefined && (obj.clan_avatar = message.clan_avatar);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.clan_logo !== undefined && (obj.clan_logo = message.clan_logo);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationInfo.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationInfo();\r\n        message.username = object.username ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        message.clan_nick = object.clan_nick ?? \"\";\r\n        message.clan_avatar = object.clan_avatar ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        message.category_name = object.category_name ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.clan_logo = object.clan_logo ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseMessageReaction() {\r\n    return {\r\n        id: \"\",\r\n        emoji_id: \"\",\r\n        emoji: \"\",\r\n        sender_id: \"\",\r\n        sender_name: \"\",\r\n        sender_avatar: \"\",\r\n        action: false,\r\n        count: 0,\r\n        channel_id: \"\",\r\n        message_id: \"\",\r\n        clan_id: \"\",\r\n        mode: 0,\r\n        message_sender_id: \"\",\r\n    };\r\n}\r\nconst MessageReaction = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.emoji_id !== \"\") {\r\n            writer.uint32(18).string(message.emoji_id);\r\n        }\r\n        if (message.emoji !== \"\") {\r\n            writer.uint32(26).string(message.emoji);\r\n        }\r\n        if (message.sender_id !== \"\") {\r\n            writer.uint32(34).string(message.sender_id);\r\n        }\r\n        if (message.sender_name !== \"\") {\r\n            writer.uint32(42).string(message.sender_name);\r\n        }\r\n        if (message.sender_avatar !== \"\") {\r\n            writer.uint32(50).string(message.sender_avatar);\r\n        }\r\n        if (message.action === true) {\r\n            writer.uint32(56).bool(message.action);\r\n        }\r\n        if (message.count !== 0) {\r\n            writer.uint32(64).int32(message.count);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(74).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(82).string(message.message_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(90).string(message.clan_id);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(96).int32(message.mode);\r\n        }\r\n        if (message.message_sender_id !== \"\") {\r\n            writer.uint32(106).string(message.message_sender_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseMessageReaction();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.emoji_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.emoji = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.sender_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.sender_name = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.sender_avatar = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.action = reader.bool();\r\n                    break;\r\n                case 8:\r\n                    message.count = reader.int32();\r\n                    break;\r\n                case 9:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 11:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 12:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 13:\r\n                    message.message_sender_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            emoji_id: isSet(object.emoji_id) ? String(object.emoji_id) : \"\",\r\n            emoji: isSet(object.emoji) ? String(object.emoji) : \"\",\r\n            sender_id: isSet(object.sender_id) ? String(object.sender_id) : \"\",\r\n            sender_name: isSet(object.sender_name) ? String(object.sender_name) : \"\",\r\n            sender_avatar: isSet(object.sender_avatar) ? String(object.sender_avatar) : \"\",\r\n            action: isSet(object.action) ? Boolean(object.action) : false,\r\n            count: isSet(object.count) ? Number(object.count) : 0,\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            message_sender_id: isSet(object.message_sender_id) ? String(object.message_sender_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.emoji_id !== undefined && (obj.emoji_id = message.emoji_id);\r\n        message.emoji !== undefined && (obj.emoji = message.emoji);\r\n        message.sender_id !== undefined && (obj.sender_id = message.sender_id);\r\n        message.sender_name !== undefined && (obj.sender_name = message.sender_name);\r\n        message.sender_avatar !== undefined && (obj.sender_avatar = message.sender_avatar);\r\n        message.action !== undefined && (obj.action = message.action);\r\n        message.count !== undefined && (obj.count = Math.round(message.count));\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.message_sender_id !== undefined && (obj.message_sender_id = message.message_sender_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return MessageReaction.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseMessageReaction();\r\n        message.id = object.id ?? \"\";\r\n        message.emoji_id = object.emoji_id ?? \"\";\r\n        message.emoji = object.emoji ?? \"\";\r\n        message.sender_id = object.sender_id ?? \"\";\r\n        message.sender_name = object.sender_name ?? \"\";\r\n        message.sender_avatar = object.sender_avatar ?? \"\";\r\n        message.action = object.action ?? false;\r\n        message.count = object.count ?? 0;\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.mode = object.mode ?? 0;\r\n        message.message_sender_id = object.message_sender_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseMessageAttachment() {\r\n    return { filename: \"\", size: 0, url: \"\", filetype: \"\", width: 0, height: 0 };\r\n}\r\nconst MessageAttachment = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.filename !== \"\") {\r\n            writer.uint32(10).string(message.filename);\r\n        }\r\n        if (message.size !== 0) {\r\n            writer.uint32(16).int64(message.size);\r\n        }\r\n        if (message.url !== \"\") {\r\n            writer.uint32(26).string(message.url);\r\n        }\r\n        if (message.filetype !== \"\") {\r\n            writer.uint32(34).string(message.filetype);\r\n        }\r\n        if (message.width !== 0) {\r\n            writer.uint32(40).int32(message.width);\r\n        }\r\n        if (message.height !== 0) {\r\n            writer.uint32(48).int32(message.height);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseMessageAttachment();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.filename = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.size = longToNumber(reader.int64());\r\n                    break;\r\n                case 3:\r\n                    message.url = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.filetype = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.width = reader.int32();\r\n                    break;\r\n                case 6:\r\n                    message.height = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            filename: isSet(object.filename) ? String(object.filename) : \"\",\r\n            size: isSet(object.size) ? Number(object.size) : 0,\r\n            url: isSet(object.url) ? String(object.url) : \"\",\r\n            filetype: isSet(object.filetype) ? String(object.filetype) : \"\",\r\n            width: isSet(object.width) ? Number(object.width) : 0,\r\n            height: isSet(object.height) ? Number(object.height) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.filename !== undefined && (obj.filename = message.filename);\r\n        message.size !== undefined && (obj.size = Math.round(message.size));\r\n        message.url !== undefined && (obj.url = message.url);\r\n        message.filetype !== undefined && (obj.filetype = message.filetype);\r\n        message.width !== undefined && (obj.width = Math.round(message.width));\r\n        message.height !== undefined && (obj.height = Math.round(message.height));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return MessageAttachment.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseMessageAttachment();\r\n        message.filename = object.filename ?? \"\";\r\n        message.size = object.size ?? 0;\r\n        message.url = object.url ?? \"\";\r\n        message.filetype = object.filetype ?? \"\";\r\n        message.width = object.width ?? 0;\r\n        message.height = object.height ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseMessageRef() {\r\n    return {\r\n        message_id: \"\",\r\n        message_ref_id: \"\",\r\n        content: \"\",\r\n        has_attachment: false,\r\n        ref_type: 0,\r\n        message_sender_id: \"\",\r\n        message_sender_username: \"\",\r\n        mesages_sender_avatar: \"\",\r\n        message_sender_clan_nick: \"\",\r\n        message_sender_display_name: \"\",\r\n    };\r\n}\r\nconst MessageRef = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(10).string(message.message_id);\r\n        }\r\n        if (message.message_ref_id !== \"\") {\r\n            writer.uint32(18).string(message.message_ref_id);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(26).string(message.content);\r\n        }\r\n        if (message.has_attachment === true) {\r\n            writer.uint32(32).bool(message.has_attachment);\r\n        }\r\n        if (message.ref_type !== 0) {\r\n            writer.uint32(40).int32(message.ref_type);\r\n        }\r\n        if (message.message_sender_id !== \"\") {\r\n            writer.uint32(50).string(message.message_sender_id);\r\n        }\r\n        if (message.message_sender_username !== \"\") {\r\n            writer.uint32(58).string(message.message_sender_username);\r\n        }\r\n        if (message.mesages_sender_avatar !== \"\") {\r\n            writer.uint32(66).string(message.mesages_sender_avatar);\r\n        }\r\n        if (message.message_sender_clan_nick !== \"\") {\r\n            writer.uint32(74).string(message.message_sender_clan_nick);\r\n        }\r\n        if (message.message_sender_display_name !== \"\") {\r\n            writer.uint32(82).string(message.message_sender_display_name);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseMessageRef();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.message_ref_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.has_attachment = reader.bool();\r\n                    break;\r\n                case 5:\r\n                    message.ref_type = reader.int32();\r\n                    break;\r\n                case 6:\r\n                    message.message_sender_id = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.message_sender_username = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.mesages_sender_avatar = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.message_sender_clan_nick = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.message_sender_display_name = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            message_ref_id: isSet(object.message_ref_id) ? String(object.message_ref_id) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            has_attachment: isSet(object.has_attachment) ? Boolean(object.has_attachment) : false,\r\n            ref_type: isSet(object.ref_type) ? Number(object.ref_type) : 0,\r\n            message_sender_id: isSet(object.message_sender_id) ? String(object.message_sender_id) : \"\",\r\n            message_sender_username: isSet(object.message_sender_username) ? String(object.message_sender_username) : \"\",\r\n            mesages_sender_avatar: isSet(object.mesages_sender_avatar) ? String(object.mesages_sender_avatar) : \"\",\r\n            message_sender_clan_nick: isSet(object.message_sender_clan_nick) ? String(object.message_sender_clan_nick) : \"\",\r\n            message_sender_display_name: isSet(object.message_sender_display_name)\r\n                ? String(object.message_sender_display_name)\r\n                : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.message_ref_id !== undefined && (obj.message_ref_id = message.message_ref_id);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        message.has_attachment !== undefined && (obj.has_attachment = message.has_attachment);\r\n        message.ref_type !== undefined && (obj.ref_type = Math.round(message.ref_type));\r\n        message.message_sender_id !== undefined && (obj.message_sender_id = message.message_sender_id);\r\n        message.message_sender_username !== undefined && (obj.message_sender_username = message.message_sender_username);\r\n        message.mesages_sender_avatar !== undefined && (obj.mesages_sender_avatar = message.mesages_sender_avatar);\r\n        message.message_sender_clan_nick !== undefined && (obj.message_sender_clan_nick = message.message_sender_clan_nick);\r\n        message.message_sender_display_name !== undefined &&\r\n            (obj.message_sender_display_name = message.message_sender_display_name);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return MessageRef.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseMessageRef();\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.message_ref_id = object.message_ref_id ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.has_attachment = object.has_attachment ?? false;\r\n        message.ref_type = object.ref_type ?? 0;\r\n        message.message_sender_id = object.message_sender_id ?? \"\";\r\n        message.message_sender_username = object.message_sender_username ?? \"\";\r\n        message.mesages_sender_avatar = object.mesages_sender_avatar ?? \"\";\r\n        message.message_sender_clan_nick = object.message_sender_clan_nick ?? \"\";\r\n        message.message_sender_display_name = object.message_sender_display_name ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseMessageDeleted() {\r\n    return { message_id: \"\", deletor: \"\" };\r\n}\r\nconst MessageDeleted = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(10).string(message.message_id);\r\n        }\r\n        if (message.deletor !== \"\") {\r\n            writer.uint32(18).string(message.deletor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseMessageDeleted();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.deletor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            deletor: isSet(object.deletor) ? String(object.deletor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.deletor !== undefined && (obj.deletor = message.deletor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return MessageDeleted.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseMessageDeleted();\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.deletor = object.deletor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessageList() {\r\n    return { messages: [], last_seen_message: undefined, last_sent_message: undefined };\r\n}\r\nconst ChannelMessageList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.messages) {\r\n            ChannelMessage.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.last_seen_message !== undefined) {\r\n            ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.last_sent_message !== undefined) {\r\n            ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessageList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.messages.push(ChannelMessage.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());\r\n                    break;\r\n                case 3:\r\n                    message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            messages: Array.isArray(object?.messages) ? object.messages.map((e) => ChannelMessage.fromJSON(e)) : [],\r\n            last_seen_message: isSet(object.last_seen_message)\r\n                ? ChannelMessageHeader.fromJSON(object.last_seen_message)\r\n                : undefined,\r\n            last_sent_message: isSet(object.last_sent_message)\r\n                ? ChannelMessageHeader.fromJSON(object.last_sent_message)\r\n                : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.messages) {\r\n            obj.messages = message.messages.map((e) => e ? ChannelMessage.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.messages = [];\r\n        }\r\n        message.last_seen_message !== undefined && (obj.last_seen_message = message.last_seen_message\r\n            ? ChannelMessageHeader.toJSON(message.last_seen_message)\r\n            : undefined);\r\n        message.last_sent_message !== undefined && (obj.last_sent_message = message.last_sent_message\r\n            ? ChannelMessageHeader.toJSON(message.last_sent_message)\r\n            : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessageList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessageList();\r\n        message.messages = object.messages?.map((e) => ChannelMessage.fromPartial(e)) || [];\r\n        message.last_seen_message = (object.last_seen_message !== undefined && object.last_seen_message !== null)\r\n            ? ChannelMessageHeader.fromPartial(object.last_seen_message)\r\n            : undefined;\r\n        message.last_sent_message = (object.last_sent_message !== undefined && object.last_sent_message !== null)\r\n            ? ChannelMessageHeader.fromPartial(object.last_sent_message)\r\n            : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCreateGroupRequest() {\r\n    return { name: \"\", description: \"\", lang_tag: \"\", avatar_url: \"\", open: false, max_count: 0 };\r\n}\r\nconst CreateGroupRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.name !== \"\") {\r\n            writer.uint32(10).string(message.name);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(18).string(message.description);\r\n        }\r\n        if (message.lang_tag !== \"\") {\r\n            writer.uint32(26).string(message.lang_tag);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(34).string(message.avatar_url);\r\n        }\r\n        if (message.open === true) {\r\n            writer.uint32(40).bool(message.open);\r\n        }\r\n        if (message.max_count !== 0) {\r\n            writer.uint32(48).int32(message.max_count);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCreateGroupRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.lang_tag = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.open = reader.bool();\r\n                    break;\r\n                case 6:\r\n                    message.max_count = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            name: isSet(object.name) ? String(object.name) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n            open: isSet(object.open) ? Boolean(object.open) : false,\r\n            max_count: isSet(object.max_count) ? Number(object.max_count) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.name !== undefined && (obj.name = message.name);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.open !== undefined && (obj.open = message.open);\r\n        message.max_count !== undefined && (obj.max_count = Math.round(message.max_count));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CreateGroupRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCreateGroupRequest();\r\n        message.name = object.name ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.lang_tag = object.lang_tag ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        message.open = object.open ?? false;\r\n        message.max_count = object.max_count ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteFriendsRequest() {\r\n    return { ids: [], usernames: [] };\r\n}\r\nconst DeleteFriendsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        for (const v of message.usernames) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteFriendsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.ids.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.usernames.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [],\r\n            usernames: Array.isArray(object?.usernames) ? object.usernames.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.ids) {\r\n            obj.ids = message.ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.ids = [];\r\n        }\r\n        if (message.usernames) {\r\n            obj.usernames = message.usernames.map((e) => e);\r\n        }\r\n        else {\r\n            obj.usernames = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteFriendsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteFriendsRequest();\r\n        message.ids = object.ids?.map((e) => e) || [];\r\n        message.usernames = object.usernames?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteGroupRequest() {\r\n    return { group_id: \"\" };\r\n}\r\nconst DeleteGroupRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteGroupRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { group_id: isSet(object.group_id) ? String(object.group_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteGroupRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteGroupRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteNotificationsRequest() {\r\n    return { ids: [] };\r\n}\r\nconst DeleteNotificationsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteNotificationsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [] };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.ids) {\r\n            obj.ids = message.ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteNotificationsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteNotificationsRequest();\r\n        message.ids = object.ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEvent() {\r\n    return { name: \"\", properties: {}, timestamp: undefined, external: false };\r\n}\r\nconst Event = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.name !== \"\") {\r\n            writer.uint32(10).string(message.name);\r\n        }\r\n        Object.entries(message.properties).forEach(([key, value]) => {\r\n            Event_PropertiesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();\r\n        });\r\n        if (message.timestamp !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.external === true) {\r\n            writer.uint32(32).bool(message.external);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    const entry2 = Event_PropertiesEntry.decode(reader, reader.uint32());\r\n                    if (entry2.value !== undefined) {\r\n                        message.properties[entry2.key] = entry2.value;\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    message.timestamp = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 4:\r\n                    message.external = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            name: isSet(object.name) ? String(object.name) : \"\",\r\n            properties: isObject(object.properties)\r\n                ? Object.entries(object.properties).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n            timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,\r\n            external: isSet(object.external) ? Boolean(object.external) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.name !== undefined && (obj.name = message.name);\r\n        obj.properties = {};\r\n        if (message.properties) {\r\n            Object.entries(message.properties).forEach(([k, v]) => {\r\n                obj.properties[k] = v;\r\n            });\r\n        }\r\n        message.timestamp !== undefined && (obj.timestamp = message.timestamp.toISOString());\r\n        message.external !== undefined && (obj.external = message.external);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Event.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEvent();\r\n        message.name = object.name ?? \"\";\r\n        message.properties = Object.entries(object.properties ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        message.timestamp = object.timestamp ?? undefined;\r\n        message.external = object.external ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEvent_PropertiesEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst Event_PropertiesEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEvent_PropertiesEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Event_PropertiesEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEvent_PropertiesEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseFriend() {\r\n    return { user: undefined, state: undefined, update_time: undefined };\r\n}\r\nconst Friend = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user !== undefined) {\r\n            User.encode(message.user, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.update_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.update_time), writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseFriend();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user = User.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.update_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.update_time !== undefined && (obj.update_time = message.update_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Friend.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseFriend();\r\n        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.update_time = object.update_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseFriendList() {\r\n    return { friends: [], cursor: \"\" };\r\n}\r\nconst FriendList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.friends) {\r\n            Friend.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseFriendList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.friends.push(Friend.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            friends: Array.isArray(object?.friends) ? object.friends.map((e) => Friend.fromJSON(e)) : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.friends) {\r\n            obj.friends = message.friends.map((e) => e ? Friend.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.friends = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return FriendList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseFriendList();\r\n        message.friends = object.friends?.map((e) => Friend.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseGetUsersRequest() {\r\n    return { ids: [], usernames: [], facebook_ids: [] };\r\n}\r\nconst GetUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        for (const v of message.usernames) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        for (const v of message.facebook_ids) {\r\n            writer.uint32(26).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseGetUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.ids.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.usernames.push(reader.string());\r\n                    break;\r\n                case 3:\r\n                    message.facebook_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [],\r\n            usernames: Array.isArray(object?.usernames) ? object.usernames.map((e) => String(e)) : [],\r\n            facebook_ids: Array.isArray(object?.facebook_ids) ? object.facebook_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.ids) {\r\n            obj.ids = message.ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.ids = [];\r\n        }\r\n        if (message.usernames) {\r\n            obj.usernames = message.usernames.map((e) => e);\r\n        }\r\n        else {\r\n            obj.usernames = [];\r\n        }\r\n        if (message.facebook_ids) {\r\n            obj.facebook_ids = message.facebook_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.facebook_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return GetUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseGetUsersRequest();\r\n        message.ids = object.ids?.map((e) => e) || [];\r\n        message.usernames = object.usernames?.map((e) => e) || [];\r\n        message.facebook_ids = object.facebook_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateUsersRequest() {\r\n    return { display_name: \"\", avatar_url: \"\" };\r\n}\r\nconst UpdateUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(18).string(message.display_name);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(26).string(message.avatar_url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 2:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateUsersRequest();\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseGroup() {\r\n    return {\r\n        id: \"\",\r\n        creator_id: \"\",\r\n        name: \"\",\r\n        description: \"\",\r\n        lang_tag: \"\",\r\n        metadata: \"\",\r\n        avatar_url: \"\",\r\n        open: undefined,\r\n        edge_count: 0,\r\n        max_count: 0,\r\n        create_time: undefined,\r\n        update_time: undefined,\r\n    };\r\n}\r\nconst Group = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(18).string(message.creator_id);\r\n        }\r\n        if (message.name !== \"\") {\r\n            writer.uint32(26).string(message.name);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(34).string(message.description);\r\n        }\r\n        if (message.lang_tag !== \"\") {\r\n            writer.uint32(42).string(message.lang_tag);\r\n        }\r\n        if (message.metadata !== \"\") {\r\n            writer.uint32(50).string(message.metadata);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(58).string(message.avatar_url);\r\n        }\r\n        if (message.open !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.open }, writer.uint32(66).fork()).ldelim();\r\n        }\r\n        if (message.edge_count !== 0) {\r\n            writer.uint32(72).int32(message.edge_count);\r\n        }\r\n        if (message.max_count !== 0) {\r\n            writer.uint32(80).int32(message.max_count);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(90).fork()).ldelim();\r\n        }\r\n        if (message.update_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.update_time), writer.uint32(98).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseGroup();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.lang_tag = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.metadata = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.open = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 9:\r\n                    message.edge_count = reader.int32();\r\n                    break;\r\n                case 10:\r\n                    message.max_count = reader.int32();\r\n                    break;\r\n                case 11:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 12:\r\n                    message.update_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            name: isSet(object.name) ? String(object.name) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : \"\",\r\n            metadata: isSet(object.metadata) ? String(object.metadata) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n            open: isSet(object.open) ? Boolean(object.open) : undefined,\r\n            edge_count: isSet(object.edge_count) ? Number(object.edge_count) : 0,\r\n            max_count: isSet(object.max_count) ? Number(object.max_count) : 0,\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.name !== undefined && (obj.name = message.name);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.metadata !== undefined && (obj.metadata = message.metadata);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.open !== undefined && (obj.open = message.open);\r\n        message.edge_count !== undefined && (obj.edge_count = Math.round(message.edge_count));\r\n        message.max_count !== undefined && (obj.max_count = Math.round(message.max_count));\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.update_time !== undefined && (obj.update_time = message.update_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Group.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseGroup();\r\n        message.id = object.id ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.name = object.name ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.lang_tag = object.lang_tag ?? \"\";\r\n        message.metadata = object.metadata ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        message.open = object.open ?? undefined;\r\n        message.edge_count = object.edge_count ?? 0;\r\n        message.max_count = object.max_count ?? 0;\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.update_time = object.update_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseGroupList() {\r\n    return { groups: [], cursor: \"\" };\r\n}\r\nconst GroupList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.groups) {\r\n            Group.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseGroupList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.groups.push(Group.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            groups: Array.isArray(object?.groups) ? object.groups.map((e) => Group.fromJSON(e)) : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.groups) {\r\n            obj.groups = message.groups.map((e) => e ? Group.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.groups = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return GroupList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseGroupList();\r\n        message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseGroupUserList() {\r\n    return { group_users: [], cursor: \"\" };\r\n}\r\nconst GroupUserList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.group_users) {\r\n            GroupUserList_GroupUser.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseGroupUserList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_users.push(GroupUserList_GroupUser.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_users: Array.isArray(object?.group_users)\r\n                ? object.group_users.map((e) => GroupUserList_GroupUser.fromJSON(e))\r\n                : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.group_users) {\r\n            obj.group_users = message.group_users.map((e) => e ? GroupUserList_GroupUser.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.group_users = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return GroupUserList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseGroupUserList();\r\n        message.group_users = object.group_users?.map((e) => GroupUserList_GroupUser.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseGroupUserList_GroupUser() {\r\n    return { user: undefined, state: undefined };\r\n}\r\nconst GroupUserList_GroupUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user !== undefined) {\r\n            User.encode(message.user, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseGroupUserList_GroupUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user = User.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return GroupUserList_GroupUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseGroupUserList_GroupUser();\r\n        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;\r\n        message.state = object.state ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelUserList() {\r\n    return { channel_users: [], cursor: \"\", channel_id: \"\" };\r\n}\r\nconst ChannelUserList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.channel_users) {\r\n            ChannelUserList_ChannelUser.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelUserList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_users.push(ChannelUserList_ChannelUser.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_users: Array.isArray(object?.channel_users)\r\n                ? object.channel_users.map((e) => ChannelUserList_ChannelUser.fromJSON(e))\r\n                : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.channel_users) {\r\n            obj.channel_users = message.channel_users.map((e) => e ? ChannelUserList_ChannelUser.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.channel_users = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelUserList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelUserList();\r\n        message.channel_users = object.channel_users?.map((e) => ChannelUserList_ChannelUser.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelUserList_ChannelUser() {\r\n    return { user: undefined, role_id: [], id: \"\", thread_id: \"\", clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\r\n}\r\nconst ChannelUserList_ChannelUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user !== undefined) {\r\n            User.encode(message.user, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        for (const v of message.role_id) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        if (message.id !== \"\") {\r\n            writer.uint32(26).string(message.id);\r\n        }\r\n        if (message.thread_id !== \"\") {\r\n            writer.uint32(34).string(message.thread_id);\r\n        }\r\n        if (message.clan_nick !== \"\") {\r\n            writer.uint32(42).string(message.clan_nick);\r\n        }\r\n        if (message.clan_avatar !== \"\") {\r\n            writer.uint32(50).string(message.clan_avatar);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(58).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelUserList_ChannelUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user = User.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.role_id.push(reader.string());\r\n                    break;\r\n                case 3:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.thread_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.clan_nick = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.clan_avatar = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,\r\n            role_id: Array.isArray(object?.role_id) ? object.role_id.map((e) => String(e)) : [],\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            thread_id: isSet(object.thread_id) ? String(object.thread_id) : \"\",\r\n            clan_nick: isSet(object.clan_nick) ? String(object.clan_nick) : \"\",\r\n            clan_avatar: isSet(object.clan_avatar) ? String(object.clan_avatar) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);\r\n        if (message.role_id) {\r\n            obj.role_id = message.role_id.map((e) => e);\r\n        }\r\n        else {\r\n            obj.role_id = [];\r\n        }\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.thread_id !== undefined && (obj.thread_id = message.thread_id);\r\n        message.clan_nick !== undefined && (obj.clan_nick = message.clan_nick);\r\n        message.clan_avatar !== undefined && (obj.clan_avatar = message.clan_avatar);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelUserList_ChannelUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelUserList_ChannelUser();\r\n        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;\r\n        message.role_id = object.role_id?.map((e) => e) || [];\r\n        message.id = object.id ?? \"\";\r\n        message.thread_id = object.thread_id ?? \"\";\r\n        message.clan_nick = object.clan_nick ?? \"\";\r\n        message.clan_avatar = object.clan_avatar ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseVoiceChannelUser() {\r\n    return { id: \"\", user_id: \"\", channel_id: \"\", participant: \"\" };\r\n}\r\nconst VoiceChannelUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(18).string(message.user_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.participant !== \"\") {\r\n            writer.uint32(34).string(message.participant);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseVoiceChannelUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.participant = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            participant: isSet(object.participant) ? String(object.participant) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.participant !== undefined && (obj.participant = message.participant);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return VoiceChannelUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseVoiceChannelUser();\r\n        message.id = object.id ?? \"\";\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.participant = object.participant ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseVoiceChannelUserList() {\r\n    return { voice_channel_users: [] };\r\n}\r\nconst VoiceChannelUserList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.voice_channel_users) {\r\n            VoiceChannelUser.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseVoiceChannelUserList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.voice_channel_users.push(VoiceChannelUser.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            voice_channel_users: Array.isArray(object?.voice_channel_users)\r\n                ? object.voice_channel_users.map((e) => VoiceChannelUser.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.voice_channel_users) {\r\n            obj.voice_channel_users = message.voice_channel_users.map((e) => e ? VoiceChannelUser.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.voice_channel_users = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return VoiceChannelUserList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseVoiceChannelUserList();\r\n        message.voice_channel_users = object.voice_channel_users?.map((e) => VoiceChannelUser.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelAttachment() {\r\n    return { id: \"\", filename: \"\", filetype: \"\", filesize: \"\", url: \"\", uploader: \"\", create_time: undefined };\r\n}\r\nconst ChannelAttachment = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.filename !== \"\") {\r\n            writer.uint32(18).string(message.filename);\r\n        }\r\n        if (message.filetype !== \"\") {\r\n            writer.uint32(26).string(message.filetype);\r\n        }\r\n        if (message.filesize !== \"\") {\r\n            writer.uint32(34).string(message.filesize);\r\n        }\r\n        if (message.url !== \"\") {\r\n            writer.uint32(42).string(message.url);\r\n        }\r\n        if (message.uploader !== \"\") {\r\n            writer.uint32(50).string(message.uploader);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(58).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelAttachment();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.filename = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.filetype = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.filesize = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.url = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.uploader = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            filename: isSet(object.filename) ? String(object.filename) : \"\",\r\n            filetype: isSet(object.filetype) ? String(object.filetype) : \"\",\r\n            filesize: isSet(object.filesize) ? String(object.filesize) : \"\",\r\n            url: isSet(object.url) ? String(object.url) : \"\",\r\n            uploader: isSet(object.uploader) ? String(object.uploader) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.filename !== undefined && (obj.filename = message.filename);\r\n        message.filetype !== undefined && (obj.filetype = message.filetype);\r\n        message.filesize !== undefined && (obj.filesize = message.filesize);\r\n        message.url !== undefined && (obj.url = message.url);\r\n        message.uploader !== undefined && (obj.uploader = message.uploader);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelAttachment.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelAttachment();\r\n        message.id = object.id ?? \"\";\r\n        message.filename = object.filename ?? \"\";\r\n        message.filetype = object.filetype ?? \"\";\r\n        message.filesize = object.filesize ?? \"\";\r\n        message.url = object.url ?? \"\";\r\n        message.uploader = object.uploader ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelAttachmentList() {\r\n    return { attachments: [] };\r\n}\r\nconst ChannelAttachmentList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.attachments) {\r\n            ChannelAttachment.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelAttachmentList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.attachments.push(ChannelAttachment.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            attachments: Array.isArray(object?.attachments)\r\n                ? object.attachments.map((e) => ChannelAttachment.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.attachments) {\r\n            obj.attachments = message.attachments.map((e) => e ? ChannelAttachment.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.attachments = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelAttachmentList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelAttachmentList();\r\n        message.attachments = object.attachments?.map((e) => ChannelAttachment.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanUserList() {\r\n    return { clan_users: [], cursor: \"\", clan_id: \"\" };\r\n}\r\nconst ClanUserList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.clan_users) {\r\n            ClanUserList_ClanUser.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(26).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanUserList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_users.push(ClanUserList_ClanUser.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_users: Array.isArray(object?.clan_users)\r\n                ? object.clan_users.map((e) => ClanUserList_ClanUser.fromJSON(e))\r\n                : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.clan_users) {\r\n            obj.clan_users = message.clan_users.map((e) => e ? ClanUserList_ClanUser.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.clan_users = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanUserList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanUserList();\r\n        message.clan_users = object.clan_users?.map((e) => ClanUserList_ClanUser.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanUserList_ClanUser() {\r\n    return { user: undefined, role_id: undefined, clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\r\n}\r\nconst ClanUserList_ClanUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user !== undefined) {\r\n            User.encode(message.user, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.role_id !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.role_id }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.clan_nick !== \"\") {\r\n            writer.uint32(26).string(message.clan_nick);\r\n        }\r\n        if (message.clan_avatar !== \"\") {\r\n            writer.uint32(34).string(message.clan_avatar);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(42).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanUserList_ClanUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user = User.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.role_id = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.clan_nick = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_avatar = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user: isSet(object.user) ? User.fromJSON(object.user) : undefined,\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : undefined,\r\n            clan_nick: isSet(object.clan_nick) ? String(object.clan_nick) : \"\",\r\n            clan_avatar: isSet(object.clan_avatar) ? String(object.clan_avatar) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        message.clan_nick !== undefined && (obj.clan_nick = message.clan_nick);\r\n        message.clan_avatar !== undefined && (obj.clan_avatar = message.clan_avatar);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanUserList_ClanUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanUserList_ClanUser();\r\n        message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;\r\n        message.role_id = object.role_id ?? undefined;\r\n        message.clan_nick = object.clan_nick ?? \"\";\r\n        message.clan_avatar = object.clan_avatar ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseImportFacebookFriendsRequest() {\r\n    return { account: undefined, reset: undefined };\r\n}\r\nconst ImportFacebookFriendsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.reset !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.reset }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseImportFacebookFriendsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountFacebook.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.reset = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountFacebook.fromJSON(object.account) : undefined,\r\n            reset: isSet(object.reset) ? Boolean(object.reset) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountFacebook.toJSON(message.account) : undefined);\r\n        message.reset !== undefined && (obj.reset = message.reset);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ImportFacebookFriendsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseImportFacebookFriendsRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountFacebook.fromPartial(object.account)\r\n            : undefined;\r\n        message.reset = object.reset ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseImportSteamFriendsRequest() {\r\n    return { account: undefined, reset: undefined };\r\n}\r\nconst ImportSteamFriendsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.reset !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.reset }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseImportSteamFriendsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountSteam.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.reset = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountSteam.fromJSON(object.account) : undefined,\r\n            reset: isSet(object.reset) ? Boolean(object.reset) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined && (obj.account = message.account ? AccountSteam.toJSON(message.account) : undefined);\r\n        message.reset !== undefined && (obj.reset = message.reset);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ImportSteamFriendsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseImportSteamFriendsRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountSteam.fromPartial(object.account)\r\n            : undefined;\r\n        message.reset = object.reset ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRegistFcmDeviceTokenRequest() {\r\n    return { token: \"\", device_id: \"\", platform: \"\" };\r\n}\r\nconst RegistFcmDeviceTokenRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.token !== \"\") {\r\n            writer.uint32(10).string(message.token);\r\n        }\r\n        if (message.device_id !== \"\") {\r\n            writer.uint32(18).string(message.device_id);\r\n        }\r\n        if (message.platform !== \"\") {\r\n            writer.uint32(26).string(message.platform);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRegistFcmDeviceTokenRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.device_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.platform = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            device_id: isSet(object.device_id) ? String(object.device_id) : \"\",\r\n            platform: isSet(object.platform) ? String(object.platform) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.token !== undefined && (obj.token = message.token);\r\n        message.device_id !== undefined && (obj.device_id = message.device_id);\r\n        message.platform !== undefined && (obj.platform = message.platform);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RegistFcmDeviceTokenRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRegistFcmDeviceTokenRequest();\r\n        message.token = object.token ?? \"\";\r\n        message.device_id = object.device_id ?? \"\";\r\n        message.platform = object.platform ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLinkFacebookRequest() {\r\n    return { account: undefined, sync: undefined };\r\n}\r\nconst LinkFacebookRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.sync !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.sync }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLinkFacebookRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountFacebook.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.sync = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountFacebook.fromJSON(object.account) : undefined,\r\n            sync: isSet(object.sync) ? Boolean(object.sync) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined &&\r\n            (obj.account = message.account ? AccountFacebook.toJSON(message.account) : undefined);\r\n        message.sync !== undefined && (obj.sync = message.sync);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LinkFacebookRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLinkFacebookRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountFacebook.fromPartial(object.account)\r\n            : undefined;\r\n        message.sync = object.sync ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLinkSteamRequest() {\r\n    return { account: undefined, sync: undefined };\r\n}\r\nconst LinkSteamRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.sync !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.sync }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLinkSteamRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountSteam.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.sync = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            account: isSet(object.account) ? AccountSteam.fromJSON(object.account) : undefined,\r\n            sync: isSet(object.sync) ? Boolean(object.sync) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined && (obj.account = message.account ? AccountSteam.toJSON(message.account) : undefined);\r\n        message.sync !== undefined && (obj.sync = message.sync);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LinkSteamRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLinkSteamRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountSteam.fromPartial(object.account)\r\n            : undefined;\r\n        message.sync = object.sync ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListChannelMessagesRequest() {\r\n    return { channel_id: \"\", message_id: \"\", limit: undefined, direction: undefined };\r\n}\r\nconst ListChannelMessagesRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(18).string(message.message_id);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.direction !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.direction }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListChannelMessagesRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.direction = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            direction: isSet(object.direction) ? Number(object.direction) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.direction !== undefined && (obj.direction = message.direction);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListChannelMessagesRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListChannelMessagesRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.limit = object.limit ?? undefined;\r\n        message.direction = object.direction ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListFriendsRequest() {\r\n    return { limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListFriendsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListFriendsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListFriendsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListFriendsRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListGroupsRequest() {\r\n    return { name: \"\", cursor: \"\", limit: undefined, lang_tag: \"\", members: undefined, open: undefined };\r\n}\r\nconst ListGroupsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.name !== \"\") {\r\n            writer.uint32(10).string(message.name);\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.lang_tag !== \"\") {\r\n            writer.uint32(34).string(message.lang_tag);\r\n        }\r\n        if (message.members !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.members }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.open !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.open }, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListGroupsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.lang_tag = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.members = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.open = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            name: isSet(object.name) ? String(object.name) : \"\",\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : \"\",\r\n            members: isSet(object.members) ? Number(object.members) : undefined,\r\n            open: isSet(object.open) ? Boolean(object.open) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.name !== undefined && (obj.name = message.name);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.members !== undefined && (obj.members = message.members);\r\n        message.open !== undefined && (obj.open = message.open);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListGroupsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListGroupsRequest();\r\n        message.name = object.name ?? \"\";\r\n        message.cursor = object.cursor ?? \"\";\r\n        message.limit = object.limit ?? undefined;\r\n        message.lang_tag = object.lang_tag ?? \"\";\r\n        message.members = object.members ?? undefined;\r\n        message.open = object.open ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListGroupUsersRequest() {\r\n    return { group_id: \"\", limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListGroupUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(34).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListGroupUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_id: isSet(object.group_id) ? String(object.group_id) : \"\",\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListGroupUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListGroupUsersRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListChannelUsersRequest() {\r\n    return { clan_id: \"\", channel_id: \"\", channel_type: 0, limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListChannelUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(24).int32(message.channel_type);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(50).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListChannelUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                case 4:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListChannelUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListChannelUsersRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListChannelAttachmentRequest() {\r\n    return { clan_id: \"\", channel_id: \"\", file_type: \"\", limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListChannelAttachmentRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.file_type !== \"\") {\r\n            writer.uint32(26).string(message.file_type);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(50).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListChannelAttachmentRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.file_type = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            file_type: isSet(object.file_type) ? String(object.file_type) : \"\",\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.file_type !== undefined && (obj.file_type = message.file_type);\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListChannelAttachmentRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListChannelAttachmentRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.file_type = object.file_type ?? \"\";\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListClanUsersRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ListClanUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListClanUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListClanUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListClanUsersRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListNotificationsRequest() {\r\n    return { limit: undefined, clan_id: \"\", cacheable_cursor: \"\" };\r\n}\r\nconst ListNotificationsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        if (message.cacheable_cursor !== \"\") {\r\n            writer.uint32(26).string(message.cacheable_cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListNotificationsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.cacheable_cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            cacheable_cursor: isSet(object.cacheable_cursor) ? String(object.cacheable_cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.cacheable_cursor !== undefined && (obj.cacheable_cursor = message.cacheable_cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListNotificationsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListNotificationsRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.cacheable_cursor = object.cacheable_cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListUserGroupsRequest() {\r\n    return { user_id: \"\", limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListUserGroupsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(34).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListUserGroupsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListUserGroupsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListUserGroupsRequest();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotification() {\r\n    return {\r\n        id: \"\",\r\n        subject: \"\",\r\n        content: \"\",\r\n        code: 0,\r\n        sender_id: \"\",\r\n        create_time: undefined,\r\n        persistent: false,\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        channel_type: 0,\r\n        avatar_url: \"\",\r\n    };\r\n}\r\nconst Notification = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.subject !== \"\") {\r\n            writer.uint32(18).string(message.subject);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(26).string(message.content);\r\n        }\r\n        if (message.code !== 0) {\r\n            writer.uint32(32).int32(message.code);\r\n        }\r\n        if (message.sender_id !== \"\") {\r\n            writer.uint32(42).string(message.sender_id);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.persistent === true) {\r\n            writer.uint32(56).bool(message.persistent);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(66).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(74).string(message.channel_id);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(80).int32(message.channel_type);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(90).string(message.avatar_url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotification();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.subject = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.code = reader.int32();\r\n                    break;\r\n                case 5:\r\n                    message.sender_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.persistent = reader.bool();\r\n                    break;\r\n                case 8:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                case 11:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            subject: isSet(object.subject) ? String(object.subject) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            code: isSet(object.code) ? Number(object.code) : 0,\r\n            sender_id: isSet(object.sender_id) ? String(object.sender_id) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            persistent: isSet(object.persistent) ? Boolean(object.persistent) : false,\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.subject !== undefined && (obj.subject = message.subject);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        message.code !== undefined && (obj.code = Math.round(message.code));\r\n        message.sender_id !== undefined && (obj.sender_id = message.sender_id);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.persistent !== undefined && (obj.persistent = message.persistent);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Notification.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotification();\r\n        message.id = object.id ?? \"\";\r\n        message.subject = object.subject ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.code = object.code ?? 0;\r\n        message.sender_id = object.sender_id ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.persistent = object.persistent ?? false;\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationList() {\r\n    return { notifications: [], cacheable_cursor: \"\" };\r\n}\r\nconst NotificationList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.notifications) {\r\n            Notification.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cacheable_cursor !== \"\") {\r\n            writer.uint32(18).string(message.cacheable_cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.notifications.push(Notification.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cacheable_cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            notifications: Array.isArray(object?.notifications)\r\n                ? object.notifications.map((e) => Notification.fromJSON(e))\r\n                : [],\r\n            cacheable_cursor: isSet(object.cacheable_cursor) ? String(object.cacheable_cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.notifications) {\r\n            obj.notifications = message.notifications.map((e) => e ? Notification.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.notifications = [];\r\n        }\r\n        message.cacheable_cursor !== undefined && (obj.cacheable_cursor = message.cacheable_cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationList();\r\n        message.notifications = object.notifications?.map((e) => Notification.fromPartial(e)) || [];\r\n        message.cacheable_cursor = object.cacheable_cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePromoteGroupUsersRequest() {\r\n    return { group_id: \"\", user_ids: [] };\r\n}\r\nconst PromoteGroupUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePromoteGroupUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_id: isSet(object.group_id) ? String(object.group_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PromoteGroupUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePromoteGroupUsersRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDemoteGroupUsersRequest() {\r\n    return { group_id: \"\", user_ids: [] };\r\n}\r\nconst DemoteGroupUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDemoteGroupUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_id: isSet(object.group_id) ? String(object.group_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DemoteGroupUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDemoteGroupUsersRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRpc() {\r\n    return { id: \"\", payload: \"\", http_key: \"\" };\r\n}\r\nconst Rpc = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.payload !== \"\") {\r\n            writer.uint32(18).string(message.payload);\r\n        }\r\n        if (message.http_key !== \"\") {\r\n            writer.uint32(26).string(message.http_key);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRpc();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.payload = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.http_key = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            payload: isSet(object.payload) ? String(object.payload) : \"\",\r\n            http_key: isSet(object.http_key) ? String(object.http_key) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.payload !== undefined && (obj.payload = message.payload);\r\n        message.http_key !== undefined && (obj.http_key = message.http_key);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Rpc.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRpc();\r\n        message.id = object.id ?? \"\";\r\n        message.payload = object.payload ?? \"\";\r\n        message.http_key = object.http_key ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSession() {\r\n    return { created: false, token: \"\", refresh_token: \"\" };\r\n}\r\nconst Session = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.created === true) {\r\n            writer.uint32(8).bool(message.created);\r\n        }\r\n        if (message.token !== \"\") {\r\n            writer.uint32(18).string(message.token);\r\n        }\r\n        if (message.refresh_token !== \"\") {\r\n            writer.uint32(26).string(message.refresh_token);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSession();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.created = reader.bool();\r\n                    break;\r\n                case 2:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.refresh_token = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            created: isSet(object.created) ? Boolean(object.created) : false,\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            refresh_token: isSet(object.refresh_token) ? String(object.refresh_token) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.created !== undefined && (obj.created = message.created);\r\n        message.token !== undefined && (obj.token = message.token);\r\n        message.refresh_token !== undefined && (obj.refresh_token = message.refresh_token);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Session.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSession();\r\n        message.created = object.created ?? false;\r\n        message.token = object.token ?? \"\";\r\n        message.refresh_token = object.refresh_token ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateAccountRequest() {\r\n    return {\r\n        username: undefined,\r\n        display_name: undefined,\r\n        avatar_url: undefined,\r\n        lang_tag: undefined,\r\n        location: undefined,\r\n        timezone: undefined,\r\n        about_me: \"\",\r\n    };\r\n}\r\nconst UpdateAccountRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.username !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.username }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.display_name !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.display_name }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.avatar_url !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.avatar_url }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.lang_tag !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.lang_tag }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.location !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.location }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.timezone !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.timezone }, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.about_me !== \"\") {\r\n            writer.uint32(58).string(message.about_me);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateAccountRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.username = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.display_name = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.avatar_url = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.lang_tag = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.location = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.timezone = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 7:\r\n                    message.about_me = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            username: isSet(object.username) ? String(object.username) : undefined,\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : undefined,\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : undefined,\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : undefined,\r\n            location: isSet(object.location) ? String(object.location) : undefined,\r\n            timezone: isSet(object.timezone) ? String(object.timezone) : undefined,\r\n            about_me: isSet(object.about_me) ? String(object.about_me) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.location !== undefined && (obj.location = message.location);\r\n        message.timezone !== undefined && (obj.timezone = message.timezone);\r\n        message.about_me !== undefined && (obj.about_me = message.about_me);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateAccountRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateAccountRequest();\r\n        message.username = object.username ?? undefined;\r\n        message.display_name = object.display_name ?? undefined;\r\n        message.avatar_url = object.avatar_url ?? undefined;\r\n        message.lang_tag = object.lang_tag ?? undefined;\r\n        message.location = object.location ?? undefined;\r\n        message.timezone = object.timezone ?? undefined;\r\n        message.about_me = object.about_me ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateGroupRequest() {\r\n    return {\r\n        group_id: \"\",\r\n        name: undefined,\r\n        description: undefined,\r\n        lang_tag: undefined,\r\n        avatar_url: undefined,\r\n        open: undefined,\r\n    };\r\n}\r\nconst UpdateGroupRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group_id !== \"\") {\r\n            writer.uint32(10).string(message.group_id);\r\n        }\r\n        if (message.name !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.name }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.description !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.description }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.lang_tag !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.lang_tag }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.avatar_url !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.avatar_url }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.open !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.open }, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateGroupRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.name = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.description = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.lang_tag = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.avatar_url = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.open = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group_id: isSet(object.group_id) ? String(object.group_id) : \"\",\r\n            name: isSet(object.name) ? String(object.name) : undefined,\r\n            description: isSet(object.description) ? String(object.description) : undefined,\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : undefined,\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : undefined,\r\n            open: isSet(object.open) ? Boolean(object.open) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group_id !== undefined && (obj.group_id = message.group_id);\r\n        message.name !== undefined && (obj.name = message.name);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.open !== undefined && (obj.open = message.open);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateGroupRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateGroupRequest();\r\n        message.group_id = object.group_id ?? \"\";\r\n        message.name = object.name ?? undefined;\r\n        message.description = object.description ?? undefined;\r\n        message.lang_tag = object.lang_tag ?? undefined;\r\n        message.avatar_url = object.avatar_url ?? undefined;\r\n        message.open = object.open ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateCategoryDescRequest() {\r\n    return { category_id: \"\", category_name: \"\" };\r\n}\r\nconst UpdateCategoryDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(10).string(message.category_id);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(18).string(message.category_name);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateCategoryDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateCategoryDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateCategoryDescRequest();\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUser() {\r\n    return {\r\n        id: \"\",\r\n        username: \"\",\r\n        display_name: \"\",\r\n        avatar_url: \"\",\r\n        lang_tag: \"\",\r\n        location: \"\",\r\n        timezone: \"\",\r\n        metadata: \"\",\r\n        facebook_id: \"\",\r\n        google_id: \"\",\r\n        gamecenter_id: \"\",\r\n        steam_id: \"\",\r\n        online: false,\r\n        edge_count: 0,\r\n        create_time: undefined,\r\n        update_time: undefined,\r\n        apple_id: \"\",\r\n        about_me: \"\",\r\n        join_time: undefined,\r\n    };\r\n}\r\nconst User = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(18).string(message.username);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(26).string(message.display_name);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(34).string(message.avatar_url);\r\n        }\r\n        if (message.lang_tag !== \"\") {\r\n            writer.uint32(42).string(message.lang_tag);\r\n        }\r\n        if (message.location !== \"\") {\r\n            writer.uint32(50).string(message.location);\r\n        }\r\n        if (message.timezone !== \"\") {\r\n            writer.uint32(58).string(message.timezone);\r\n        }\r\n        if (message.metadata !== \"\") {\r\n            writer.uint32(66).string(message.metadata);\r\n        }\r\n        if (message.facebook_id !== \"\") {\r\n            writer.uint32(74).string(message.facebook_id);\r\n        }\r\n        if (message.google_id !== \"\") {\r\n            writer.uint32(82).string(message.google_id);\r\n        }\r\n        if (message.gamecenter_id !== \"\") {\r\n            writer.uint32(90).string(message.gamecenter_id);\r\n        }\r\n        if (message.steam_id !== \"\") {\r\n            writer.uint32(98).string(message.steam_id);\r\n        }\r\n        if (message.online === true) {\r\n            writer.uint32(104).bool(message.online);\r\n        }\r\n        if (message.edge_count !== 0) {\r\n            writer.uint32(112).int32(message.edge_count);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(122).fork()).ldelim();\r\n        }\r\n        if (message.update_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.update_time), writer.uint32(130).fork()).ldelim();\r\n        }\r\n        if (message.apple_id !== \"\") {\r\n            writer.uint32(138).string(message.apple_id);\r\n        }\r\n        if (message.about_me !== \"\") {\r\n            writer.uint32(146).string(message.about_me);\r\n        }\r\n        if (message.join_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.join_time), writer.uint32(154).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.lang_tag = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.location = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.timezone = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.metadata = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.facebook_id = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.google_id = reader.string();\r\n                    break;\r\n                case 11:\r\n                    message.gamecenter_id = reader.string();\r\n                    break;\r\n                case 12:\r\n                    message.steam_id = reader.string();\r\n                    break;\r\n                case 13:\r\n                    message.online = reader.bool();\r\n                    break;\r\n                case 14:\r\n                    message.edge_count = reader.int32();\r\n                    break;\r\n                case 15:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 16:\r\n                    message.update_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 17:\r\n                    message.apple_id = reader.string();\r\n                    break;\r\n                case 18:\r\n                    message.about_me = reader.string();\r\n                    break;\r\n                case 19:\r\n                    message.join_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : \"\",\r\n            location: isSet(object.location) ? String(object.location) : \"\",\r\n            timezone: isSet(object.timezone) ? String(object.timezone) : \"\",\r\n            metadata: isSet(object.metadata) ? String(object.metadata) : \"\",\r\n            facebook_id: isSet(object.facebook_id) ? String(object.facebook_id) : \"\",\r\n            google_id: isSet(object.google_id) ? String(object.google_id) : \"\",\r\n            gamecenter_id: isSet(object.gamecenter_id) ? String(object.gamecenter_id) : \"\",\r\n            steam_id: isSet(object.steam_id) ? String(object.steam_id) : \"\",\r\n            online: isSet(object.online) ? Boolean(object.online) : false,\r\n            edge_count: isSet(object.edge_count) ? Number(object.edge_count) : 0,\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,\r\n            apple_id: isSet(object.apple_id) ? String(object.apple_id) : \"\",\r\n            about_me: isSet(object.about_me) ? String(object.about_me) : \"\",\r\n            join_time: isSet(object.join_time) ? fromJsonTimestamp(object.join_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.location !== undefined && (obj.location = message.location);\r\n        message.timezone !== undefined && (obj.timezone = message.timezone);\r\n        message.metadata !== undefined && (obj.metadata = message.metadata);\r\n        message.facebook_id !== undefined && (obj.facebook_id = message.facebook_id);\r\n        message.google_id !== undefined && (obj.google_id = message.google_id);\r\n        message.gamecenter_id !== undefined && (obj.gamecenter_id = message.gamecenter_id);\r\n        message.steam_id !== undefined && (obj.steam_id = message.steam_id);\r\n        message.online !== undefined && (obj.online = message.online);\r\n        message.edge_count !== undefined && (obj.edge_count = Math.round(message.edge_count));\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.update_time !== undefined && (obj.update_time = message.update_time.toISOString());\r\n        message.apple_id !== undefined && (obj.apple_id = message.apple_id);\r\n        message.about_me !== undefined && (obj.about_me = message.about_me);\r\n        message.join_time !== undefined && (obj.join_time = message.join_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return User.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUser();\r\n        message.id = object.id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        message.lang_tag = object.lang_tag ?? \"\";\r\n        message.location = object.location ?? \"\";\r\n        message.timezone = object.timezone ?? \"\";\r\n        message.metadata = object.metadata ?? \"\";\r\n        message.facebook_id = object.facebook_id ?? \"\";\r\n        message.google_id = object.google_id ?? \"\";\r\n        message.gamecenter_id = object.gamecenter_id ?? \"\";\r\n        message.steam_id = object.steam_id ?? \"\";\r\n        message.online = object.online ?? false;\r\n        message.edge_count = object.edge_count ?? 0;\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.update_time = object.update_time ?? undefined;\r\n        message.apple_id = object.apple_id ?? \"\";\r\n        message.about_me = object.about_me ?? \"\";\r\n        message.join_time = object.join_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserGroupList() {\r\n    return { user_groups: [], cursor: \"\" };\r\n}\r\nconst UserGroupList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.user_groups) {\r\n            UserGroupList_UserGroup.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserGroupList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_groups.push(UserGroupList_UserGroup.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_groups: Array.isArray(object?.user_groups)\r\n                ? object.user_groups.map((e) => UserGroupList_UserGroup.fromJSON(e))\r\n                : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.user_groups) {\r\n            obj.user_groups = message.user_groups.map((e) => e ? UserGroupList_UserGroup.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.user_groups = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserGroupList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserGroupList();\r\n        message.user_groups = object.user_groups?.map((e) => UserGroupList_UserGroup.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserGroupList_UserGroup() {\r\n    return { group: undefined, state: undefined };\r\n}\r\nconst UserGroupList_UserGroup = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.group !== undefined) {\r\n            Group.encode(message.group, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserGroupList_UserGroup();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.group = Group.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.group !== undefined && (obj.group = message.group ? Group.toJSON(message.group) : undefined);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserGroupList_UserGroup.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserGroupList_UserGroup();\r\n        message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;\r\n        message.state = object.state ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUsers() {\r\n    return { users: [] };\r\n}\r\nconst Users = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.users) {\r\n            User.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUsers();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.users.push(User.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { users: Array.isArray(object?.users) ? object.users.map((e) => User.fromJSON(e)) : [] };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.users) {\r\n            obj.users = message.users.map((e) => e ? User.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.users = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Users.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUsers();\r\n        message.users = object.users?.map((e) => User.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanDescProfile() {\r\n    return { clan_id: \"\", creator_id: \"\", nick_name: \"\", profile_banner: \"\", profile_theme: \"\", avatar_url: \"\" };\r\n}\r\nconst ClanDescProfile = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(18).string(message.creator_id);\r\n        }\r\n        if (message.nick_name !== \"\") {\r\n            writer.uint32(26).string(message.nick_name);\r\n        }\r\n        if (message.profile_banner !== \"\") {\r\n            writer.uint32(34).string(message.profile_banner);\r\n        }\r\n        if (message.profile_theme !== \"\") {\r\n            writer.uint32(42).string(message.profile_theme);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(50).string(message.avatar_url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanDescProfile();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.nick_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.profile_banner = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.profile_theme = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            nick_name: isSet(object.nick_name) ? String(object.nick_name) : \"\",\r\n            profile_banner: isSet(object.profile_banner) ? String(object.profile_banner) : \"\",\r\n            profile_theme: isSet(object.profile_theme) ? String(object.profile_theme) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.nick_name !== undefined && (obj.nick_name = message.nick_name);\r\n        message.profile_banner !== undefined && (obj.profile_banner = message.profile_banner);\r\n        message.profile_theme !== undefined && (obj.profile_theme = message.profile_theme);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanDescProfile.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanDescProfile();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.nick_name = object.nick_name ?? \"\";\r\n        message.profile_banner = object.profile_banner ?? \"\";\r\n        message.profile_theme = object.profile_theme ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateClanDescProfileRequest() {\r\n    return { clan_id: \"\", nick_name: \"\", profile_banner: \"\", profile_theme: \"\", avatar_url: \"\" };\r\n}\r\nconst UpdateClanDescProfileRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.nick_name !== \"\") {\r\n            writer.uint32(18).string(message.nick_name);\r\n        }\r\n        if (message.profile_banner !== \"\") {\r\n            writer.uint32(26).string(message.profile_banner);\r\n        }\r\n        if (message.profile_theme !== \"\") {\r\n            writer.uint32(34).string(message.profile_theme);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(42).string(message.avatar_url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateClanDescProfileRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.nick_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.profile_banner = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.profile_theme = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            nick_name: isSet(object.nick_name) ? String(object.nick_name) : \"\",\r\n            profile_banner: isSet(object.profile_banner) ? String(object.profile_banner) : \"\",\r\n            profile_theme: isSet(object.profile_theme) ? String(object.profile_theme) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.nick_name !== undefined && (obj.nick_name = message.nick_name);\r\n        message.profile_banner !== undefined && (obj.profile_banner = message.profile_banner);\r\n        message.profile_theme !== undefined && (obj.profile_theme = message.profile_theme);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateClanDescProfileRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateClanDescProfileRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.nick_name = object.nick_name ?? \"\";\r\n        message.profile_banner = object.profile_banner ?? \"\";\r\n        message.profile_theme = object.profile_theme ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanDescProfileRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ClanDescProfileRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanDescProfileRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanDescProfileRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanDescProfileRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanDesc() {\r\n    return { creator_id: \"\", clan_name: \"\", logo: \"\", banner: \"\", clan_id: \"\", status: 0 };\r\n}\r\nconst ClanDesc = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(10).string(message.creator_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(18).string(message.clan_name);\r\n        }\r\n        if (message.logo !== \"\") {\r\n            writer.uint32(26).string(message.logo);\r\n        }\r\n        if (message.banner !== \"\") {\r\n            writer.uint32(34).string(message.banner);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(42).string(message.clan_id);\r\n        }\r\n        if (message.status !== 0) {\r\n            writer.uint32(48).int32(message.status);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanDesc();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.logo = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.banner = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.status = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            logo: isSet(object.logo) ? String(object.logo) : \"\",\r\n            banner: isSet(object.banner) ? String(object.banner) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            status: isSet(object.status) ? Number(object.status) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.logo !== undefined && (obj.logo = message.logo);\r\n        message.banner !== undefined && (obj.banner = message.banner);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.status !== undefined && (obj.status = Math.round(message.status));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanDesc.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanDesc();\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.logo = object.logo ?? \"\";\r\n        message.banner = object.banner ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.status = object.status ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCreateClanDescRequest() {\r\n    return { creator_id: \"\", clan_name: \"\", logo: \"\", banner: \"\" };\r\n}\r\nconst CreateClanDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(10).string(message.creator_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(18).string(message.clan_name);\r\n        }\r\n        if (message.logo !== \"\") {\r\n            writer.uint32(26).string(message.logo);\r\n        }\r\n        if (message.banner !== \"\") {\r\n            writer.uint32(34).string(message.banner);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCreateClanDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.logo = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.banner = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            logo: isSet(object.logo) ? String(object.logo) : \"\",\r\n            banner: isSet(object.banner) ? String(object.banner) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.logo !== undefined && (obj.logo = message.logo);\r\n        message.banner !== undefined && (obj.banner = message.banner);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CreateClanDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCreateClanDescRequest();\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.logo = object.logo ?? \"\";\r\n        message.banner = object.banner ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateClanDescRequest() {\r\n    return { clan_id: \"\", creator_id: \"\", clan_name: \"\", logo: \"\", banner: \"\", status: 0 };\r\n}\r\nconst UpdateClanDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(18).string(message.creator_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(26).string(message.clan_name);\r\n        }\r\n        if (message.logo !== \"\") {\r\n            writer.uint32(34).string(message.logo);\r\n        }\r\n        if (message.banner !== \"\") {\r\n            writer.uint32(42).string(message.banner);\r\n        }\r\n        if (message.status !== 0) {\r\n            writer.uint32(48).int32(message.status);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateClanDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.logo = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.banner = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.status = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            logo: isSet(object.logo) ? String(object.logo) : \"\",\r\n            banner: isSet(object.banner) ? String(object.banner) : \"\",\r\n            status: isSet(object.status) ? Number(object.status) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.logo !== undefined && (obj.logo = message.logo);\r\n        message.banner !== undefined && (obj.banner = message.banner);\r\n        message.status !== undefined && (obj.status = Math.round(message.status));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateClanDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateClanDescRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.logo = object.logo ?? \"\";\r\n        message.banner = object.banner ?? \"\";\r\n        message.status = object.status ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteClanDescRequest() {\r\n    return { clan_desc_id: \"\" };\r\n}\r\nconst DeleteClanDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_desc_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_desc_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteClanDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_desc_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_desc_id: isSet(object.clan_desc_id) ? String(object.clan_desc_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_desc_id !== undefined && (obj.clan_desc_id = message.clan_desc_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteClanDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteClanDescRequest();\r\n        message.clan_desc_id = object.clan_desc_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListClanDescRequest() {\r\n    return { limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListClanDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListClanDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListClanDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListClanDescRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanDescList() {\r\n    return { clandesc: [] };\r\n}\r\nconst ClanDescList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.clandesc) {\r\n            ClanDesc.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanDescList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clandesc.push(ClanDesc.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clandesc: Array.isArray(object?.clandesc) ? object.clandesc.map((e) => ClanDesc.fromJSON(e)) : [] };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.clandesc) {\r\n            obj.clandesc = message.clandesc.map((e) => e ? ClanDesc.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.clandesc = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanDescList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanDescList();\r\n        message.clandesc = object.clandesc?.map((e) => ClanDesc.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLinkInviteUserRequest() {\r\n    return { clan_id: \"\", channel_id: \"\", expiry_time: 0 };\r\n}\r\nconst LinkInviteUserRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.expiry_time !== 0) {\r\n            writer.uint32(24).int32(message.expiry_time);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLinkInviteUserRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.expiry_time = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            expiry_time: isSet(object.expiry_time) ? Number(object.expiry_time) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.expiry_time !== undefined && (obj.expiry_time = Math.round(message.expiry_time));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LinkInviteUserRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLinkInviteUserRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.expiry_time = object.expiry_time ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseInviteUserRequest() {\r\n    return { invite_id: \"\" };\r\n}\r\nconst InviteUserRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.invite_id !== \"\") {\r\n            writer.uint32(10).string(message.invite_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseInviteUserRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.invite_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { invite_id: isSet(object.invite_id) ? String(object.invite_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.invite_id !== undefined && (obj.invite_id = message.invite_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return InviteUserRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseInviteUserRequest();\r\n        message.invite_id = object.invite_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseInviteUserRes() {\r\n    return { clan_id: \"\", channel_id: \"\", clan_name: \"\", channel_label: \"\", user_joined: false, expiry_time: undefined };\r\n}\r\nconst InviteUserRes = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(26).string(message.clan_name);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(34).string(message.channel_label);\r\n        }\r\n        if (message.user_joined === true) {\r\n            writer.uint32(40).bool(message.user_joined);\r\n        }\r\n        if (message.expiry_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.expiry_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseInviteUserRes();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.user_joined = reader.bool();\r\n                    break;\r\n                case 6:\r\n                    message.expiry_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            user_joined: isSet(object.user_joined) ? Boolean(object.user_joined) : false,\r\n            expiry_time: isSet(object.expiry_time) ? fromJsonTimestamp(object.expiry_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.user_joined !== undefined && (obj.user_joined = message.user_joined);\r\n        message.expiry_time !== undefined && (obj.expiry_time = message.expiry_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return InviteUserRes.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseInviteUserRes();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.user_joined = object.user_joined ?? false;\r\n        message.expiry_time = object.expiry_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseJoinClanChannelRequest() {\r\n    return { clan_id: \"\", channel_id: \"\" };\r\n}\r\nconst JoinClanChannelRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseJoinClanChannelRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return JoinClanChannelRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseJoinClanChannelRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLinkInviteUser() {\r\n    return {\r\n        clan_id: \"\",\r\n        creator_id: \"\",\r\n        channel_id: \"\",\r\n        invite_link: \"\",\r\n        create_time: undefined,\r\n        expiry_time: undefined,\r\n        id: \"\",\r\n    };\r\n}\r\nconst LinkInviteUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(18).string(message.creator_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.invite_link !== \"\") {\r\n            writer.uint32(34).string(message.invite_link);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.expiry_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.expiry_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.id !== \"\") {\r\n            writer.uint32(58).string(message.id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLinkInviteUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.invite_link = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 6:\r\n                    message.expiry_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            invite_link: isSet(object.invite_link) ? String(object.invite_link) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            expiry_time: isSet(object.expiry_time) ? fromJsonTimestamp(object.expiry_time) : undefined,\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.invite_link !== undefined && (obj.invite_link = message.invite_link);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.expiry_time !== undefined && (obj.expiry_time = message.expiry_time.toISOString());\r\n        message.id !== undefined && (obj.id = message.id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LinkInviteUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLinkInviteUser();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.invite_link = object.invite_link ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.expiry_time = object.expiry_time ?? undefined;\r\n        message.id = object.id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanProfile() {\r\n    return { user_id: \"\", nick_name: \"\", avartar: \"\", clan_id: \"\" };\r\n}\r\nconst ClanProfile = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.nick_name !== \"\") {\r\n            writer.uint32(18).string(message.nick_name);\r\n        }\r\n        if (message.avartar !== \"\") {\r\n            writer.uint32(26).string(message.avartar);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(34).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanProfile();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.nick_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.avartar = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            nick_name: isSet(object.nick_name) ? String(object.nick_name) : \"\",\r\n            avartar: isSet(object.avartar) ? String(object.avartar) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.nick_name !== undefined && (obj.nick_name = message.nick_name);\r\n        message.avartar !== undefined && (obj.avartar = message.avartar);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanProfile.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanProfile();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.nick_name = object.nick_name ?? \"\";\r\n        message.avartar = object.avartar ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanProfileRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ClanProfileRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanProfileRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanProfileRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanProfileRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateClanProfileRequest() {\r\n    return { clan_id: \"\", nick_name: \"\", avatar: \"\" };\r\n}\r\nconst UpdateClanProfileRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.nick_name !== \"\") {\r\n            writer.uint32(18).string(message.nick_name);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(26).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateClanProfileRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.nick_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            nick_name: isSet(object.nick_name) ? String(object.nick_name) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.nick_name !== undefined && (obj.nick_name = message.nick_name);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateClanProfileRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateClanProfileRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.nick_name = object.nick_name ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCategoryDesc() {\r\n    return { creator_id: \"\", clan_id: \"\", category_name: \"\", category_id: \"\" };\r\n}\r\nconst CategoryDesc = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(10).string(message.creator_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(26).string(message.category_name);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(34).string(message.category_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCategoryDesc();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CategoryDesc.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCategoryDesc();\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        message.category_id = object.category_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCreateCategoryDescRequest() {\r\n    return { category_name: \"\", clan_id: \"\" };\r\n}\r\nconst CreateCategoryDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(10).string(message.category_name);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCreateCategoryDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CreateCategoryDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCreateCategoryDescRequest();\r\n        message.category_name = object.category_name ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteCategoryDescRequest() {\r\n    return { creator_id: \"\" };\r\n}\r\nconst DeleteCategoryDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(10).string(message.creator_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteCategoryDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteCategoryDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteCategoryDescRequest();\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCategoryDescList() {\r\n    return { categorydesc: [] };\r\n}\r\nconst CategoryDescList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.categorydesc) {\r\n            CategoryDesc.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCategoryDescList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.categorydesc.push(CategoryDesc.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            categorydesc: Array.isArray(object?.categorydesc)\r\n                ? object.categorydesc.map((e) => CategoryDesc.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.categorydesc) {\r\n            obj.categorydesc = message.categorydesc.map((e) => e ? CategoryDesc.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.categorydesc = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CategoryDescList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCategoryDescList();\r\n        message.categorydesc = object.categorydesc?.map((e) => CategoryDesc.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListCategoryDescsRequest() {\r\n    return { limit: undefined, state: undefined, cursor: \"\" };\r\n}\r\nconst ListCategoryDescsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListCategoryDescsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListCategoryDescsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListCategoryDescsRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessageHeader() {\r\n    return { id: \"\", timestamp: \"\", sender_id: \"\", content: \"\", attachment: \"\", referece: \"\", mention: \"\", reaction: \"\" };\r\n}\r\nconst ChannelMessageHeader = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.timestamp !== \"\") {\r\n            writer.uint32(18).string(message.timestamp);\r\n        }\r\n        if (message.sender_id !== \"\") {\r\n            writer.uint32(26).string(message.sender_id);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(34).string(message.content);\r\n        }\r\n        if (message.attachment !== \"\") {\r\n            writer.uint32(42).string(message.attachment);\r\n        }\r\n        if (message.referece !== \"\") {\r\n            writer.uint32(50).string(message.referece);\r\n        }\r\n        if (message.mention !== \"\") {\r\n            writer.uint32(58).string(message.mention);\r\n        }\r\n        if (message.reaction !== \"\") {\r\n            writer.uint32(66).string(message.reaction);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessageHeader();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.timestamp = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.sender_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.attachment = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.referece = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.mention = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.reaction = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            timestamp: isSet(object.timestamp) ? String(object.timestamp) : \"\",\r\n            sender_id: isSet(object.sender_id) ? String(object.sender_id) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            attachment: isSet(object.attachment) ? String(object.attachment) : \"\",\r\n            referece: isSet(object.referece) ? String(object.referece) : \"\",\r\n            mention: isSet(object.mention) ? String(object.mention) : \"\",\r\n            reaction: isSet(object.reaction) ? String(object.reaction) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.timestamp !== undefined && (obj.timestamp = message.timestamp);\r\n        message.sender_id !== undefined && (obj.sender_id = message.sender_id);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        message.attachment !== undefined && (obj.attachment = message.attachment);\r\n        message.referece !== undefined && (obj.referece = message.referece);\r\n        message.mention !== undefined && (obj.mention = message.mention);\r\n        message.reaction !== undefined && (obj.reaction = message.reaction);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessageHeader.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessageHeader();\r\n        message.id = object.id ?? \"\";\r\n        message.timestamp = object.timestamp ?? \"\";\r\n        message.sender_id = object.sender_id ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.attachment = object.attachment ?? \"\";\r\n        message.referece = object.referece ?? \"\";\r\n        message.mention = object.mention ?? \"\";\r\n        message.reaction = object.reaction ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelDescription() {\r\n    return {\r\n        clan_id: \"\",\r\n        parrent_id: \"\",\r\n        channel_id: \"\",\r\n        category_id: \"\",\r\n        category_name: \"\",\r\n        type: undefined,\r\n        creator_id: \"\",\r\n        channel_label: \"\",\r\n        channel_private: 0,\r\n        channel_avatar: [],\r\n        user_id: [],\r\n        last_sent_message: undefined,\r\n        last_seen_message: undefined,\r\n        status: 0,\r\n        meeting_code: \"\",\r\n        count_mess_unread: 0,\r\n        active: 0,\r\n        last_pin_message: \"\",\r\n        usernames: \"\",\r\n        creator_name: \"\",\r\n        create_time_ms: 0,\r\n        update_time_ms: 0,\r\n    };\r\n}\r\nconst ChannelDescription = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(18).string(message.parrent_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(34).string(message.category_id);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(42).string(message.category_name);\r\n        }\r\n        if (message.type !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.type }, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(58).string(message.creator_id);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(66).string(message.channel_label);\r\n        }\r\n        if (message.channel_private !== 0) {\r\n            writer.uint32(72).int32(message.channel_private);\r\n        }\r\n        for (const v of message.channel_avatar) {\r\n            writer.uint32(82).string(v);\r\n        }\r\n        for (const v of message.user_id) {\r\n            writer.uint32(90).string(v);\r\n        }\r\n        if (message.last_sent_message !== undefined) {\r\n            ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();\r\n        }\r\n        if (message.last_seen_message !== undefined) {\r\n            ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(106).fork()).ldelim();\r\n        }\r\n        if (message.status !== 0) {\r\n            writer.uint32(112).int32(message.status);\r\n        }\r\n        if (message.meeting_code !== \"\") {\r\n            writer.uint32(122).string(message.meeting_code);\r\n        }\r\n        if (message.count_mess_unread !== 0) {\r\n            writer.uint32(128).int32(message.count_mess_unread);\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(136).int32(message.active);\r\n        }\r\n        if (message.last_pin_message !== \"\") {\r\n            writer.uint32(146).string(message.last_pin_message);\r\n        }\r\n        if (message.usernames !== \"\") {\r\n            writer.uint32(154).string(message.usernames);\r\n        }\r\n        if (message.creator_name !== \"\") {\r\n            writer.uint32(162).string(message.creator_name);\r\n        }\r\n        if (message.create_time_ms !== 0) {\r\n            writer.uint32(168).uint32(message.create_time_ms);\r\n        }\r\n        if (message.update_time_ms !== 0) {\r\n            writer.uint32(176).uint32(message.update_time_ms);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelDescription();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.type = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 7:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.channel_private = reader.int32();\r\n                    break;\r\n                case 10:\r\n                    message.channel_avatar.push(reader.string());\r\n                    break;\r\n                case 11:\r\n                    message.user_id.push(reader.string());\r\n                    break;\r\n                case 12:\r\n                    message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());\r\n                    break;\r\n                case 13:\r\n                    message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());\r\n                    break;\r\n                case 14:\r\n                    message.status = reader.int32();\r\n                    break;\r\n                case 15:\r\n                    message.meeting_code = reader.string();\r\n                    break;\r\n                case 16:\r\n                    message.count_mess_unread = reader.int32();\r\n                    break;\r\n                case 17:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                case 18:\r\n                    message.last_pin_message = reader.string();\r\n                    break;\r\n                case 19:\r\n                    message.usernames = reader.string();\r\n                    break;\r\n                case 20:\r\n                    message.creator_name = reader.string();\r\n                    break;\r\n                case 21:\r\n                    message.create_time_ms = reader.uint32();\r\n                    break;\r\n                case 22:\r\n                    message.update_time_ms = reader.uint32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n            type: isSet(object.type) ? Number(object.type) : undefined,\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_private: isSet(object.channel_private) ? Number(object.channel_private) : 0,\r\n            channel_avatar: Array.isArray(object?.channel_avatar) ? object.channel_avatar.map((e) => String(e)) : [],\r\n            user_id: Array.isArray(object?.user_id) ? object.user_id.map((e) => String(e)) : [],\r\n            last_sent_message: isSet(object.last_sent_message)\r\n                ? ChannelMessageHeader.fromJSON(object.last_sent_message)\r\n                : undefined,\r\n            last_seen_message: isSet(object.last_seen_message)\r\n                ? ChannelMessageHeader.fromJSON(object.last_seen_message)\r\n                : undefined,\r\n            status: isSet(object.status) ? Number(object.status) : 0,\r\n            meeting_code: isSet(object.meeting_code) ? String(object.meeting_code) : \"\",\r\n            count_mess_unread: isSet(object.count_mess_unread) ? Number(object.count_mess_unread) : 0,\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n            last_pin_message: isSet(object.last_pin_message) ? String(object.last_pin_message) : \"\",\r\n            usernames: isSet(object.usernames) ? String(object.usernames) : \"\",\r\n            creator_name: isSet(object.creator_name) ? String(object.creator_name) : \"\",\r\n            create_time_ms: isSet(object.create_time_ms) ? Number(object.create_time_ms) : 0,\r\n            update_time_ms: isSet(object.update_time_ms) ? Number(object.update_time_ms) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        message.type !== undefined && (obj.type = message.type);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_private !== undefined && (obj.channel_private = Math.round(message.channel_private));\r\n        if (message.channel_avatar) {\r\n            obj.channel_avatar = message.channel_avatar.map((e) => e);\r\n        }\r\n        else {\r\n            obj.channel_avatar = [];\r\n        }\r\n        if (message.user_id) {\r\n            obj.user_id = message.user_id.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_id = [];\r\n        }\r\n        message.last_sent_message !== undefined && (obj.last_sent_message = message.last_sent_message\r\n            ? ChannelMessageHeader.toJSON(message.last_sent_message)\r\n            : undefined);\r\n        message.last_seen_message !== undefined && (obj.last_seen_message = message.last_seen_message\r\n            ? ChannelMessageHeader.toJSON(message.last_seen_message)\r\n            : undefined);\r\n        message.status !== undefined && (obj.status = Math.round(message.status));\r\n        message.meeting_code !== undefined && (obj.meeting_code = message.meeting_code);\r\n        message.count_mess_unread !== undefined && (obj.count_mess_unread = Math.round(message.count_mess_unread));\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        message.last_pin_message !== undefined && (obj.last_pin_message = message.last_pin_message);\r\n        message.usernames !== undefined && (obj.usernames = message.usernames);\r\n        message.creator_name !== undefined && (obj.creator_name = message.creator_name);\r\n        message.create_time_ms !== undefined && (obj.create_time_ms = Math.round(message.create_time_ms));\r\n        message.update_time_ms !== undefined && (obj.update_time_ms = Math.round(message.update_time_ms));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelDescription.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelDescription();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        message.type = object.type ?? undefined;\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_private = object.channel_private ?? 0;\r\n        message.channel_avatar = object.channel_avatar?.map((e) => e) || [];\r\n        message.user_id = object.user_id?.map((e) => e) || [];\r\n        message.last_sent_message = (object.last_sent_message !== undefined && object.last_sent_message !== null)\r\n            ? ChannelMessageHeader.fromPartial(object.last_sent_message)\r\n            : undefined;\r\n        message.last_seen_message = (object.last_seen_message !== undefined && object.last_seen_message !== null)\r\n            ? ChannelMessageHeader.fromPartial(object.last_seen_message)\r\n            : undefined;\r\n        message.status = object.status ?? 0;\r\n        message.meeting_code = object.meeting_code ?? \"\";\r\n        message.count_mess_unread = object.count_mess_unread ?? 0;\r\n        message.active = object.active ?? 0;\r\n        message.last_pin_message = object.last_pin_message ?? \"\";\r\n        message.usernames = object.usernames ?? \"\";\r\n        message.creator_name = object.creator_name ?? \"\";\r\n        message.create_time_ms = object.create_time_ms ?? 0;\r\n        message.update_time_ms = object.update_time_ms ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelDescList() {\r\n    return { channeldesc: [], next_cursor: \"\", prev_cursor: \"\", cacheable_cursor: \"\" };\r\n}\r\nconst ChannelDescList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.channeldesc) {\r\n            ChannelDescription.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.next_cursor !== \"\") {\r\n            writer.uint32(18).string(message.next_cursor);\r\n        }\r\n        if (message.prev_cursor !== \"\") {\r\n            writer.uint32(26).string(message.prev_cursor);\r\n        }\r\n        if (message.cacheable_cursor !== \"\") {\r\n            writer.uint32(34).string(message.cacheable_cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelDescList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.next_cursor = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.prev_cursor = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.cacheable_cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channeldesc: Array.isArray(object?.channeldesc)\r\n                ? object.channeldesc.map((e) => ChannelDescription.fromJSON(e))\r\n                : [],\r\n            next_cursor: isSet(object.next_cursor) ? String(object.next_cursor) : \"\",\r\n            prev_cursor: isSet(object.prev_cursor) ? String(object.prev_cursor) : \"\",\r\n            cacheable_cursor: isSet(object.cacheable_cursor) ? String(object.cacheable_cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.channeldesc) {\r\n            obj.channeldesc = message.channeldesc.map((e) => e ? ChannelDescription.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.channeldesc = [];\r\n        }\r\n        message.next_cursor !== undefined && (obj.next_cursor = message.next_cursor);\r\n        message.prev_cursor !== undefined && (obj.prev_cursor = message.prev_cursor);\r\n        message.cacheable_cursor !== undefined && (obj.cacheable_cursor = message.cacheable_cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelDescList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelDescList();\r\n        message.channeldesc = object.channeldesc?.map((e) => ChannelDescription.fromPartial(e)) || [];\r\n        message.next_cursor = object.next_cursor ?? \"\";\r\n        message.prev_cursor = object.prev_cursor ?? \"\";\r\n        message.cacheable_cursor = object.cacheable_cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListChannelDescsRequest() {\r\n    return { limit: undefined, state: undefined, cursor: \"\", clan_id: \"\", channel_type: 0 };\r\n}\r\nconst ListChannelDescsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(34).string(message.clan_id);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(40).int32(message.channel_type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListChannelDescsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListChannelDescsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListChannelDescsRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAddRoleChannelDescRequest() {\r\n    return { role_ids: [], channel_id: \"\" };\r\n}\r\nconst AddRoleChannelDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.role_ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAddRoleChannelDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_ids.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_ids: Array.isArray(object?.role_ids) ? object.role_ids.map((e) => String(e)) : [],\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.role_ids) {\r\n            obj.role_ids = message.role_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.role_ids = [];\r\n        }\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AddRoleChannelDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAddRoleChannelDescRequest();\r\n        message.role_ids = object.role_ids?.map((e) => e) || [];\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCreateChannelDescRequest() {\r\n    return {\r\n        clan_id: \"\",\r\n        parrent_id: \"\",\r\n        channel_id: \"\",\r\n        category_id: \"\",\r\n        type: undefined,\r\n        channel_label: \"\",\r\n        channel_private: 0,\r\n        user_ids: [],\r\n    };\r\n}\r\nconst CreateChannelDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(18).string(message.parrent_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(34).string(message.category_id);\r\n        }\r\n        if (message.type !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.type }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(50).string(message.channel_label);\r\n        }\r\n        if (message.channel_private !== 0) {\r\n            writer.uint32(56).int32(message.channel_private);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(66).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCreateChannelDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.type = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.channel_private = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            type: isSet(object.type) ? Number(object.type) : undefined,\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_private: isSet(object.channel_private) ? Number(object.channel_private) : 0,\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.type !== undefined && (obj.type = message.type);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_private !== undefined && (obj.channel_private = Math.round(message.channel_private));\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CreateChannelDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCreateChannelDescRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.type = object.type ?? undefined;\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_private = object.channel_private ?? 0;\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteChannelDescRequest() {\r\n    return { channel_id: \"\" };\r\n}\r\nconst DeleteChannelDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteChannelDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteChannelDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteChannelDescRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateChannelDescRequest() {\r\n    return { channel_id: \"\", channel_label: undefined, category_id: undefined };\r\n}\r\nconst UpdateChannelDescRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.channel_label !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.channel_label }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.category_id !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.category_id }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateChannelDescRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_label = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.category_id = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : undefined,\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateChannelDescRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateChannelDescRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_label = object.channel_label ?? undefined;\r\n        message.category_id = object.category_id ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChangeChannelPrivateRequest() {\r\n    return { channel_id: \"\", channel_private: 0, user_ids: [], role_ids: [] };\r\n}\r\nconst ChangeChannelPrivateRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.channel_private !== 0) {\r\n            writer.uint32(16).int32(message.channel_private);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(26).string(v);\r\n        }\r\n        for (const v of message.role_ids) {\r\n            writer.uint32(34).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChangeChannelPrivateRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_private = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                case 4:\r\n                    message.role_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_private: isSet(object.channel_private) ? Number(object.channel_private) : 0,\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n            role_ids: Array.isArray(object?.role_ids) ? object.role_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_private !== undefined && (obj.channel_private = Math.round(message.channel_private));\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        if (message.role_ids) {\r\n            obj.role_ids = message.role_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.role_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChangeChannelPrivateRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChangeChannelPrivateRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_private = object.channel_private ?? 0;\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        message.role_ids = object.role_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAddChannelUsersRequest() {\r\n    return { channel_id: \"\", user_ids: [] };\r\n}\r\nconst AddChannelUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAddChannelUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AddChannelUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAddChannelUsersRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRemoveChannelUsersRequest() {\r\n    return { channel_id: \"\", user_ids: [] };\r\n}\r\nconst RemoveChannelUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRemoveChannelUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RemoveChannelUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRemoveChannelUsersRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRemoveClanUsersRequest() {\r\n    return { clan_id: \"\", user_ids: [] };\r\n}\r\nconst RemoveClanUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRemoveClanUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RemoveClanUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRemoveClanUsersRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLeaveChannelRequest() {\r\n    return { channel_id: \"\" };\r\n}\r\nconst LeaveChannelRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLeaveChannelRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LeaveChannelRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLeaveChannelRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRole() {\r\n    return {\r\n        id: \"\",\r\n        title: \"\",\r\n        color: \"\",\r\n        role_icon: \"\",\r\n        slug: \"\",\r\n        description: \"\",\r\n        creator_id: \"\",\r\n        clan_id: \"\",\r\n        active: 0,\r\n        display_online: 0,\r\n        allow_mention: 0,\r\n        role_user_list: undefined,\r\n        permission_list: undefined,\r\n        role_channel_active: 0,\r\n        channel_ids: [],\r\n    };\r\n}\r\nconst Role = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.title !== \"\") {\r\n            writer.uint32(18).string(message.title);\r\n        }\r\n        if (message.color !== \"\") {\r\n            writer.uint32(26).string(message.color);\r\n        }\r\n        if (message.role_icon !== \"\") {\r\n            writer.uint32(34).string(message.role_icon);\r\n        }\r\n        if (message.slug !== \"\") {\r\n            writer.uint32(42).string(message.slug);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(50).string(message.description);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(58).string(message.creator_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(66).string(message.clan_id);\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(72).int32(message.active);\r\n        }\r\n        if (message.display_online !== 0) {\r\n            writer.uint32(80).int32(message.display_online);\r\n        }\r\n        if (message.allow_mention !== 0) {\r\n            writer.uint32(88).int32(message.allow_mention);\r\n        }\r\n        if (message.role_user_list !== undefined) {\r\n            RoleUserList.encode(message.role_user_list, writer.uint32(98).fork()).ldelim();\r\n        }\r\n        if (message.permission_list !== undefined) {\r\n            PermissionList.encode(message.permission_list, writer.uint32(106).fork()).ldelim();\r\n        }\r\n        if (message.role_channel_active !== 0) {\r\n            writer.uint32(112).int32(message.role_channel_active);\r\n        }\r\n        for (const v of message.channel_ids) {\r\n            writer.uint32(122).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRole();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.title = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.color = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.role_icon = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.slug = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                case 10:\r\n                    message.display_online = reader.int32();\r\n                    break;\r\n                case 11:\r\n                    message.allow_mention = reader.int32();\r\n                    break;\r\n                case 12:\r\n                    message.role_user_list = RoleUserList.decode(reader, reader.uint32());\r\n                    break;\r\n                case 13:\r\n                    message.permission_list = PermissionList.decode(reader, reader.uint32());\r\n                    break;\r\n                case 14:\r\n                    message.role_channel_active = reader.int32();\r\n                    break;\r\n                case 15:\r\n                    message.channel_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            title: isSet(object.title) ? String(object.title) : \"\",\r\n            color: isSet(object.color) ? String(object.color) : \"\",\r\n            role_icon: isSet(object.role_icon) ? String(object.role_icon) : \"\",\r\n            slug: isSet(object.slug) ? String(object.slug) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n            display_online: isSet(object.display_online) ? Number(object.display_online) : 0,\r\n            allow_mention: isSet(object.allow_mention) ? Number(object.allow_mention) : 0,\r\n            role_user_list: isSet(object.role_user_list) ? RoleUserList.fromJSON(object.role_user_list) : undefined,\r\n            permission_list: isSet(object.permission_list) ? PermissionList.fromJSON(object.permission_list) : undefined,\r\n            role_channel_active: isSet(object.role_channel_active) ? Number(object.role_channel_active) : 0,\r\n            channel_ids: Array.isArray(object?.channel_ids) ? object.channel_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.color !== undefined && (obj.color = message.color);\r\n        message.role_icon !== undefined && (obj.role_icon = message.role_icon);\r\n        message.slug !== undefined && (obj.slug = message.slug);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        message.display_online !== undefined && (obj.display_online = Math.round(message.display_online));\r\n        message.allow_mention !== undefined && (obj.allow_mention = Math.round(message.allow_mention));\r\n        message.role_user_list !== undefined &&\r\n            (obj.role_user_list = message.role_user_list ? RoleUserList.toJSON(message.role_user_list) : undefined);\r\n        message.permission_list !== undefined &&\r\n            (obj.permission_list = message.permission_list ? PermissionList.toJSON(message.permission_list) : undefined);\r\n        message.role_channel_active !== undefined && (obj.role_channel_active = Math.round(message.role_channel_active));\r\n        if (message.channel_ids) {\r\n            obj.channel_ids = message.channel_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.channel_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Role.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRole();\r\n        message.id = object.id ?? \"\";\r\n        message.title = object.title ?? \"\";\r\n        message.color = object.color ?? \"\";\r\n        message.role_icon = object.role_icon ?? \"\";\r\n        message.slug = object.slug ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.active = object.active ?? 0;\r\n        message.display_online = object.display_online ?? 0;\r\n        message.allow_mention = object.allow_mention ?? 0;\r\n        message.role_user_list = (object.role_user_list !== undefined && object.role_user_list !== null)\r\n            ? RoleUserList.fromPartial(object.role_user_list)\r\n            : undefined;\r\n        message.permission_list = (object.permission_list !== undefined && object.permission_list !== null)\r\n            ? PermissionList.fromPartial(object.permission_list)\r\n            : undefined;\r\n        message.role_channel_active = object.role_channel_active ?? 0;\r\n        message.channel_ids = object.channel_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEventManagement() {\r\n    return {\r\n        id: \"\",\r\n        title: \"\",\r\n        logo: \"\",\r\n        description: \"\",\r\n        active: 0,\r\n        start_event: 0,\r\n        creator_id: \"\",\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        address: \"\",\r\n        start_time: undefined,\r\n        end_time: undefined,\r\n        user_ids: [],\r\n        create_time: undefined,\r\n    };\r\n}\r\nconst EventManagement = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.title !== \"\") {\r\n            writer.uint32(18).string(message.title);\r\n        }\r\n        if (message.logo !== \"\") {\r\n            writer.uint32(26).string(message.logo);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(34).string(message.description);\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(40).int32(message.active);\r\n        }\r\n        if (message.start_event !== 0) {\r\n            writer.uint32(48).int32(message.start_event);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(58).string(message.creator_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(66).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(74).string(message.channel_id);\r\n        }\r\n        if (message.address !== \"\") {\r\n            writer.uint32(82).string(message.address);\r\n        }\r\n        if (message.start_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.start_time), writer.uint32(90).fork()).ldelim();\r\n        }\r\n        if (message.end_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.end_time), writer.uint32(98).fork()).ldelim();\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(106).string(v);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(114).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEventManagement();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.title = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.logo = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                case 6:\r\n                    message.start_event = reader.int32();\r\n                    break;\r\n                case 7:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.address = reader.string();\r\n                    break;\r\n                case 11:\r\n                    message.start_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 12:\r\n                    message.end_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 13:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                case 14:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            title: isSet(object.title) ? String(object.title) : \"\",\r\n            logo: isSet(object.logo) ? String(object.logo) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n            start_event: isSet(object.start_event) ? Number(object.start_event) : 0,\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            address: isSet(object.address) ? String(object.address) : \"\",\r\n            start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,\r\n            end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.logo !== undefined && (obj.logo = message.logo);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        message.start_event !== undefined && (obj.start_event = Math.round(message.start_event));\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.address !== undefined && (obj.address = message.address);\r\n        message.start_time !== undefined && (obj.start_time = message.start_time.toISOString());\r\n        message.end_time !== undefined && (obj.end_time = message.end_time.toISOString());\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return EventManagement.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEventManagement();\r\n        message.id = object.id ?? \"\";\r\n        message.title = object.title ?? \"\";\r\n        message.logo = object.logo ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.active = object.active ?? 0;\r\n        message.start_event = object.start_event ?? 0;\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.address = object.address ?? \"\";\r\n        message.start_time = object.start_time ?? undefined;\r\n        message.end_time = object.end_time ?? undefined;\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        message.create_time = object.create_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePermission() {\r\n    return { id: \"\", title: \"\", slug: \"\", description: \"\", active: 0, scope: 0 };\r\n}\r\nconst Permission = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.title !== \"\") {\r\n            writer.uint32(18).string(message.title);\r\n        }\r\n        if (message.slug !== \"\") {\r\n            writer.uint32(26).string(message.slug);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(34).string(message.description);\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(40).int32(message.active);\r\n        }\r\n        if (message.scope !== 0) {\r\n            writer.uint32(48).int32(message.scope);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePermission();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.title = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.slug = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                case 6:\r\n                    message.scope = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            title: isSet(object.title) ? String(object.title) : \"\",\r\n            slug: isSet(object.slug) ? String(object.slug) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n            scope: isSet(object.scope) ? Number(object.scope) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.slug !== undefined && (obj.slug = message.slug);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        message.scope !== undefined && (obj.scope = Math.round(message.scope));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Permission.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePermission();\r\n        message.id = object.id ?? \"\";\r\n        message.title = object.title ?? \"\";\r\n        message.slug = object.slug ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.active = object.active ?? 0;\r\n        message.scope = object.scope ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationSetting() {\r\n    return { id: \"\", notification_setting_type: 0 };\r\n}\r\nconst NotificationSetting = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.notification_setting_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_setting_type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationSetting();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_setting_type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            notification_setting_type: isSet(object.notification_setting_type) ? Number(object.notification_setting_type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.notification_setting_type !== undefined &&\r\n            (obj.notification_setting_type = Math.round(message.notification_setting_type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationSetting.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationSetting();\r\n        message.id = object.id ?? \"\";\r\n        message.notification_setting_type = object.notification_setting_type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationChannelCategoySetting() {\r\n    return { id: \"\", channel_category_label: \"\", notification_setting_type: 0, channel_category_title: \"\" };\r\n}\r\nconst NotificationChannelCategoySetting = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.channel_category_label !== \"\") {\r\n            writer.uint32(18).string(message.channel_category_label);\r\n        }\r\n        if (message.notification_setting_type !== 0) {\r\n            writer.uint32(24).int32(message.notification_setting_type);\r\n        }\r\n        if (message.channel_category_title !== \"\") {\r\n            writer.uint32(34).string(message.channel_category_title);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationChannelCategoySetting();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_category_label = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.notification_setting_type = reader.int32();\r\n                    break;\r\n                case 4:\r\n                    message.channel_category_title = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            channel_category_label: isSet(object.channel_category_label) ? String(object.channel_category_label) : \"\",\r\n            notification_setting_type: isSet(object.notification_setting_type) ? Number(object.notification_setting_type) : 0,\r\n            channel_category_title: isSet(object.channel_category_title) ? String(object.channel_category_title) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.channel_category_label !== undefined && (obj.channel_category_label = message.channel_category_label);\r\n        message.notification_setting_type !== undefined &&\r\n            (obj.notification_setting_type = Math.round(message.notification_setting_type));\r\n        message.channel_category_title !== undefined && (obj.channel_category_title = message.channel_category_title);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationChannelCategoySetting.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationChannelCategoySetting();\r\n        message.id = object.id ?? \"\";\r\n        message.channel_category_label = object.channel_category_label ?? \"\";\r\n        message.notification_setting_type = object.notification_setting_type ?? 0;\r\n        message.channel_category_title = object.channel_category_title ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationChannelCategoySettingsList() {\r\n    return { noti_channel_categoy_setting: [] };\r\n}\r\nconst NotificationChannelCategoySettingsList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.noti_channel_categoy_setting) {\r\n            NotificationChannelCategoySetting.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationChannelCategoySettingsList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.noti_channel_categoy_setting.push(NotificationChannelCategoySetting.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            noti_channel_categoy_setting: Array.isArray(object?.noti_channel_categoy_setting)\r\n                ? object.noti_channel_categoy_setting.map((e) => NotificationChannelCategoySetting.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.noti_channel_categoy_setting) {\r\n            obj.noti_channel_categoy_setting = message.noti_channel_categoy_setting.map((e) => e ? NotificationChannelCategoySetting.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.noti_channel_categoy_setting = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationChannelCategoySettingsList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationChannelCategoySettingsList();\r\n        message.noti_channel_categoy_setting =\r\n            object.noti_channel_categoy_setting?.map((e) => NotificationChannelCategoySetting.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeletePinMessage() {\r\n    return { message_id: \"\" };\r\n}\r\nconst DeletePinMessage = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(10).string(message.message_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeletePinMessage();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { message_id: isSet(object.message_id) ? String(object.message_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeletePinMessage.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeletePinMessage();\r\n        message.message_id = object.message_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePinMessage() {\r\n    return { id: \"\", message_id: \"\", channel_id: \"\", sender_id: \"\", content: \"\", username: \"\", avatar: \"\" };\r\n}\r\nconst PinMessage = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(18).string(message.message_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.sender_id !== \"\") {\r\n            writer.uint32(34).string(message.sender_id);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(42).string(message.content);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(50).string(message.username);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(58).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePinMessage();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.sender_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            sender_id: isSet(object.sender_id) ? String(object.sender_id) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.sender_id !== undefined && (obj.sender_id = message.sender_id);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PinMessage.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePinMessage();\r\n        message.id = object.id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.sender_id = object.sender_id ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePinMessagesList() {\r\n    return { pin_messages_list: [] };\r\n}\r\nconst PinMessagesList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.pin_messages_list) {\r\n            PinMessage.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePinMessagesList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.pin_messages_list.push(PinMessage.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            pin_messages_list: Array.isArray(object?.pin_messages_list)\r\n                ? object.pin_messages_list.map((e) => PinMessage.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.pin_messages_list) {\r\n            obj.pin_messages_list = message.pin_messages_list.map((e) => e ? PinMessage.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.pin_messages_list = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PinMessagesList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePinMessagesList();\r\n        message.pin_messages_list = object.pin_messages_list?.map((e) => PinMessage.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationUserChannel() {\r\n    return { id: \"\", notification_setting_type: 0, time_mute: undefined, active: 0 };\r\n}\r\nconst NotificationUserChannel = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.notification_setting_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_setting_type);\r\n        }\r\n        if (message.time_mute !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(32).int32(message.active);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationUserChannel();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_setting_type = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.time_mute = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 4:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            notification_setting_type: isSet(object.notification_setting_type) ? Number(object.notification_setting_type) : 0,\r\n            time_mute: isSet(object.time_mute) ? fromJsonTimestamp(object.time_mute) : undefined,\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.notification_setting_type !== undefined &&\r\n            (obj.notification_setting_type = Math.round(message.notification_setting_type));\r\n        message.time_mute !== undefined && (obj.time_mute = message.time_mute.toISOString());\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationUserChannel.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationUserChannel();\r\n        message.id = object.id ?? \"\";\r\n        message.notification_setting_type = object.notification_setting_type ?? 0;\r\n        message.time_mute = object.time_mute ?? undefined;\r\n        message.active = object.active ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotifiReactMessage() {\r\n    return { id: \"\", user_id: \"\", channel_id: \"\" };\r\n}\r\nconst NotifiReactMessage = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(18).string(message.user_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotifiReactMessage();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotifiReactMessage.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotifiReactMessage();\r\n        message.id = object.id ?? \"\";\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDefaultNotificationClan() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst DefaultNotificationClan = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDefaultNotificationClan();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DefaultNotificationClan.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDefaultNotificationClan();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDefaultNotificationCategory() {\r\n    return { category_id: \"\" };\r\n}\r\nconst DefaultNotificationCategory = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(10).string(message.category_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDefaultNotificationCategory();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { category_id: isSet(object.category_id) ? String(object.category_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DefaultNotificationCategory.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDefaultNotificationCategory();\r\n        message.category_id = object.category_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationChannel() {\r\n    return { channel_id: \"\" };\r\n}\r\nconst NotificationChannel = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationChannel();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationChannel.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationChannel();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationSettingList() {\r\n    return { notification_setting: [] };\r\n}\r\nconst NotificationSettingList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.notification_setting) {\r\n            NotificationSetting.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationSettingList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.notification_setting.push(NotificationSetting.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            notification_setting: Array.isArray(object?.notification_setting)\r\n                ? object.notification_setting.map((e) => NotificationSetting.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.notification_setting) {\r\n            obj.notification_setting = message.notification_setting.map((e) => e ? NotificationSetting.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.notification_setting = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationSettingList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationSettingList();\r\n        message.notification_setting = object.notification_setting?.map((e) => NotificationSetting.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSetNotificationRequest() {\r\n    return { channel_category_id: \"\", notification_type: 0, time_mute: undefined };\r\n}\r\nconst SetNotificationRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_category_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_category_id);\r\n        }\r\n        if (message.notification_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_type);\r\n        }\r\n        if (message.time_mute !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSetNotificationRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_category_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_type = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.time_mute = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_category_id: isSet(object.channel_category_id) ? String(object.channel_category_id) : \"\",\r\n            notification_type: isSet(object.notification_type) ? Number(object.notification_type) : 0,\r\n            time_mute: isSet(object.time_mute) ? fromJsonTimestamp(object.time_mute) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_category_id !== undefined && (obj.channel_category_id = message.channel_category_id);\r\n        message.notification_type !== undefined && (obj.notification_type = Math.round(message.notification_type));\r\n        message.time_mute !== undefined && (obj.time_mute = message.time_mute.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SetNotificationRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSetNotificationRequest();\r\n        message.channel_category_id = object.channel_category_id ?? \"\";\r\n        message.notification_type = object.notification_type ?? 0;\r\n        message.time_mute = object.time_mute ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePinMessageRequest() {\r\n    return { message_id: \"\", channel_id: \"\" };\r\n}\r\nconst PinMessageRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(10).string(message.message_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePinMessageRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PinMessageRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePinMessageRequest();\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSetMuteNotificationRequest() {\r\n    return { channel_id: \"\", notification_type: 0, active: 0 };\r\n}\r\nconst SetMuteNotificationRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.notification_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_type);\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(24).int32(message.active);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSetMuteNotificationRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_type = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            notification_type: isSet(object.notification_type) ? Number(object.notification_type) : 0,\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.notification_type !== undefined && (obj.notification_type = Math.round(message.notification_type));\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SetMuteNotificationRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSetMuteNotificationRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.notification_type = object.notification_type ?? 0;\r\n        message.active = object.active ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSetDefaultNotificationRequest() {\r\n    return { clan_id: \"\", notification_type: 0, category_id: \"\" };\r\n}\r\nconst SetDefaultNotificationRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.notification_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_type);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(26).string(message.category_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSetDefaultNotificationRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_type = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            notification_type: isSet(object.notification_type) ? Number(object.notification_type) : 0,\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.notification_type !== undefined && (obj.notification_type = Math.round(message.notification_type));\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SetDefaultNotificationRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSetDefaultNotificationRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.notification_type = object.notification_type ?? 0;\r\n        message.category_id = object.category_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRoleList() {\r\n    return { roles: [], next_cursor: \"\", prev_cursor: \"\", cacheable_cursor: \"\" };\r\n}\r\nconst RoleList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.roles) {\r\n            Role.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.next_cursor !== \"\") {\r\n            writer.uint32(18).string(message.next_cursor);\r\n        }\r\n        if (message.prev_cursor !== \"\") {\r\n            writer.uint32(26).string(message.prev_cursor);\r\n        }\r\n        if (message.cacheable_cursor !== \"\") {\r\n            writer.uint32(34).string(message.cacheable_cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRoleList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.roles.push(Role.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.next_cursor = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.prev_cursor = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.cacheable_cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            roles: Array.isArray(object?.roles) ? object.roles.map((e) => Role.fromJSON(e)) : [],\r\n            next_cursor: isSet(object.next_cursor) ? String(object.next_cursor) : \"\",\r\n            prev_cursor: isSet(object.prev_cursor) ? String(object.prev_cursor) : \"\",\r\n            cacheable_cursor: isSet(object.cacheable_cursor) ? String(object.cacheable_cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.roles) {\r\n            obj.roles = message.roles.map((e) => e ? Role.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.roles = [];\r\n        }\r\n        message.next_cursor !== undefined && (obj.next_cursor = message.next_cursor);\r\n        message.prev_cursor !== undefined && (obj.prev_cursor = message.prev_cursor);\r\n        message.cacheable_cursor !== undefined && (obj.cacheable_cursor = message.cacheable_cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RoleList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRoleList();\r\n        message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];\r\n        message.next_cursor = object.next_cursor ?? \"\";\r\n        message.prev_cursor = object.prev_cursor ?? \"\";\r\n        message.cacheable_cursor = object.cacheable_cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEventList() {\r\n    return { events: [] };\r\n}\r\nconst EventList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.events) {\r\n            EventManagement.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEventList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.events.push(EventManagement.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { events: Array.isArray(object?.events) ? object.events.map((e) => EventManagement.fromJSON(e)) : [] };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.events) {\r\n            obj.events = message.events.map((e) => e ? EventManagement.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.events = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return EventList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEventList();\r\n        message.events = object.events?.map((e) => EventManagement.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePermissionList() {\r\n    return { permissions: [] };\r\n}\r\nconst PermissionList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.permissions) {\r\n            Permission.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePermissionList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.permissions.push(Permission.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            permissions: Array.isArray(object?.permissions) ? object.permissions.map((e) => Permission.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.permissions) {\r\n            obj.permissions = message.permissions.map((e) => e ? Permission.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.permissions = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PermissionList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePermissionList();\r\n        message.permissions = object.permissions?.map((e) => Permission.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListPermissionsRequest() {\r\n    return { role_id: \"\" };\r\n}\r\nconst ListPermissionsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(10).string(message.role_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListPermissionsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { role_id: isSet(object.role_id) ? String(object.role_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListPermissionsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListPermissionsRequest();\r\n        message.role_id = object.role_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListRoleUsersRequest() {\r\n    return { role_id: \"\", limit: undefined, cursor: \"\" };\r\n}\r\nconst ListRoleUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(10).string(message.role_id);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListRoleUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : \"\",\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListRoleUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListRoleUsersRequest();\r\n        message.role_id = object.role_id ?? \"\";\r\n        message.limit = object.limit ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListPermissionOfUsersRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ListPermissionOfUsersRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListPermissionOfUsersRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListPermissionOfUsersRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListPermissionOfUsersRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRoleUserList() {\r\n    return { role_users: [], cursor: \"\" };\r\n}\r\nconst RoleUserList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.role_users) {\r\n            RoleUserList_RoleUser.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(18).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRoleUserList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_users.push(RoleUserList_RoleUser.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_users: Array.isArray(object?.role_users)\r\n                ? object.role_users.map((e) => RoleUserList_RoleUser.fromJSON(e))\r\n                : [],\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.role_users) {\r\n            obj.role_users = message.role_users.map((e) => e ? RoleUserList_RoleUser.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.role_users = [];\r\n        }\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RoleUserList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRoleUserList();\r\n        message.role_users = object.role_users?.map((e) => RoleUserList_RoleUser.fromPartial(e)) || [];\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRoleUserList_RoleUser() {\r\n    return { id: \"\", username: \"\", display_name: \"\", avatar_url: \"\", lang_tag: \"\", location: \"\", online: false };\r\n}\r\nconst RoleUserList_RoleUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(18).string(message.username);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(26).string(message.display_name);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(34).string(message.avatar_url);\r\n        }\r\n        if (message.lang_tag !== \"\") {\r\n            writer.uint32(42).string(message.lang_tag);\r\n        }\r\n        if (message.location !== \"\") {\r\n            writer.uint32(50).string(message.location);\r\n        }\r\n        if (message.online === true) {\r\n            writer.uint32(56).bool(message.online);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRoleUserList_RoleUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.lang_tag = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.location = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.online = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n            lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : \"\",\r\n            location: isSet(object.location) ? String(object.location) : \"\",\r\n            online: isSet(object.online) ? Boolean(object.online) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.lang_tag !== undefined && (obj.lang_tag = message.lang_tag);\r\n        message.location !== undefined && (obj.location = message.location);\r\n        message.online !== undefined && (obj.online = message.online);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RoleUserList_RoleUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRoleUserList_RoleUser();\r\n        message.id = object.id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        message.lang_tag = object.lang_tag ?? \"\";\r\n        message.location = object.location ?? \"\";\r\n        message.online = object.online ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEventUserList() {\r\n    return { user_event: [] };\r\n}\r\nconst EventUserList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.user_event) {\r\n            EventUserList_EventUser.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEventUserList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_event.push(EventUserList_EventUser.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_event: Array.isArray(object?.user_event)\r\n                ? object.user_event.map((e) => EventUserList_EventUser.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.user_event) {\r\n            obj.user_event = message.user_event.map((e) => e ? EventUserList_EventUser.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.user_event = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return EventUserList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEventUserList();\r\n        message.user_event = object.user_event?.map((e) => EventUserList_EventUser.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEventUserList_EventUser() {\r\n    return { id: \"\", username: \"\", display_name: \"\", avatar_url: \"\" };\r\n}\r\nconst EventUserList_EventUser = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(18).string(message.username);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(26).string(message.display_name);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(34).string(message.avatar_url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEventUserList_EventUser();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return EventUserList_EventUser.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEventUserList_EventUser();\r\n        message.id = object.id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListRolesRequest() {\r\n    return { limit: undefined, state: undefined, cursor: \"\", clan_id: \"\" };\r\n}\r\nconst ListRolesRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.state !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.state }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(34).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListRolesRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.state = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            state: isSet(object.state) ? Number(object.state) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.state !== undefined && (obj.state = message.state);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListRolesRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListRolesRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.state = object.state ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListEventsRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ListEventsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListEventsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListEventsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListEventsRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCreateRoleRequest() {\r\n    return {\r\n        title: \"\",\r\n        color: \"\",\r\n        role_icon: \"\",\r\n        description: \"\",\r\n        clan_id: \"\",\r\n        display_online: 0,\r\n        allow_mention: 0,\r\n        add_user_ids: [],\r\n        active_permission_ids: [],\r\n    };\r\n}\r\nconst CreateRoleRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.title !== \"\") {\r\n            writer.uint32(10).string(message.title);\r\n        }\r\n        if (message.color !== \"\") {\r\n            writer.uint32(18).string(message.color);\r\n        }\r\n        if (message.role_icon !== \"\") {\r\n            writer.uint32(26).string(message.role_icon);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(34).string(message.description);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(42).string(message.clan_id);\r\n        }\r\n        if (message.display_online !== 0) {\r\n            writer.uint32(48).int32(message.display_online);\r\n        }\r\n        if (message.allow_mention !== 0) {\r\n            writer.uint32(56).int32(message.allow_mention);\r\n        }\r\n        for (const v of message.add_user_ids) {\r\n            writer.uint32(66).string(v);\r\n        }\r\n        for (const v of message.active_permission_ids) {\r\n            writer.uint32(74).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCreateRoleRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.title = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.color = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.role_icon = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.display_online = reader.int32();\r\n                    break;\r\n                case 7:\r\n                    message.allow_mention = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.add_user_ids.push(reader.string());\r\n                    break;\r\n                case 9:\r\n                    message.active_permission_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            title: isSet(object.title) ? String(object.title) : \"\",\r\n            color: isSet(object.color) ? String(object.color) : \"\",\r\n            role_icon: isSet(object.role_icon) ? String(object.role_icon) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            display_online: isSet(object.display_online) ? Number(object.display_online) : 0,\r\n            allow_mention: isSet(object.allow_mention) ? Number(object.allow_mention) : 0,\r\n            add_user_ids: Array.isArray(object?.add_user_ids) ? object.add_user_ids.map((e) => String(e)) : [],\r\n            active_permission_ids: Array.isArray(object?.active_permission_ids)\r\n                ? object.active_permission_ids.map((e) => String(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.color !== undefined && (obj.color = message.color);\r\n        message.role_icon !== undefined && (obj.role_icon = message.role_icon);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.display_online !== undefined && (obj.display_online = Math.round(message.display_online));\r\n        message.allow_mention !== undefined && (obj.allow_mention = Math.round(message.allow_mention));\r\n        if (message.add_user_ids) {\r\n            obj.add_user_ids = message.add_user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.add_user_ids = [];\r\n        }\r\n        if (message.active_permission_ids) {\r\n            obj.active_permission_ids = message.active_permission_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.active_permission_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CreateRoleRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCreateRoleRequest();\r\n        message.title = object.title ?? \"\";\r\n        message.color = object.color ?? \"\";\r\n        message.role_icon = object.role_icon ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.display_online = object.display_online ?? 0;\r\n        message.allow_mention = object.allow_mention ?? 0;\r\n        message.add_user_ids = object.add_user_ids?.map((e) => e) || [];\r\n        message.active_permission_ids = object.active_permission_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCreateEventRequest() {\r\n    return {\r\n        title: \"\",\r\n        logo: \"\",\r\n        description: \"\",\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        address: \"\",\r\n        start_time: undefined,\r\n        end_time: undefined,\r\n    };\r\n}\r\nconst CreateEventRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.title !== \"\") {\r\n            writer.uint32(10).string(message.title);\r\n        }\r\n        if (message.logo !== \"\") {\r\n            writer.uint32(18).string(message.logo);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(26).string(message.description);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(34).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(42).string(message.channel_id);\r\n        }\r\n        if (message.address !== \"\") {\r\n            writer.uint32(50).string(message.address);\r\n        }\r\n        if (message.start_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.start_time), writer.uint32(58).fork()).ldelim();\r\n        }\r\n        if (message.end_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.end_time), writer.uint32(66).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCreateEventRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.title = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.logo = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.address = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.start_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 8:\r\n                    message.end_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            title: isSet(object.title) ? String(object.title) : \"\",\r\n            logo: isSet(object.logo) ? String(object.logo) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            address: isSet(object.address) ? String(object.address) : \"\",\r\n            start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,\r\n            end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.logo !== undefined && (obj.logo = message.logo);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.address !== undefined && (obj.address = message.address);\r\n        message.start_time !== undefined && (obj.start_time = message.start_time.toISOString());\r\n        message.end_time !== undefined && (obj.end_time = message.end_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CreateEventRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCreateEventRequest();\r\n        message.title = object.title ?? \"\";\r\n        message.logo = object.logo ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.address = object.address ?? \"\";\r\n        message.start_time = object.start_time ?? undefined;\r\n        message.end_time = object.end_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateEventRequest() {\r\n    return {\r\n        title: \"\",\r\n        logo: \"\",\r\n        description: \"\",\r\n        event_id: \"\",\r\n        channel_id: \"\",\r\n        address: \"\",\r\n        start_time: undefined,\r\n        end_time: undefined,\r\n    };\r\n}\r\nconst UpdateEventRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.title !== \"\") {\r\n            writer.uint32(10).string(message.title);\r\n        }\r\n        if (message.logo !== \"\") {\r\n            writer.uint32(18).string(message.logo);\r\n        }\r\n        if (message.description !== \"\") {\r\n            writer.uint32(26).string(message.description);\r\n        }\r\n        if (message.event_id !== \"\") {\r\n            writer.uint32(34).string(message.event_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(42).string(message.channel_id);\r\n        }\r\n        if (message.address !== \"\") {\r\n            writer.uint32(50).string(message.address);\r\n        }\r\n        if (message.start_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.start_time), writer.uint32(58).fork()).ldelim();\r\n        }\r\n        if (message.end_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.end_time), writer.uint32(66).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateEventRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.title = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.logo = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.description = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.event_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.address = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.start_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 8:\r\n                    message.end_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            title: isSet(object.title) ? String(object.title) : \"\",\r\n            logo: isSet(object.logo) ? String(object.logo) : \"\",\r\n            description: isSet(object.description) ? String(object.description) : \"\",\r\n            event_id: isSet(object.event_id) ? String(object.event_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            address: isSet(object.address) ? String(object.address) : \"\",\r\n            start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,\r\n            end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.logo !== undefined && (obj.logo = message.logo);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.event_id !== undefined && (obj.event_id = message.event_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.address !== undefined && (obj.address = message.address);\r\n        message.start_time !== undefined && (obj.start_time = message.start_time.toISOString());\r\n        message.end_time !== undefined && (obj.end_time = message.end_time.toISOString());\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateEventRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateEventRequest();\r\n        message.title = object.title ?? \"\";\r\n        message.logo = object.logo ?? \"\";\r\n        message.description = object.description ?? \"\";\r\n        message.event_id = object.event_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.address = object.address ?? \"\";\r\n        message.start_time = object.start_time ?? undefined;\r\n        message.end_time = object.end_time ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteRoleRequest() {\r\n    return { role_id: \"\", channel_id: \"\", clan_id: \"\" };\r\n}\r\nconst DeleteRoleRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(10).string(message.role_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(26).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteRoleRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteRoleRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteRoleRequest();\r\n        message.role_id = object.role_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteEventRequest() {\r\n    return { event_id: \"\" };\r\n}\r\nconst DeleteEventRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.event_id !== \"\") {\r\n            writer.uint32(10).string(message.event_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteEventRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.event_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { event_id: isSet(object.event_id) ? String(object.event_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.event_id !== undefined && (obj.event_id = message.event_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteEventRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteEventRequest();\r\n        message.event_id = object.event_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateRoleRequest() {\r\n    return {\r\n        role_id: \"\",\r\n        title: undefined,\r\n        color: undefined,\r\n        role_icon: undefined,\r\n        description: undefined,\r\n        display_online: undefined,\r\n        allow_mention: undefined,\r\n        add_user_ids: [],\r\n        active_permission_ids: [],\r\n        remove_user_ids: [],\r\n        remove_permission_ids: [],\r\n        clan_id: \"\",\r\n    };\r\n}\r\nconst UpdateRoleRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(10).string(message.role_id);\r\n        }\r\n        if (message.title !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.title }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.color !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.color }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.role_icon !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.role_icon }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.description !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.description }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.display_online !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.display_online }, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.allow_mention !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.allow_mention }, writer.uint32(58).fork()).ldelim();\r\n        }\r\n        for (const v of message.add_user_ids) {\r\n            writer.uint32(66).string(v);\r\n        }\r\n        for (const v of message.active_permission_ids) {\r\n            writer.uint32(74).string(v);\r\n        }\r\n        for (const v of message.remove_user_ids) {\r\n            writer.uint32(82).string(v);\r\n        }\r\n        for (const v of message.remove_permission_ids) {\r\n            writer.uint32(90).string(v);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(98).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateRoleRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.title = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.color = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.role_icon = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.description = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 6:\r\n                    message.display_online = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 7:\r\n                    message.allow_mention = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 8:\r\n                    message.add_user_ids.push(reader.string());\r\n                    break;\r\n                case 9:\r\n                    message.active_permission_ids.push(reader.string());\r\n                    break;\r\n                case 10:\r\n                    message.remove_user_ids.push(reader.string());\r\n                    break;\r\n                case 11:\r\n                    message.remove_permission_ids.push(reader.string());\r\n                    break;\r\n                case 12:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : \"\",\r\n            title: isSet(object.title) ? String(object.title) : undefined,\r\n            color: isSet(object.color) ? String(object.color) : undefined,\r\n            role_icon: isSet(object.role_icon) ? String(object.role_icon) : undefined,\r\n            description: isSet(object.description) ? String(object.description) : undefined,\r\n            display_online: isSet(object.display_online) ? Number(object.display_online) : undefined,\r\n            allow_mention: isSet(object.allow_mention) ? Number(object.allow_mention) : undefined,\r\n            add_user_ids: Array.isArray(object?.add_user_ids) ? object.add_user_ids.map((e) => String(e)) : [],\r\n            active_permission_ids: Array.isArray(object?.active_permission_ids)\r\n                ? object.active_permission_ids.map((e) => String(e))\r\n                : [],\r\n            remove_user_ids: Array.isArray(object?.remove_user_ids) ? object.remove_user_ids.map((e) => String(e)) : [],\r\n            remove_permission_ids: Array.isArray(object?.remove_permission_ids)\r\n                ? object.remove_permission_ids.map((e) => String(e))\r\n                : [],\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        message.title !== undefined && (obj.title = message.title);\r\n        message.color !== undefined && (obj.color = message.color);\r\n        message.role_icon !== undefined && (obj.role_icon = message.role_icon);\r\n        message.description !== undefined && (obj.description = message.description);\r\n        message.display_online !== undefined && (obj.display_online = message.display_online);\r\n        message.allow_mention !== undefined && (obj.allow_mention = message.allow_mention);\r\n        if (message.add_user_ids) {\r\n            obj.add_user_ids = message.add_user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.add_user_ids = [];\r\n        }\r\n        if (message.active_permission_ids) {\r\n            obj.active_permission_ids = message.active_permission_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.active_permission_ids = [];\r\n        }\r\n        if (message.remove_user_ids) {\r\n            obj.remove_user_ids = message.remove_user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.remove_user_ids = [];\r\n        }\r\n        if (message.remove_permission_ids) {\r\n            obj.remove_permission_ids = message.remove_permission_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.remove_permission_ids = [];\r\n        }\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateRoleRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateRoleRequest();\r\n        message.role_id = object.role_id ?? \"\";\r\n        message.title = object.title ?? undefined;\r\n        message.color = object.color ?? undefined;\r\n        message.role_icon = object.role_icon ?? undefined;\r\n        message.description = object.description ?? undefined;\r\n        message.display_online = object.display_online ?? undefined;\r\n        message.allow_mention = object.allow_mention ?? undefined;\r\n        message.add_user_ids = object.add_user_ids?.map((e) => e) || [];\r\n        message.active_permission_ids = object.active_permission_ids?.map((e) => e) || [];\r\n        message.remove_user_ids = object.remove_user_ids?.map((e) => e) || [];\r\n        message.remove_permission_ids = object.remove_permission_ids?.map((e) => e) || [];\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateRoleChannelRequest() {\r\n    return { role_id: \"\", permissionUpdate: [], channel_id: \"\" };\r\n}\r\nconst UpdateRoleChannelRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(10).string(message.role_id);\r\n        }\r\n        for (const v of message.permissionUpdate) {\r\n            PermissionUpdate.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateRoleChannelRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.permissionUpdate.push(PermissionUpdate.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : \"\",\r\n            permissionUpdate: Array.isArray(object?.permissionUpdate)\r\n                ? object.permissionUpdate.map((e) => PermissionUpdate.fromJSON(e))\r\n                : [],\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        if (message.permissionUpdate) {\r\n            obj.permissionUpdate = message.permissionUpdate.map((e) => e ? PermissionUpdate.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.permissionUpdate = [];\r\n        }\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateRoleChannelRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateRoleChannelRequest();\r\n        message.role_id = object.role_id ?? \"\";\r\n        message.permissionUpdate = object.permissionUpdate?.map((e) => PermissionUpdate.fromPartial(e)) || [];\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePermissionUpdate() {\r\n    return { permission_id: \"\", type: 0 };\r\n}\r\nconst PermissionUpdate = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.permission_id !== \"\") {\r\n            writer.uint32(10).string(message.permission_id);\r\n        }\r\n        if (message.type !== 0) {\r\n            writer.uint32(16).int32(message.type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePermissionUpdate();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.permission_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            permission_id: isSet(object.permission_id) ? String(object.permission_id) : \"\",\r\n            type: isSet(object.type) ? Number(object.type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.permission_id !== undefined && (obj.permission_id = message.permission_id);\r\n        message.type !== undefined && (obj.type = Math.round(message.type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PermissionUpdate.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePermissionUpdate();\r\n        message.permission_id = object.permission_id ?? \"\";\r\n        message.type = object.type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUploadAttachmentRequest() {\r\n    return { filename: \"\", filetype: \"\", size: 0, width: 0, height: 0 };\r\n}\r\nconst UploadAttachmentRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.filename !== \"\") {\r\n            writer.uint32(10).string(message.filename);\r\n        }\r\n        if (message.filetype !== \"\") {\r\n            writer.uint32(18).string(message.filetype);\r\n        }\r\n        if (message.size !== 0) {\r\n            writer.uint32(24).int32(message.size);\r\n        }\r\n        if (message.width !== 0) {\r\n            writer.uint32(32).int32(message.width);\r\n        }\r\n        if (message.height !== 0) {\r\n            writer.uint32(40).int32(message.height);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUploadAttachmentRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.filename = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.filetype = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.size = reader.int32();\r\n                    break;\r\n                case 4:\r\n                    message.width = reader.int32();\r\n                    break;\r\n                case 5:\r\n                    message.height = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            filename: isSet(object.filename) ? String(object.filename) : \"\",\r\n            filetype: isSet(object.filetype) ? String(object.filetype) : \"\",\r\n            size: isSet(object.size) ? Number(object.size) : 0,\r\n            width: isSet(object.width) ? Number(object.width) : 0,\r\n            height: isSet(object.height) ? Number(object.height) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.filename !== undefined && (obj.filename = message.filename);\r\n        message.filetype !== undefined && (obj.filetype = message.filetype);\r\n        message.size !== undefined && (obj.size = Math.round(message.size));\r\n        message.width !== undefined && (obj.width = Math.round(message.width));\r\n        message.height !== undefined && (obj.height = Math.round(message.height));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UploadAttachmentRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUploadAttachmentRequest();\r\n        message.filename = object.filename ?? \"\";\r\n        message.filetype = object.filetype ?? \"\";\r\n        message.size = object.size ?? 0;\r\n        message.width = object.width ?? 0;\r\n        message.height = object.height ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListMessageMentionRequest() {\r\n    return { limit: undefined, forward: undefined, cursor: \"\" };\r\n}\r\nconst ListMessageMentionRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.forward !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.forward }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListMessageMentionRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 2:\r\n                    message.forward = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            forward: isSet(object.forward) ? Boolean(object.forward) : undefined,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        message.forward !== undefined && (obj.forward = message.forward);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListMessageMentionRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListMessageMentionRequest();\r\n        message.limit = object.limit ?? undefined;\r\n        message.forward = object.forward ?? undefined;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUploadAttachment() {\r\n    return { filename: \"\", url: \"\" };\r\n}\r\nconst UploadAttachment = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.filename !== \"\") {\r\n            writer.uint32(10).string(message.filename);\r\n        }\r\n        if (message.url !== \"\") {\r\n            writer.uint32(18).string(message.url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUploadAttachment();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.filename = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            filename: isSet(object.filename) ? String(object.filename) : \"\",\r\n            url: isSet(object.url) ? String(object.url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.filename !== undefined && (obj.filename = message.filename);\r\n        message.url !== undefined && (obj.url = message.url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UploadAttachment.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUploadAttachment();\r\n        message.filename = object.filename ?? \"\";\r\n        message.url = object.url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSearchMessageRequest() {\r\n    return { filters: [], from: undefined, size: undefined, sorts: [] };\r\n}\r\nconst SearchMessageRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.filters) {\r\n            FilterParam.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.from !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.from }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.size !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.size }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        for (const v of message.sorts) {\r\n            SortParam.encode(v, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSearchMessageRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.filters.push(FilterParam.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.from = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.size = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.sorts.push(SortParam.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            filters: Array.isArray(object?.filters) ? object.filters.map((e) => FilterParam.fromJSON(e)) : [],\r\n            from: isSet(object.from) ? Number(object.from) : undefined,\r\n            size: isSet(object.size) ? Number(object.size) : undefined,\r\n            sorts: Array.isArray(object?.sorts) ? object.sorts.map((e) => SortParam.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.filters) {\r\n            obj.filters = message.filters.map((e) => e ? FilterParam.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.filters = [];\r\n        }\r\n        message.from !== undefined && (obj.from = message.from);\r\n        message.size !== undefined && (obj.size = message.size);\r\n        if (message.sorts) {\r\n            obj.sorts = message.sorts.map((e) => e ? SortParam.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.sorts = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SearchMessageRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSearchMessageRequest();\r\n        message.filters = object.filters?.map((e) => FilterParam.fromPartial(e)) || [];\r\n        message.from = object.from ?? undefined;\r\n        message.size = object.size ?? undefined;\r\n        message.sorts = object.sorts?.map((e) => SortParam.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSortParam() {\r\n    return { field_name: \"\", order: \"\" };\r\n}\r\nconst SortParam = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.field_name !== \"\") {\r\n            writer.uint32(10).string(message.field_name);\r\n        }\r\n        if (message.order !== \"\") {\r\n            writer.uint32(18).string(message.order);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSortParam();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.field_name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.order = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            field_name: isSet(object.field_name) ? String(object.field_name) : \"\",\r\n            order: isSet(object.order) ? String(object.order) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.field_name !== undefined && (obj.field_name = message.field_name);\r\n        message.order !== undefined && (obj.order = message.order);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SortParam.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSortParam();\r\n        message.field_name = object.field_name ?? \"\";\r\n        message.order = object.order ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseFilterParam() {\r\n    return { field_name: \"\", field_value: \"\" };\r\n}\r\nconst FilterParam = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.field_name !== \"\") {\r\n            writer.uint32(10).string(message.field_name);\r\n        }\r\n        if (message.field_value !== \"\") {\r\n            writer.uint32(18).string(message.field_value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseFilterParam();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.field_name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.field_value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            field_name: isSet(object.field_name) ? String(object.field_name) : \"\",\r\n            field_value: isSet(object.field_value) ? String(object.field_value) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.field_name !== undefined && (obj.field_name = message.field_name);\r\n        message.field_value !== undefined && (obj.field_value = message.field_value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return FilterParam.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseFilterParam();\r\n        message.field_name = object.field_name ?? \"\";\r\n        message.field_value = object.field_value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSearchMessageDocument() {\r\n    return {\r\n        message_id: \"\",\r\n        channel_id: 0,\r\n        clan_id: 0,\r\n        sender_id: 0,\r\n        content: \"\",\r\n        mention: \"\",\r\n        reaction: \"\",\r\n        attachment: \"\",\r\n        reference: \"\",\r\n        create_time: \"\",\r\n        update_time: \"\",\r\n        channel_label: \"\",\r\n        channel_type: 0,\r\n        clan_name: \"\",\r\n        username: \"\",\r\n        display_name: \"\",\r\n        avatar_url: \"\",\r\n    };\r\n}\r\nconst SearchMessageDocument = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(10).string(message.message_id);\r\n        }\r\n        if (message.channel_id !== 0) {\r\n            writer.uint32(16).int64(message.channel_id);\r\n        }\r\n        if (message.clan_id !== 0) {\r\n            writer.uint32(24).int64(message.clan_id);\r\n        }\r\n        if (message.sender_id !== 0) {\r\n            writer.uint32(32).int64(message.sender_id);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(42).string(message.content);\r\n        }\r\n        if (message.mention !== \"\") {\r\n            writer.uint32(50).string(message.mention);\r\n        }\r\n        if (message.reaction !== \"\") {\r\n            writer.uint32(58).string(message.reaction);\r\n        }\r\n        if (message.attachment !== \"\") {\r\n            writer.uint32(66).string(message.attachment);\r\n        }\r\n        if (message.reference !== \"\") {\r\n            writer.uint32(74).string(message.reference);\r\n        }\r\n        if (message.create_time !== \"\") {\r\n            writer.uint32(82).string(message.create_time);\r\n        }\r\n        if (message.update_time !== \"\") {\r\n            writer.uint32(90).string(message.update_time);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(98).string(message.channel_label);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(104).int32(message.channel_type);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(114).string(message.clan_name);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(122).string(message.username);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(130).string(message.display_name);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(138).string(message.avatar_url);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSearchMessageDocument();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = longToNumber(reader.int64());\r\n                    break;\r\n                case 3:\r\n                    message.clan_id = longToNumber(reader.int64());\r\n                    break;\r\n                case 4:\r\n                    message.sender_id = longToNumber(reader.int64());\r\n                    break;\r\n                case 5:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.mention = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.reaction = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.attachment = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.reference = reader.string();\r\n                    break;\r\n                case 10:\r\n                    message.create_time = reader.string();\r\n                    break;\r\n                case 11:\r\n                    message.update_time = reader.string();\r\n                    break;\r\n                case 12:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 13:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                case 14:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 15:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 16:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 17:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? Number(object.channel_id) : 0,\r\n            clan_id: isSet(object.clan_id) ? Number(object.clan_id) : 0,\r\n            sender_id: isSet(object.sender_id) ? Number(object.sender_id) : 0,\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            mention: isSet(object.mention) ? String(object.mention) : \"\",\r\n            reaction: isSet(object.reaction) ? String(object.reaction) : \"\",\r\n            attachment: isSet(object.attachment) ? String(object.attachment) : \"\",\r\n            reference: isSet(object.reference) ? String(object.reference) : \"\",\r\n            create_time: isSet(object.create_time) ? String(object.create_time) : \"\",\r\n            update_time: isSet(object.update_time) ? String(object.update_time) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.channel_id !== undefined && (obj.channel_id = Math.round(message.channel_id));\r\n        message.clan_id !== undefined && (obj.clan_id = Math.round(message.clan_id));\r\n        message.sender_id !== undefined && (obj.sender_id = Math.round(message.sender_id));\r\n        message.content !== undefined && (obj.content = message.content);\r\n        message.mention !== undefined && (obj.mention = message.mention);\r\n        message.reaction !== undefined && (obj.reaction = message.reaction);\r\n        message.attachment !== undefined && (obj.attachment = message.attachment);\r\n        message.reference !== undefined && (obj.reference = message.reference);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time);\r\n        message.update_time !== undefined && (obj.update_time = message.update_time);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SearchMessageDocument.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSearchMessageDocument();\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? 0;\r\n        message.clan_id = object.clan_id ?? 0;\r\n        message.sender_id = object.sender_id ?? 0;\r\n        message.content = object.content ?? \"\";\r\n        message.mention = object.mention ?? \"\";\r\n        message.reaction = object.reaction ?? \"\";\r\n        message.attachment = object.attachment ?? \"\";\r\n        message.reference = object.reference ?? \"\";\r\n        message.create_time = object.create_time ?? \"\";\r\n        message.update_time = object.update_time ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseSearchMessageResponse() {\r\n    return { messages: [], total: 0 };\r\n}\r\nconst SearchMessageResponse = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.messages) {\r\n            SearchMessageDocument.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.total !== 0) {\r\n            writer.uint32(16).int32(message.total);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseSearchMessageResponse();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.messages.push(SearchMessageDocument.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.total = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            messages: Array.isArray(object?.messages)\r\n                ? object.messages.map((e) => SearchMessageDocument.fromJSON(e))\r\n                : [],\r\n            total: isSet(object.total) ? Number(object.total) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.messages) {\r\n            obj.messages = message.messages.map((e) => e ? SearchMessageDocument.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.messages = [];\r\n        }\r\n        message.total !== undefined && (obj.total = Math.round(message.total));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return SearchMessageResponse.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseSearchMessageResponse();\r\n        message.messages = object.messages?.map((e) => SearchMessageDocument.fromPartial(e)) || [];\r\n        message.total = object.total ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRegistrationEmailRequest() {\r\n    return { email: \"\", password: \"\", username: \"\", display_name: \"\", avatar_url: \"\", dob: \"\", vars: {} };\r\n}\r\nconst RegistrationEmailRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.email !== \"\") {\r\n            writer.uint32(10).string(message.email);\r\n        }\r\n        if (message.password !== \"\") {\r\n            writer.uint32(18).string(message.password);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(34).string(message.display_name);\r\n        }\r\n        if (message.avatar_url !== \"\") {\r\n            writer.uint32(42).string(message.avatar_url);\r\n        }\r\n        if (message.dob !== \"\") {\r\n            writer.uint32(50).string(message.dob);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            RegistrationEmailRequest_VarsEntry.encode({ key: key, value }, writer.uint32(58).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRegistrationEmailRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.email = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.password = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.avatar_url = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.dob = reader.string();\r\n                    break;\r\n                case 7:\r\n                    const entry7 = RegistrationEmailRequest_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry7.value !== undefined) {\r\n                        message.vars[entry7.key] = entry7.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            email: isSet(object.email) ? String(object.email) : \"\",\r\n            password: isSet(object.password) ? String(object.password) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : \"\",\r\n            dob: isSet(object.dob) ? String(object.dob) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.email !== undefined && (obj.email = message.email);\r\n        message.password !== undefined && (obj.password = message.password);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar_url !== undefined && (obj.avatar_url = message.avatar_url);\r\n        message.dob !== undefined && (obj.dob = message.dob);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RegistrationEmailRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRegistrationEmailRequest();\r\n        message.email = object.email ?? \"\";\r\n        message.password = object.password ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar_url = object.avatar_url ?? \"\";\r\n        message.dob = object.dob ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseRegistrationEmailRequest_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst RegistrationEmailRequest_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseRegistrationEmailRequest_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return RegistrationEmailRequest_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseRegistrationEmailRequest_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanEmojiCreateRequest() {\r\n    return { clan_id: \"\", source: \"\", shortname: \"\", category: \"\", id: \"\" };\r\n}\r\nconst ClanEmojiCreateRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.source !== \"\") {\r\n            writer.uint32(18).string(message.source);\r\n        }\r\n        if (message.shortname !== \"\") {\r\n            writer.uint32(26).string(message.shortname);\r\n        }\r\n        if (message.category !== \"\") {\r\n            writer.uint32(34).string(message.category);\r\n        }\r\n        if (message.id !== \"\") {\r\n            writer.uint32(42).string(message.id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanEmojiCreateRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.source = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.shortname = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            source: isSet(object.source) ? String(object.source) : \"\",\r\n            shortname: isSet(object.shortname) ? String(object.shortname) : \"\",\r\n            category: isSet(object.category) ? String(object.category) : \"\",\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.source !== undefined && (obj.source = message.source);\r\n        message.shortname !== undefined && (obj.shortname = message.shortname);\r\n        message.category !== undefined && (obj.category = message.category);\r\n        message.id !== undefined && (obj.id = message.id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanEmojiCreateRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanEmojiCreateRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.source = object.source ?? \"\";\r\n        message.shortname = object.shortname ?? \"\";\r\n        message.category = object.category ?? \"\";\r\n        message.id = object.id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanEmojiGetByClanIdRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ClanEmojiGetByClanIdRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanEmojiGetByClanIdRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanEmojiGetByClanIdRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanEmojiGetByClanIdRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanEmojiDeleteRequest() {\r\n    return { id: \"\", clan_id: \"\" };\r\n}\r\nconst ClanEmojiDeleteRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanEmojiDeleteRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanEmojiDeleteRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanEmojiDeleteRequest();\r\n        message.id = object.id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanEmojiUpdateRequest() {\r\n    return { id: \"\", source: \"\", shortname: \"\", category: \"\", clan_id: \"\" };\r\n}\r\nconst ClanEmojiUpdateRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.source !== \"\") {\r\n            writer.uint32(18).string(message.source);\r\n        }\r\n        if (message.shortname !== \"\") {\r\n            writer.uint32(26).string(message.shortname);\r\n        }\r\n        if (message.category !== \"\") {\r\n            writer.uint32(34).string(message.category);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(42).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanEmojiUpdateRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.source = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.shortname = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            source: isSet(object.source) ? String(object.source) : \"\",\r\n            shortname: isSet(object.shortname) ? String(object.shortname) : \"\",\r\n            category: isSet(object.category) ? String(object.category) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.source !== undefined && (obj.source = message.source);\r\n        message.shortname !== undefined && (obj.shortname = message.shortname);\r\n        message.category !== undefined && (obj.category = message.category);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanEmojiUpdateRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanEmojiUpdateRequest();\r\n        message.id = object.id ?? \"\";\r\n        message.source = object.source ?? \"\";\r\n        message.shortname = object.shortname ?? \"\";\r\n        message.category = object.category ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhook() {\r\n    return {\r\n        id: \"\",\r\n        webhook_name: \"\",\r\n        channel_id: \"\",\r\n        active: 0,\r\n        url: \"\",\r\n        creator_id: \"\",\r\n        create_time: \"\",\r\n        update_time: \"\",\r\n        avatar: \"\",\r\n    };\r\n}\r\nconst Webhook = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.webhook_name !== \"\") {\r\n            writer.uint32(18).string(message.webhook_name);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(32).int32(message.active);\r\n        }\r\n        if (message.url !== \"\") {\r\n            writer.uint32(42).string(message.url);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(50).string(message.creator_id);\r\n        }\r\n        if (message.create_time !== \"\") {\r\n            writer.uint32(58).string(message.create_time);\r\n        }\r\n        if (message.update_time !== \"\") {\r\n            writer.uint32(66).string(message.update_time);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(74).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhook();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.webhook_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                case 5:\r\n                    message.url = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.create_time = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.update_time = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            webhook_name: isSet(object.webhook_name) ? String(object.webhook_name) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n            url: isSet(object.url) ? String(object.url) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            create_time: isSet(object.create_time) ? String(object.create_time) : \"\",\r\n            update_time: isSet(object.update_time) ? String(object.update_time) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.webhook_name !== undefined && (obj.webhook_name = message.webhook_name);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        message.url !== undefined && (obj.url = message.url);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time);\r\n        message.update_time !== undefined && (obj.update_time = message.update_time);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Webhook.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhook();\r\n        message.id = object.id ?? \"\";\r\n        message.webhook_name = object.webhook_name ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.active = object.active ?? 0;\r\n        message.url = object.url ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.create_time = object.create_time ?? \"\";\r\n        message.update_time = object.update_time ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookCreateRequest() {\r\n    return { webhook_name: \"\", channel_id: \"\", avatar: \"\" };\r\n}\r\nconst WebhookCreateRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.webhook_name !== \"\") {\r\n            writer.uint32(10).string(message.webhook_name);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(26).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookCreateRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.webhook_name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            webhook_name: isSet(object.webhook_name) ? String(object.webhook_name) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.webhook_name !== undefined && (obj.webhook_name = message.webhook_name);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookCreateRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookCreateRequest();\r\n        message.webhook_name = object.webhook_name ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookListRequestById() {\r\n    return { id: \"\" };\r\n}\r\nconst WebhookListRequestById = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookListRequestById();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookListRequestById.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookListRequestById();\r\n        message.id = object.id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookUpdateRequestById() {\r\n    return { id: \"\", webhook_name: \"\", channel_id: \"\", avatar: \"\" };\r\n}\r\nconst WebhookUpdateRequestById = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.webhook_name !== \"\") {\r\n            writer.uint32(18).string(message.webhook_name);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(34).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookUpdateRequestById();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.webhook_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            webhook_name: isSet(object.webhook_name) ? String(object.webhook_name) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.webhook_name !== undefined && (obj.webhook_name = message.webhook_name);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookUpdateRequestById.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookUpdateRequestById();\r\n        message.id = object.id ?? \"\";\r\n        message.webhook_name = object.webhook_name ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookDeleteRequestById() {\r\n    return { id: \"\" };\r\n}\r\nconst WebhookDeleteRequestById = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookDeleteRequestById();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookDeleteRequestById.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookDeleteRequestById();\r\n        message.id = object.id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookListRequest() {\r\n    return { channel_id: \"\", clan_id: \"\" };\r\n}\r\nconst WebhookListRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookListRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookListRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookListRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookListResponse() {\r\n    return { webhooks: [] };\r\n}\r\nconst WebhookListResponse = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.webhooks) {\r\n            Webhook.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookListResponse();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.webhooks.push(Webhook.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { webhooks: Array.isArray(object?.webhooks) ? object.webhooks.map((e) => Webhook.fromJSON(e)) : [] };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.webhooks) {\r\n            obj.webhooks = message.webhooks.map((e) => e ? Webhook.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.webhooks = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookListResponse.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookListResponse();\r\n        message.webhooks = object.webhooks?.map((e) => Webhook.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseWebhookGenerateResponse() {\r\n    return { url: \"\", hook_name: \"\", channel_id: \"\", avatar: \"\" };\r\n}\r\nconst WebhookGenerateResponse = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.url !== \"\") {\r\n            writer.uint32(10).string(message.url);\r\n        }\r\n        if (message.hook_name !== \"\") {\r\n            writer.uint32(18).string(message.hook_name);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(34).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseWebhookGenerateResponse();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.url = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.hook_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            url: isSet(object.url) ? String(object.url) : \"\",\r\n            hook_name: isSet(object.hook_name) ? String(object.hook_name) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.url !== undefined && (obj.url = message.url);\r\n        message.hook_name !== undefined && (obj.hook_name = message.hook_name);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return WebhookGenerateResponse.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseWebhookGenerateResponse();\r\n        message.url = object.url ?? \"\";\r\n        message.hook_name = object.hook_name ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCheckDuplicateClanNameRequest() {\r\n    return { clan_name: \"\" };\r\n}\r\nconst CheckDuplicateClanNameRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(10).string(message.clan_name);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCheckDuplicateClanNameRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CheckDuplicateClanNameRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCheckDuplicateClanNameRequest();\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCheckDuplicateClanNameResponse() {\r\n    return { is_duplicate: false };\r\n}\r\nconst CheckDuplicateClanNameResponse = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.is_duplicate === true) {\r\n            writer.uint32(8).bool(message.is_duplicate);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCheckDuplicateClanNameResponse();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.is_duplicate = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { is_duplicate: isSet(object.is_duplicate) ? Boolean(object.is_duplicate) : false };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.is_duplicate !== undefined && (obj.is_duplicate = message.is_duplicate);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CheckDuplicateClanNameResponse.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCheckDuplicateClanNameResponse();\r\n        message.is_duplicate = object.is_duplicate ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanStickerAddRequest() {\r\n    return { source: \"\", shortname: \"\", category: \"\", clan_id: 0, id: \"\" };\r\n}\r\nconst ClanStickerAddRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.source !== \"\") {\r\n            writer.uint32(10).string(message.source);\r\n        }\r\n        if (message.shortname !== \"\") {\r\n            writer.uint32(18).string(message.shortname);\r\n        }\r\n        if (message.category !== \"\") {\r\n            writer.uint32(26).string(message.category);\r\n        }\r\n        if (message.clan_id !== 0) {\r\n            writer.uint32(32).int64(message.clan_id);\r\n        }\r\n        if (message.id !== \"\") {\r\n            writer.uint32(42).string(message.id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanStickerAddRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.source = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.shortname = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.category = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = longToNumber(reader.int64());\r\n                    break;\r\n                case 5:\r\n                    message.id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            source: isSet(object.source) ? String(object.source) : \"\",\r\n            shortname: isSet(object.shortname) ? String(object.shortname) : \"\",\r\n            category: isSet(object.category) ? String(object.category) : \"\",\r\n            clan_id: isSet(object.clan_id) ? Number(object.clan_id) : 0,\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.source !== undefined && (obj.source = message.source);\r\n        message.shortname !== undefined && (obj.shortname = message.shortname);\r\n        message.category !== undefined && (obj.category = message.category);\r\n        message.clan_id !== undefined && (obj.clan_id = Math.round(message.clan_id));\r\n        message.id !== undefined && (obj.id = message.id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanStickerAddRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanStickerAddRequest();\r\n        message.source = object.source ?? \"\";\r\n        message.shortname = object.shortname ?? \"\";\r\n        message.category = object.category ?? \"\";\r\n        message.clan_id = object.clan_id ?? 0;\r\n        message.id = object.id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanStickerListByClanIdRequest() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ClanStickerListByClanIdRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanStickerListByClanIdRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanStickerListByClanIdRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanStickerListByClanIdRequest();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanStickerUpdateByIdRequest() {\r\n    return { id: 0, source: \"\", shortname: \"\", category: \"\" };\r\n}\r\nconst ClanStickerUpdateByIdRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== 0) {\r\n            writer.uint32(8).int64(message.id);\r\n        }\r\n        if (message.source !== \"\") {\r\n            writer.uint32(18).string(message.source);\r\n        }\r\n        if (message.shortname !== \"\") {\r\n            writer.uint32(26).string(message.shortname);\r\n        }\r\n        if (message.category !== \"\") {\r\n            writer.uint32(34).string(message.category);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanStickerUpdateByIdRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = longToNumber(reader.int64());\r\n                    break;\r\n                case 2:\r\n                    message.source = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.shortname = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? Number(object.id) : 0,\r\n            source: isSet(object.source) ? String(object.source) : \"\",\r\n            shortname: isSet(object.shortname) ? String(object.shortname) : \"\",\r\n            category: isSet(object.category) ? String(object.category) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = Math.round(message.id));\r\n        message.source !== undefined && (obj.source = message.source);\r\n        message.shortname !== undefined && (obj.shortname = message.shortname);\r\n        message.category !== undefined && (obj.category = message.category);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanStickerUpdateByIdRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanStickerUpdateByIdRequest();\r\n        message.id = object.id ?? 0;\r\n        message.source = object.source ?? \"\";\r\n        message.shortname = object.shortname ?? \"\";\r\n        message.category = object.category ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanStickerDeleteRequest() {\r\n    return { id: 0, clan_id: \"\" };\r\n}\r\nconst ClanStickerDeleteRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== 0) {\r\n            writer.uint32(8).int64(message.id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanStickerDeleteRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = longToNumber(reader.int64());\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? Number(object.id) : 0,\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = Math.round(message.id));\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanStickerDeleteRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanStickerDeleteRequest();\r\n        message.id = object.id ?? 0;\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChangeChannelCategoryRequest() {\r\n    return { channel_id: \"\", new_category_id: \"\" };\r\n}\r\nconst ChangeChannelCategoryRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.new_category_id !== \"\") {\r\n            writer.uint32(18).string(message.new_category_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChangeChannelCategoryRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.new_category_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            new_category_id: isSet(object.new_category_id) ? String(object.new_category_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.new_category_id !== undefined && (obj.new_category_id = message.new_category_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChangeChannelCategoryRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChangeChannelCategoryRequest();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.new_category_id = object.new_category_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseApp() {\r\n    return {\r\n        id: \"\",\r\n        appname: \"\",\r\n        creator_id: \"\",\r\n        applogo: \"\",\r\n        is_shadow: false,\r\n        disable_time: undefined,\r\n        token: \"\",\r\n        role: 0,\r\n    };\r\n}\r\nconst App = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.appname !== \"\") {\r\n            writer.uint32(18).string(message.appname);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(26).string(message.creator_id);\r\n        }\r\n        if (message.applogo !== \"\") {\r\n            writer.uint32(34).string(message.applogo);\r\n        }\r\n        if (message.is_shadow === true) {\r\n            writer.uint32(40).bool(message.is_shadow);\r\n        }\r\n        if (message.disable_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.disable_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.token !== \"\") {\r\n            writer.uint32(58).string(message.token);\r\n        }\r\n        if (message.role !== 0) {\r\n            writer.uint32(64).int32(message.role);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseApp();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.appname = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.applogo = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.is_shadow = reader.bool();\r\n                    break;\r\n                case 6:\r\n                    message.disable_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.role = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            appname: isSet(object.appname) ? String(object.appname) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            applogo: isSet(object.applogo) ? String(object.applogo) : \"\",\r\n            is_shadow: isSet(object.is_shadow) ? Boolean(object.is_shadow) : false,\r\n            disable_time: isSet(object.disable_time) ? fromJsonTimestamp(object.disable_time) : undefined,\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            role: isSet(object.role) ? Number(object.role) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.appname !== undefined && (obj.appname = message.appname);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.applogo !== undefined && (obj.applogo = message.applogo);\r\n        message.is_shadow !== undefined && (obj.is_shadow = message.is_shadow);\r\n        message.disable_time !== undefined && (obj.disable_time = message.disable_time.toISOString());\r\n        message.token !== undefined && (obj.token = message.token);\r\n        message.role !== undefined && (obj.role = Math.round(message.role));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return App.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseApp();\r\n        message.id = object.id ?? \"\";\r\n        message.appname = object.appname ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.applogo = object.applogo ?? \"\";\r\n        message.is_shadow = object.is_shadow ?? false;\r\n        message.disable_time = object.disable_time ?? undefined;\r\n        message.token = object.token ?? \"\";\r\n        message.role = object.role ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAppDeleteRequest() {\r\n    return { id: \"\", record_deletion: undefined };\r\n}\r\nconst AppDeleteRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.record_deletion !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.record_deletion }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAppDeleteRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.record_deletion = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            record_deletion: isSet(object.record_deletion) ? Boolean(object.record_deletion) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.record_deletion !== undefined && (obj.record_deletion = message.record_deletion);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AppDeleteRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAppDeleteRequest();\r\n        message.id = object.id ?? \"\";\r\n        message.record_deletion = object.record_deletion ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAppList() {\r\n    return { apps: [], total_count: 0, next_cursor: \"\" };\r\n}\r\nconst AppList = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        for (const v of message.apps) {\r\n            App.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.total_count !== 0) {\r\n            writer.uint32(16).int32(message.total_count);\r\n        }\r\n        if (message.next_cursor !== \"\") {\r\n            writer.uint32(26).string(message.next_cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAppList();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.apps.push(App.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.total_count = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.next_cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            apps: Array.isArray(object?.apps) ? object.apps.map((e) => App.fromJSON(e)) : [],\r\n            total_count: isSet(object.total_count) ? Number(object.total_count) : 0,\r\n            next_cursor: isSet(object.next_cursor) ? String(object.next_cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.apps) {\r\n            obj.apps = message.apps.map((e) => e ? App.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.apps = [];\r\n        }\r\n        message.total_count !== undefined && (obj.total_count = Math.round(message.total_count));\r\n        message.next_cursor !== undefined && (obj.next_cursor = message.next_cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AppList.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAppList();\r\n        message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];\r\n        message.total_count = object.total_count ?? 0;\r\n        message.next_cursor = object.next_cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAddAppRequest() {\r\n    return { appname: \"\", token: \"\", creator_id: \"\", role: 0 };\r\n}\r\nconst AddAppRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.appname !== \"\") {\r\n            writer.uint32(10).string(message.appname);\r\n        }\r\n        if (message.token !== \"\") {\r\n            writer.uint32(18).string(message.token);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(26).string(message.creator_id);\r\n        }\r\n        if (message.role !== 0) {\r\n            writer.uint32(32).int32(message.role);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAddAppRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.appname = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.role = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            appname: isSet(object.appname) ? String(object.appname) : \"\",\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            role: isSet(object.role) ? Number(object.role) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.appname !== undefined && (obj.appname = message.appname);\r\n        message.token !== undefined && (obj.token = message.token);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.role !== undefined && (obj.role = Math.round(message.role));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AddAppRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAddAppRequest();\r\n        message.appname = object.appname ?? \"\";\r\n        message.token = object.token ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.role = object.role ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseListAppsRequest() {\r\n    return { filter: \"\", tombstones: false, cursor: \"\" };\r\n}\r\nconst ListAppsRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.filter !== \"\") {\r\n            writer.uint32(10).string(message.filter);\r\n        }\r\n        if (message.tombstones === true) {\r\n            writer.uint32(16).bool(message.tombstones);\r\n        }\r\n        if (message.cursor !== \"\") {\r\n            writer.uint32(26).string(message.cursor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseListAppsRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.filter = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.tombstones = reader.bool();\r\n                    break;\r\n                case 3:\r\n                    message.cursor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            filter: isSet(object.filter) ? String(object.filter) : \"\",\r\n            tombstones: isSet(object.tombstones) ? Boolean(object.tombstones) : false,\r\n            cursor: isSet(object.cursor) ? String(object.cursor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.filter !== undefined && (obj.filter = message.filter);\r\n        message.tombstones !== undefined && (obj.tombstones = message.tombstones);\r\n        message.cursor !== undefined && (obj.cursor = message.cursor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ListAppsRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseListAppsRequest();\r\n        message.filter = object.filter ?? \"\";\r\n        message.tombstones = object.tombstones ?? false;\r\n        message.cursor = object.cursor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUpdateAppRequest() {\r\n    return { id: \"\", appname: undefined, metadata: undefined, applogo: undefined, token: undefined };\r\n}\r\nconst UpdateAppRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.appname !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.appname }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.metadata !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.metadata }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.applogo !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.applogo }, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.token !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.token }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUpdateAppRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.appname = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.metadata = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.applogo = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 5:\r\n                    message.token = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            appname: isSet(object.appname) ? String(object.appname) : undefined,\r\n            metadata: isSet(object.metadata) ? String(object.metadata) : undefined,\r\n            applogo: isSet(object.applogo) ? String(object.applogo) : undefined,\r\n            token: isSet(object.token) ? String(object.token) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.appname !== undefined && (obj.appname = message.appname);\r\n        message.metadata !== undefined && (obj.metadata = message.metadata);\r\n        message.applogo !== undefined && (obj.applogo = message.applogo);\r\n        message.token !== undefined && (obj.token = message.token);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UpdateAppRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUpdateAppRequest();\r\n        message.id = object.id ?? \"\";\r\n        message.appname = object.appname ?? undefined;\r\n        message.metadata = object.metadata ?? undefined;\r\n        message.applogo = object.applogo ?? undefined;\r\n        message.token = object.token ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAppId() {\r\n    return { id: \"\" };\r\n}\r\nconst AppId = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAppId();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AppId.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAppId();\r\n        message.id = object.id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAppClan() {\r\n    return { app_id: \"\", clan_id: \"\" };\r\n}\r\nconst AppClan = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.app_id !== \"\") {\r\n            writer.uint32(10).string(message.app_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAppClan();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.app_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            app_id: isSet(object.app_id) ? String(object.app_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.app_id !== undefined && (obj.app_id = message.app_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AppClan.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAppClan();\r\n        message.app_id = object.app_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAuthenticateRequest() {\r\n    return { account: undefined };\r\n}\r\nconst AuthenticateRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.account !== undefined) {\r\n            AccountApp.encode(message.account, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAuthenticateRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.account = AccountApp.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { account: isSet(object.account) ? AccountApp.fromJSON(object.account) : undefined };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.account !== undefined && (obj.account = message.account ? AccountApp.toJSON(message.account) : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AuthenticateRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAuthenticateRequest();\r\n        message.account = (object.account !== undefined && object.account !== null)\r\n            ? AccountApp.fromPartial(object.account)\r\n            : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountApp() {\r\n    return { appid: \"\", appname: \"\", token: \"\", vars: {} };\r\n}\r\nconst AccountApp = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.appid !== \"\") {\r\n            writer.uint32(10).string(message.appid);\r\n        }\r\n        if (message.appname !== \"\") {\r\n            writer.uint32(18).string(message.appname);\r\n        }\r\n        if (message.token !== \"\") {\r\n            writer.uint32(26).string(message.token);\r\n        }\r\n        Object.entries(message.vars).forEach(([key, value]) => {\r\n            AccountApp_VarsEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountApp();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.appid = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.appname = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.token = reader.string();\r\n                    break;\r\n                case 4:\r\n                    const entry4 = AccountApp_VarsEntry.decode(reader, reader.uint32());\r\n                    if (entry4.value !== undefined) {\r\n                        message.vars[entry4.key] = entry4.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            appid: isSet(object.appid) ? String(object.appid) : \"\",\r\n            appname: isSet(object.appname) ? String(object.appname) : \"\",\r\n            token: isSet(object.token) ? String(object.token) : \"\",\r\n            vars: isObject(object.vars)\r\n                ? Object.entries(object.vars).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.appid !== undefined && (obj.appid = message.appid);\r\n        message.appname !== undefined && (obj.appname = message.appname);\r\n        message.token !== undefined && (obj.token = message.token);\r\n        obj.vars = {};\r\n        if (message.vars) {\r\n            Object.entries(message.vars).forEach(([k, v]) => {\r\n                obj.vars[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountApp.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountApp();\r\n        message.appid = object.appid ?? \"\";\r\n        message.appname = object.appname ?? \"\";\r\n        message.token = object.token ?? \"\";\r\n        message.vars = Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAccountApp_VarsEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst AccountApp_VarsEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAccountApp_VarsEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AccountApp_VarsEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAccountApp_VarsEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteChannelMessagesRequest() {\r\n    return { before: undefined, ids: [] };\r\n}\r\nconst DeleteChannelMessagesRequest = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.before !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.before), writer.uint32(10).fork()).ldelim();\r\n        }\r\n        for (const v of message.ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteChannelMessagesRequest();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.before = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 2:\r\n                    message.ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            before: isSet(object.before) ? fromJsonTimestamp(object.before) : undefined,\r\n            ids: Array.isArray(object?.ids) ? object.ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.before !== undefined && (obj.before = message.before.toISOString());\r\n        if (message.ids) {\r\n            obj.ids = message.ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteChannelMessagesRequest.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteChannelMessagesRequest();\r\n        message.before = object.before ?? undefined;\r\n        message.ids = object.ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseDeleteChannelMessagesResponse() {\r\n    return { total: 0 };\r\n}\r\nconst DeleteChannelMessagesResponse = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.total !== 0) {\r\n            writer.uint32(8).int64(message.total);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDeleteChannelMessagesResponse();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.total = longToNumber(reader.int64());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { total: isSet(object.total) ? Number(object.total) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.total !== undefined && (obj.total = Math.round(message.total));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DeleteChannelMessagesResponse.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDeleteChannelMessagesResponse();\r\n        message.total = object.total ?? 0;\r\n        return message;\r\n    },\r\n};\r\nvar tsProtoGlobalThis = (() => {\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof __webpack_require__.g !== \"undefined\") {\r\n        return __webpack_require__.g;\r\n    }\r\n    throw \"Unable to locate global object\";\r\n})();\r\nfunction toTimestamp(date) {\r\n    const seconds = date.getTime() / 1_000;\r\n    const nanos = (date.getTime() % 1_000) * 1_000_000;\r\n    return { seconds, nanos };\r\n}\r\nfunction fromTimestamp(t) {\r\n    let millis = t.seconds * 1_000;\r\n    millis += t.nanos / 1_000_000;\r\n    return new Date(millis);\r\n}\r\nfunction fromJsonTimestamp(o) {\r\n    if (o instanceof Date) {\r\n        return o;\r\n    }\r\n    else if (typeof o === \"string\") {\r\n        return new Date(o);\r\n    }\r\n    else {\r\n        return fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.fromJSON(o));\r\n    }\r\n}\r\nfunction longToNumber(long) {\r\n    if (long.gt(Number.MAX_SAFE_INTEGER)) {\r\n        throw new tsProtoGlobalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\r\n    }\r\n    return long.toNumber();\r\n}\r\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== (long__WEBPACK_IMPORTED_MODULE_0___default())) {\r\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = (long__WEBPACK_IMPORTED_MODULE_0___default());\r\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\r\n}\r\nfunction isObject(value) {\r\n    return typeof value === \"object\" && value !== null;\r\n}\r\nfunction isSet(value) {\r\n    return value !== null && value !== undefined;\r\n}\r\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/api/api.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/client.js":
/*!***************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/client.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MezonClient: () => (/* binding */ MezonClient)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./node_modules/mezon-sdk/dist/esm/api.js\");\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./session */ \"./node_modules/mezon-sdk/dist/esm/session.js\");\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket */ \"./node_modules/mezon-sdk/dist/esm/socket.js\");\n/* harmony import */ var _web_socket_adapter_pb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./web_socket_adapter_pb */ \"./node_modules/mezon-sdk/dist/esm/web_socket_adapter_pb.js\");\n/**\r\n * Copyright 2020 The Nakama Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n\r\n\r\nconst DEFAULT_HOST = \"127.0.0.1\"; //\"mezon.vn\";\r\nconst DEFAULT_PORT = \"7350\"; //\"7305\";\r\nconst DEFAULT_API_KEY = \"defaultkey\";\r\nconst DEFAULT_TIMEOUT_MS = 7000;\r\nconst DEFAULT_EXPIRED_TIMESPAN_MS = 5 * 60 * 1000;\r\n/** A client for Mezon server. */\r\nclass MezonClient {\r\n    apiKey;\r\n    host;\r\n    port;\r\n    useSSL;\r\n    timeout;\r\n    autoRefreshSession;\r\n    /** The expired timespan used to check session lifetime. */\r\n    expiredTimespanMs = DEFAULT_EXPIRED_TIMESPAN_MS;\r\n    /** The low level API client for Nakama server. */\r\n    apiClient;\r\n    /** the socket */\r\n    socket;\r\n    constructor(apiKey = DEFAULT_API_KEY, host = DEFAULT_HOST, port = DEFAULT_PORT, useSSL = false, timeout = DEFAULT_TIMEOUT_MS, autoRefreshSession = true) {\r\n        this.apiKey = apiKey;\r\n        this.host = host;\r\n        this.port = port;\r\n        this.useSSL = useSSL;\r\n        this.timeout = timeout;\r\n        this.autoRefreshSession = autoRefreshSession;\r\n        const scheme = (useSSL) ? \"https://\" : \"http://\";\r\n        const basePath = `${scheme}${host}:${port}`;\r\n        this.apiClient = new _api__WEBPACK_IMPORTED_MODULE_0__.MezonApi(apiKey, basePath, timeout);\r\n        this.socket = this.createSocket(this.useSSL, false, new _web_socket_adapter_pb__WEBPACK_IMPORTED_MODULE_3__.WebSocketAdapterPb());\r\n    }\r\n    async sendMessage(clan_id, channel_id, mode, msg, mentions, attachments, ref) {\r\n        const msgACK = await this.socket.writeChatMessage(clan_id, channel_id, mode, msg, mentions, attachments, ref);\r\n        return Promise.resolve(msgACK.channel_id === channel_id);\r\n    }\r\n    /** Authenticate a user with an ID against the server. */\r\n    async authenticate() {\r\n        return this.apiClient.mezonAuthenticate(this.apiKey, \"\", {\r\n            account: {\r\n                token: this.apiKey,\r\n            }\r\n        }).then(async (apiSession) => {\r\n            const sockSession = new _session__WEBPACK_IMPORTED_MODULE_1__.Session(apiSession.token || \"\", apiSession.refresh_token || \"\");\r\n            const session = await this.socket.connect(sockSession, false);\r\n            if (!session) {\r\n                return Promise.resolve(\"error authenticate\");\r\n            }\r\n            const clans = await this.apiClient.listClanDescs(session.token);\r\n            clans.clandesc?.forEach(async (clan) => {\r\n                await this.socket.joinClanChat(clan.clan_id || '');\r\n            });\r\n            // join direct message\r\n            await this.socket.joinClanChat(\"0\");\r\n            this.socket.onchannelmessage = this.onchannelmessage;\r\n            this.socket.ondisconnect = this.ondisconnect;\r\n            this.socket.onerror = this.onerror;\r\n            this.socket.onmessagereaction = this.onmessagereaction;\r\n            this.socket.onuserchannelremoved = this.onuserchannelremoved;\r\n            this.socket.onuserclanremoved = this.onuserclanremoved;\r\n            this.socket.onuserchanneladded = this.onuserchanneladded;\r\n            this.socket.onchannelcreated = this.onchannelcreated;\r\n            this.socket.onchanneldeleted = this.onchanneldeleted;\r\n            this.socket.onchannelupdated = this.onchannelupdated;\r\n            this.socket.onheartbeattimeout = this.onheartbeattimeout;\r\n            return Promise.resolve(\"connect successful\");\r\n        });\r\n    }\r\n    /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */\r\n    async sessionRefresh(session) {\r\n        const request = {\r\n            \"refresh_token\": session.refresh_token,\r\n        };\r\n        return this.apiClient.mezonAuthenticateRefresh(this.apiKey, \"\", request).then((apiSession) => {\r\n            return Promise.resolve(new _session__WEBPACK_IMPORTED_MODULE_1__.Session(apiSession.token || \"\", apiSession.refresh_token || \"\"));\r\n        });\r\n    }\r\n    /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */\r\n    async logout(session) {\r\n        const request = {\r\n            \"token\": session.token,\r\n            \"refresh_token\": session.refresh_token\r\n        };\r\n        return this.apiClient.mezonAuthenticateLogout(session.token, request).then((response) => {\r\n            return Promise.resolve(response !== undefined);\r\n        });\r\n    }\r\n    /** A socket created with the client's configuration. */\r\n    createSocket(useSSL = false, verbose = false, adapter = new _web_socket_adapter_pb__WEBPACK_IMPORTED_MODULE_3__.WebSocketAdapterPb(), sendTimeoutMs = _socket__WEBPACK_IMPORTED_MODULE_2__.DefaultSocket.DefaultSendTimeoutMs) {\r\n        return new _socket__WEBPACK_IMPORTED_MODULE_2__.DefaultSocket(this.host, this.port, useSSL, verbose, adapter, sendTimeoutMs);\r\n    }\r\n    onerror(evt) {\r\n        console.log(evt);\r\n    }\r\n    onchannelmessage(message) {\r\n        console.log(message);\r\n    }\r\n    onmessagereaction(messagereaction) {\r\n        console.log(messagereaction);\r\n    }\r\n    ondisconnect(e) {\r\n        console.log(e);\r\n    }\r\n    onuserchanneladded(user) {\r\n        console.log(user);\r\n    }\r\n    onuserchannelremoved(user) {\r\n        console.log(user);\r\n    }\r\n    onuserclanremoved(user) {\r\n        console.log(user);\r\n    }\r\n    onchannelcreated(channelCreated) {\r\n        console.log(channelCreated);\r\n    }\r\n    onchanneldeleted(channelDeleted) {\r\n        console.log(channelDeleted);\r\n    }\r\n    onchannelupdated(channelUpdated) {\r\n        console.log(channelUpdated);\r\n    }\r\n    onheartbeattimeout() {\r\n        console.log(\"Heartbeat timeout.\");\r\n    }\r\n}\r\n;\r\n//# sourceMappingURL=client.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/client.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/google/protobuf/timestamp.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/google/protobuf/timestamp.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"./node_modules/long/src/long.js\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\r\n\r\n\r\nconst protobufPackage = \"google.protobuf\";\r\nfunction createBaseTimestamp() {\r\n    return { seconds: 0, nanos: 0 };\r\n}\r\nconst Timestamp = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.seconds !== 0) {\r\n            writer.uint32(8).int64(message.seconds);\r\n        }\r\n        if (message.nanos !== 0) {\r\n            writer.uint32(16).int32(message.nanos);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseTimestamp();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.seconds = longToNumber(reader.int64());\r\n                    break;\r\n                case 2:\r\n                    message.nanos = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            seconds: isSet(object.seconds) ? Number(object.seconds) : 0,\r\n            nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.seconds !== undefined && (obj.seconds = Math.round(message.seconds));\r\n        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Timestamp.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseTimestamp();\r\n        message.seconds = object.seconds ?? 0;\r\n        message.nanos = object.nanos ?? 0;\r\n        return message;\r\n    },\r\n};\r\nvar tsProtoGlobalThis = (() => {\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof __webpack_require__.g !== \"undefined\") {\r\n        return __webpack_require__.g;\r\n    }\r\n    throw \"Unable to locate global object\";\r\n})();\r\nfunction longToNumber(long) {\r\n    if (long.gt(Number.MAX_SAFE_INTEGER)) {\r\n        throw new tsProtoGlobalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\r\n    }\r\n    return long.toNumber();\r\n}\r\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== (long__WEBPACK_IMPORTED_MODULE_0___default())) {\r\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = (long__WEBPACK_IMPORTED_MODULE_0___default());\r\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\r\n}\r\nfunction isSet(value) {\r\n    return value !== null && value !== undefined;\r\n}\r\n//# sourceMappingURL=timestamp.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/google/protobuf/timestamp.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/google/protobuf/wrappers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/google/protobuf/wrappers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoolValue: () => (/* binding */ BoolValue),\n/* harmony export */   BytesValue: () => (/* binding */ BytesValue),\n/* harmony export */   DoubleValue: () => (/* binding */ DoubleValue),\n/* harmony export */   FloatValue: () => (/* binding */ FloatValue),\n/* harmony export */   Int32Value: () => (/* binding */ Int32Value),\n/* harmony export */   Int64Value: () => (/* binding */ Int64Value),\n/* harmony export */   StringValue: () => (/* binding */ StringValue),\n/* harmony export */   UInt32Value: () => (/* binding */ UInt32Value),\n/* harmony export */   UInt64Value: () => (/* binding */ UInt64Value),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"./node_modules/long/src/long.js\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* eslint-disable */\r\n\r\n\r\nconst protobufPackage = \"google.protobuf\";\r\nfunction createBaseDoubleValue() {\r\n    return { value: 0 };\r\n}\r\nconst DoubleValue = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== 0) {\r\n            writer.uint32(9).double(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseDoubleValue();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.double();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Number(object.value) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return DoubleValue.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseDoubleValue();\r\n        message.value = object.value ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseFloatValue() {\r\n    return { value: 0 };\r\n}\r\nconst FloatValue = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== 0) {\r\n            writer.uint32(13).float(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseFloatValue();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.float();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Number(object.value) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return FloatValue.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseFloatValue();\r\n        message.value = object.value ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseInt64Value() {\r\n    return { value: 0 };\r\n}\r\nconst Int64Value = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== 0) {\r\n            writer.uint32(8).int64(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseInt64Value();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = longToNumber(reader.int64());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Number(object.value) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = Math.round(message.value));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Int64Value.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseInt64Value();\r\n        message.value = object.value ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUInt64Value() {\r\n    return { value: 0 };\r\n}\r\nconst UInt64Value = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== 0) {\r\n            writer.uint32(8).uint64(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUInt64Value();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = longToNumber(reader.uint64());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Number(object.value) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = Math.round(message.value));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UInt64Value.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUInt64Value();\r\n        message.value = object.value ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseInt32Value() {\r\n    return { value: 0 };\r\n}\r\nconst Int32Value = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== 0) {\r\n            writer.uint32(8).int32(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseInt32Value();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Number(object.value) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = Math.round(message.value));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Int32Value.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseInt32Value();\r\n        message.value = object.value ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUInt32Value() {\r\n    return { value: 0 };\r\n}\r\nconst UInt32Value = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== 0) {\r\n            writer.uint32(8).uint32(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUInt32Value();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.uint32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Number(object.value) : 0 };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = Math.round(message.value));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UInt32Value.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUInt32Value();\r\n        message.value = object.value ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseBoolValue() {\r\n    return { value: false };\r\n}\r\nconst BoolValue = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value === true) {\r\n            writer.uint32(8).bool(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseBoolValue();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? Boolean(object.value) : false };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return BoolValue.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseBoolValue();\r\n        message.value = object.value ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStringValue() {\r\n    return { value: \"\" };\r\n}\r\nconst StringValue = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value !== \"\") {\r\n            writer.uint32(10).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStringValue();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StringValue.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStringValue();\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseBytesValue() {\r\n    return { value: new Uint8Array() };\r\n}\r\nconst BytesValue = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Writer.create()) {\r\n        if (message.value.length !== 0) {\r\n            writer.uint32(10).bytes(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseBytesValue();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.value = reader.bytes();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array() };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.value !== undefined &&\r\n            (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return BytesValue.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseBytesValue();\r\n        message.value = object.value ?? new Uint8Array();\r\n        return message;\r\n    },\r\n};\r\nvar tsProtoGlobalThis = (() => {\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof __webpack_require__.g !== \"undefined\") {\r\n        return __webpack_require__.g;\r\n    }\r\n    throw \"Unable to locate global object\";\r\n})();\r\nfunction bytesFromBase64(b64) {\r\n    if (tsProtoGlobalThis.Buffer) {\r\n        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, \"base64\"));\r\n    }\r\n    else {\r\n        const bin = tsProtoGlobalThis.atob(b64);\r\n        const arr = new Uint8Array(bin.length);\r\n        for (let i = 0; i < bin.length; ++i) {\r\n            arr[i] = bin.charCodeAt(i);\r\n        }\r\n        return arr;\r\n    }\r\n}\r\nfunction base64FromBytes(arr) {\r\n    if (tsProtoGlobalThis.Buffer) {\r\n        return tsProtoGlobalThis.Buffer.from(arr).toString(\"base64\");\r\n    }\r\n    else {\r\n        const bin = [];\r\n        arr.forEach((byte) => {\r\n            bin.push(String.fromCharCode(byte));\r\n        });\r\n        return tsProtoGlobalThis.btoa(bin.join(\"\"));\r\n    }\r\n}\r\nfunction longToNumber(long) {\r\n    if (long.gt(Number.MAX_SAFE_INTEGER)) {\r\n        throw new tsProtoGlobalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\r\n    }\r\n    return long.toNumber();\r\n}\r\nif ((protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long !== (long__WEBPACK_IMPORTED_MODULE_0___default())) {\r\n    (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().util).Long = (long__WEBPACK_IMPORTED_MODULE_0___default());\r\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default().configure();\r\n}\r\nfunction isSet(value) {\r\n    return value !== null && value !== undefined;\r\n}\r\n//# sourceMappingURL=wrappers.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/google/protobuf/wrappers.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MezonClient: () => (/* reexport safe */ _client__WEBPACK_IMPORTED_MODULE_0__.MezonClient)\n/* harmony export */ });\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client */ \"./node_modules/mezon-sdk/dist/esm/client.js\");\n/**\r\n * Copyright 2020 The Nakama Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/rtapi/realtime.js":
/*!***********************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/rtapi/realtime.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddUsers: () => (/* binding */ AddUsers),\n/* harmony export */   Channel: () => (/* binding */ Channel),\n/* harmony export */   ChannelCreatedEvent: () => (/* binding */ ChannelCreatedEvent),\n/* harmony export */   ChannelDeletedEvent: () => (/* binding */ ChannelDeletedEvent),\n/* harmony export */   ChannelDescListEvent: () => (/* binding */ ChannelDescListEvent),\n/* harmony export */   ChannelDescription: () => (/* binding */ ChannelDescription),\n/* harmony export */   ChannelJoin: () => (/* binding */ ChannelJoin),\n/* harmony export */   ChannelLeave: () => (/* binding */ ChannelLeave),\n/* harmony export */   ChannelMessageAck: () => (/* binding */ ChannelMessageAck),\n/* harmony export */   ChannelMessageRemove: () => (/* binding */ ChannelMessageRemove),\n/* harmony export */   ChannelMessageSend: () => (/* binding */ ChannelMessageSend),\n/* harmony export */   ChannelMessageUpdate: () => (/* binding */ ChannelMessageUpdate),\n/* harmony export */   ChannelPresenceEvent: () => (/* binding */ ChannelPresenceEvent),\n/* harmony export */   ChannelUpdatedEvent: () => (/* binding */ ChannelUpdatedEvent),\n/* harmony export */   ClanEmoji: () => (/* binding */ ClanEmoji),\n/* harmony export */   ClanJoin: () => (/* binding */ ClanJoin),\n/* harmony export */   ClanNameExistedEvent: () => (/* binding */ ClanNameExistedEvent),\n/* harmony export */   ClanProfileUpdatedEvent: () => (/* binding */ ClanProfileUpdatedEvent),\n/* harmony export */   ClanSticker: () => (/* binding */ ClanSticker),\n/* harmony export */   ClanUpdatedEvent: () => (/* binding */ ClanUpdatedEvent),\n/* harmony export */   CustomStatusEvent: () => (/* binding */ CustomStatusEvent),\n/* harmony export */   EmojiListedEvent: () => (/* binding */ EmojiListedEvent),\n/* harmony export */   Envelope: () => (/* binding */ Envelope),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   Error_Code: () => (/* binding */ Error_Code),\n/* harmony export */   Error_ContextEntry: () => (/* binding */ Error_ContextEntry),\n/* harmony export */   FCMTokens: () => (/* binding */ FCMTokens),\n/* harmony export */   HashtagDm: () => (/* binding */ HashtagDm),\n/* harmony export */   HashtagDmListEvent: () => (/* binding */ HashtagDmListEvent),\n/* harmony export */   LastPinMessageEvent: () => (/* binding */ LastPinMessageEvent),\n/* harmony export */   LastSeenMessageEvent: () => (/* binding */ LastSeenMessageEvent),\n/* harmony export */   MessageTypingEvent: () => (/* binding */ MessageTypingEvent),\n/* harmony export */   NotifiReactMessage: () => (/* binding */ NotifiReactMessage),\n/* harmony export */   NotifiReactMessageEvent: () => (/* binding */ NotifiReactMessageEvent),\n/* harmony export */   NotificationCategorySettingEvent: () => (/* binding */ NotificationCategorySettingEvent),\n/* harmony export */   NotificationChannelSettingEvent: () => (/* binding */ NotificationChannelSettingEvent),\n/* harmony export */   NotificationClanSettingEvent: () => (/* binding */ NotificationClanSettingEvent),\n/* harmony export */   NotificationSetting: () => (/* binding */ NotificationSetting),\n/* harmony export */   NotificationUserChannel: () => (/* binding */ NotificationUserChannel),\n/* harmony export */   Notifications: () => (/* binding */ Notifications),\n/* harmony export */   PermissionRoleChannel: () => (/* binding */ PermissionRoleChannel),\n/* harmony export */   PermissionRoleChannelListEvent: () => (/* binding */ PermissionRoleChannelListEvent),\n/* harmony export */   Ping: () => (/* binding */ Ping),\n/* harmony export */   Pong: () => (/* binding */ Pong),\n/* harmony export */   Status: () => (/* binding */ Status),\n/* harmony export */   StatusFollow: () => (/* binding */ StatusFollow),\n/* harmony export */   StatusPresenceEvent: () => (/* binding */ StatusPresenceEvent),\n/* harmony export */   StatusUnfollow: () => (/* binding */ StatusUnfollow),\n/* harmony export */   StatusUpdate: () => (/* binding */ StatusUpdate),\n/* harmony export */   Stream: () => (/* binding */ Stream),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   StreamPresenceEvent: () => (/* binding */ StreamPresenceEvent),\n/* harmony export */   StrickerListedEvent: () => (/* binding */ StrickerListedEvent),\n/* harmony export */   UserChannelAdded: () => (/* binding */ UserChannelAdded),\n/* harmony export */   UserChannelRemoved: () => (/* binding */ UserChannelRemoved),\n/* harmony export */   UserClanRemoved: () => (/* binding */ UserClanRemoved),\n/* harmony export */   UserPresence: () => (/* binding */ UserPresence),\n/* harmony export */   UserProfileRedis: () => (/* binding */ UserProfileRedis),\n/* harmony export */   UserProfileUpdatedEvent: () => (/* binding */ UserProfileUpdatedEvent),\n/* harmony export */   VoiceEndedEvent: () => (/* binding */ VoiceEndedEvent),\n/* harmony export */   VoiceJoinedEvent: () => (/* binding */ VoiceJoinedEvent),\n/* harmony export */   VoiceLeavedEvent: () => (/* binding */ VoiceLeavedEvent),\n/* harmony export */   VoiceStartedEvent: () => (/* binding */ VoiceStartedEvent),\n/* harmony export */   error_CodeFromJSON: () => (/* binding */ error_CodeFromJSON),\n/* harmony export */   error_CodeToJSON: () => (/* binding */ error_CodeToJSON),\n/* harmony export */   protobufPackage: () => (/* binding */ protobufPackage)\n/* harmony export */ });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _api_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/api */ \"./node_modules/mezon-sdk/dist/esm/api/api.js\");\n/* harmony import */ var _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../google/protobuf/timestamp */ \"./node_modules/mezon-sdk/dist/esm/google/protobuf/timestamp.js\");\n/* harmony import */ var _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../google/protobuf/wrappers */ \"./node_modules/mezon-sdk/dist/esm/google/protobuf/wrappers.js\");\n/* eslint-disable */\r\n\r\n\r\n\r\n\r\nconst protobufPackage = \"mezon.realtime\";\r\n/** The selection of possible error codes. */\r\nvar Error_Code;\r\n(function (Error_Code) {\r\n    /** RUNTIME_EXCEPTION - An unexpected result from the server. */\r\n    Error_Code[Error_Code[\"RUNTIME_EXCEPTION\"] = 0] = \"RUNTIME_EXCEPTION\";\r\n    /** UNRECOGNIZED_PAYLOAD - The server received a message which is not recognised. */\r\n    Error_Code[Error_Code[\"UNRECOGNIZED_PAYLOAD\"] = 1] = \"UNRECOGNIZED_PAYLOAD\";\r\n    /** MISSING_PAYLOAD - A message was expected but contains no content. */\r\n    Error_Code[Error_Code[\"MISSING_PAYLOAD\"] = 2] = \"MISSING_PAYLOAD\";\r\n    /** BAD_INPUT - Fields in the message have an invalid format. */\r\n    Error_Code[Error_Code[\"BAD_INPUT\"] = 3] = \"BAD_INPUT\";\r\n    /** MATCH_NOT_FOUND - The match id was not found. */\r\n    Error_Code[Error_Code[\"MATCH_NOT_FOUND\"] = 4] = \"MATCH_NOT_FOUND\";\r\n    /** MATCH_JOIN_REJECTED - The match join was rejected. */\r\n    Error_Code[Error_Code[\"MATCH_JOIN_REJECTED\"] = 5] = \"MATCH_JOIN_REJECTED\";\r\n    /** RUNTIME_FUNCTION_NOT_FOUND - The runtime function does not exist on the server. */\r\n    Error_Code[Error_Code[\"RUNTIME_FUNCTION_NOT_FOUND\"] = 6] = \"RUNTIME_FUNCTION_NOT_FOUND\";\r\n    /** RUNTIME_FUNCTION_EXCEPTION - The runtime function executed with an error. */\r\n    Error_Code[Error_Code[\"RUNTIME_FUNCTION_EXCEPTION\"] = 7] = \"RUNTIME_FUNCTION_EXCEPTION\";\r\n    Error_Code[Error_Code[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\r\n})(Error_Code || (Error_Code = {}));\r\nfunction error_CodeFromJSON(object) {\r\n    switch (object) {\r\n        case 0:\r\n        case \"RUNTIME_EXCEPTION\":\r\n            return Error_Code.RUNTIME_EXCEPTION;\r\n        case 1:\r\n        case \"UNRECOGNIZED_PAYLOAD\":\r\n            return Error_Code.UNRECOGNIZED_PAYLOAD;\r\n        case 2:\r\n        case \"MISSING_PAYLOAD\":\r\n            return Error_Code.MISSING_PAYLOAD;\r\n        case 3:\r\n        case \"BAD_INPUT\":\r\n            return Error_Code.BAD_INPUT;\r\n        case 4:\r\n        case \"MATCH_NOT_FOUND\":\r\n            return Error_Code.MATCH_NOT_FOUND;\r\n        case 5:\r\n        case \"MATCH_JOIN_REJECTED\":\r\n            return Error_Code.MATCH_JOIN_REJECTED;\r\n        case 6:\r\n        case \"RUNTIME_FUNCTION_NOT_FOUND\":\r\n            return Error_Code.RUNTIME_FUNCTION_NOT_FOUND;\r\n        case 7:\r\n        case \"RUNTIME_FUNCTION_EXCEPTION\":\r\n            return Error_Code.RUNTIME_FUNCTION_EXCEPTION;\r\n        case -1:\r\n        case \"UNRECOGNIZED\":\r\n        default:\r\n            return Error_Code.UNRECOGNIZED;\r\n    }\r\n}\r\nfunction error_CodeToJSON(object) {\r\n    switch (object) {\r\n        case Error_Code.RUNTIME_EXCEPTION:\r\n            return \"RUNTIME_EXCEPTION\";\r\n        case Error_Code.UNRECOGNIZED_PAYLOAD:\r\n            return \"UNRECOGNIZED_PAYLOAD\";\r\n        case Error_Code.MISSING_PAYLOAD:\r\n            return \"MISSING_PAYLOAD\";\r\n        case Error_Code.BAD_INPUT:\r\n            return \"BAD_INPUT\";\r\n        case Error_Code.MATCH_NOT_FOUND:\r\n            return \"MATCH_NOT_FOUND\";\r\n        case Error_Code.MATCH_JOIN_REJECTED:\r\n            return \"MATCH_JOIN_REJECTED\";\r\n        case Error_Code.RUNTIME_FUNCTION_NOT_FOUND:\r\n            return \"RUNTIME_FUNCTION_NOT_FOUND\";\r\n        case Error_Code.RUNTIME_FUNCTION_EXCEPTION:\r\n            return \"RUNTIME_FUNCTION_EXCEPTION\";\r\n        case Error_Code.UNRECOGNIZED:\r\n        default:\r\n            return \"UNRECOGNIZED\";\r\n    }\r\n}\r\nfunction createBaseEnvelope() {\r\n    return {\r\n        cid: \"\",\r\n        channel: undefined,\r\n        clan_join: undefined,\r\n        channel_join: undefined,\r\n        channel_leave: undefined,\r\n        channel_message: undefined,\r\n        channel_message_ack: undefined,\r\n        channel_message_send: undefined,\r\n        channel_message_update: undefined,\r\n        channel_message_remove: undefined,\r\n        channel_presence_event: undefined,\r\n        error: undefined,\r\n        notifications: undefined,\r\n        rpc: undefined,\r\n        status: undefined,\r\n        status_follow: undefined,\r\n        status_presence_event: undefined,\r\n        status_unfollow: undefined,\r\n        status_update: undefined,\r\n        stream_data: undefined,\r\n        stream_presence_event: undefined,\r\n        ping: undefined,\r\n        pong: undefined,\r\n        message_typing_event: undefined,\r\n        last_seen_message_event: undefined,\r\n        message_reaction_event: undefined,\r\n        voice_joined_event: undefined,\r\n        voice_leaved_event: undefined,\r\n        voice_started_event: undefined,\r\n        voice_ended_event: undefined,\r\n        channel_created_event: undefined,\r\n        channel_deleted_event: undefined,\r\n        channel_updated_event: undefined,\r\n        last_pin_message_event: undefined,\r\n        custom_status_event: undefined,\r\n        user_channel_added_event: undefined,\r\n        user_channel_removed_event: undefined,\r\n        user_clan_removed_event: undefined,\r\n        clan_updated_event: undefined,\r\n        clan_profile_updated_event: undefined,\r\n        clan_name_existed_event: undefined,\r\n        user_profile_updated_event: undefined,\r\n        emojis_listed_event: undefined,\r\n        sticker_listed_event: undefined,\r\n        channel_desc_list_event: undefined,\r\n        hashtag_dm_list_event: undefined,\r\n        notification_channel_setting_event: undefined,\r\n        notification_category_setting_event: undefined,\r\n        notification_clan_setting_event: undefined,\r\n        notifi_react_message_event: undefined,\r\n        permission_role_channel_list_event: undefined,\r\n    };\r\n}\r\nconst Envelope = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.cid !== \"\") {\r\n            writer.uint32(10).string(message.cid);\r\n        }\r\n        if (message.channel !== undefined) {\r\n            Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.clan_join !== undefined) {\r\n            ClanJoin.encode(message.clan_join, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.channel_join !== undefined) {\r\n            ChannelJoin.encode(message.channel_join, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        if (message.channel_leave !== undefined) {\r\n            ChannelLeave.encode(message.channel_leave, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.channel_message !== undefined) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.ChannelMessage.encode(message.channel_message, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.channel_message_ack !== undefined) {\r\n            ChannelMessageAck.encode(message.channel_message_ack, writer.uint32(58).fork()).ldelim();\r\n        }\r\n        if (message.channel_message_send !== undefined) {\r\n            ChannelMessageSend.encode(message.channel_message_send, writer.uint32(66).fork()).ldelim();\r\n        }\r\n        if (message.channel_message_update !== undefined) {\r\n            ChannelMessageUpdate.encode(message.channel_message_update, writer.uint32(74).fork()).ldelim();\r\n        }\r\n        if (message.channel_message_remove !== undefined) {\r\n            ChannelMessageRemove.encode(message.channel_message_remove, writer.uint32(82).fork()).ldelim();\r\n        }\r\n        if (message.channel_presence_event !== undefined) {\r\n            ChannelPresenceEvent.encode(message.channel_presence_event, writer.uint32(90).fork()).ldelim();\r\n        }\r\n        if (message.error !== undefined) {\r\n            Error.encode(message.error, writer.uint32(98).fork()).ldelim();\r\n        }\r\n        if (message.notifications !== undefined) {\r\n            Notifications.encode(message.notifications, writer.uint32(106).fork()).ldelim();\r\n        }\r\n        if (message.rpc !== undefined) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.Rpc.encode(message.rpc, writer.uint32(114).fork()).ldelim();\r\n        }\r\n        if (message.status !== undefined) {\r\n            Status.encode(message.status, writer.uint32(122).fork()).ldelim();\r\n        }\r\n        if (message.status_follow !== undefined) {\r\n            StatusFollow.encode(message.status_follow, writer.uint32(130).fork()).ldelim();\r\n        }\r\n        if (message.status_presence_event !== undefined) {\r\n            StatusPresenceEvent.encode(message.status_presence_event, writer.uint32(138).fork()).ldelim();\r\n        }\r\n        if (message.status_unfollow !== undefined) {\r\n            StatusUnfollow.encode(message.status_unfollow, writer.uint32(146).fork()).ldelim();\r\n        }\r\n        if (message.status_update !== undefined) {\r\n            StatusUpdate.encode(message.status_update, writer.uint32(154).fork()).ldelim();\r\n        }\r\n        if (message.stream_data !== undefined) {\r\n            StreamData.encode(message.stream_data, writer.uint32(162).fork()).ldelim();\r\n        }\r\n        if (message.stream_presence_event !== undefined) {\r\n            StreamPresenceEvent.encode(message.stream_presence_event, writer.uint32(170).fork()).ldelim();\r\n        }\r\n        if (message.ping !== undefined) {\r\n            Ping.encode(message.ping, writer.uint32(178).fork()).ldelim();\r\n        }\r\n        if (message.pong !== undefined) {\r\n            Pong.encode(message.pong, writer.uint32(186).fork()).ldelim();\r\n        }\r\n        if (message.message_typing_event !== undefined) {\r\n            MessageTypingEvent.encode(message.message_typing_event, writer.uint32(194).fork()).ldelim();\r\n        }\r\n        if (message.last_seen_message_event !== undefined) {\r\n            LastSeenMessageEvent.encode(message.last_seen_message_event, writer.uint32(202).fork()).ldelim();\r\n        }\r\n        if (message.message_reaction_event !== undefined) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageReaction.encode(message.message_reaction_event, writer.uint32(210).fork()).ldelim();\r\n        }\r\n        if (message.voice_joined_event !== undefined) {\r\n            VoiceJoinedEvent.encode(message.voice_joined_event, writer.uint32(218).fork()).ldelim();\r\n        }\r\n        if (message.voice_leaved_event !== undefined) {\r\n            VoiceLeavedEvent.encode(message.voice_leaved_event, writer.uint32(226).fork()).ldelim();\r\n        }\r\n        if (message.voice_started_event !== undefined) {\r\n            VoiceStartedEvent.encode(message.voice_started_event, writer.uint32(234).fork()).ldelim();\r\n        }\r\n        if (message.voice_ended_event !== undefined) {\r\n            VoiceEndedEvent.encode(message.voice_ended_event, writer.uint32(242).fork()).ldelim();\r\n        }\r\n        if (message.channel_created_event !== undefined) {\r\n            ChannelCreatedEvent.encode(message.channel_created_event, writer.uint32(250).fork()).ldelim();\r\n        }\r\n        if (message.channel_deleted_event !== undefined) {\r\n            ChannelDeletedEvent.encode(message.channel_deleted_event, writer.uint32(258).fork()).ldelim();\r\n        }\r\n        if (message.channel_updated_event !== undefined) {\r\n            ChannelUpdatedEvent.encode(message.channel_updated_event, writer.uint32(266).fork()).ldelim();\r\n        }\r\n        if (message.last_pin_message_event !== undefined) {\r\n            LastPinMessageEvent.encode(message.last_pin_message_event, writer.uint32(274).fork()).ldelim();\r\n        }\r\n        if (message.custom_status_event !== undefined) {\r\n            CustomStatusEvent.encode(message.custom_status_event, writer.uint32(282).fork()).ldelim();\r\n        }\r\n        if (message.user_channel_added_event !== undefined) {\r\n            UserChannelAdded.encode(message.user_channel_added_event, writer.uint32(290).fork()).ldelim();\r\n        }\r\n        if (message.user_channel_removed_event !== undefined) {\r\n            UserChannelRemoved.encode(message.user_channel_removed_event, writer.uint32(298).fork()).ldelim();\r\n        }\r\n        if (message.user_clan_removed_event !== undefined) {\r\n            UserClanRemoved.encode(message.user_clan_removed_event, writer.uint32(306).fork()).ldelim();\r\n        }\r\n        if (message.clan_updated_event !== undefined) {\r\n            ClanUpdatedEvent.encode(message.clan_updated_event, writer.uint32(314).fork()).ldelim();\r\n        }\r\n        if (message.clan_profile_updated_event !== undefined) {\r\n            ClanProfileUpdatedEvent.encode(message.clan_profile_updated_event, writer.uint32(322).fork()).ldelim();\r\n        }\r\n        if (message.clan_name_existed_event !== undefined) {\r\n            ClanNameExistedEvent.encode(message.clan_name_existed_event, writer.uint32(330).fork()).ldelim();\r\n        }\r\n        if (message.user_profile_updated_event !== undefined) {\r\n            UserProfileUpdatedEvent.encode(message.user_profile_updated_event, writer.uint32(338).fork()).ldelim();\r\n        }\r\n        if (message.emojis_listed_event !== undefined) {\r\n            EmojiListedEvent.encode(message.emojis_listed_event, writer.uint32(346).fork()).ldelim();\r\n        }\r\n        if (message.sticker_listed_event !== undefined) {\r\n            StrickerListedEvent.encode(message.sticker_listed_event, writer.uint32(354).fork()).ldelim();\r\n        }\r\n        if (message.channel_desc_list_event !== undefined) {\r\n            ChannelDescListEvent.encode(message.channel_desc_list_event, writer.uint32(362).fork()).ldelim();\r\n        }\r\n        if (message.hashtag_dm_list_event !== undefined) {\r\n            HashtagDmListEvent.encode(message.hashtag_dm_list_event, writer.uint32(370).fork()).ldelim();\r\n        }\r\n        if (message.notification_channel_setting_event !== undefined) {\r\n            NotificationChannelSettingEvent.encode(message.notification_channel_setting_event, writer.uint32(378).fork())\r\n                .ldelim();\r\n        }\r\n        if (message.notification_category_setting_event !== undefined) {\r\n            NotificationCategorySettingEvent.encode(message.notification_category_setting_event, writer.uint32(386).fork())\r\n                .ldelim();\r\n        }\r\n        if (message.notification_clan_setting_event !== undefined) {\r\n            NotificationClanSettingEvent.encode(message.notification_clan_setting_event, writer.uint32(394).fork()).ldelim();\r\n        }\r\n        if (message.notifi_react_message_event !== undefined) {\r\n            NotifiReactMessageEvent.encode(message.notifi_react_message_event, writer.uint32(402).fork()).ldelim();\r\n        }\r\n        if (message.permission_role_channel_list_event !== undefined) {\r\n            PermissionRoleChannelListEvent.encode(message.permission_role_channel_list_event, writer.uint32(410).fork())\r\n                .ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEnvelope();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.cid = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel = Channel.decode(reader, reader.uint32());\r\n                    break;\r\n                case 3:\r\n                    message.clan_join = ClanJoin.decode(reader, reader.uint32());\r\n                    break;\r\n                case 4:\r\n                    message.channel_join = ChannelJoin.decode(reader, reader.uint32());\r\n                    break;\r\n                case 5:\r\n                    message.channel_leave = ChannelLeave.decode(reader, reader.uint32());\r\n                    break;\r\n                case 6:\r\n                    message.channel_message = _api_api__WEBPACK_IMPORTED_MODULE_1__.ChannelMessage.decode(reader, reader.uint32());\r\n                    break;\r\n                case 7:\r\n                    message.channel_message_ack = ChannelMessageAck.decode(reader, reader.uint32());\r\n                    break;\r\n                case 8:\r\n                    message.channel_message_send = ChannelMessageSend.decode(reader, reader.uint32());\r\n                    break;\r\n                case 9:\r\n                    message.channel_message_update = ChannelMessageUpdate.decode(reader, reader.uint32());\r\n                    break;\r\n                case 10:\r\n                    message.channel_message_remove = ChannelMessageRemove.decode(reader, reader.uint32());\r\n                    break;\r\n                case 11:\r\n                    message.channel_presence_event = ChannelPresenceEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 12:\r\n                    message.error = Error.decode(reader, reader.uint32());\r\n                    break;\r\n                case 13:\r\n                    message.notifications = Notifications.decode(reader, reader.uint32());\r\n                    break;\r\n                case 14:\r\n                    message.rpc = _api_api__WEBPACK_IMPORTED_MODULE_1__.Rpc.decode(reader, reader.uint32());\r\n                    break;\r\n                case 15:\r\n                    message.status = Status.decode(reader, reader.uint32());\r\n                    break;\r\n                case 16:\r\n                    message.status_follow = StatusFollow.decode(reader, reader.uint32());\r\n                    break;\r\n                case 17:\r\n                    message.status_presence_event = StatusPresenceEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 18:\r\n                    message.status_unfollow = StatusUnfollow.decode(reader, reader.uint32());\r\n                    break;\r\n                case 19:\r\n                    message.status_update = StatusUpdate.decode(reader, reader.uint32());\r\n                    break;\r\n                case 20:\r\n                    message.stream_data = StreamData.decode(reader, reader.uint32());\r\n                    break;\r\n                case 21:\r\n                    message.stream_presence_event = StreamPresenceEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 22:\r\n                    message.ping = Ping.decode(reader, reader.uint32());\r\n                    break;\r\n                case 23:\r\n                    message.pong = Pong.decode(reader, reader.uint32());\r\n                    break;\r\n                case 24:\r\n                    message.message_typing_event = MessageTypingEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 25:\r\n                    message.last_seen_message_event = LastSeenMessageEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 26:\r\n                    message.message_reaction_event = _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageReaction.decode(reader, reader.uint32());\r\n                    break;\r\n                case 27:\r\n                    message.voice_joined_event = VoiceJoinedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 28:\r\n                    message.voice_leaved_event = VoiceLeavedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 29:\r\n                    message.voice_started_event = VoiceStartedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 30:\r\n                    message.voice_ended_event = VoiceEndedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 31:\r\n                    message.channel_created_event = ChannelCreatedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 32:\r\n                    message.channel_deleted_event = ChannelDeletedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 33:\r\n                    message.channel_updated_event = ChannelUpdatedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 34:\r\n                    message.last_pin_message_event = LastPinMessageEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 35:\r\n                    message.custom_status_event = CustomStatusEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 36:\r\n                    message.user_channel_added_event = UserChannelAdded.decode(reader, reader.uint32());\r\n                    break;\r\n                case 37:\r\n                    message.user_channel_removed_event = UserChannelRemoved.decode(reader, reader.uint32());\r\n                    break;\r\n                case 38:\r\n                    message.user_clan_removed_event = UserClanRemoved.decode(reader, reader.uint32());\r\n                    break;\r\n                case 39:\r\n                    message.clan_updated_event = ClanUpdatedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 40:\r\n                    message.clan_profile_updated_event = ClanProfileUpdatedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 41:\r\n                    message.clan_name_existed_event = ClanNameExistedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 42:\r\n                    message.user_profile_updated_event = UserProfileUpdatedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 43:\r\n                    message.emojis_listed_event = EmojiListedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 44:\r\n                    message.sticker_listed_event = StrickerListedEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 45:\r\n                    message.channel_desc_list_event = ChannelDescListEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 46:\r\n                    message.hashtag_dm_list_event = HashtagDmListEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 47:\r\n                    message.notification_channel_setting_event = NotificationChannelSettingEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 48:\r\n                    message.notification_category_setting_event = NotificationCategorySettingEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 49:\r\n                    message.notification_clan_setting_event = NotificationClanSettingEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 50:\r\n                    message.notifi_react_message_event = NotifiReactMessageEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                case 51:\r\n                    message.permission_role_channel_list_event = PermissionRoleChannelListEvent.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            cid: isSet(object.cid) ? String(object.cid) : \"\",\r\n            channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined,\r\n            clan_join: isSet(object.clan_join) ? ClanJoin.fromJSON(object.clan_join) : undefined,\r\n            channel_join: isSet(object.channel_join) ? ChannelJoin.fromJSON(object.channel_join) : undefined,\r\n            channel_leave: isSet(object.channel_leave) ? ChannelLeave.fromJSON(object.channel_leave) : undefined,\r\n            channel_message: isSet(object.channel_message) ? _api_api__WEBPACK_IMPORTED_MODULE_1__.ChannelMessage.fromJSON(object.channel_message) : undefined,\r\n            channel_message_ack: isSet(object.channel_message_ack)\r\n                ? ChannelMessageAck.fromJSON(object.channel_message_ack)\r\n                : undefined,\r\n            channel_message_send: isSet(object.channel_message_send)\r\n                ? ChannelMessageSend.fromJSON(object.channel_message_send)\r\n                : undefined,\r\n            channel_message_update: isSet(object.channel_message_update)\r\n                ? ChannelMessageUpdate.fromJSON(object.channel_message_update)\r\n                : undefined,\r\n            channel_message_remove: isSet(object.channel_message_remove)\r\n                ? ChannelMessageRemove.fromJSON(object.channel_message_remove)\r\n                : undefined,\r\n            channel_presence_event: isSet(object.channel_presence_event)\r\n                ? ChannelPresenceEvent.fromJSON(object.channel_presence_event)\r\n                : undefined,\r\n            error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,\r\n            notifications: isSet(object.notifications) ? Notifications.fromJSON(object.notifications) : undefined,\r\n            rpc: isSet(object.rpc) ? _api_api__WEBPACK_IMPORTED_MODULE_1__.Rpc.fromJSON(object.rpc) : undefined,\r\n            status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,\r\n            status_follow: isSet(object.status_follow) ? StatusFollow.fromJSON(object.status_follow) : undefined,\r\n            status_presence_event: isSet(object.status_presence_event)\r\n                ? StatusPresenceEvent.fromJSON(object.status_presence_event)\r\n                : undefined,\r\n            status_unfollow: isSet(object.status_unfollow) ? StatusUnfollow.fromJSON(object.status_unfollow) : undefined,\r\n            status_update: isSet(object.status_update) ? StatusUpdate.fromJSON(object.status_update) : undefined,\r\n            stream_data: isSet(object.stream_data) ? StreamData.fromJSON(object.stream_data) : undefined,\r\n            stream_presence_event: isSet(object.stream_presence_event)\r\n                ? StreamPresenceEvent.fromJSON(object.stream_presence_event)\r\n                : undefined,\r\n            ping: isSet(object.ping) ? Ping.fromJSON(object.ping) : undefined,\r\n            pong: isSet(object.pong) ? Pong.fromJSON(object.pong) : undefined,\r\n            message_typing_event: isSet(object.message_typing_event)\r\n                ? MessageTypingEvent.fromJSON(object.message_typing_event)\r\n                : undefined,\r\n            last_seen_message_event: isSet(object.last_seen_message_event)\r\n                ? LastSeenMessageEvent.fromJSON(object.last_seen_message_event)\r\n                : undefined,\r\n            message_reaction_event: isSet(object.message_reaction_event)\r\n                ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageReaction.fromJSON(object.message_reaction_event)\r\n                : undefined,\r\n            voice_joined_event: isSet(object.voice_joined_event)\r\n                ? VoiceJoinedEvent.fromJSON(object.voice_joined_event)\r\n                : undefined,\r\n            voice_leaved_event: isSet(object.voice_leaved_event)\r\n                ? VoiceLeavedEvent.fromJSON(object.voice_leaved_event)\r\n                : undefined,\r\n            voice_started_event: isSet(object.voice_started_event)\r\n                ? VoiceStartedEvent.fromJSON(object.voice_started_event)\r\n                : undefined,\r\n            voice_ended_event: isSet(object.voice_ended_event)\r\n                ? VoiceEndedEvent.fromJSON(object.voice_ended_event)\r\n                : undefined,\r\n            channel_created_event: isSet(object.channel_created_event)\r\n                ? ChannelCreatedEvent.fromJSON(object.channel_created_event)\r\n                : undefined,\r\n            channel_deleted_event: isSet(object.channel_deleted_event)\r\n                ? ChannelDeletedEvent.fromJSON(object.channel_deleted_event)\r\n                : undefined,\r\n            channel_updated_event: isSet(object.channel_updated_event)\r\n                ? ChannelUpdatedEvent.fromJSON(object.channel_updated_event)\r\n                : undefined,\r\n            last_pin_message_event: isSet(object.last_pin_message_event)\r\n                ? LastPinMessageEvent.fromJSON(object.last_pin_message_event)\r\n                : undefined,\r\n            custom_status_event: isSet(object.custom_status_event)\r\n                ? CustomStatusEvent.fromJSON(object.custom_status_event)\r\n                : undefined,\r\n            user_channel_added_event: isSet(object.user_channel_added_event)\r\n                ? UserChannelAdded.fromJSON(object.user_channel_added_event)\r\n                : undefined,\r\n            user_channel_removed_event: isSet(object.user_channel_removed_event)\r\n                ? UserChannelRemoved.fromJSON(object.user_channel_removed_event)\r\n                : undefined,\r\n            user_clan_removed_event: isSet(object.user_clan_removed_event)\r\n                ? UserClanRemoved.fromJSON(object.user_clan_removed_event)\r\n                : undefined,\r\n            clan_updated_event: isSet(object.clan_updated_event)\r\n                ? ClanUpdatedEvent.fromJSON(object.clan_updated_event)\r\n                : undefined,\r\n            clan_profile_updated_event: isSet(object.clan_profile_updated_event)\r\n                ? ClanProfileUpdatedEvent.fromJSON(object.clan_profile_updated_event)\r\n                : undefined,\r\n            clan_name_existed_event: isSet(object.clan_name_existed_event)\r\n                ? ClanNameExistedEvent.fromJSON(object.clan_name_existed_event)\r\n                : undefined,\r\n            user_profile_updated_event: isSet(object.user_profile_updated_event)\r\n                ? UserProfileUpdatedEvent.fromJSON(object.user_profile_updated_event)\r\n                : undefined,\r\n            emojis_listed_event: isSet(object.emojis_listed_event)\r\n                ? EmojiListedEvent.fromJSON(object.emojis_listed_event)\r\n                : undefined,\r\n            sticker_listed_event: isSet(object.sticker_listed_event)\r\n                ? StrickerListedEvent.fromJSON(object.sticker_listed_event)\r\n                : undefined,\r\n            channel_desc_list_event: isSet(object.channel_desc_list_event)\r\n                ? ChannelDescListEvent.fromJSON(object.channel_desc_list_event)\r\n                : undefined,\r\n            hashtag_dm_list_event: isSet(object.hashtag_dm_list_event)\r\n                ? HashtagDmListEvent.fromJSON(object.hashtag_dm_list_event)\r\n                : undefined,\r\n            notification_channel_setting_event: isSet(object.notification_channel_setting_event)\r\n                ? NotificationChannelSettingEvent.fromJSON(object.notification_channel_setting_event)\r\n                : undefined,\r\n            notification_category_setting_event: isSet(object.notification_category_setting_event)\r\n                ? NotificationCategorySettingEvent.fromJSON(object.notification_category_setting_event)\r\n                : undefined,\r\n            notification_clan_setting_event: isSet(object.notification_clan_setting_event)\r\n                ? NotificationClanSettingEvent.fromJSON(object.notification_clan_setting_event)\r\n                : undefined,\r\n            notifi_react_message_event: isSet(object.notifi_react_message_event)\r\n                ? NotifiReactMessageEvent.fromJSON(object.notifi_react_message_event)\r\n                : undefined,\r\n            permission_role_channel_list_event: isSet(object.permission_role_channel_list_event)\r\n                ? PermissionRoleChannelListEvent.fromJSON(object.permission_role_channel_list_event)\r\n                : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.cid !== undefined && (obj.cid = message.cid);\r\n        message.channel !== undefined && (obj.channel = message.channel ? Channel.toJSON(message.channel) : undefined);\r\n        message.clan_join !== undefined &&\r\n            (obj.clan_join = message.clan_join ? ClanJoin.toJSON(message.clan_join) : undefined);\r\n        message.channel_join !== undefined &&\r\n            (obj.channel_join = message.channel_join ? ChannelJoin.toJSON(message.channel_join) : undefined);\r\n        message.channel_leave !== undefined &&\r\n            (obj.channel_leave = message.channel_leave ? ChannelLeave.toJSON(message.channel_leave) : undefined);\r\n        message.channel_message !== undefined &&\r\n            (obj.channel_message = message.channel_message ? _api_api__WEBPACK_IMPORTED_MODULE_1__.ChannelMessage.toJSON(message.channel_message) : undefined);\r\n        message.channel_message_ack !== undefined && (obj.channel_message_ack = message.channel_message_ack\r\n            ? ChannelMessageAck.toJSON(message.channel_message_ack)\r\n            : undefined);\r\n        message.channel_message_send !== undefined && (obj.channel_message_send = message.channel_message_send\r\n            ? ChannelMessageSend.toJSON(message.channel_message_send)\r\n            : undefined);\r\n        message.channel_message_update !== undefined && (obj.channel_message_update = message.channel_message_update\r\n            ? ChannelMessageUpdate.toJSON(message.channel_message_update)\r\n            : undefined);\r\n        message.channel_message_remove !== undefined && (obj.channel_message_remove = message.channel_message_remove\r\n            ? ChannelMessageRemove.toJSON(message.channel_message_remove)\r\n            : undefined);\r\n        message.channel_presence_event !== undefined && (obj.channel_presence_event = message.channel_presence_event\r\n            ? ChannelPresenceEvent.toJSON(message.channel_presence_event)\r\n            : undefined);\r\n        message.error !== undefined && (obj.error = message.error ? Error.toJSON(message.error) : undefined);\r\n        message.notifications !== undefined &&\r\n            (obj.notifications = message.notifications ? Notifications.toJSON(message.notifications) : undefined);\r\n        message.rpc !== undefined && (obj.rpc = message.rpc ? _api_api__WEBPACK_IMPORTED_MODULE_1__.Rpc.toJSON(message.rpc) : undefined);\r\n        message.status !== undefined && (obj.status = message.status ? Status.toJSON(message.status) : undefined);\r\n        message.status_follow !== undefined &&\r\n            (obj.status_follow = message.status_follow ? StatusFollow.toJSON(message.status_follow) : undefined);\r\n        message.status_presence_event !== undefined && (obj.status_presence_event = message.status_presence_event\r\n            ? StatusPresenceEvent.toJSON(message.status_presence_event)\r\n            : undefined);\r\n        message.status_unfollow !== undefined &&\r\n            (obj.status_unfollow = message.status_unfollow ? StatusUnfollow.toJSON(message.status_unfollow) : undefined);\r\n        message.status_update !== undefined &&\r\n            (obj.status_update = message.status_update ? StatusUpdate.toJSON(message.status_update) : undefined);\r\n        message.stream_data !== undefined &&\r\n            (obj.stream_data = message.stream_data ? StreamData.toJSON(message.stream_data) : undefined);\r\n        message.stream_presence_event !== undefined && (obj.stream_presence_event = message.stream_presence_event\r\n            ? StreamPresenceEvent.toJSON(message.stream_presence_event)\r\n            : undefined);\r\n        message.ping !== undefined && (obj.ping = message.ping ? Ping.toJSON(message.ping) : undefined);\r\n        message.pong !== undefined && (obj.pong = message.pong ? Pong.toJSON(message.pong) : undefined);\r\n        message.message_typing_event !== undefined && (obj.message_typing_event = message.message_typing_event\r\n            ? MessageTypingEvent.toJSON(message.message_typing_event)\r\n            : undefined);\r\n        message.last_seen_message_event !== undefined && (obj.last_seen_message_event = message.last_seen_message_event\r\n            ? LastSeenMessageEvent.toJSON(message.last_seen_message_event)\r\n            : undefined);\r\n        message.message_reaction_event !== undefined && (obj.message_reaction_event = message.message_reaction_event\r\n            ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageReaction.toJSON(message.message_reaction_event)\r\n            : undefined);\r\n        message.voice_joined_event !== undefined && (obj.voice_joined_event = message.voice_joined_event\r\n            ? VoiceJoinedEvent.toJSON(message.voice_joined_event)\r\n            : undefined);\r\n        message.voice_leaved_event !== undefined && (obj.voice_leaved_event = message.voice_leaved_event\r\n            ? VoiceLeavedEvent.toJSON(message.voice_leaved_event)\r\n            : undefined);\r\n        message.voice_started_event !== undefined && (obj.voice_started_event = message.voice_started_event\r\n            ? VoiceStartedEvent.toJSON(message.voice_started_event)\r\n            : undefined);\r\n        message.voice_ended_event !== undefined &&\r\n            (obj.voice_ended_event = message.voice_ended_event\r\n                ? VoiceEndedEvent.toJSON(message.voice_ended_event)\r\n                : undefined);\r\n        message.channel_created_event !== undefined && (obj.channel_created_event = message.channel_created_event\r\n            ? ChannelCreatedEvent.toJSON(message.channel_created_event)\r\n            : undefined);\r\n        message.channel_deleted_event !== undefined && (obj.channel_deleted_event = message.channel_deleted_event\r\n            ? ChannelDeletedEvent.toJSON(message.channel_deleted_event)\r\n            : undefined);\r\n        message.channel_updated_event !== undefined && (obj.channel_updated_event = message.channel_updated_event\r\n            ? ChannelUpdatedEvent.toJSON(message.channel_updated_event)\r\n            : undefined);\r\n        message.last_pin_message_event !== undefined && (obj.last_pin_message_event = message.last_pin_message_event\r\n            ? LastPinMessageEvent.toJSON(message.last_pin_message_event)\r\n            : undefined);\r\n        message.custom_status_event !== undefined && (obj.custom_status_event = message.custom_status_event\r\n            ? CustomStatusEvent.toJSON(message.custom_status_event)\r\n            : undefined);\r\n        message.user_channel_added_event !== undefined && (obj.user_channel_added_event = message.user_channel_added_event\r\n            ? UserChannelAdded.toJSON(message.user_channel_added_event)\r\n            : undefined);\r\n        message.user_channel_removed_event !== undefined &&\r\n            (obj.user_channel_removed_event = message.user_channel_removed_event\r\n                ? UserChannelRemoved.toJSON(message.user_channel_removed_event)\r\n                : undefined);\r\n        message.user_clan_removed_event !== undefined && (obj.user_clan_removed_event = message.user_clan_removed_event\r\n            ? UserClanRemoved.toJSON(message.user_clan_removed_event)\r\n            : undefined);\r\n        message.clan_updated_event !== undefined && (obj.clan_updated_event = message.clan_updated_event\r\n            ? ClanUpdatedEvent.toJSON(message.clan_updated_event)\r\n            : undefined);\r\n        message.clan_profile_updated_event !== undefined &&\r\n            (obj.clan_profile_updated_event = message.clan_profile_updated_event\r\n                ? ClanProfileUpdatedEvent.toJSON(message.clan_profile_updated_event)\r\n                : undefined);\r\n        message.clan_name_existed_event !== undefined && (obj.clan_name_existed_event = message.clan_name_existed_event\r\n            ? ClanNameExistedEvent.toJSON(message.clan_name_existed_event)\r\n            : undefined);\r\n        message.user_profile_updated_event !== undefined &&\r\n            (obj.user_profile_updated_event = message.user_profile_updated_event\r\n                ? UserProfileUpdatedEvent.toJSON(message.user_profile_updated_event)\r\n                : undefined);\r\n        message.emojis_listed_event !== undefined && (obj.emojis_listed_event = message.emojis_listed_event\r\n            ? EmojiListedEvent.toJSON(message.emojis_listed_event)\r\n            : undefined);\r\n        message.sticker_listed_event !== undefined && (obj.sticker_listed_event = message.sticker_listed_event\r\n            ? StrickerListedEvent.toJSON(message.sticker_listed_event)\r\n            : undefined);\r\n        message.channel_desc_list_event !== undefined && (obj.channel_desc_list_event = message.channel_desc_list_event\r\n            ? ChannelDescListEvent.toJSON(message.channel_desc_list_event)\r\n            : undefined);\r\n        message.hashtag_dm_list_event !== undefined && (obj.hashtag_dm_list_event = message.hashtag_dm_list_event\r\n            ? HashtagDmListEvent.toJSON(message.hashtag_dm_list_event)\r\n            : undefined);\r\n        message.notification_channel_setting_event !== undefined &&\r\n            (obj.notification_channel_setting_event = message.notification_channel_setting_event\r\n                ? NotificationChannelSettingEvent.toJSON(message.notification_channel_setting_event)\r\n                : undefined);\r\n        message.notification_category_setting_event !== undefined &&\r\n            (obj.notification_category_setting_event = message.notification_category_setting_event\r\n                ? NotificationCategorySettingEvent.toJSON(message.notification_category_setting_event)\r\n                : undefined);\r\n        message.notification_clan_setting_event !== undefined &&\r\n            (obj.notification_clan_setting_event = message.notification_clan_setting_event\r\n                ? NotificationClanSettingEvent.toJSON(message.notification_clan_setting_event)\r\n                : undefined);\r\n        message.notifi_react_message_event !== undefined &&\r\n            (obj.notifi_react_message_event = message.notifi_react_message_event\r\n                ? NotifiReactMessageEvent.toJSON(message.notifi_react_message_event)\r\n                : undefined);\r\n        message.permission_role_channel_list_event !== undefined &&\r\n            (obj.permission_role_channel_list_event = message.permission_role_channel_list_event\r\n                ? PermissionRoleChannelListEvent.toJSON(message.permission_role_channel_list_event)\r\n                : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Envelope.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEnvelope();\r\n        message.cid = object.cid ?? \"\";\r\n        message.channel = (object.channel !== undefined && object.channel !== null)\r\n            ? Channel.fromPartial(object.channel)\r\n            : undefined;\r\n        message.clan_join = (object.clan_join !== undefined && object.clan_join !== null)\r\n            ? ClanJoin.fromPartial(object.clan_join)\r\n            : undefined;\r\n        message.channel_join = (object.channel_join !== undefined && object.channel_join !== null)\r\n            ? ChannelJoin.fromPartial(object.channel_join)\r\n            : undefined;\r\n        message.channel_leave = (object.channel_leave !== undefined && object.channel_leave !== null)\r\n            ? ChannelLeave.fromPartial(object.channel_leave)\r\n            : undefined;\r\n        message.channel_message = (object.channel_message !== undefined && object.channel_message !== null)\r\n            ? _api_api__WEBPACK_IMPORTED_MODULE_1__.ChannelMessage.fromPartial(object.channel_message)\r\n            : undefined;\r\n        message.channel_message_ack = (object.channel_message_ack !== undefined && object.channel_message_ack !== null)\r\n            ? ChannelMessageAck.fromPartial(object.channel_message_ack)\r\n            : undefined;\r\n        message.channel_message_send = (object.channel_message_send !== undefined && object.channel_message_send !== null)\r\n            ? ChannelMessageSend.fromPartial(object.channel_message_send)\r\n            : undefined;\r\n        message.channel_message_update =\r\n            (object.channel_message_update !== undefined && object.channel_message_update !== null)\r\n                ? ChannelMessageUpdate.fromPartial(object.channel_message_update)\r\n                : undefined;\r\n        message.channel_message_remove =\r\n            (object.channel_message_remove !== undefined && object.channel_message_remove !== null)\r\n                ? ChannelMessageRemove.fromPartial(object.channel_message_remove)\r\n                : undefined;\r\n        message.channel_presence_event =\r\n            (object.channel_presence_event !== undefined && object.channel_presence_event !== null)\r\n                ? ChannelPresenceEvent.fromPartial(object.channel_presence_event)\r\n                : undefined;\r\n        message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;\r\n        message.notifications = (object.notifications !== undefined && object.notifications !== null)\r\n            ? Notifications.fromPartial(object.notifications)\r\n            : undefined;\r\n        message.rpc = (object.rpc !== undefined && object.rpc !== null) ? _api_api__WEBPACK_IMPORTED_MODULE_1__.Rpc.fromPartial(object.rpc) : undefined;\r\n        message.status = (object.status !== undefined && object.status !== null)\r\n            ? Status.fromPartial(object.status)\r\n            : undefined;\r\n        message.status_follow = (object.status_follow !== undefined && object.status_follow !== null)\r\n            ? StatusFollow.fromPartial(object.status_follow)\r\n            : undefined;\r\n        message.status_presence_event =\r\n            (object.status_presence_event !== undefined && object.status_presence_event !== null)\r\n                ? StatusPresenceEvent.fromPartial(object.status_presence_event)\r\n                : undefined;\r\n        message.status_unfollow = (object.status_unfollow !== undefined && object.status_unfollow !== null)\r\n            ? StatusUnfollow.fromPartial(object.status_unfollow)\r\n            : undefined;\r\n        message.status_update = (object.status_update !== undefined && object.status_update !== null)\r\n            ? StatusUpdate.fromPartial(object.status_update)\r\n            : undefined;\r\n        message.stream_data = (object.stream_data !== undefined && object.stream_data !== null)\r\n            ? StreamData.fromPartial(object.stream_data)\r\n            : undefined;\r\n        message.stream_presence_event =\r\n            (object.stream_presence_event !== undefined && object.stream_presence_event !== null)\r\n                ? StreamPresenceEvent.fromPartial(object.stream_presence_event)\r\n                : undefined;\r\n        message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;\r\n        message.pong = (object.pong !== undefined && object.pong !== null) ? Pong.fromPartial(object.pong) : undefined;\r\n        message.message_typing_event = (object.message_typing_event !== undefined && object.message_typing_event !== null)\r\n            ? MessageTypingEvent.fromPartial(object.message_typing_event)\r\n            : undefined;\r\n        message.last_seen_message_event =\r\n            (object.last_seen_message_event !== undefined && object.last_seen_message_event !== null)\r\n                ? LastSeenMessageEvent.fromPartial(object.last_seen_message_event)\r\n                : undefined;\r\n        message.message_reaction_event =\r\n            (object.message_reaction_event !== undefined && object.message_reaction_event !== null)\r\n                ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageReaction.fromPartial(object.message_reaction_event)\r\n                : undefined;\r\n        message.voice_joined_event = (object.voice_joined_event !== undefined && object.voice_joined_event !== null)\r\n            ? VoiceJoinedEvent.fromPartial(object.voice_joined_event)\r\n            : undefined;\r\n        message.voice_leaved_event = (object.voice_leaved_event !== undefined && object.voice_leaved_event !== null)\r\n            ? VoiceLeavedEvent.fromPartial(object.voice_leaved_event)\r\n            : undefined;\r\n        message.voice_started_event = (object.voice_started_event !== undefined && object.voice_started_event !== null)\r\n            ? VoiceStartedEvent.fromPartial(object.voice_started_event)\r\n            : undefined;\r\n        message.voice_ended_event = (object.voice_ended_event !== undefined && object.voice_ended_event !== null)\r\n            ? VoiceEndedEvent.fromPartial(object.voice_ended_event)\r\n            : undefined;\r\n        message.channel_created_event =\r\n            (object.channel_created_event !== undefined && object.channel_created_event !== null)\r\n                ? ChannelCreatedEvent.fromPartial(object.channel_created_event)\r\n                : undefined;\r\n        message.channel_deleted_event =\r\n            (object.channel_deleted_event !== undefined && object.channel_deleted_event !== null)\r\n                ? ChannelDeletedEvent.fromPartial(object.channel_deleted_event)\r\n                : undefined;\r\n        message.channel_updated_event =\r\n            (object.channel_updated_event !== undefined && object.channel_updated_event !== null)\r\n                ? ChannelUpdatedEvent.fromPartial(object.channel_updated_event)\r\n                : undefined;\r\n        message.last_pin_message_event =\r\n            (object.last_pin_message_event !== undefined && object.last_pin_message_event !== null)\r\n                ? LastPinMessageEvent.fromPartial(object.last_pin_message_event)\r\n                : undefined;\r\n        message.custom_status_event = (object.custom_status_event !== undefined && object.custom_status_event !== null)\r\n            ? CustomStatusEvent.fromPartial(object.custom_status_event)\r\n            : undefined;\r\n        message.user_channel_added_event =\r\n            (object.user_channel_added_event !== undefined && object.user_channel_added_event !== null)\r\n                ? UserChannelAdded.fromPartial(object.user_channel_added_event)\r\n                : undefined;\r\n        message.user_channel_removed_event =\r\n            (object.user_channel_removed_event !== undefined && object.user_channel_removed_event !== null)\r\n                ? UserChannelRemoved.fromPartial(object.user_channel_removed_event)\r\n                : undefined;\r\n        message.user_clan_removed_event =\r\n            (object.user_clan_removed_event !== undefined && object.user_clan_removed_event !== null)\r\n                ? UserClanRemoved.fromPartial(object.user_clan_removed_event)\r\n                : undefined;\r\n        message.clan_updated_event = (object.clan_updated_event !== undefined && object.clan_updated_event !== null)\r\n            ? ClanUpdatedEvent.fromPartial(object.clan_updated_event)\r\n            : undefined;\r\n        message.clan_profile_updated_event =\r\n            (object.clan_profile_updated_event !== undefined && object.clan_profile_updated_event !== null)\r\n                ? ClanProfileUpdatedEvent.fromPartial(object.clan_profile_updated_event)\r\n                : undefined;\r\n        message.clan_name_existed_event =\r\n            (object.clan_name_existed_event !== undefined && object.clan_name_existed_event !== null)\r\n                ? ClanNameExistedEvent.fromPartial(object.clan_name_existed_event)\r\n                : undefined;\r\n        message.user_profile_updated_event =\r\n            (object.user_profile_updated_event !== undefined && object.user_profile_updated_event !== null)\r\n                ? UserProfileUpdatedEvent.fromPartial(object.user_profile_updated_event)\r\n                : undefined;\r\n        message.emojis_listed_event = (object.emojis_listed_event !== undefined && object.emojis_listed_event !== null)\r\n            ? EmojiListedEvent.fromPartial(object.emojis_listed_event)\r\n            : undefined;\r\n        message.sticker_listed_event = (object.sticker_listed_event !== undefined && object.sticker_listed_event !== null)\r\n            ? StrickerListedEvent.fromPartial(object.sticker_listed_event)\r\n            : undefined;\r\n        message.channel_desc_list_event =\r\n            (object.channel_desc_list_event !== undefined && object.channel_desc_list_event !== null)\r\n                ? ChannelDescListEvent.fromPartial(object.channel_desc_list_event)\r\n                : undefined;\r\n        message.hashtag_dm_list_event =\r\n            (object.hashtag_dm_list_event !== undefined && object.hashtag_dm_list_event !== null)\r\n                ? HashtagDmListEvent.fromPartial(object.hashtag_dm_list_event)\r\n                : undefined;\r\n        message.notification_channel_setting_event =\r\n            (object.notification_channel_setting_event !== undefined && object.notification_channel_setting_event !== null)\r\n                ? NotificationChannelSettingEvent.fromPartial(object.notification_channel_setting_event)\r\n                : undefined;\r\n        message.notification_category_setting_event =\r\n            (object.notification_category_setting_event !== undefined && object.notification_category_setting_event !== null)\r\n                ? NotificationCategorySettingEvent.fromPartial(object.notification_category_setting_event)\r\n                : undefined;\r\n        message.notification_clan_setting_event =\r\n            (object.notification_clan_setting_event !== undefined && object.notification_clan_setting_event !== null)\r\n                ? NotificationClanSettingEvent.fromPartial(object.notification_clan_setting_event)\r\n                : undefined;\r\n        message.notifi_react_message_event =\r\n            (object.notifi_react_message_event !== undefined && object.notifi_react_message_event !== null)\r\n                ? NotifiReactMessageEvent.fromPartial(object.notifi_react_message_event)\r\n                : undefined;\r\n        message.permission_role_channel_list_event =\r\n            (object.permission_role_channel_list_event !== undefined && object.permission_role_channel_list_event !== null)\r\n                ? PermissionRoleChannelListEvent.fromPartial(object.permission_role_channel_list_event)\r\n                : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePermissionRoleChannelListEvent() {\r\n    return { role_id: \"\", channel_id: \"\", permission_role_channel: [] };\r\n}\r\nconst PermissionRoleChannelListEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.role_id !== \"\") {\r\n            writer.uint32(10).string(message.role_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        for (const v of message.permission_role_channel) {\r\n            PermissionRoleChannel.encode(v, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePermissionRoleChannelListEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.role_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.permission_role_channel.push(PermissionRoleChannel.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            role_id: isSet(object.role_id) ? String(object.role_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            permission_role_channel: Array.isArray(object?.permission_role_channel)\r\n                ? object.permission_role_channel.map((e) => PermissionRoleChannel.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.role_id !== undefined && (obj.role_id = message.role_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        if (message.permission_role_channel) {\r\n            obj.permission_role_channel = message.permission_role_channel.map((e) => e ? PermissionRoleChannel.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.permission_role_channel = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PermissionRoleChannelListEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePermissionRoleChannelListEvent();\r\n        message.role_id = object.role_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.permission_role_channel =\r\n            object.permission_role_channel?.map((e) => PermissionRoleChannel.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePermissionRoleChannel() {\r\n    return { permission_id: \"\", active: false };\r\n}\r\nconst PermissionRoleChannel = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.permission_id !== \"\") {\r\n            writer.uint32(10).string(message.permission_id);\r\n        }\r\n        if (message.active === true) {\r\n            writer.uint32(16).bool(message.active);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePermissionRoleChannel();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.permission_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.active = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            permission_id: isSet(object.permission_id) ? String(object.permission_id) : \"\",\r\n            active: isSet(object.active) ? Boolean(object.active) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.permission_id !== undefined && (obj.permission_id = message.permission_id);\r\n        message.active !== undefined && (obj.active = message.active);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return PermissionRoleChannel.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBasePermissionRoleChannel();\r\n        message.permission_id = object.permission_id ?? \"\";\r\n        message.active = object.active ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseHashtagDmListEvent() {\r\n    return { user_id: [], limit: undefined, hashtag_dm: [] };\r\n}\r\nconst HashtagDmListEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.user_id) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        if (message.limit !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.limit }, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        for (const v of message.hashtag_dm) {\r\n            HashtagDm.encode(v, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseHashtagDmListEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.limit = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 3:\r\n                    message.hashtag_dm.push(HashtagDm.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: Array.isArray(object?.user_id) ? object.user_id.map((e) => String(e)) : [],\r\n            limit: isSet(object.limit) ? Number(object.limit) : undefined,\r\n            hashtag_dm: Array.isArray(object?.hashtag_dm) ? object.hashtag_dm.map((e) => HashtagDm.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.user_id) {\r\n            obj.user_id = message.user_id.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_id = [];\r\n        }\r\n        message.limit !== undefined && (obj.limit = message.limit);\r\n        if (message.hashtag_dm) {\r\n            obj.hashtag_dm = message.hashtag_dm.map((e) => e ? HashtagDm.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.hashtag_dm = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return HashtagDmListEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseHashtagDmListEvent();\r\n        message.user_id = object.user_id?.map((e) => e) || [];\r\n        message.limit = object.limit ?? undefined;\r\n        message.hashtag_dm = object.hashtag_dm?.map((e) => HashtagDm.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseHashtagDm() {\r\n    return {\r\n        channel_id: \"\",\r\n        channel_label: \"\",\r\n        clan_id: \"\",\r\n        clan_name: \"\",\r\n        meeting_code: \"\",\r\n        type: 0,\r\n        channel_private: 0,\r\n        parrent_id: \"\",\r\n    };\r\n}\r\nconst HashtagDm = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(18).string(message.channel_label);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(26).string(message.clan_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(34).string(message.clan_name);\r\n        }\r\n        if (message.meeting_code !== \"\") {\r\n            writer.uint32(42).string(message.meeting_code);\r\n        }\r\n        if (message.type !== 0) {\r\n            writer.uint32(48).int32(message.type);\r\n        }\r\n        if (message.channel_private !== 0) {\r\n            writer.uint32(56).int32(message.channel_private);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(66).string(message.parrent_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseHashtagDm();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.meeting_code = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.type = reader.int32();\r\n                    break;\r\n                case 7:\r\n                    message.channel_private = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            meeting_code: isSet(object.meeting_code) ? String(object.meeting_code) : \"\",\r\n            type: isSet(object.type) ? Number(object.type) : 0,\r\n            channel_private: isSet(object.channel_private) ? Number(object.channel_private) : 0,\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.meeting_code !== undefined && (obj.meeting_code = message.meeting_code);\r\n        message.type !== undefined && (obj.type = Math.round(message.type));\r\n        message.channel_private !== undefined && (obj.channel_private = Math.round(message.channel_private));\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return HashtagDm.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseHashtagDm();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.meeting_code = object.meeting_code ?? \"\";\r\n        message.type = object.type ?? 0;\r\n        message.channel_private = object.channel_private ?? 0;\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelDescListEvent() {\r\n    return { channeldesc: [] };\r\n}\r\nconst ChannelDescListEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.channeldesc) {\r\n            ChannelDescription.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelDescListEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channeldesc: Array.isArray(object?.channeldesc)\r\n                ? object.channeldesc.map((e) => ChannelDescription.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.channeldesc) {\r\n            obj.channeldesc = message.channeldesc.map((e) => e ? ChannelDescription.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.channeldesc = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelDescListEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelDescListEvent();\r\n        message.channeldesc = object.channeldesc?.map((e) => ChannelDescription.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelDescription() {\r\n    return {\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        type: undefined,\r\n        channel_label: \"\",\r\n        channel_private: 0,\r\n        meeting_code: \"\",\r\n        clan_name: \"\",\r\n        parrent_id: \"\",\r\n    };\r\n}\r\nconst ChannelDescription = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.type !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.type }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(34).string(message.channel_label);\r\n        }\r\n        if (message.channel_private !== 0) {\r\n            writer.uint32(40).int32(message.channel_private);\r\n        }\r\n        if (message.meeting_code !== \"\") {\r\n            writer.uint32(50).string(message.meeting_code);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(58).string(message.clan_name);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(66).string(message.parrent_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelDescription();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.type = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_private = reader.int32();\r\n                    break;\r\n                case 6:\r\n                    message.meeting_code = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            type: isSet(object.type) ? Number(object.type) : undefined,\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_private: isSet(object.channel_private) ? Number(object.channel_private) : 0,\r\n            meeting_code: isSet(object.meeting_code) ? String(object.meeting_code) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.type !== undefined && (obj.type = message.type);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_private !== undefined && (obj.channel_private = Math.round(message.channel_private));\r\n        message.meeting_code !== undefined && (obj.meeting_code = message.meeting_code);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelDescription.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelDescription();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.type = object.type ?? undefined;\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_private = object.channel_private ?? 0;\r\n        message.meeting_code = object.meeting_code ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStrickerListedEvent() {\r\n    return { clan_id: \"\", stickers: [] };\r\n}\r\nconst StrickerListedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        for (const v of message.stickers) {\r\n            ClanSticker.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStrickerListedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.stickers.push(ClanSticker.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            stickers: Array.isArray(object?.stickers) ? object.stickers.map((e) => ClanSticker.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        if (message.stickers) {\r\n            obj.stickers = message.stickers.map((e) => e ? ClanSticker.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.stickers = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StrickerListedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStrickerListedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.stickers = object.stickers?.map((e) => ClanSticker.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanSticker() {\r\n    return { id: \"\", source: \"\", shortname: \"\", category: \"\", creator_id: \"\", create_time: undefined, clan_id: \"\" };\r\n}\r\nconst ClanSticker = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.source !== \"\") {\r\n            writer.uint32(18).string(message.source);\r\n        }\r\n        if (message.shortname !== \"\") {\r\n            writer.uint32(26).string(message.shortname);\r\n        }\r\n        if (message.category !== \"\") {\r\n            writer.uint32(34).string(message.category);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(42).string(message.creator_id);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(58).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanSticker();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.source = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.shortname = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            source: isSet(object.source) ? String(object.source) : \"\",\r\n            shortname: isSet(object.shortname) ? String(object.shortname) : \"\",\r\n            category: isSet(object.category) ? String(object.category) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.source !== undefined && (obj.source = message.source);\r\n        message.shortname !== undefined && (obj.shortname = message.shortname);\r\n        message.category !== undefined && (obj.category = message.category);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanSticker.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanSticker();\r\n        message.id = object.id ?? \"\";\r\n        message.source = object.source ?? \"\";\r\n        message.shortname = object.shortname ?? \"\";\r\n        message.category = object.category ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanEmoji() {\r\n    return { id: \"\", src: \"\", shortname: \"\", category: \"\", creator_id: \"\" };\r\n}\r\nconst ClanEmoji = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.src !== \"\") {\r\n            writer.uint32(18).string(message.src);\r\n        }\r\n        if (message.shortname !== \"\") {\r\n            writer.uint32(26).string(message.shortname);\r\n        }\r\n        if (message.category !== \"\") {\r\n            writer.uint32(34).string(message.category);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(42).string(message.creator_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanEmoji();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.src = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.shortname = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.category = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            src: isSet(object.src) ? String(object.src) : \"\",\r\n            shortname: isSet(object.shortname) ? String(object.shortname) : \"\",\r\n            category: isSet(object.category) ? String(object.category) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.src !== undefined && (obj.src = message.src);\r\n        message.shortname !== undefined && (obj.shortname = message.shortname);\r\n        message.category !== undefined && (obj.category = message.category);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanEmoji.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanEmoji();\r\n        message.id = object.id ?? \"\";\r\n        message.src = object.src ?? \"\";\r\n        message.shortname = object.shortname ?? \"\";\r\n        message.category = object.category ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseEmojiListedEvent() {\r\n    return { clan_id: \"\", emoji_list: [] };\r\n}\r\nconst EmojiListedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        for (const v of message.emoji_list) {\r\n            ClanEmoji.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseEmojiListedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.emoji_list.push(ClanEmoji.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            emoji_list: Array.isArray(object?.emoji_list) ? object.emoji_list.map((e) => ClanEmoji.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        if (message.emoji_list) {\r\n            obj.emoji_list = message.emoji_list.map((e) => e ? ClanEmoji.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.emoji_list = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return EmojiListedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseEmojiListedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.emoji_list = object.emoji_list?.map((e) => ClanEmoji.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannel() {\r\n    return { id: \"\", presences: [], self: undefined, chanel_label: \"\", clan_logo: \"\", category_name: \"\" };\r\n}\r\nconst Channel = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        for (const v of message.presences) {\r\n            UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.self !== undefined) {\r\n            UserPresence.encode(message.self, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.chanel_label !== \"\") {\r\n            writer.uint32(34).string(message.chanel_label);\r\n        }\r\n        if (message.clan_logo !== \"\") {\r\n            writer.uint32(42).string(message.clan_logo);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(50).string(message.category_name);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannel();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.presences.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.self = UserPresence.decode(reader, reader.uint32());\r\n                    break;\r\n                case 4:\r\n                    message.chanel_label = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.clan_logo = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            presences: Array.isArray(object?.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : [],\r\n            self: isSet(object.self) ? UserPresence.fromJSON(object.self) : undefined,\r\n            chanel_label: isSet(object.chanel_label) ? String(object.chanel_label) : \"\",\r\n            clan_logo: isSet(object.clan_logo) ? String(object.clan_logo) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        if (message.presences) {\r\n            obj.presences = message.presences.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.presences = [];\r\n        }\r\n        message.self !== undefined && (obj.self = message.self ? UserPresence.toJSON(message.self) : undefined);\r\n        message.chanel_label !== undefined && (obj.chanel_label = message.chanel_label);\r\n        message.clan_logo !== undefined && (obj.clan_logo = message.clan_logo);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Channel.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannel();\r\n        message.id = object.id ?? \"\";\r\n        message.presences = object.presences?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        message.self = (object.self !== undefined && object.self !== null)\r\n            ? UserPresence.fromPartial(object.self)\r\n            : undefined;\r\n        message.chanel_label = object.chanel_label ?? \"\";\r\n        message.clan_logo = object.clan_logo ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanJoin() {\r\n    return { clan_id: \"\" };\r\n}\r\nconst ClanJoin = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanJoin();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanJoin.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanJoin();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelJoin() {\r\n    return { clan_id: \"\", channel_id: \"\", channel_type: 0 };\r\n}\r\nconst ChannelJoin = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(24).int32(message.channel_type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelJoin();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelJoin.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelJoin();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelLeave() {\r\n    return { clan_id: \"\", channel_id: \"\", channel_type: 0 };\r\n}\r\nconst ChannelLeave = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(24).int32(message.channel_type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelLeave();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelLeave.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelLeave();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessageAck() {\r\n    return {\r\n        channel_id: \"\",\r\n        message_id: \"\",\r\n        code: undefined,\r\n        username: \"\",\r\n        create_time: undefined,\r\n        update_time: undefined,\r\n        persistent: undefined,\r\n        clan_logo: \"\",\r\n        category_name: \"\",\r\n    };\r\n}\r\nconst ChannelMessageAck = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(18).string(message.message_id);\r\n        }\r\n        if (message.code !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.code }, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(34).string(message.username);\r\n        }\r\n        if (message.create_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.create_time), writer.uint32(42).fork()).ldelim();\r\n        }\r\n        if (message.update_time !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.update_time), writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.persistent !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.encode({ value: message.persistent }, writer.uint32(58).fork()).ldelim();\r\n        }\r\n        if (message.clan_logo !== \"\") {\r\n            writer.uint32(66).string(message.clan_logo);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(74).string(message.category_name);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessageAck();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.code = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 4:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.create_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 6:\r\n                    message.update_time = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.persistent = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.BoolValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 8:\r\n                    message.clan_logo = reader.string();\r\n                    break;\r\n                case 9:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            code: isSet(object.code) ? Number(object.code) : undefined,\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,\r\n            update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,\r\n            persistent: isSet(object.persistent) ? Boolean(object.persistent) : undefined,\r\n            clan_logo: isSet(object.clan_logo) ? String(object.clan_logo) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.code !== undefined && (obj.code = message.code);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.create_time !== undefined && (obj.create_time = message.create_time.toISOString());\r\n        message.update_time !== undefined && (obj.update_time = message.update_time.toISOString());\r\n        message.persistent !== undefined && (obj.persistent = message.persistent);\r\n        message.clan_logo !== undefined && (obj.clan_logo = message.clan_logo);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessageAck.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessageAck();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.code = object.code ?? undefined;\r\n        message.username = object.username ?? \"\";\r\n        message.create_time = object.create_time ?? undefined;\r\n        message.update_time = object.update_time ?? undefined;\r\n        message.persistent = object.persistent ?? undefined;\r\n        message.clan_logo = object.clan_logo ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessageSend() {\r\n    return {\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        content: \"\",\r\n        mentions: [],\r\n        attachments: [],\r\n        references: [],\r\n        mode: 0,\r\n        anonymous_message: false,\r\n        mention_everyone: false,\r\n        avatar: \"\",\r\n    };\r\n}\r\nconst ChannelMessageSend = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(26).string(message.content);\r\n        }\r\n        for (const v of message.mentions) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.encode(v, writer.uint32(34).fork()).ldelim();\r\n        }\r\n        for (const v of message.attachments) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.encode(v, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        for (const v of message.references) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageRef.encode(v, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(56).int32(message.mode);\r\n        }\r\n        if (message.anonymous_message === true) {\r\n            writer.uint32(64).bool(message.anonymous_message);\r\n        }\r\n        if (message.mention_everyone === true) {\r\n            writer.uint32(72).bool(message.mention_everyone);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(82).string(message.avatar);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessageSend();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.mentions.push(_api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 5:\r\n                    message.attachments.push(_api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 6:\r\n                    message.references.push(_api_api__WEBPACK_IMPORTED_MODULE_1__.MessageRef.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.anonymous_message = reader.bool();\r\n                    break;\r\n                case 9:\r\n                    message.mention_everyone = reader.bool();\r\n                    break;\r\n                case 10:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            mentions: Array.isArray(object?.mentions) ? object.mentions.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.fromJSON(e)) : [],\r\n            attachments: Array.isArray(object?.attachments)\r\n                ? object.attachments.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.fromJSON(e))\r\n                : [],\r\n            references: Array.isArray(object?.references) ? object.references.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageRef.fromJSON(e)) : [],\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            anonymous_message: isSet(object.anonymous_message) ? Boolean(object.anonymous_message) : false,\r\n            mention_everyone: isSet(object.mention_everyone) ? Boolean(object.mention_everyone) : false,\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        if (message.mentions) {\r\n            obj.mentions = message.mentions.map((e) => e ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.mentions = [];\r\n        }\r\n        if (message.attachments) {\r\n            obj.attachments = message.attachments.map((e) => e ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.attachments = [];\r\n        }\r\n        if (message.references) {\r\n            obj.references = message.references.map((e) => e ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageRef.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.references = [];\r\n        }\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.anonymous_message !== undefined && (obj.anonymous_message = message.anonymous_message);\r\n        message.mention_everyone !== undefined && (obj.mention_everyone = message.mention_everyone);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessageSend.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessageSend();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.mentions = object.mentions?.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.fromPartial(e)) || [];\r\n        message.attachments = object.attachments?.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.fromPartial(e)) || [];\r\n        message.references = object.references?.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageRef.fromPartial(e)) || [];\r\n        message.mode = object.mode ?? 0;\r\n        message.anonymous_message = object.anonymous_message ?? false;\r\n        message.mention_everyone = object.mention_everyone ?? false;\r\n        message.avatar = object.avatar ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessageUpdate() {\r\n    return {\r\n        clan_id: \"\",\r\n        channel_id: \"\",\r\n        message_id: \"\",\r\n        content: \"\",\r\n        mentions: [],\r\n        attachments: [],\r\n        mode: 0,\r\n        hide_editted: false,\r\n    };\r\n}\r\nconst ChannelMessageUpdate = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(26).string(message.message_id);\r\n        }\r\n        if (message.content !== \"\") {\r\n            writer.uint32(34).string(message.content);\r\n        }\r\n        for (const v of message.mentions) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.encode(v, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        for (const v of message.attachments) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.encode(v, writer.uint32(50).fork()).ldelim();\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(56).int32(message.mode);\r\n        }\r\n        if (message.hide_editted === true) {\r\n            writer.uint32(64).bool(message.hide_editted);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessageUpdate();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.content = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.mentions.push(_api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 6:\r\n                    message.attachments.push(_api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 7:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.hide_editted = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            content: isSet(object.content) ? String(object.content) : \"\",\r\n            mentions: Array.isArray(object?.mentions) ? object.mentions.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.fromJSON(e)) : [],\r\n            attachments: Array.isArray(object?.attachments)\r\n                ? object.attachments.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.fromJSON(e))\r\n                : [],\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            hide_editted: isSet(object.hide_editted) ? Boolean(object.hide_editted) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.content !== undefined && (obj.content = message.content);\r\n        if (message.mentions) {\r\n            obj.mentions = message.mentions.map((e) => e ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.mentions = [];\r\n        }\r\n        if (message.attachments) {\r\n            obj.attachments = message.attachments.map((e) => e ? _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.attachments = [];\r\n        }\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.hide_editted !== undefined && (obj.hide_editted = message.hide_editted);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessageUpdate.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessageUpdate();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.content = object.content ?? \"\";\r\n        message.mentions = object.mentions?.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageMention.fromPartial(e)) || [];\r\n        message.attachments = object.attachments?.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.MessageAttachment.fromPartial(e)) || [];\r\n        message.mode = object.mode ?? 0;\r\n        message.hide_editted = object.hide_editted ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelMessageRemove() {\r\n    return { clan_id: \"\", channel_id: \"\", message_id: \"\", mode: 0 };\r\n}\r\nconst ChannelMessageRemove = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(26).string(message.message_id);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(32).int32(message.mode);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelMessageRemove();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelMessageRemove.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelMessageRemove();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.mode = object.mode ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelPresenceEvent() {\r\n    return { channel_id: \"\", joins: [], leaves: [], clan_logo: \"\", category_name: \"\", mode: 0 };\r\n}\r\nconst ChannelPresenceEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        for (const v of message.joins) {\r\n            UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        for (const v of message.leaves) {\r\n            UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.clan_logo !== \"\") {\r\n            writer.uint32(34).string(message.clan_logo);\r\n        }\r\n        if (message.category_name !== \"\") {\r\n            writer.uint32(42).string(message.category_name);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(48).int32(message.mode);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelPresenceEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.joins.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.leaves.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 4:\r\n                    message.clan_logo = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.category_name = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            joins: Array.isArray(object?.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\r\n            leaves: Array.isArray(object?.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : [],\r\n            clan_logo: isSet(object.clan_logo) ? String(object.clan_logo) : \"\",\r\n            category_name: isSet(object.category_name) ? String(object.category_name) : \"\",\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        if (message.joins) {\r\n            obj.joins = message.joins.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.joins = [];\r\n        }\r\n        if (message.leaves) {\r\n            obj.leaves = message.leaves.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.leaves = [];\r\n        }\r\n        message.clan_logo !== undefined && (obj.clan_logo = message.clan_logo);\r\n        message.category_name !== undefined && (obj.category_name = message.category_name);\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelPresenceEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelPresenceEvent();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.joins = object.joins?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        message.leaves = object.leaves?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        message.clan_logo = object.clan_logo ?? \"\";\r\n        message.category_name = object.category_name ?? \"\";\r\n        message.mode = object.mode ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseError() {\r\n    return { code: 0, message: \"\", context: {} };\r\n}\r\nconst Error = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.code !== 0) {\r\n            writer.uint32(8).int32(message.code);\r\n        }\r\n        if (message.message !== \"\") {\r\n            writer.uint32(18).string(message.message);\r\n        }\r\n        Object.entries(message.context).forEach(([key, value]) => {\r\n            Error_ContextEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();\r\n        });\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseError();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.code = reader.int32();\r\n                    break;\r\n                case 2:\r\n                    message.message = reader.string();\r\n                    break;\r\n                case 3:\r\n                    const entry3 = Error_ContextEntry.decode(reader, reader.uint32());\r\n                    if (entry3.value !== undefined) {\r\n                        message.context[entry3.key] = entry3.value;\r\n                    }\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            code: isSet(object.code) ? Number(object.code) : 0,\r\n            message: isSet(object.message) ? String(object.message) : \"\",\r\n            context: isObject(object.context)\r\n                ? Object.entries(object.context).reduce((acc, [key, value]) => {\r\n                    acc[key] = String(value);\r\n                    return acc;\r\n                }, {})\r\n                : {},\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.code !== undefined && (obj.code = Math.round(message.code));\r\n        message.message !== undefined && (obj.message = message.message);\r\n        obj.context = {};\r\n        if (message.context) {\r\n            Object.entries(message.context).forEach(([k, v]) => {\r\n                obj.context[k] = v;\r\n            });\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Error.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseError();\r\n        message.code = object.code ?? 0;\r\n        message.message = object.message ?? \"\";\r\n        message.context = Object.entries(object.context ?? {}).reduce((acc, [key, value]) => {\r\n            if (value !== undefined) {\r\n                acc[key] = String(value);\r\n            }\r\n            return acc;\r\n        }, {});\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseError_ContextEntry() {\r\n    return { key: \"\", value: \"\" };\r\n}\r\nconst Error_ContextEntry = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.key !== \"\") {\r\n            writer.uint32(10).string(message.key);\r\n        }\r\n        if (message.value !== \"\") {\r\n            writer.uint32(18).string(message.value);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseError_ContextEntry();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.key = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.value = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.key !== undefined && (obj.key = message.key);\r\n        message.value !== undefined && (obj.value = message.value);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Error_ContextEntry.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseError_ContextEntry();\r\n        message.key = object.key ?? \"\";\r\n        message.value = object.value ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotifications() {\r\n    return { notifications: [] };\r\n}\r\nconst Notifications = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.notifications) {\r\n            _api_api__WEBPACK_IMPORTED_MODULE_1__.Notification.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotifications();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.notifications.push(_api_api__WEBPACK_IMPORTED_MODULE_1__.Notification.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            notifications: Array.isArray(object?.notifications)\r\n                ? object.notifications.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.Notification.fromJSON(e))\r\n                : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.notifications) {\r\n            obj.notifications = message.notifications.map((e) => e ? _api_api__WEBPACK_IMPORTED_MODULE_1__.Notification.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.notifications = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Notifications.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotifications();\r\n        message.notifications = object.notifications?.map((e) => _api_api__WEBPACK_IMPORTED_MODULE_1__.Notification.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePing() {\r\n    return {};\r\n}\r\nconst Ping = {\r\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePing();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(_) {\r\n        return {};\r\n    },\r\n    toJSON(_) {\r\n        const obj = {};\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Ping.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(_) {\r\n        const message = createBasePing();\r\n        return message;\r\n    },\r\n};\r\nfunction createBasePong() {\r\n    return {};\r\n}\r\nconst Pong = {\r\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBasePong();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(_) {\r\n        return {};\r\n    },\r\n    toJSON(_) {\r\n        const obj = {};\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Pong.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(_) {\r\n        const message = createBasePong();\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStatus() {\r\n    return { presences: [] };\r\n}\r\nconst Status = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.presences) {\r\n            UserPresence.encode(v, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStatus();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.presences.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            presences: Array.isArray(object?.presences) ? object.presences.map((e) => UserPresence.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.presences) {\r\n            obj.presences = message.presences.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.presences = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Status.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStatus();\r\n        message.presences = object.presences?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStatusFollow() {\r\n    return { user_ids: [], usernames: [] };\r\n}\r\nconst StatusFollow = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        for (const v of message.usernames) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStatusFollow();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                case 2:\r\n                    message.usernames.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n            usernames: Array.isArray(object?.usernames) ? object.usernames.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        if (message.usernames) {\r\n            obj.usernames = message.usernames.map((e) => e);\r\n        }\r\n        else {\r\n            obj.usernames = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StatusFollow.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStatusFollow();\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        message.usernames = object.usernames?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStatusPresenceEvent() {\r\n    return { joins: [], leaves: [] };\r\n}\r\nconst StatusPresenceEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.joins) {\r\n            UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        for (const v of message.leaves) {\r\n            UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStatusPresenceEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 2:\r\n                    message.joins.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.leaves.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            joins: Array.isArray(object?.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\r\n            leaves: Array.isArray(object?.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.joins) {\r\n            obj.joins = message.joins.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.joins = [];\r\n        }\r\n        if (message.leaves) {\r\n            obj.leaves = message.leaves.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.leaves = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StatusPresenceEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStatusPresenceEvent();\r\n        message.joins = object.joins?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        message.leaves = object.leaves?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLastPinMessageEvent() {\r\n    return { clan_id: \"\", channel_id: \"\", message_id: \"\", mode: 0, user_id: \"\", timestamp: \"\", operation: 0 };\r\n}\r\nconst LastPinMessageEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(26).string(message.message_id);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(32).int32(message.mode);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(42).string(message.user_id);\r\n        }\r\n        if (message.timestamp !== \"\") {\r\n            writer.uint32(50).string(message.timestamp);\r\n        }\r\n        if (message.operation !== 0) {\r\n            writer.uint32(56).int32(message.operation);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLastPinMessageEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 5:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.timestamp = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.operation = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            timestamp: isSet(object.timestamp) ? String(object.timestamp) : \"\",\r\n            operation: isSet(object.operation) ? Number(object.operation) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.timestamp !== undefined && (obj.timestamp = message.timestamp);\r\n        message.operation !== undefined && (obj.operation = Math.round(message.operation));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LastPinMessageEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLastPinMessageEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.mode = object.mode ?? 0;\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.timestamp = object.timestamp ?? \"\";\r\n        message.operation = object.operation ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseLastSeenMessageEvent() {\r\n    return { channel_id: \"\", message_id: \"\", mode: 0, timestamp: \"\" };\r\n}\r\nconst LastSeenMessageEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.message_id !== \"\") {\r\n            writer.uint32(18).string(message.message_id);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(24).int32(message.mode);\r\n        }\r\n        if (message.timestamp !== \"\") {\r\n            writer.uint32(34).string(message.timestamp);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseLastSeenMessageEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.message_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 4:\r\n                    message.timestamp = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            message_id: isSet(object.message_id) ? String(object.message_id) : \"\",\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            timestamp: isSet(object.timestamp) ? String(object.timestamp) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.message_id !== undefined && (obj.message_id = message.message_id);\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.timestamp !== undefined && (obj.timestamp = message.timestamp);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return LastSeenMessageEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseLastSeenMessageEvent();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.message_id = object.message_id ?? \"\";\r\n        message.mode = object.mode ?? 0;\r\n        message.timestamp = object.timestamp ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseMessageTypingEvent() {\r\n    return { clan_id: \"\", channel_id: \"\", sender_id: \"\", mode: 0 };\r\n}\r\nconst MessageTypingEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.sender_id !== \"\") {\r\n            writer.uint32(26).string(message.sender_id);\r\n        }\r\n        if (message.mode !== 0) {\r\n            writer.uint32(32).int32(message.mode);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseMessageTypingEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.sender_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            sender_id: isSet(object.sender_id) ? String(object.sender_id) : \"\",\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.sender_id !== undefined && (obj.sender_id = message.sender_id);\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return MessageTypingEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseMessageTypingEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.sender_id = object.sender_id ?? \"\";\r\n        message.mode = object.mode ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseVoiceLeavedEvent() {\r\n    return { id: \"\", clan_id: \"\", voice_channel_id: \"\", voice_user_id: \"\" };\r\n}\r\nconst VoiceLeavedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        if (message.voice_channel_id !== \"\") {\r\n            writer.uint32(26).string(message.voice_channel_id);\r\n        }\r\n        if (message.voice_user_id !== \"\") {\r\n            writer.uint32(34).string(message.voice_user_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseVoiceLeavedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.voice_channel_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.voice_user_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            voice_channel_id: isSet(object.voice_channel_id) ? String(object.voice_channel_id) : \"\",\r\n            voice_user_id: isSet(object.voice_user_id) ? String(object.voice_user_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.voice_channel_id !== undefined && (obj.voice_channel_id = message.voice_channel_id);\r\n        message.voice_user_id !== undefined && (obj.voice_user_id = message.voice_user_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return VoiceLeavedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseVoiceLeavedEvent();\r\n        message.id = object.id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.voice_channel_id = object.voice_channel_id ?? \"\";\r\n        message.voice_user_id = object.voice_user_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseVoiceJoinedEvent() {\r\n    return {\r\n        clan_id: \"\",\r\n        clan_name: \"\",\r\n        id: \"\",\r\n        participant: \"\",\r\n        user_id: \"\",\r\n        voice_channel_label: \"\",\r\n        voice_channel_id: \"\",\r\n        last_screenshot: \"\",\r\n    };\r\n}\r\nconst VoiceJoinedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(18).string(message.clan_name);\r\n        }\r\n        if (message.id !== \"\") {\r\n            writer.uint32(26).string(message.id);\r\n        }\r\n        if (message.participant !== \"\") {\r\n            writer.uint32(34).string(message.participant);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(42).string(message.user_id);\r\n        }\r\n        if (message.voice_channel_label !== \"\") {\r\n            writer.uint32(50).string(message.voice_channel_label);\r\n        }\r\n        if (message.voice_channel_id !== \"\") {\r\n            writer.uint32(58).string(message.voice_channel_id);\r\n        }\r\n        if (message.last_screenshot !== \"\") {\r\n            writer.uint32(66).string(message.last_screenshot);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseVoiceJoinedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.participant = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.voice_channel_label = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.voice_channel_id = reader.string();\r\n                    break;\r\n                case 8:\r\n                    message.last_screenshot = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            participant: isSet(object.participant) ? String(object.participant) : \"\",\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            voice_channel_label: isSet(object.voice_channel_label) ? String(object.voice_channel_label) : \"\",\r\n            voice_channel_id: isSet(object.voice_channel_id) ? String(object.voice_channel_id) : \"\",\r\n            last_screenshot: isSet(object.last_screenshot) ? String(object.last_screenshot) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.participant !== undefined && (obj.participant = message.participant);\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.voice_channel_label !== undefined && (obj.voice_channel_label = message.voice_channel_label);\r\n        message.voice_channel_id !== undefined && (obj.voice_channel_id = message.voice_channel_id);\r\n        message.last_screenshot !== undefined && (obj.last_screenshot = message.last_screenshot);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return VoiceJoinedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseVoiceJoinedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.id = object.id ?? \"\";\r\n        message.participant = object.participant ?? \"\";\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.voice_channel_label = object.voice_channel_label ?? \"\";\r\n        message.voice_channel_id = object.voice_channel_id ?? \"\";\r\n        message.last_screenshot = object.last_screenshot ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseVoiceStartedEvent() {\r\n    return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\r\n}\r\nconst VoiceStartedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        if (message.voice_channel_id !== \"\") {\r\n            writer.uint32(26).string(message.voice_channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseVoiceStartedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.voice_channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            voice_channel_id: isSet(object.voice_channel_id) ? String(object.voice_channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.voice_channel_id !== undefined && (obj.voice_channel_id = message.voice_channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return VoiceStartedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseVoiceStartedEvent();\r\n        message.id = object.id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.voice_channel_id = object.voice_channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseVoiceEndedEvent() {\r\n    return { id: \"\", clan_id: \"\", voice_channel_id: \"\" };\r\n}\r\nconst VoiceEndedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(18).string(message.clan_id);\r\n        }\r\n        if (message.voice_channel_id !== \"\") {\r\n            writer.uint32(26).string(message.voice_channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseVoiceEndedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.voice_channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            voice_channel_id: isSet(object.voice_channel_id) ? String(object.voice_channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.voice_channel_id !== undefined && (obj.voice_channel_id = message.voice_channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return VoiceEndedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseVoiceEndedEvent();\r\n        message.id = object.id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.voice_channel_id = object.voice_channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelCreatedEvent() {\r\n    return {\r\n        clan_id: \"\",\r\n        category_id: \"\",\r\n        creator_id: \"\",\r\n        parrent_id: \"\",\r\n        channel_id: \"\",\r\n        channel_label: \"\",\r\n        channel_private: 0,\r\n        channel_type: undefined,\r\n        status: 0,\r\n    };\r\n}\r\nconst ChannelCreatedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(18).string(message.category_id);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(26).string(message.creator_id);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(34).string(message.parrent_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(42).string(message.channel_id);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(50).string(message.channel_label);\r\n        }\r\n        if (message.channel_private !== 0) {\r\n            writer.uint32(56).int32(message.channel_private);\r\n        }\r\n        if (message.channel_type !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.channel_type }, writer.uint32(66).fork()).ldelim();\r\n        }\r\n        if (message.status !== 0) {\r\n            writer.uint32(72).int32(message.status);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelCreatedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.channel_private = reader.int32();\r\n                    break;\r\n                case 8:\r\n                    message.channel_type = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 9:\r\n                    message.status = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_private: isSet(object.channel_private) ? Number(object.channel_private) : 0,\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : undefined,\r\n            status: isSet(object.status) ? Number(object.status) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_private !== undefined && (obj.channel_private = Math.round(message.channel_private));\r\n        message.channel_type !== undefined && (obj.channel_type = message.channel_type);\r\n        message.status !== undefined && (obj.status = Math.round(message.status));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelCreatedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelCreatedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_private = object.channel_private ?? 0;\r\n        message.channel_type = object.channel_type ?? undefined;\r\n        message.status = object.status ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelDeletedEvent() {\r\n    return { clan_id: \"\", category_id: \"\", parrent_id: \"\", channel_id: \"\", deletor: \"\" };\r\n}\r\nconst ChannelDeletedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(18).string(message.category_id);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(26).string(message.parrent_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(34).string(message.channel_id);\r\n        }\r\n        if (message.deletor !== \"\") {\r\n            writer.uint32(42).string(message.deletor);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelDeletedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.deletor = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            deletor: isSet(object.deletor) ? String(object.deletor) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.deletor !== undefined && (obj.deletor = message.deletor);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelDeletedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelDeletedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.deletor = object.deletor ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseChannelUpdatedEvent() {\r\n    return {\r\n        clan_id: \"\",\r\n        category_id: \"\",\r\n        creator_id: \"\",\r\n        parrent_id: \"\",\r\n        channel_id: \"\",\r\n        channel_label: \"\",\r\n        channel_type: undefined,\r\n        status: 0,\r\n    };\r\n}\r\nconst ChannelUpdatedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(18).string(message.category_id);\r\n        }\r\n        if (message.creator_id !== \"\") {\r\n            writer.uint32(26).string(message.creator_id);\r\n        }\r\n        if (message.parrent_id !== \"\") {\r\n            writer.uint32(34).string(message.parrent_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(42).string(message.channel_id);\r\n        }\r\n        if (message.channel_label !== \"\") {\r\n            writer.uint32(50).string(message.channel_label);\r\n        }\r\n        if (message.channel_type !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.encode({ value: message.channel_type }, writer.uint32(58).fork()).ldelim();\r\n        }\r\n        if (message.status !== 0) {\r\n            writer.uint32(64).int32(message.status);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseChannelUpdatedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.creator_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.parrent_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.channel_label = reader.string();\r\n                    break;\r\n                case 7:\r\n                    message.channel_type = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.Int32Value.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                case 8:\r\n                    message.status = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            creator_id: isSet(object.creator_id) ? String(object.creator_id) : \"\",\r\n            parrent_id: isSet(object.parrent_id) ? String(object.parrent_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            channel_label: isSet(object.channel_label) ? String(object.channel_label) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : undefined,\r\n            status: isSet(object.status) ? Number(object.status) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.creator_id !== undefined && (obj.creator_id = message.creator_id);\r\n        message.parrent_id !== undefined && (obj.parrent_id = message.parrent_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.channel_label !== undefined && (obj.channel_label = message.channel_label);\r\n        message.channel_type !== undefined && (obj.channel_type = message.channel_type);\r\n        message.status !== undefined && (obj.status = Math.round(message.status));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ChannelUpdatedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseChannelUpdatedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.creator_id = object.creator_id ?? \"\";\r\n        message.parrent_id = object.parrent_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.channel_label = object.channel_label ?? \"\";\r\n        message.channel_type = object.channel_type ?? undefined;\r\n        message.status = object.status ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStatusUnfollow() {\r\n    return { user_ids: [] };\r\n}\r\nconst StatusUnfollow = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(10).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStatusUnfollow();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [] };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StatusUnfollow.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStatusUnfollow();\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStatusUpdate() {\r\n    return { status: undefined };\r\n}\r\nconst StatusUpdate = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.status !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.status }, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStatusUpdate();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.status = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return { status: isSet(object.status) ? String(object.status) : undefined };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.status !== undefined && (obj.status = message.status);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StatusUpdate.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStatusUpdate();\r\n        message.status = object.status ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStream() {\r\n    return { mode: 0, channel_id: \"\", clan_id: \"\", label: \"\" };\r\n}\r\nconst Stream = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.mode !== 0) {\r\n            writer.uint32(8).int32(message.mode);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(18).string(message.channel_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(26).string(message.clan_id);\r\n        }\r\n        if (message.label !== \"\") {\r\n            writer.uint32(34).string(message.label);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStream();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.mode = reader.int32();\r\n                    break;\r\n                case 2:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.label = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            mode: isSet(object.mode) ? Number(object.mode) : 0,\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            label: isSet(object.label) ? String(object.label) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.mode !== undefined && (obj.mode = Math.round(message.mode));\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.label !== undefined && (obj.label = message.label);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return Stream.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStream();\r\n        message.mode = object.mode ?? 0;\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.label = object.label ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStreamData() {\r\n    return { stream: undefined, sender: undefined, data: \"\", reliable: false };\r\n}\r\nconst StreamData = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.stream !== undefined) {\r\n            Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        if (message.sender !== undefined) {\r\n            UserPresence.encode(message.sender, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.data !== \"\") {\r\n            writer.uint32(26).string(message.data);\r\n        }\r\n        if (message.reliable === true) {\r\n            writer.uint32(32).bool(message.reliable);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStreamData();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.stream = Stream.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.sender = UserPresence.decode(reader, reader.uint32());\r\n                    break;\r\n                case 3:\r\n                    message.data = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.reliable = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            stream: isSet(object.stream) ? Stream.fromJSON(object.stream) : undefined,\r\n            sender: isSet(object.sender) ? UserPresence.fromJSON(object.sender) : undefined,\r\n            data: isSet(object.data) ? String(object.data) : \"\",\r\n            reliable: isSet(object.reliable) ? Boolean(object.reliable) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.stream !== undefined && (obj.stream = message.stream ? Stream.toJSON(message.stream) : undefined);\r\n        message.sender !== undefined && (obj.sender = message.sender ? UserPresence.toJSON(message.sender) : undefined);\r\n        message.data !== undefined && (obj.data = message.data);\r\n        message.reliable !== undefined && (obj.reliable = message.reliable);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StreamData.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStreamData();\r\n        message.stream = (object.stream !== undefined && object.stream !== null)\r\n            ? Stream.fromPartial(object.stream)\r\n            : undefined;\r\n        message.sender = (object.sender !== undefined && object.sender !== null)\r\n            ? UserPresence.fromPartial(object.sender)\r\n            : undefined;\r\n        message.data = object.data ?? \"\";\r\n        message.reliable = object.reliable ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseStreamPresenceEvent() {\r\n    return { stream: undefined, joins: [], leaves: [] };\r\n}\r\nconst StreamPresenceEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.stream !== undefined) {\r\n            Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();\r\n        }\r\n        for (const v of message.joins) {\r\n            UserPresence.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        for (const v of message.leaves) {\r\n            UserPresence.encode(v, writer.uint32(26).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseStreamPresenceEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.stream = Stream.decode(reader, reader.uint32());\r\n                    break;\r\n                case 2:\r\n                    message.joins.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.leaves.push(UserPresence.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            stream: isSet(object.stream) ? Stream.fromJSON(object.stream) : undefined,\r\n            joins: Array.isArray(object?.joins) ? object.joins.map((e) => UserPresence.fromJSON(e)) : [],\r\n            leaves: Array.isArray(object?.leaves) ? object.leaves.map((e) => UserPresence.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.stream !== undefined && (obj.stream = message.stream ? Stream.toJSON(message.stream) : undefined);\r\n        if (message.joins) {\r\n            obj.joins = message.joins.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.joins = [];\r\n        }\r\n        if (message.leaves) {\r\n            obj.leaves = message.leaves.map((e) => e ? UserPresence.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.leaves = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return StreamPresenceEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseStreamPresenceEvent();\r\n        message.stream = (object.stream !== undefined && object.stream !== null)\r\n            ? Stream.fromPartial(object.stream)\r\n            : undefined;\r\n        message.joins = object.joins?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        message.leaves = object.leaves?.map((e) => UserPresence.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserPresence() {\r\n    return { user_id: \"\", session_id: \"\", username: \"\", persistence: false, status: undefined };\r\n}\r\nconst UserPresence = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.session_id !== \"\") {\r\n            writer.uint32(18).string(message.session_id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        if (message.persistence === true) {\r\n            writer.uint32(32).bool(message.persistence);\r\n        }\r\n        if (message.status !== undefined) {\r\n            _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.encode({ value: message.status }, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserPresence();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.session_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.persistence = reader.bool();\r\n                    break;\r\n                case 5:\r\n                    message.status = _google_protobuf_wrappers__WEBPACK_IMPORTED_MODULE_3__.StringValue.decode(reader, reader.uint32()).value;\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            session_id: isSet(object.session_id) ? String(object.session_id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            persistence: isSet(object.persistence) ? Boolean(object.persistence) : false,\r\n            status: isSet(object.status) ? String(object.status) : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.session_id !== undefined && (obj.session_id = message.session_id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.persistence !== undefined && (obj.persistence = message.persistence);\r\n        message.status !== undefined && (obj.status = message.status);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserPresence.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserPresence();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.session_id = object.session_id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.persistence = object.persistence ?? false;\r\n        message.status = object.status ?? undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseCustomStatusEvent() {\r\n    return { clan_id: \"\", user_id: \"\", username: \"\", status: \"\" };\r\n}\r\nconst CustomStatusEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(18).string(message.user_id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        if (message.status !== \"\") {\r\n            writer.uint32(34).string(message.status);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseCustomStatusEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.status = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            status: isSet(object.status) ? String(object.status) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.status !== undefined && (obj.status = message.status);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return CustomStatusEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseCustomStatusEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.status = object.status ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseAddUsers() {\r\n    return { user_id: \"\", avatar: \"\", username: \"\" };\r\n}\r\nconst AddUsers = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(18).string(message.avatar);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(26).string(message.username);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseAddUsers();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.username = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return AddUsers.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseAddUsers();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserChannelAdded() {\r\n    return { channel_id: \"\", users: [], status: \"\", clan_id: \"\", channel_type: 0 };\r\n}\r\nconst UserChannelAdded = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        for (const v of message.users) {\r\n            AddUsers.encode(v, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        if (message.status !== \"\") {\r\n            writer.uint32(26).string(message.status);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(34).string(message.clan_id);\r\n        }\r\n        if (message.channel_type !== 0) {\r\n            writer.uint32(40).int32(message.channel_type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserChannelAdded();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.users.push(AddUsers.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 3:\r\n                    message.status = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            users: Array.isArray(object?.users) ? object.users.map((e) => AddUsers.fromJSON(e)) : [],\r\n            status: isSet(object.status) ? String(object.status) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            channel_type: isSet(object.channel_type) ? Number(object.channel_type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        if (message.users) {\r\n            obj.users = message.users.map((e) => e ? AddUsers.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.users = [];\r\n        }\r\n        message.status !== undefined && (obj.status = message.status);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.channel_type !== undefined && (obj.channel_type = Math.round(message.channel_type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserChannelAdded.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserChannelAdded();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.users = object.users?.map((e) => AddUsers.fromPartial(e)) || [];\r\n        message.status = object.status ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.channel_type = object.channel_type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserChannelRemoved() {\r\n    return { channel_id: \"\", user_ids: [] };\r\n}\r\nconst UserChannelRemoved = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserChannelRemoved();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserChannelRemoved.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserChannelRemoved();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserClanRemoved() {\r\n    return { clan_id: \"\", user_ids: [] };\r\n}\r\nconst UserClanRemoved = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        for (const v of message.user_ids) {\r\n            writer.uint32(18).string(v);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserClanRemoved();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_ids.push(reader.string());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            user_ids: Array.isArray(object?.user_ids) ? object.user_ids.map((e) => String(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        if (message.user_ids) {\r\n            obj.user_ids = message.user_ids.map((e) => e);\r\n        }\r\n        else {\r\n            obj.user_ids = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserClanRemoved.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserClanRemoved();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.user_ids = object.user_ids?.map((e) => e) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanUpdatedEvent() {\r\n    return { clan_id: \"\", clan_name: \"\", clan_logo: \"\" };\r\n}\r\nconst ClanUpdatedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(18).string(message.clan_name);\r\n        }\r\n        if (message.clan_logo !== \"\") {\r\n            writer.uint32(26).string(message.clan_logo);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanUpdatedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_logo = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            clan_logo: isSet(object.clan_logo) ? String(object.clan_logo) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.clan_logo !== undefined && (obj.clan_logo = message.clan_logo);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanUpdatedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanUpdatedEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.clan_logo = object.clan_logo ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanProfileUpdatedEvent() {\r\n    return { user_id: \"\", clan_nick: \"\", clan_avatar: \"\", clan_id: \"\" };\r\n}\r\nconst ClanProfileUpdatedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.clan_nick !== \"\") {\r\n            writer.uint32(18).string(message.clan_nick);\r\n        }\r\n        if (message.clan_avatar !== \"\") {\r\n            writer.uint32(26).string(message.clan_avatar);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(34).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanProfileUpdatedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.clan_nick = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.clan_avatar = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            clan_nick: isSet(object.clan_nick) ? String(object.clan_nick) : \"\",\r\n            clan_avatar: isSet(object.clan_avatar) ? String(object.clan_avatar) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.clan_nick !== undefined && (obj.clan_nick = message.clan_nick);\r\n        message.clan_avatar !== undefined && (obj.clan_avatar = message.clan_avatar);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanProfileUpdatedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanProfileUpdatedEvent();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.clan_nick = object.clan_nick ?? \"\";\r\n        message.clan_avatar = object.clan_avatar ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserProfileUpdatedEvent() {\r\n    return { user_id: \"\", display_name: \"\", avatar: \"\", about_me: \"\", channel_id: \"\", clan_id: \"\" };\r\n}\r\nconst UserProfileUpdatedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(18).string(message.display_name);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(26).string(message.avatar);\r\n        }\r\n        if (message.about_me !== \"\") {\r\n            writer.uint32(34).string(message.about_me);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(42).string(message.channel_id);\r\n        }\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(50).string(message.clan_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserProfileUpdatedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.about_me = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 6:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n            about_me: isSet(object.about_me) ? String(object.about_me) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        message.about_me !== undefined && (obj.about_me = message.about_me);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserProfileUpdatedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserProfileUpdatedEvent();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        message.about_me = object.about_me ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseUserProfileRedis() {\r\n    return { user_id: \"\", username: \"\", avatar: \"\", display_name: \"\", fcm_tokens: [] };\r\n}\r\nconst UserProfileRedis = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(10).string(message.user_id);\r\n        }\r\n        if (message.username !== \"\") {\r\n            writer.uint32(18).string(message.username);\r\n        }\r\n        if (message.avatar !== \"\") {\r\n            writer.uint32(26).string(message.avatar);\r\n        }\r\n        if (message.display_name !== \"\") {\r\n            writer.uint32(34).string(message.display_name);\r\n        }\r\n        for (const v of message.fcm_tokens) {\r\n            FCMTokens.encode(v, writer.uint32(42).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseUserProfileRedis();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.username = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.avatar = reader.string();\r\n                    break;\r\n                case 4:\r\n                    message.display_name = reader.string();\r\n                    break;\r\n                case 5:\r\n                    message.fcm_tokens.push(FCMTokens.decode(reader, reader.uint32()));\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            username: isSet(object.username) ? String(object.username) : \"\",\r\n            avatar: isSet(object.avatar) ? String(object.avatar) : \"\",\r\n            display_name: isSet(object.display_name) ? String(object.display_name) : \"\",\r\n            fcm_tokens: Array.isArray(object?.fcm_tokens) ? object.fcm_tokens.map((e) => FCMTokens.fromJSON(e)) : [],\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.username !== undefined && (obj.username = message.username);\r\n        message.avatar !== undefined && (obj.avatar = message.avatar);\r\n        message.display_name !== undefined && (obj.display_name = message.display_name);\r\n        if (message.fcm_tokens) {\r\n            obj.fcm_tokens = message.fcm_tokens.map((e) => e ? FCMTokens.toJSON(e) : undefined);\r\n        }\r\n        else {\r\n            obj.fcm_tokens = [];\r\n        }\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return UserProfileRedis.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseUserProfileRedis();\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.username = object.username ?? \"\";\r\n        message.avatar = object.avatar ?? \"\";\r\n        message.display_name = object.display_name ?? \"\";\r\n        message.fcm_tokens = object.fcm_tokens?.map((e) => FCMTokens.fromPartial(e)) || [];\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseFCMTokens() {\r\n    return { device_id: \"\", token_id: \"\" };\r\n}\r\nconst FCMTokens = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.device_id !== \"\") {\r\n            writer.uint32(10).string(message.device_id);\r\n        }\r\n        if (message.token_id !== \"\") {\r\n            writer.uint32(18).string(message.token_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseFCMTokens();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.device_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.token_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            device_id: isSet(object.device_id) ? String(object.device_id) : \"\",\r\n            token_id: isSet(object.token_id) ? String(object.token_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.device_id !== undefined && (obj.device_id = message.device_id);\r\n        message.token_id !== undefined && (obj.token_id = message.token_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return FCMTokens.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseFCMTokens();\r\n        message.device_id = object.device_id ?? \"\";\r\n        message.token_id = object.token_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseClanNameExistedEvent() {\r\n    return { clan_name: \"\", exist: false };\r\n}\r\nconst ClanNameExistedEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_name !== \"\") {\r\n            writer.uint32(10).string(message.clan_name);\r\n        }\r\n        if (message.exist === true) {\r\n            writer.uint32(16).bool(message.exist);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseClanNameExistedEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_name = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.exist = reader.bool();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_name: isSet(object.clan_name) ? String(object.clan_name) : \"\",\r\n            exist: isSet(object.exist) ? Boolean(object.exist) : false,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_name !== undefined && (obj.clan_name = message.clan_name);\r\n        message.exist !== undefined && (obj.exist = message.exist);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return ClanNameExistedEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseClanNameExistedEvent();\r\n        message.clan_name = object.clan_name ?? \"\";\r\n        message.exist = object.exist ?? false;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationChannelSettingEvent() {\r\n    return { channel_id: \"\", notification_user_channel: undefined };\r\n}\r\nconst NotificationChannelSettingEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.notification_user_channel !== undefined) {\r\n            NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationChannelSettingEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            notification_user_channel: isSet(object.notification_user_channel)\r\n                ? NotificationUserChannel.fromJSON(object.notification_user_channel)\r\n                : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.notification_user_channel !== undefined &&\r\n            (obj.notification_user_channel = message.notification_user_channel\r\n                ? NotificationUserChannel.toJSON(message.notification_user_channel)\r\n                : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationChannelSettingEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationChannelSettingEvent();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.notification_user_channel =\r\n            (object.notification_user_channel !== undefined && object.notification_user_channel !== null)\r\n                ? NotificationUserChannel.fromPartial(object.notification_user_channel)\r\n                : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationUserChannel() {\r\n    return { id: \"\", notification_setting_type: 0, time_mute: undefined, active: 0 };\r\n}\r\nconst NotificationUserChannel = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.notification_setting_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_setting_type);\r\n        }\r\n        if (message.time_mute !== undefined) {\r\n            _google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();\r\n        }\r\n        if (message.active !== 0) {\r\n            writer.uint32(32).int32(message.active);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationUserChannel();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_setting_type = reader.int32();\r\n                    break;\r\n                case 3:\r\n                    message.time_mute = fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.decode(reader, reader.uint32()));\r\n                    break;\r\n                case 4:\r\n                    message.active = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            notification_setting_type: isSet(object.notification_setting_type) ? Number(object.notification_setting_type) : 0,\r\n            time_mute: isSet(object.time_mute) ? fromJsonTimestamp(object.time_mute) : undefined,\r\n            active: isSet(object.active) ? Number(object.active) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.notification_setting_type !== undefined &&\r\n            (obj.notification_setting_type = Math.round(message.notification_setting_type));\r\n        message.time_mute !== undefined && (obj.time_mute = message.time_mute.toISOString());\r\n        message.active !== undefined && (obj.active = Math.round(message.active));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationUserChannel.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationUserChannel();\r\n        message.id = object.id ?? \"\";\r\n        message.notification_setting_type = object.notification_setting_type ?? 0;\r\n        message.time_mute = object.time_mute ?? undefined;\r\n        message.active = object.active ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationCategorySettingEvent() {\r\n    return { category_id: \"\", notification_user_channel: undefined };\r\n}\r\nconst NotificationCategorySettingEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.category_id !== \"\") {\r\n            writer.uint32(10).string(message.category_id);\r\n        }\r\n        if (message.notification_user_channel !== undefined) {\r\n            NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationCategorySettingEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.category_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            category_id: isSet(object.category_id) ? String(object.category_id) : \"\",\r\n            notification_user_channel: isSet(object.notification_user_channel)\r\n                ? NotificationUserChannel.fromJSON(object.notification_user_channel)\r\n                : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.category_id !== undefined && (obj.category_id = message.category_id);\r\n        message.notification_user_channel !== undefined &&\r\n            (obj.notification_user_channel = message.notification_user_channel\r\n                ? NotificationUserChannel.toJSON(message.notification_user_channel)\r\n                : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationCategorySettingEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationCategorySettingEvent();\r\n        message.category_id = object.category_id ?? \"\";\r\n        message.notification_user_channel =\r\n            (object.notification_user_channel !== undefined && object.notification_user_channel !== null)\r\n                ? NotificationUserChannel.fromPartial(object.notification_user_channel)\r\n                : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationClanSettingEvent() {\r\n    return { clan_id: \"\", notification_setting: undefined };\r\n}\r\nconst NotificationClanSettingEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.clan_id !== \"\") {\r\n            writer.uint32(10).string(message.clan_id);\r\n        }\r\n        if (message.notification_setting !== undefined) {\r\n            NotificationSetting.encode(message.notification_setting, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationClanSettingEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.clan_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_setting = NotificationSetting.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            clan_id: isSet(object.clan_id) ? String(object.clan_id) : \"\",\r\n            notification_setting: isSet(object.notification_setting)\r\n                ? NotificationSetting.fromJSON(object.notification_setting)\r\n                : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.clan_id !== undefined && (obj.clan_id = message.clan_id);\r\n        message.notification_setting !== undefined && (obj.notification_setting = message.notification_setting\r\n            ? NotificationSetting.toJSON(message.notification_setting)\r\n            : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationClanSettingEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationClanSettingEvent();\r\n        message.clan_id = object.clan_id ?? \"\";\r\n        message.notification_setting = (object.notification_setting !== undefined && object.notification_setting !== null)\r\n            ? NotificationSetting.fromPartial(object.notification_setting)\r\n            : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotificationSetting() {\r\n    return { id: \"\", notification_setting_type: 0 };\r\n}\r\nconst NotificationSetting = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.notification_setting_type !== 0) {\r\n            writer.uint32(16).int32(message.notification_setting_type);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotificationSetting();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notification_setting_type = reader.int32();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            notification_setting_type: isSet(object.notification_setting_type) ? Number(object.notification_setting_type) : 0,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.notification_setting_type !== undefined &&\r\n            (obj.notification_setting_type = Math.round(message.notification_setting_type));\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotificationSetting.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotificationSetting();\r\n        message.id = object.id ?? \"\";\r\n        message.notification_setting_type = object.notification_setting_type ?? 0;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotifiReactMessageEvent() {\r\n    return { channel_id: \"\", notifi_react_message: undefined };\r\n}\r\nconst NotifiReactMessageEvent = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(10).string(message.channel_id);\r\n        }\r\n        if (message.notifi_react_message !== undefined) {\r\n            NotifiReactMessage.encode(message.notifi_react_message, writer.uint32(18).fork()).ldelim();\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotifiReactMessageEvent();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.notifi_react_message = NotifiReactMessage.decode(reader, reader.uint32());\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n            notifi_react_message: isSet(object.notifi_react_message)\r\n                ? NotifiReactMessage.fromJSON(object.notifi_react_message)\r\n                : undefined,\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        message.notifi_react_message !== undefined && (obj.notifi_react_message = message.notifi_react_message\r\n            ? NotifiReactMessage.toJSON(message.notifi_react_message)\r\n            : undefined);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotifiReactMessageEvent.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotifiReactMessageEvent();\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        message.notifi_react_message = (object.notifi_react_message !== undefined && object.notifi_react_message !== null)\r\n            ? NotifiReactMessage.fromPartial(object.notifi_react_message)\r\n            : undefined;\r\n        return message;\r\n    },\r\n};\r\nfunction createBaseNotifiReactMessage() {\r\n    return { id: \"\", user_id: \"\", channel_id: \"\" };\r\n}\r\nconst NotifiReactMessage = {\r\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Writer.create()) {\r\n        if (message.id !== \"\") {\r\n            writer.uint32(10).string(message.id);\r\n        }\r\n        if (message.user_id !== \"\") {\r\n            writer.uint32(18).string(message.user_id);\r\n        }\r\n        if (message.channel_id !== \"\") {\r\n            writer.uint32(26).string(message.channel_id);\r\n        }\r\n        return writer;\r\n    },\r\n    decode(input, length) {\r\n        const reader = input instanceof (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader) ? input : new (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default().Reader)(input);\r\n        let end = length === undefined ? reader.len : reader.pos + length;\r\n        const message = createBaseNotifiReactMessage();\r\n        while (reader.pos < end) {\r\n            const tag = reader.uint32();\r\n            switch (tag >>> 3) {\r\n                case 1:\r\n                    message.id = reader.string();\r\n                    break;\r\n                case 2:\r\n                    message.user_id = reader.string();\r\n                    break;\r\n                case 3:\r\n                    message.channel_id = reader.string();\r\n                    break;\r\n                default:\r\n                    reader.skipType(tag & 7);\r\n                    break;\r\n            }\r\n        }\r\n        return message;\r\n    },\r\n    fromJSON(object) {\r\n        return {\r\n            id: isSet(object.id) ? String(object.id) : \"\",\r\n            user_id: isSet(object.user_id) ? String(object.user_id) : \"\",\r\n            channel_id: isSet(object.channel_id) ? String(object.channel_id) : \"\",\r\n        };\r\n    },\r\n    toJSON(message) {\r\n        const obj = {};\r\n        message.id !== undefined && (obj.id = message.id);\r\n        message.user_id !== undefined && (obj.user_id = message.user_id);\r\n        message.channel_id !== undefined && (obj.channel_id = message.channel_id);\r\n        return obj;\r\n    },\r\n    create(base) {\r\n        return NotifiReactMessage.fromPartial(base ?? {});\r\n    },\r\n    fromPartial(object) {\r\n        const message = createBaseNotifiReactMessage();\r\n        message.id = object.id ?? \"\";\r\n        message.user_id = object.user_id ?? \"\";\r\n        message.channel_id = object.channel_id ?? \"\";\r\n        return message;\r\n    },\r\n};\r\nfunction toTimestamp(date) {\r\n    const seconds = date.getTime() / 1_000;\r\n    const nanos = (date.getTime() % 1_000) * 1_000_000;\r\n    return { seconds, nanos };\r\n}\r\nfunction fromTimestamp(t) {\r\n    let millis = t.seconds * 1_000;\r\n    millis += t.nanos / 1_000_000;\r\n    return new Date(millis);\r\n}\r\nfunction fromJsonTimestamp(o) {\r\n    if (o instanceof Date) {\r\n        return o;\r\n    }\r\n    else if (typeof o === \"string\") {\r\n        return new Date(o);\r\n    }\r\n    else {\r\n        return fromTimestamp(_google_protobuf_timestamp__WEBPACK_IMPORTED_MODULE_2__.Timestamp.fromJSON(o));\r\n    }\r\n}\r\nfunction isObject(value) {\r\n    return typeof value === \"object\" && value !== null;\r\n}\r\nfunction isSet(value) {\r\n    return value !== null && value !== undefined;\r\n}\r\n//# sourceMappingURL=realtime.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/rtapi/realtime.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/session.js":
/*!****************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/session.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Session: () => (/* binding */ Session)\n/* harmony export */ });\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-base64 */ \"../../node_modules/js-base64/base64.mjs\");\n/**\r\n * Copyright 2022 The Nakama Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nclass Session {\r\n    token;\r\n    created_at;\r\n    expires_at;\r\n    refresh_expires_at;\r\n    refresh_token;\r\n    user_id;\r\n    vars;\r\n    constructor(token, refresh_token) {\r\n        this.token = token;\r\n        this.refresh_token = refresh_token;\r\n        this.created_at = Math.floor(new Date().getTime() / 1000);\r\n        this.update(token, refresh_token);\r\n    }\r\n    isexpired(currenttime) {\r\n        return (this.expires_at - currenttime) < 0;\r\n    }\r\n    isrefreshexpired(currenttime) {\r\n        return (this.refresh_expires_at - currenttime) < 0;\r\n    }\r\n    update(token, refreshToken) {\r\n        const tokenParts = token.split('.');\r\n        if (tokenParts.length != 3) {\r\n            throw 'jwt is not valid.';\r\n        }\r\n        const tokenDecoded = JSON.parse(js_base64__WEBPACK_IMPORTED_MODULE_0__.atob(tokenParts[1]));\r\n        const tokenExpiresAt = Math.floor(parseInt(tokenDecoded['exp']));\r\n        /** clients that have just updated to the refresh tokens */\r\n        /** client release will not have a cached refresh token */\r\n        if (refreshToken) {\r\n            const refreshTokenParts = refreshToken.split('.');\r\n            if (refreshTokenParts.length != 3) {\r\n                throw 'refresh jwt is not valid.';\r\n            }\r\n            const refreshTokenDecoded = JSON.parse(js_base64__WEBPACK_IMPORTED_MODULE_0__.atob(refreshTokenParts[1]));\r\n            const refreshTokenExpiresAt = Math.floor(parseInt(refreshTokenDecoded['exp']));\r\n            this.refresh_expires_at = refreshTokenExpiresAt;\r\n            this.refresh_token = refreshToken;\r\n        }\r\n        this.token = token;\r\n        this.expires_at = tokenExpiresAt;\r\n        this.user_id = tokenDecoded['uid'];\r\n        this.vars = tokenDecoded['vrs'];\r\n    }\r\n    static restore(token, refreshToken) {\r\n        return new Session(token, refreshToken);\r\n    }\r\n}\r\n//# sourceMappingURL=session.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/session.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/socket.js":
/*!***************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/socket.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultSocket: () => (/* binding */ DefaultSocket)\n/* harmony export */ });\n/* harmony import */ var _web_socket_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web_socket_adapter */ \"./node_modules/mezon-sdk/dist/esm/web_socket_adapter.js\");\n/**\r\n * Copyright 2020 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/** A socket connection to Mezon server implemented with the DOM's WebSocket API. */\r\nclass DefaultSocket {\r\n    host;\r\n    port;\r\n    useSSL;\r\n    verbose;\r\n    adapter;\r\n    sendTimeoutMs;\r\n    static DefaultHeartbeatTimeoutMs = 10000;\r\n    static DefaultSendTimeoutMs = 10000;\r\n    static DefaultConnectTimeoutMs = 30000;\r\n    cIds;\r\n    nextCid;\r\n    _heartbeatTimeoutMs;\r\n    constructor(host, port, useSSL = false, verbose = false, adapter = new _web_socket_adapter__WEBPACK_IMPORTED_MODULE_0__.WebSocketAdapterText(), sendTimeoutMs = DefaultSocket.DefaultSendTimeoutMs) {\r\n        this.host = host;\r\n        this.port = port;\r\n        this.useSSL = useSSL;\r\n        this.verbose = verbose;\r\n        this.adapter = adapter;\r\n        this.sendTimeoutMs = sendTimeoutMs;\r\n        this.cIds = {};\r\n        this.nextCid = 1;\r\n        this._heartbeatTimeoutMs = DefaultSocket.DefaultHeartbeatTimeoutMs;\r\n    }\r\n    generatecid() {\r\n        const cid = this.nextCid.toString();\r\n        ++this.nextCid;\r\n        return cid;\r\n    }\r\n    isOpen() {\r\n        return this.adapter.isOpen();\r\n    }\r\n    connect(session, createStatus = false, connectTimeoutMs = DefaultSocket.DefaultConnectTimeoutMs) {\r\n        if (this.adapter.isOpen()) {\r\n            return Promise.resolve(session);\r\n        }\r\n        const scheme = (this.useSSL) ? \"wss://\" : \"ws://\";\r\n        this.adapter.connect(scheme, this.host, this.port, createStatus, session.token);\r\n        this.adapter.onClose = (evt) => {\r\n            this.ondisconnect(evt);\r\n        };\r\n        this.adapter.onError = (evt) => {\r\n            this.onerror(evt);\r\n        };\r\n        this.adapter.onMessage = (message) => {\r\n            if (this.verbose) {\r\n                console.log(\"Response: %o\", JSON.stringify(message));\r\n            }\r\n            /** Inbound message from server. */\r\n            if (!message.cid) {\r\n                if (message.voice_started_event) {\r\n                    this.onvoicestarted(message.voice_started_event);\r\n                }\r\n                else if (message.voice_ended_event) {\r\n                    this.onvoiceended(message.voice_ended_event);\r\n                }\r\n                else if (message.voice_joined_event) {\r\n                    this.onvoicejoined(message.voice_joined_event);\r\n                }\r\n                else if (message.voice_leaved_event) {\r\n                    this.onvoiceleaved(message.voice_leaved_event);\r\n                }\r\n                else if (message.channel_created_event) {\r\n                    this.onchannelcreated(message.channel_created_event);\r\n                }\r\n                else if (message.channel_deleted_event) {\r\n                    this.onchanneldeleted(message.channel_deleted_event);\r\n                }\r\n                else if (message.channel_updated_event) {\r\n                    this.onchannelupdated(message.channel_updated_event);\r\n                }\r\n                else if (message.clan_profile_updated_event) {\r\n                    this.onclanprofileupdated(message.clan_profile_updated_event);\r\n                }\r\n                else if (message.clan_updated_event) {\r\n                    this.onclanupdated(message.clan_updated_event);\r\n                }\r\n                else if (message.status_presence_event) {\r\n                    this.onstatuspresence(message.status_presence_event);\r\n                }\r\n                else if (message.stream_presence_event) {\r\n                    this.onstreampresence(message.stream_presence_event);\r\n                }\r\n                else if (message.stream_data) {\r\n                    this.onstreamdata(message.stream_data);\r\n                }\r\n                else if (message.channel_message) {\r\n                    var content, reactions, mentions, attachments, references;\r\n                    try {\r\n                        content = JSON.parse(message.channel_message.content);\r\n                    }\r\n                    catch (e) {\r\n                        //console.log(\"content is invalid\", e)\r\n                    }\r\n                    try {\r\n                        reactions = JSON.parse(message.channel_message.reactions);\r\n                    }\r\n                    catch (e) {\r\n                        //console.log(\"reactions is invalid\", e)\r\n                    }\r\n                    try {\r\n                        mentions = JSON.parse(message.channel_message.mentions);\r\n                    }\r\n                    catch (e) {\r\n                        //console.log(\"mentions is invalid\", e)\r\n                    }\r\n                    try {\r\n                        attachments = JSON.parse(message.channel_message.attachments);\r\n                    }\r\n                    catch (e) {\r\n                        //console.log(\"attachments is invalid\", e)\r\n                    }\r\n                    try {\r\n                        references = JSON.parse(message.channel_message.references);\r\n                    }\r\n                    catch (e) {\r\n                        //console.log(\"references is invalid\", e);\r\n                    }\r\n                    var e = {\r\n                        id: message.id,\r\n                        avatar: message.channel_message.avatar,\r\n                        channel_id: message.channel_message.channel_id,\r\n                        mode: message.channel_message.mode,\r\n                        channel_label: message.channel_message.channel_label,\r\n                        clan_id: message.channel_message.clan_id,\r\n                        code: message.channel_message.code,\r\n                        create_time: message.channel_message.create_time,\r\n                        message_id: message.channel_message.message_id,\r\n                        sender_id: message.channel_message.sender_id,\r\n                        update_time: message.channel_message.update_time,\r\n                        clan_logo: message.channel_message.clan_logo,\r\n                        category_name: message.channel_message.category_name,\r\n                        username: message.channel_message.username,\r\n                        clan_nick: message.channel_message.clan_nick,\r\n                        clan_avatar: message.channel_message.clan_avatar,\r\n                        display_name: message.channel_message.display_name,\r\n                        content: content,\r\n                        reactions: reactions,\r\n                        mentions: mentions,\r\n                        attachments: attachments,\r\n                        references: references,\r\n                    };\r\n                    this.onchannelmessage(e);\r\n                }\r\n                else if (message.message_typing_event) {\r\n                    this.onmessagetyping(message.message_typing_event);\r\n                }\r\n                else if (message.message_reaction_event) {\r\n                    this.onmessagereaction(message.message_reaction_event);\r\n                }\r\n                else if (message.channel_presence_event) {\r\n                    this.onchannelpresence(message.channel_presence_event);\r\n                }\r\n                else if (message.last_pin_message_event) {\r\n                    this.onpinmessage(message.last_pin_message_event);\r\n                }\r\n                else if (message.custom_status_event) {\r\n                    this.oncustomstatus(message.custom_status_event);\r\n                }\r\n                else if (message.user_channel_added_event) {\r\n                    this.onuserchanneladded(message.user_channel_added_event);\r\n                }\r\n                else if (message.user_channel_added_event) {\r\n                    this.onuserprofileupdate(message.user_profile_updated_event);\r\n                }\r\n                else if (message.user_profile_updated_event) {\r\n                    this.onuserchannelremoved(message.user_channel_removed_event);\r\n                }\r\n                else if (message.user_clan_removed_event) {\r\n                    this.onuserclanremoved(message.user_clan_removed_event);\r\n                }\r\n                else {\r\n                    if (this.verbose) {\r\n                        console.log(\"Unrecognized message received: %o\", message);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const executor = this.cIds[message.cid];\r\n                if (!executor) {\r\n                    if (this.verbose) {\r\n                        console.error(\"No promise executor for message: %o\", message);\r\n                    }\r\n                    return;\r\n                }\r\n                delete this.cIds[message.cid];\r\n                if (message.error) {\r\n                    executor.reject(message.error);\r\n                }\r\n                else {\r\n                    executor.resolve(message);\r\n                }\r\n            }\r\n        };\r\n        return new Promise((resolve, reject) => {\r\n            this.adapter.onOpen = (evt) => {\r\n                if (this.verbose) {\r\n                    console.log(evt);\r\n                }\r\n                this.pingPong();\r\n                resolve(session);\r\n            };\r\n            this.adapter.onError = (evt) => {\r\n                reject(evt);\r\n                this.adapter.close();\r\n            };\r\n            setTimeout(() => {\r\n                // if promise has resolved by now, the reject() is a no-op\r\n                reject(\"The socket timed out when trying to connect.\");\r\n            }, connectTimeoutMs);\r\n        });\r\n    }\r\n    disconnect(fireDisconnectEvent = true) {\r\n        if (this.adapter.isOpen()) {\r\n            this.adapter.close();\r\n        }\r\n        if (fireDisconnectEvent) {\r\n            this.ondisconnect({});\r\n        }\r\n    }\r\n    setHeartbeatTimeoutMs(ms) {\r\n        this._heartbeatTimeoutMs = ms;\r\n    }\r\n    getHeartbeatTimeoutMs() {\r\n        return this._heartbeatTimeoutMs;\r\n    }\r\n    ondisconnect(evt) {\r\n        if (this.verbose) {\r\n            console.log(evt);\r\n        }\r\n    }\r\n    onerror(evt) {\r\n        if (this.verbose) {\r\n            console.log(evt);\r\n        }\r\n    }\r\n    onmessagetyping(messagetyping) {\r\n        if (this.verbose) {\r\n            console.log(messagetyping);\r\n        }\r\n    }\r\n    onmessagereaction(messagereaction) {\r\n        if (this.verbose) {\r\n            console.log(messagereaction);\r\n        }\r\n    }\r\n    onchannelmessage(channelMessage) {\r\n        if (this.verbose) {\r\n            console.log(channelMessage);\r\n        }\r\n    }\r\n    onchannelpresence(channelPresence) {\r\n        if (this.verbose) {\r\n            console.log(channelPresence);\r\n        }\r\n    }\r\n    onuserchanneladded(user) {\r\n        if (this.verbose) {\r\n            console.log(user);\r\n        }\r\n    }\r\n    onuserprofileupdate(user) {\r\n        if (this.verbose) {\r\n            console.log(user);\r\n        }\r\n    }\r\n    onuserchannelremoved(user) {\r\n        if (this.verbose) {\r\n            console.log(user);\r\n        }\r\n    }\r\n    onuserclanremoved(user) {\r\n        if (this.verbose) {\r\n            console.log(user);\r\n        }\r\n    }\r\n    onstatuspresence(statusPresence) {\r\n        if (this.verbose) {\r\n            console.log(statusPresence);\r\n        }\r\n    }\r\n    onpinmessage(pin) {\r\n        if (this.verbose) {\r\n            console.log(pin);\r\n        }\r\n    }\r\n    onvoiceended(voice) {\r\n        if (this.verbose) {\r\n            console.log(voice);\r\n        }\r\n    }\r\n    onvoicestarted(voice) {\r\n        if (this.verbose) {\r\n            console.log(voice);\r\n        }\r\n    }\r\n    onvoicejoined(voiceParticipant) {\r\n        if (this.verbose) {\r\n            console.log(voiceParticipant);\r\n        }\r\n    }\r\n    onvoiceleaved(voiceParticipant) {\r\n        if (this.verbose) {\r\n            console.log(voiceParticipant);\r\n        }\r\n    }\r\n    onchannelcreated(channelCreated) {\r\n        if (this.verbose) {\r\n            console.log(channelCreated);\r\n        }\r\n    }\r\n    onchanneldeleted(channelDeleted) {\r\n        if (this.verbose) {\r\n            console.log(channelDeleted);\r\n        }\r\n    }\r\n    onchannelupdated(channelUpdated) {\r\n        if (this.verbose) {\r\n            console.log(channelUpdated);\r\n        }\r\n    }\r\n    onclanprofileupdated(clanprofile) {\r\n        if (this.verbose) {\r\n            console.log(clanprofile);\r\n        }\r\n    }\r\n    onclanupdated(clan) {\r\n        if (this.verbose) {\r\n            console.log(clan);\r\n        }\r\n    }\r\n    onstreampresence(streamPresence) {\r\n        if (this.verbose) {\r\n            console.log(streamPresence);\r\n        }\r\n    }\r\n    onstreamdata(streamData) {\r\n        if (this.verbose) {\r\n            console.log(streamData);\r\n        }\r\n    }\r\n    onheartbeattimeout() {\r\n        if (this.verbose) {\r\n            console.log(\"Heartbeat timeout.\");\r\n        }\r\n    }\r\n    oncustomstatus(statusEvent) {\r\n        if (this.verbose) {\r\n            console.log(statusEvent);\r\n        }\r\n    }\r\n    send(message, sendTimeout = DefaultSocket.DefaultSendTimeoutMs) {\r\n        const untypedMessage = message;\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.adapter.isOpen()) {\r\n                reject(\"Socket connection has not been established yet.\");\r\n            }\r\n            else {\r\n                if (untypedMessage.channel_message_send) {\r\n                    untypedMessage.channel_message_send.content = JSON.stringify(untypedMessage.channel_message_send.content);\r\n                }\r\n                else if (untypedMessage.channel_message_update) {\r\n                    untypedMessage.channel_message_update.content = JSON.stringify(untypedMessage.channel_message_update.content);\r\n                }\r\n                const cid = this.generatecid();\r\n                this.cIds[cid] = { resolve, reject };\r\n                setTimeout(() => {\r\n                    reject(\"The socket timed out while waiting for a response.\");\r\n                }, sendTimeout);\r\n                /** Add id for promise executor. */\r\n                untypedMessage.cid = cid;\r\n                this.adapter.send(untypedMessage);\r\n            }\r\n        });\r\n    }\r\n    async joinClanChat(clan_id) {\r\n        const response = await this.send({\r\n            clan_join: {\r\n                clan_id: clan_id,\r\n            }\r\n        });\r\n        return response.clan_join;\r\n    }\r\n    async joinChat(clan_id, channel_id, channel_type) {\r\n        const response = await this.send({\r\n            channel_join: {\r\n                clan_id: clan_id,\r\n                channel_id: channel_id,\r\n                channel_type: channel_type,\r\n            }\r\n        });\r\n        return response.channel;\r\n    }\r\n    leaveChat(clan_id, channel_id, channel_type) {\r\n        return this.send({ channel_leave: { clan_id: clan_id, channel_id: channel_id, channel_type: channel_type } });\r\n    }\r\n    async removeChatMessage(clan_id, channel_id, mode, message_id) {\r\n        const response = await this.send({\r\n            channel_message_remove: {\r\n                clan_id: clan_id,\r\n                channel_id: channel_id,\r\n                mode: mode,\r\n                message_id: message_id\r\n            }\r\n        });\r\n        return response.channel_message_ack;\r\n    }\r\n    async removePartyMember(party_id, member) {\r\n        return this.send({ party_remove: {\r\n                party_id: party_id,\r\n                presence: member\r\n            } });\r\n    }\r\n    async rpc(id, payload, http_key) {\r\n        const response = await this.send({\r\n            rpc: {\r\n                id: id,\r\n                payload: payload,\r\n                http_key: http_key,\r\n            }\r\n        });\r\n        return response.rpc;\r\n    }\r\n    sendPartyData(party_id, op_code, data) {\r\n        return this.send({ party_data_send: { party_id: party_id, op_code: op_code, data: data } });\r\n    }\r\n    unfollowUsers(user_ids) {\r\n        return this.send({ status_unfollow: { user_ids: user_ids } });\r\n    }\r\n    async updateChatMessage(clan_id, channel_id, mode, message_id, content, mentions, attachments) {\r\n        const response = await this.send({ channel_message_update: { clan_id: clan_id, channel_id: channel_id, message_id: message_id, content: content, mentions: mentions, attachments: attachments, mode: mode } });\r\n        return response.channel_message_ack;\r\n    }\r\n    updateStatus(status) {\r\n        return this.send({ status_update: { status: status } });\r\n    }\r\n    async writeChatMessage(clan_id, channel_id, mode, content, mentions, attachments, references, anonymous_message, mention_everyone, avatar) {\r\n        const response = await this.send({ channel_message_send: { clan_id: clan_id, channel_id: channel_id, mode: mode, content: content, mentions: mentions, attachments: attachments, references: references, anonymous_message: anonymous_message, mention_everyone: mention_everyone, avatar: avatar } });\r\n        return response.channel_message_ack;\r\n    }\r\n    async writeMessageReaction(id, clan_id, channel_id, mode, message_id, emoji_id, emoji, count, message_sender_id, action_delete) {\r\n        const response = await this.send({ message_reaction_event: { id: id, clan_id: clan_id, channel_id: channel_id, mode: mode, message_id: message_id, emoji_id: emoji_id, emoji: emoji, count: count, message_sender_id: message_sender_id, action: action_delete } });\r\n        return response.message_reaction_event;\r\n    }\r\n    async writeMessageTyping(clan_id, channel_id, mode) {\r\n        const response = await this.send({ message_typing_event: { clan_id: clan_id, channel_id: channel_id, mode: mode } });\r\n        return response.message_typing_event;\r\n    }\r\n    async writeLastSeenMessage(clan_id, channel_id, mode, message_id, timestamp) {\r\n        const response = await this.send({ last_seen_message_event: { clan_id: clan_id, channel_id: channel_id, mode: mode, message_id: message_id, timestamp: timestamp } });\r\n        return response.last_seen_message_event;\r\n    }\r\n    async writeLastPinMessage(clan_id, channel_id, mode, message_id, timestamp, operation) {\r\n        const response = await this.send({ last_pin_message_event: { clan_id: clan_id, channel_id: channel_id, mode: mode, message_id: message_id, timestamp: timestamp, operation: operation } });\r\n        return response.last_pin_message_event;\r\n    }\r\n    async writeVoiceJoined(id, clanId, clanName, voiceChannelId, voiceChannelLabel, participant, lastScreenshot) {\r\n        const response = await this.send({ voice_joined_event: { clan_id: clanId, clan_name: clanName, id: id, participant: participant, voice_channel_id: voiceChannelId, voice_channel_label: voiceChannelLabel, last_screenshot: lastScreenshot } });\r\n        return response.voice_joined_event;\r\n    }\r\n    async writeVoiceLeaved(id, clanId, voiceChannelId, voiceUserId) {\r\n        const response = await this.send({ voice_leaved_event: { id: id, clan_id: clanId, voice_channel_id: voiceChannelId, voice_user_id: voiceUserId } });\r\n        return response.voice_leaved_event;\r\n    }\r\n    async writeCustomStatus(clan_id, status) {\r\n        const response = await this.send({ custom_status_event: { clan_id: clan_id, status: status } });\r\n        return response.custom_status_event;\r\n    }\r\n    async checkDuplicateClanName(clan_name) {\r\n        const response = await this.send({ clan_name_existed_event: { clan_name: clan_name } });\r\n        return response.clan_name_existed_event;\r\n    }\r\n    async listClanEmojiByClanId(clan_id) {\r\n        const response = await this.send({ emojis_listed_event: { clan_id: clan_id } });\r\n        return response.emojis_listed_event;\r\n    }\r\n    async ListChannelByUserId() {\r\n        const response = await this.send({ channel_desc_list_event: {} });\r\n        return response.channel_desc_list_event;\r\n    }\r\n    async hashtagDMList(user_id, limit) {\r\n        const response = await this.send({ hashtag_dm_list_event: { user_id: user_id, limit: limit } });\r\n        return response.hashtag_dm_list_event;\r\n    }\r\n    async listClanStickersByClanId(clan_id) {\r\n        const response = await this.send({ sticker_listed_event: { clan_id: clan_id } });\r\n        return response.sticker_listed_event;\r\n    }\r\n    async getNotificationChannelSetting(channel_id) {\r\n        const response = await this.send({ notification_channel_setting_event: { channel_id: channel_id } });\r\n        return response.notification_channel_setting_event;\r\n    }\r\n    async getNotificationCategorySetting(category_id) {\r\n        const response = await this.send({ notification_category_setting_event: { category_id: category_id } });\r\n        return response.notification_category_setting_event;\r\n    }\r\n    async getNotificationClanSetting(clan_id) {\r\n        const response = await this.send({ notification_clan_setting_event: { clan_id: clan_id } });\r\n        return response.notification_clan_setting_event;\r\n    }\r\n    async getNotificationReactMessage(channel_id) {\r\n        const response = await this.send({ notifi_react_message_event: { channel_id: channel_id } });\r\n        return response.notifi_react_message_event;\r\n    }\r\n    async pingPong() {\r\n        if (!this.adapter.isOpen()) {\r\n            return;\r\n        }\r\n        try {\r\n            await this.send({ ping: {} }, this._heartbeatTimeoutMs);\r\n        }\r\n        catch {\r\n            if (this.adapter.isOpen()) {\r\n                if (this.verbose) {\r\n                    console.error(\"Server unreachable from heartbeat.\");\r\n                }\r\n                this.onheartbeattimeout();\r\n                this.adapter.close();\r\n            }\r\n            return;\r\n        }\r\n        // reuse the timeout as the interval for now.\r\n        // we can separate them out into separate values if needed later.\r\n        setTimeout(() => this.pingPong(), this._heartbeatTimeoutMs);\r\n    }\r\n}\r\n;\r\n//# sourceMappingURL=socket.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/socket.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   b64DecodeUnicode: () => (/* binding */ b64DecodeUnicode),\n/* harmony export */   b64EncodeUnicode: () => (/* binding */ b64EncodeUnicode),\n/* harmony export */   buildFetchOptions: () => (/* binding */ buildFetchOptions)\n/* harmony export */ });\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-base64 */ \"../../node_modules/js-base64/base64.mjs\");\n\r\nfunction buildFetchOptions(method, options, bodyJson) {\r\n    const fetchOptions = { ...{ method: method }, ...options };\r\n    fetchOptions.headers = { ...options.headers };\r\n    if (!Object.keys(fetchOptions.headers).includes(\"Accept\")) {\r\n        fetchOptions.headers[\"Accept\"] = \"application/json\";\r\n    }\r\n    if (!Object.keys(fetchOptions.headers).includes(\"Content-Type\")) {\r\n        fetchOptions.headers[\"Content-Type\"] = \"application/json\";\r\n    }\r\n    Object.keys(fetchOptions.headers).forEach((key) => {\r\n        if (!fetchOptions.headers[key]) {\r\n            delete fetchOptions.headers[key];\r\n        }\r\n    });\r\n    if (bodyJson) {\r\n        fetchOptions.body = bodyJson;\r\n    }\r\n    return fetchOptions;\r\n}\r\nfunction b64EncodeUnicode(str) {\r\n    return (0,js_base64__WEBPACK_IMPORTED_MODULE_0__.encode)(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function toSolidBytes(_match, p1) {\r\n        return String.fromCharCode(Number('0x' + p1));\r\n    }));\r\n}\r\nfunction b64DecodeUnicode(str) {\r\n    return decodeURIComponent((0,js_base64__WEBPACK_IMPORTED_MODULE_0__.decode)(str).split('').map(function (c) {\r\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n    }).join(''));\r\n}\r\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/utils.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/web_socket_adapter.js":
/*!***************************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/web_socket_adapter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketAdapterText: () => (/* binding */ WebSocketAdapterText)\n/* harmony export */ });\n/* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64-arraybuffer */ \"../../node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-base64 */ \"../../node_modules/js-base64/base64.mjs\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * Copyright 2020 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n\r\n/**\r\n * A text-based socket adapter that accepts and transmits payloads over UTF-8.\r\n */\r\nclass WebSocketAdapterText {\r\n    _socket;\r\n    get onClose() {\r\n        return this._socket.onclose;\r\n    }\r\n    set onClose(value) {\r\n        this._socket.onclose = value;\r\n    }\r\n    get onError() {\r\n        return this._socket.onerror;\r\n    }\r\n    set onError(value) {\r\n        this._socket.onerror = value;\r\n    }\r\n    get onMessage() {\r\n        return this._socket.onmessage;\r\n    }\r\n    set onMessage(value) {\r\n        if (value) {\r\n            this._socket.onmessage = (evt) => {\r\n                const message = JSON.parse(evt.data);\r\n                if (message.party_data && message.party_data.data) {\r\n                    message.party_data.data = new Uint8Array((0,base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__.decode)(message.party_data.data));\r\n                }\r\n                value(message);\r\n            };\r\n        }\r\n        else {\r\n            value = null;\r\n        }\r\n    }\r\n    get onOpen() {\r\n        return this._socket.onopen;\r\n    }\r\n    set onOpen(value) {\r\n        this._socket.onopen = value;\r\n    }\r\n    isOpen() {\r\n        return this._socket?.readyState == (ws__WEBPACK_IMPORTED_MODULE_1___default().OPEN);\r\n    }\r\n    connect(scheme, host, port, createStatus, token) {\r\n        const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(createStatus.toString())}&token=${encodeURIComponent(token)}`;\r\n        this._socket = new (ws__WEBPACK_IMPORTED_MODULE_1___default())(url);\r\n    }\r\n    close() {\r\n        this._socket.close();\r\n        this._socket = undefined;\r\n    }\r\n    send(msg) {\r\n        if (msg.party_data_send) {\r\n            // according to protobuf docs, int64 is encoded to JSON as string.\r\n            msg.party_data_send.op_code = msg.party_data_send.op_code.toString();\r\n            let payload = msg.party_data_send.data;\r\n            if (payload && payload instanceof Uint8Array) {\r\n                msg.party_data_send.data = (0,base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__.encode)(payload.buffer);\r\n            }\r\n            else if (payload) { // it's a string\r\n                msg.party_data_send.data = (0,js_base64__WEBPACK_IMPORTED_MODULE_2__.btoa)(payload);\r\n            }\r\n        }\r\n        this._socket.send(JSON.stringify(msg));\r\n    }\r\n}\r\n//# sourceMappingURL=web_socket_adapter.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/web_socket_adapter.js?");

/***/ }),

/***/ "./node_modules/mezon-sdk/dist/esm/web_socket_adapter_pb.js":
/*!******************************************************************!*\
  !*** ./node_modules/mezon-sdk/dist/esm/web_socket_adapter_pb.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketAdapterPb: () => (/* binding */ WebSocketAdapterPb)\n/* harmony export */ });\n/* harmony import */ var _rtapi_realtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rtapi/realtime */ \"./node_modules/mezon-sdk/dist/esm/rtapi/realtime.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * Copyright 2020 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n/**\r\n * A protocol buffer socket adapter that accepts and transmits payloads using the protobuf binary wire format.\r\n */\r\nclass WebSocketAdapterPb {\r\n    _socket;\r\n    constructor() {\r\n    }\r\n    get onClose() {\r\n        return this._socket.onclose;\r\n    }\r\n    set onClose(value) {\r\n        this._socket.onclose = value;\r\n    }\r\n    get onError() {\r\n        return this._socket.onerror;\r\n    }\r\n    set onError(value) {\r\n        this._socket.onerror = value;\r\n    }\r\n    get onMessage() {\r\n        return this._socket.onmessage;\r\n    }\r\n    set onMessage(value) {\r\n        if (value) {\r\n            this._socket.onmessage = (evt) => {\r\n                const buffer = evt.data;\r\n                const uintBuffer = new Uint8Array(buffer);\r\n                const envelope = _rtapi_realtime__WEBPACK_IMPORTED_MODULE_0__.Envelope.decode(uintBuffer);\r\n                if (envelope.channel_message) {\r\n                    if (envelope.channel_message.code == undefined) {\r\n                        //protobuf plugin does not default-initialize missing Int32Value fields\r\n                        envelope.channel_message.code = 0;\r\n                    }\r\n                }\r\n                value(envelope);\r\n            };\r\n        }\r\n        else {\r\n            value = null;\r\n        }\r\n    }\r\n    get onOpen() {\r\n        return this._socket.onopen;\r\n    }\r\n    set onOpen(value) {\r\n        this._socket.onopen = value;\r\n    }\r\n    isOpen() {\r\n        return this._socket?.readyState == (ws__WEBPACK_IMPORTED_MODULE_1___default().OPEN);\r\n    }\r\n    close() {\r\n        this._socket.close();\r\n        this._socket = undefined;\r\n    }\r\n    connect(scheme, host, port, createStatus, token) {\r\n        const url = `${scheme}${host}:${port}/ws?lang=en&status=${encodeURIComponent(createStatus.toString())}&token=${encodeURIComponent(token)}&format=protobuf`;\r\n        this._socket = new (ws__WEBPACK_IMPORTED_MODULE_1___default())(url);\r\n        this._socket.binaryType = \"arraybuffer\";\r\n    }\r\n    send(msg) {\r\n        if (msg.match_data_send) {\r\n            let payload = msg.match_data_send.data;\r\n            // can't send a string over protobuf\r\n            if (typeof payload == \"string\") {\r\n                msg.match_data_send.data = new TextEncoder().encode(payload);\r\n            }\r\n        }\r\n        else if (msg.party_data_send) {\r\n            let payload = msg.party_data_send.data;\r\n            // can't send a string over protobuf\r\n            if (typeof payload == \"string\") {\r\n                msg.party_data_send.data = new TextEncoder().encode(payload);\r\n            }\r\n        }\r\n        const envelopeWriter = _rtapi_realtime__WEBPACK_IMPORTED_MODULE_0__.Envelope.encode(_rtapi_realtime__WEBPACK_IMPORTED_MODULE_0__.Envelope.fromPartial(msg));\r\n        const encodedMsg = envelopeWriter.finish();\r\n        this._socket.send(encodedMsg);\r\n    }\r\n}\r\n//# sourceMappingURL=web_socket_adapter_pb.js.map\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/mezon-sdk/dist/esm/web_socket_adapter_pb.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\n\n// Utility\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Service;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\n\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\"\n                   && __webpack_require__.g\n                   && __webpack_require__.g.process\n                   && __webpack_require__.g.process.versions\n                   && __webpack_require__.g.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && __webpack_require__.g\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n * Copyright 2021 The Mezon Authors\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nexports.__esModule = true;\r\nvar mezon_sdk_1 = __webpack_require__(/*! mezon-sdk */ \"./node_modules/mezon-sdk/dist/esm/index.js\");\r\nvar client = new mezon_sdk_1.MezonClient(\"594c67737675324859665a5867716d54\");\r\nclient.authenticate().then(function (e) { return __awaiter(void 0, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        console.log(\"authenticated.\", e);\r\n        return [2 /*return*/];\r\n    });\r\n}); })[\"catch\"](function (e) {\r\n    console.log(\"error authenticating.\");\r\n});\r\nclient.onchannelmessage = function (msg) {\r\n    console.log(\"channel message\", msg);\r\n};\r\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./index.ts?");

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/./node_modules/ws/browser.js?");

/***/ }),

/***/ "../../node_modules/js-base64/base64.mjs":
/*!***********************************************!*\
  !*** ../../node_modules/js-base64/base64.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base64: () => (/* binding */ gBase64),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   atob: () => (/* binding */ _atob),\n/* harmony export */   atobPolyfill: () => (/* binding */ atobPolyfill),\n/* harmony export */   btoa: () => (/* binding */ _btoa),\n/* harmony export */   btoaPolyfill: () => (/* binding */ btoaPolyfill),\n/* harmony export */   btou: () => (/* binding */ btou),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeURI: () => (/* binding */ encodeURI),\n/* harmony export */   encodeURL: () => (/* binding */ encodeURI),\n/* harmony export */   extendBuiltins: () => (/* binding */ extendBuiltins),\n/* harmony export */   extendString: () => (/* binding */ extendString),\n/* harmony export */   extendUint8Array: () => (/* binding */ extendUint8Array),\n/* harmony export */   fromBase64: () => (/* binding */ decode),\n/* harmony export */   fromUint8Array: () => (/* binding */ fromUint8Array),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   toBase64: () => (/* binding */ encode),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   utob: () => (/* binding */ utob),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.4';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasatob = typeof atob === 'function';\nconst _hasbtoa = typeof btoa === 'function';\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = _hasbtoa ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = _hasatob ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins,\n};\n// makecjs:CUT //\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// and finally,\n\n\n\n//# sourceURL=webpack://mezon-sdk-webpack-example/../../node_modules/js-base64/base64.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;