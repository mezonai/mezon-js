// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { buildFetchOptions } from './utils';
import { encode } from 'js-base64';

/** A single user-role pair. */
export interface ChannelUserListChannelUser {
  //Their relationship to the role.
  role_id?: string;
  //User.
  user?: ApiUser;
}

/** A single user-role pair. */
export interface ClanUserListClanUser {
  //Their relationship to the role.
  role_id?: string;
  //User.
  user?: ApiUser;
}

/** A single user-role pair. */
export interface GroupUserListGroupUser {
  //Their relationship to the group.
  state?: number;
  //User.
  user?: ApiUser;
}

/** A single user-role pair. */
export interface RoleUserListRoleUser {
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //The id of the user's account.
  id?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //The timezone set by the user.
  online?: boolean;
  //The username of the user's account.
  username?: string;
}

/** A single group-role pair. */
export interface UserGroupListUserGroup {
  //Group.
  group?: ApiGroup;
  //The user's relationship to the group.
  state?: number;
}

/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  //The custom id in the user's account.
  custom_id?: string;
  //The devices which belong to the user's account.
  devices?: Array<ApiAccountDevice>;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned.
  disable_time?: string;
  //The email address of the user.
  email?: string;
  //The user object.
  user?: ApiUser;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified.
  verify_time?: string;
  //The user's wallet data.
  wallet?: string;
}

/** Send a Apple Sign In token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountApple {
  //The ID token received from Apple to validate.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a custom ID to the server. Used with authenticate/link/unlink. */
export interface ApiAccountCustom {
  //A custom identifier.
  id?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface ApiAccountDevice {
  //A device identifier. Should be obtained by a platform-specific device API.
  id?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.  Ignored with unlink operations.
  password?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Facebook token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebook {
  //The OAuth token received from Facebook to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebookInstantGame {
  //
  signed_player_info?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.

https://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign */
export interface ApiAccountGameCenter {
  //Bundle ID (generated by GameCenter).
  bundle_id?: string;
  //Player ID (generated by GameCenter).
  player_id?: string;
  //The URL for the public encryption key.
  public_key_url?: string;
  //A random "NSString" used to compute the hash and keep it randomized.
  salt?: string;
  //The verification signature data generated.
  signature?: string;
  //Time since UNIX epoch when the signature was created.
  timestamp_seconds?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Google token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGoogle {
  //The OAuth token received from Google to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Steam token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountSteam {
  //The account token received from Steam to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiCategoryDesc {
  //
  category_id?: string;
  //
  category_name?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
}

/**  */
export interface ApiCategoryDescList {
  //A list of channel.
  categorydesc?: Array<ApiCategoryDesc>;
}

/** A list of channel description, usually a result of a list operation. */
export interface ApiChannelDescList {
  //Cacheable cursor to list newer channel description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //A list of channel.
  channeldesc?: Array<ApiChannelDescription>;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}

/**  */
export interface ApiChannelDescription {
  //
  category_id?: string;
  //
  category_name?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_lable?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //creator ID.
  creator_id?: string;
  //The parrent channel this message belongs to.
  parrent_id?: string;
  //The channel type.
  type?: number;
}

/** A message sent on a channel. */
export interface ApiChannelMessage {
  //
  attachments?: Array<ApiMessageAttachment>;
  //
  avatar?: string;
  //The channel this message belongs to.
  channel_id: string;
  //The name of the chat room, or an empty string if this message was not sent through a chat room.
  channel_name: string;
  //The clan this message belong to.
  clan_id?: string;
  //The code representing a message type or category.
  code: number;
  //The content payload.
  content: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time: string;
  //
  mentions?: Array<ApiMessageMention>;
  //The unique ID of this message.
  message_id: string;
  //True if the message was persisted to the channel's history, false otherwise.
  persistent?: boolean;
  //
  reactions?: Array<ApiMessageReaction>;
  //Message sender, usually a user ID.
  sender_id: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  user_id_one?: string;
  //The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  user_id_two?: string;
  //The username of the message sender, if any.
  username: string;
}

/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  //Cacheable cursor to list newer messages. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //
  last_seen_message_id?: string;
  //A list of messages.
  messages?: Array<ApiChannelMessage>;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiChannelUserList {
  //
  channel_id?: string;
  //User-role pairs for a channel.
  channel_users?: Array<ChannelUserListChannelUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiClanDesc {
  //
  banner?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
}

/**  */
export interface ApiClanDescList {
  //A list of channel.
  clandesc?: Array<ApiClanDesc>;
}

/**  */
export interface ApiClanDescProfile {
  //
  avatar_url?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  nick_name?: string;
  //
  profile_banner?: string;
  //
  profile_theme?: string;
}

/** Get clan profile. */
export interface ApiClanProfile {
  //
  avartar?: string;
  //
  clan_id?: string;
  //
  nick_name?: string;
  //
  user_id?: string;
}

/** A list of users belonging to a clan, along with their role. */
export interface ApiClanUserList {
  //
  clan_id?: string;
  //User-role pairs for a clan.
  clan_users?: Array<ClanUserListClanUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiCreateCategoryDescRequest {
  //
  category_name?: string;
  //
  clan_id?: string;
}

/** Create a channel within clan. */
export interface ApiCreateChannelDescRequest {
  //
  category_id?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_lable?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //Group ID.
  group_id?: string;
  //The parrent channel this message belongs to.
  parrent_id?: string;
  //The channel type.
  type?: number;
  //The users to add.
  user_ids?: Array<string>;
}

/**  */
export interface ApiCreateClanDescRequest {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
}

/** Create a role within clan. */
export interface ApiCreateRoleRequest {
  //The permissions to add.
  active_permission_ids?: Array<string>;
  //The users to add.
  add_user_ids?: Array<string>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  role_icon?: string;
  //
  title?: string;
}

/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The version hash of the object.
  version?: string;
}

/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface ApiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/** A friend of a user. */
export interface ApiFriend {
  //The friend status.  one of "Friend.State".
  state?: number;
  //Time of the latest relationship update.
  update_time?: string;
  //The user object.
  user?: ApiUser;
}

/** A collection of zero or more friends of the user. */
export interface ApiFriendList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //The Friend objects.
  friends?: Array<ApiFriend>;
}

/** A group in the server. */
export interface ApiGroup {
  //A URL for an avatar image.
  avatar_url?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created.
  create_time?: string;
  //The id of the user who created the group.
  creator_id?: string;
  //A description for the group.
  description?: string;
  //The current count of all members in the group.
  edge_count?: number;
  //The id of a group.
  id?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The maximum number of members allowed.
  max_count?: number;
  //Additional information stored as a JSON object.
  metadata?: string;
  //The unique name of the group.
  name?: string;
  //Anyone can join open groups, otherwise only admins can accept members.
  open?: boolean;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was last updated.
  update_time?: string;
}

/** One or more groups returned from a listing operation. */
export interface ApiGroupList {
  //A cursor used to get the next page.
  cursor?: string;
  //One or more groups.
  groups?: Array<ApiGroup>;
}

/** A list of users belonging to a group, along with their role. */
export interface ApiGroupUserList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //User-role pairs for a group.
  group_users?: Array<GroupUserListGroupUser>;
}

/** Add link invite users to. */
export interface ApiInviteUserRes {
  //id channel to add link to.
  channel_id?: string;
  //
  channel_name?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  clan_name?: string;
}

/** Add link invite users to. */
export interface ApiLinkInviteUser {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  create_time?: string;
  //The user to add.
  creator_id?: string;
  //
  expiry_time?: string;
  //
  id?: string;
  //
  invite_link?: string;
}

/** Add link invite users to. */
export interface ApiLinkInviteUserRequest {
  //id channel to add link to.
  channel_id?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  expiry_time?: number;
}

/** Link Steam to the current user's account. */
export interface ApiLinkSteamRequest {
  //The Facebook account details.
  account?: ApiAccountSteam;
  //Import Steam friends for the user.
  sync?: boolean;
}

/**  */
export interface ApiMessageAttachment {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: string;
  //
  url?: string;
  //
  width?: number;
}

/**  */
export interface ApiMessageMention {
  //
  user_id?: string;
  //
  username?: string;
}

/**  */
export interface ApiMessageReaction {
  //
  create_time?: string;
  //
  emoji?: string;
  //
  user_id?: string;
}

/** A notification in the server. */
export interface ApiNotification {
  //Category code for this notification.
  code?: number;
  //Content of the notification in JSON.
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
  create_time?: string;
  //ID of the Notification.
  id?: string;
  //True if this notification was persisted to the database.
  persistent?: boolean;
  //ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  //Subject of the notification.
  subject?: string;
}

/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  //Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  //Collection of notifications.
  notifications?: Array<ApiNotification>;
}

/**  */
export interface ApiPermission {
  //
  active?: number;
  //
  description?: string;
  //
  id?: string;
  //
  slug?: string;
  //
  title?: string;
}

/** A list of permission description, usually a result of a list operation. */
export interface ApiPermissionList {
  //A list of permission.
  permissions?: Array<ApiPermission>;
}

/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The user owner of the object.
  user_id?: string;
}

/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}

/**  */
export interface ApiRole {
  //
  active?: number;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  id?: string;
  //
  permission_list?: ApiPermissionList;
  //
  role_icon?: string;
  //
  role_user_list?: ApiRoleUserList;
  //
  slug?: string;
  //
  title?: string;
}

/** A list of role description, usually a result of a list operation. */
export interface ApiRoleList {
  //Cacheable cursor to list newer role description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  //A list of role.
  roles?: Array<ApiRole>;
}

/**  */
export interface ApiRoleUserList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //role_users pairs for a clan.
  role_users?: Array<RoleUserListRoleUser>;
}

/** Execute an Lua function on the server. */
export interface ApiRpc {
  //The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  //The identifier of the function.
  id?: string;
  //The payload of the function which must be a JSON object.
  payload?: string;
}

/** A user's session used to authenticate messages. */
export interface ApiSession {
  //True if the corresponding account was just created, false otherwise.
  created?: boolean;
  //Refresh token that can be used for session token renewal.
  refresh_token?: string;
  //Authentication credentials.
  token?: string;
}

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface ApiSessionLogoutRequest {
  //Refresh token to invalidate.
  refresh_token?: string;
  //Session token to log out.
  token?: string;
}

/** Authenticate against the server with a refresh token. */
export interface ApiSessionRefreshRequest {
  //Refresh token.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** An object within the storage engine. */
export interface ApiStorageObject {
  //The collection which stores the object.
  collection?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
  create_time?: string;
  //The key of the object within the collection.
  key?: string;
  //The read access permissions for the object.
  permission_read?: number;
  //The write access permissions for the object.
  permission_write?: number;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
  update_time?: string;
  //The user owner of the object.
  user_id?: string;
  //The value of the object.
  value?: string;
  //The version hash of the object.
  version?: string;
}

/** A storage acknowledgement. */
export interface ApiStorageObjectAck {
  //The collection which stores the object.
  collection?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
  create_time?: string;
  //The key of the object within the collection.
  key?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
  update_time?: string;
  //The owner of the object.
  user_id?: string;
  //The version hash of the object.
  version?: string;
}

/** Batch of acknowledgements for the storage object write. */
export interface ApiStorageObjectAcks {
  //Batch of storage write acknowledgements.
  acks?: Array<ApiStorageObjectAck>;
}

/** List of storage objects. */
export interface ApiStorageObjectList {
  //The cursor for the next page of results, if any.
  cursor?: string;
  //The list of storage objects.
  objects?: Array<ApiStorageObject>;
}

/** Batch of storage objects. */
export interface ApiStorageObjects {
  //The batch of storage objects.
  objects?: Array<ApiStorageObject>;
}

/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //The timezone set by the user.
  timezone?: string;
  //The username of the user's account.
  username?: string;
}

/**  */
export interface ApiUpdateCategoryDescRequest {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
}

/** Fetch a batch of zero or more users from the server. */
export interface ApiUpdateUsersRequest {
  //The avarar_url of a user.
  avatar_url?: string;
  //The account username of a user.
  display_name?: string;
}

/**  */
export interface ApiUploadAttachment {
  //
  filename?: string;
  //
  id?: string;
  //
  url?: string;
}

/**  */
export interface ApiUploadAttachmentRequest {
 //
  channel_id?: string;
  //
  filename?: string;
  //
  filetype?: string;
 //
  height?: number;
  //
  message_id?: string;
  //
  size?: number;
  //
  width?: number;
}

/** A user in the server. */
export interface ApiUser {
  //The Apple Sign In ID in the user's account.
  apple_id?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created.
  create_time?: string;
  //The display name of the user.
  display_name?: string;
  //Number of related edges to this user.
  edge_count?: number;
  //The Facebook id in the user's account.
  facebook_id?: string;
  //The Apple Game Center in of the user's account.
  gamecenter_id?: string;
  //The Google id in the user's account.
  google_id?: string;
  //The id of the user's account.
  id?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //Additional information stored as a JSON object.
  metadata?: string;
  //Indicates whether the user is currently online.
  online?: boolean;
  //The Steam id in the user's account.
  steam_id?: string;
  //The timezone set by the user.
  timezone?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated.
  update_time?: string;
  //The username of the user's account.
  username?: string;
}

/** A list of groups belonging to a user, along with the user's role in each group. */
export interface ApiUserGroupList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //Group-role pairs for a user.
  user_groups?: Array<UserGroupListUserGroup>;
}

/** A collection of zero or more users. */
export interface ApiUsers {
  //The User objects.
  users?: Array<ApiUser>;
}

/** The object to store. */
export interface ApiWriteStorageObject {
  //The collection to store the object.
  collection?: string;
  //The key for the object within the collection.
  key?: string;
  //The read access permissions for the object.
  permission_read?: number;
  //The write access permissions for the object.
  permission_write?: number;
  //The value of the object.
  value?: string;
  //The version hash of the object to check. Possible values are: ["", "*", "#hash#"].  if-match and if-none-match
  version?: string;
}

/** Write objects to the storage engine. */
export interface ApiWriteStorageObjectsRequest {
  //The objects to store on the server.
  objects?: Array<ApiWriteStorageObject>;
}

/**  */
export interface ProtobufAny {
  //
  type_url?: string;
  // 
  value?: string;
}

/**  */
export interface RpcStatus {
  //
  code?: number;
  //
  details?: Array<ProtobufAny>;
  //
  message?: string;
}

export class MezonApi {

  constructor(readonly serverKey: string, readonly basePath: string, readonly timeoutMs: number) {}

  /** A healthcheck which load balancers can use to check the service. */
  healthcheck(bearerToken: string,
      options: any = {}): Promise<any> {
    
    const urlPath = "/healthcheck";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete the current user's account. */
  deleteAccount(bearerToken: string,
      options: any = {}): Promise<any> {
    
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch the current user's account. */
  getAccount(bearerToken: string,
      options: any = {}): Promise<ApiAccount> {
    
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in the current user's account. */
  updateAccount(bearerToken: string,
      body:ApiUpdateAccountRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with an Apple ID against the server. */
  authenticateApple(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountApple,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/apple";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a custom id against the server. */
  authenticateCustom(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountCustom,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/custom";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a device id against the server. */
  authenticateDevice(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountDevice,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/device";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with an email+password against the server. */
  authenticateEmail(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountEmail,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/email";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a Facebook OAuth token against the server. */
  authenticateFacebook(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountFacebook,
      create?:boolean,
      username?:string,
      sync?:boolean,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("sync", sync);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a Facebook Instant Game token against the server. */
  authenticateFacebookInstantGame(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountFacebookInstantGame,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/facebookinstantgame";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with Apple's GameCenter against the server. */
  authenticateGameCenter(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountGameCenter,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/gamecenter";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with Google against the server. */
  authenticateGoogle(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountGoogle,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/google";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with Steam against the server. */
  authenticateSteam(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountSteam,
      create?:boolean,
      username?:string,
      sync?:boolean,
      options: any = {}): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/steam";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("sync", sync);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add an Apple ID to the social profiles on the current user's account. */
  linkApple(bearerToken: string,
      body:ApiAccountApple,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/apple";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add a custom ID to the social profiles on the current user's account. */
  linkCustom(bearerToken: string,
      body:ApiAccountCustom,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/custom";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add a device ID to the social profiles on the current user's account. */
  linkDevice(bearerToken: string,
      body:ApiAccountDevice,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/device";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add an email+password to the social profiles on the current user's account. */
  linkEmail(bearerToken: string,
      body:ApiAccountEmail,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/email";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Facebook to the social profiles on the current user's account. */
  linkFacebook(bearerToken: string,
      account:ApiAccountFacebook,
      sync?:boolean,
      options: any = {}): Promise<any> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("sync", sync);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Facebook Instant Game to the social profiles on the current user's account. */
  linkFacebookInstantGame(bearerToken: string,
      body:ApiAccountFacebookInstantGame,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/facebookinstantgame";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Apple's GameCenter to the social profiles on the current user's account. */
  linkGameCenter(bearerToken: string,
      body:ApiAccountGameCenter,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/gamecenter";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Google to the social profiles on the current user's account. */
  linkGoogle(bearerToken: string,
      body:ApiAccountGoogle,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/google";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Steam to the social profiles on the current user's account. */
  linkSteam(bearerToken: string,
      body:ApiLinkSteamRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/steam";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  sessionRefresh(basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiSessionRefreshRequest,
      options: any = {}): Promise<ApiSession> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/session/refresh";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the Apple ID from the social profiles on the current user's account. */
  unlinkApple(bearerToken: string,
      body:ApiAccountApple,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/apple";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the custom ID from the social profiles on the current user's account. */
  unlinkCustom(bearerToken: string,
      body:ApiAccountCustom,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/custom";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the device ID from the social profiles on the current user's account. */
  unlinkDevice(bearerToken: string,
      body:ApiAccountDevice,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/device";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the email+password from the social profiles on the current user's account. */
  unlinkEmail(bearerToken: string,
      body:ApiAccountEmail,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/email";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Facebook from the social profiles on the current user's account. */
  unlinkFacebook(bearerToken: string,
      body:ApiAccountFacebook,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/facebook";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Facebook Instant Game profile from the social profiles on the current user's account. */
  unlinkFacebookInstantGame(bearerToken: string,
      body:ApiAccountFacebookInstantGame,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/facebookinstantgame";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Apple's GameCenter from the social profiles on the current user's account. */
  unlinkGameCenter(bearerToken: string,
      body:ApiAccountGameCenter,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/gamecenter";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Google from the social profiles on the current user's account. */
  unlinkGoogle(bearerToken: string,
      body:ApiAccountGoogle,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/google";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Steam from the social profiles on the current user's account. */
  unlinkSteam(bearerToken: string,
      body:ApiAccountSteam,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/steam";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  listCategoryDescs(bearerToken: string,
      clanId:string,
      creatorId?:string,
      categoryName?:string,
      categoryId?:string,
      options: any = {}): Promise<ApiCategoryDescList> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/categorydesc/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();
    queryParams.set("creator_id", creatorId);
    queryParams.set("category_name", categoryName);
    queryParams.set("category_id", categoryId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List a channel's message history. */
  listChannelMessages(bearerToken: string,
      channelId:string,
      limit?:number,
      forward?:boolean,
      cursor?:string,
      options: any = {}): Promise<ApiChannelMessageList> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("forward", forward);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List user channels */
  listChannelDescs(bearerToken: string,
      limit?:number,
      state?:number,
      cursor?:string,
      clanId?:string,
      channelType?:number,
      options: any = {}): Promise<ApiChannelDescList> {
    
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_type", channelType);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Create a new channel with the current user as the owner. */
  createChannelDesc(bearerToken: string,
      body:ApiCreateChannelDescRequest,
      options: any = {}): Promise<ApiChannelDescription> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}


  /** Delete a channel by ID. */
  deleteChannelDesc(bearerToken: string,
      channelId:string,
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given channel. */
  updateChannelDesc(bearerToken: string,
      channelId:string,
      body:{},
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add users to a channel. */
  addChannelUsers(bearerToken: string,
      channelId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}/add"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Leave a channel the user is a member of. */
  leaveChannel(bearerToken: string,
      channelId:string,
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}/leave"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Kick a set of users from a channel. */
  removeChannelUsers(bearerToken: string,
      channelId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}/remove"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all users that are part of a channel. */
  listChannelUsers(bearerToken: string,
      channelId:string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiChannelUserList> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}/user"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List clans */
  listClanDescs(bearerToken: string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiClanDescList> {
    
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Create a clan */
  createClanDesc(bearerToken: string,
      body:ApiCreateClanDescRequest,
      options: any = {}): Promise<ApiClanDesc> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete a clan desc by ID. */
  deleteClanDesc(bearerToken: string,
      clanDescId:string,
      options: any = {}): Promise<any> {
    
    if (clanDescId === null || clanDescId === undefined) {
      throw new Error("'clanDescId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clandesc/{clanDescId}"
        .replace("{clanDescId}", encodeURIComponent(String(clanDescId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given clan. */
  updateClanDesc(bearerToken: string,
      clanId:string,
      creatorId?:string,
      clanName?:string,
      logo?:string,
      banner?:string,
      options: any = {}): Promise<any> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
        const urlPath = "/v2/clandesc/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();
    queryParams.set("creator_id", creatorId);
    queryParams.set("clan_name", clanName);
    queryParams.set("logo", logo);
    queryParams.set("banner", banner);

    let bodyJson : string = "";
    
    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all users that are part of a clan. */
  listClanUsers(bearerToken: string,
      clanId:string,
      options: any = {}): Promise<ApiClanUserList> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clandesc/{clanId}/user"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Get a clan desc profile */
  getClanDescProfile(bearerToken: string,
      clanId:string,
      options: any = {}): Promise<ApiClanDescProfile> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clandescprofile/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given clan profile. */
  updateClanDescProfile(bearerToken: string,
      clanId:string,
      body:{},
      options: any = {}): Promise<any> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clandescprofile/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  createCategoryDesc(bearerToken: string,
      body:ApiCreateCategoryDescRequest,
      options: any = {}): Promise<ApiCategoryDesc> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/createcategory";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  deleteCategoryDesc(bearerToken: string,
      creatorId:string,
      options: any = {}): Promise<any> {
    
    if (creatorId === null || creatorId === undefined) {
      throw new Error("'creatorId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/deletecategory/{creatorId}"
        .replace("{creatorId}", encodeURIComponent(String(creatorId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Submit an event for processing in the server's registered runtime custom events handler. */
  event(bearerToken: string,
      body:ApiEvent,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/event";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete one or more users by ID or username. */
  deleteFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {
    
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all friends for the current user. */
  listFriends(bearerToken: string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiFriendList> {
    
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add friends by ID or username to a user's account. */
  addFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {
    
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Block one or more users by ID or username. */
  blockFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {
    
    const urlPath = "/v2/friend/block";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Import Facebook friends and add them to a user's account. */
  importFacebookFriends(bearerToken: string,
      account:ApiAccountFacebook,
      reset?:boolean,
      options: any = {}): Promise<any> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/friend/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("reset", reset);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Import Steam friends and add them to a user's account. */
  importSteamFriends(bearerToken: string,
      account:ApiAccountSteam,
      reset?:boolean,
      options: any = {}): Promise<any> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/friend/steam";
    const queryParams = new Map<string, any>();
    queryParams.set("reset", reset);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  getUserProfileOnClan(bearerToken: string,
      clanId:string,
      options: any = {}): Promise<ApiClanProfile> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/getclanprofile/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List groups based on given filters. */
  listGroups(bearerToken: string,
      name?:string,
      cursor?:string,
      limit?:number,
      langTag?:string,
      members?:number,
      open?:boolean,
      options: any = {}): Promise<ApiGroupList> {
    
    const urlPath = "/v2/group";
    const queryParams = new Map<string, any>();
    queryParams.set("name", name);
    queryParams.set("cursor", cursor);
    queryParams.set("limit", limit);
    queryParams.set("lang_tag", langTag);
    queryParams.set("members", members);
    queryParams.set("open", open);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete a group by ID. */
  deleteGroup(bearerToken: string,
      groupId:string,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given group. */
  updateGroup(bearerToken: string,
      groupId:string,
      body:{},
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add users to a group. */
  addGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/add"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Demote a set of users in a group to the next role down. */
  demoteGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/demote"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Immediately join an open group, or request to join a closed one. */
  joinGroup(bearerToken: string,
      groupId:string,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/join"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Leave a group the user is a member of. */
  leaveGroup(bearerToken: string,
      groupId:string,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/leave"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Promote a set of users in a group to the next role up. */
  promoteGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/promote"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Kick a set of users from a group. */
  kickGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/remove"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all users that are part of a group. */
  listGroupUsers(bearerToken: string,
      groupId:string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiGroupUserList> {
    
    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/user"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add users to a channel. */
  createLinkInviteUser(bearerToken: string,
      body:ApiLinkInviteUserRequest,
      options: any = {}): Promise<ApiLinkInviteUser> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/invite";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add users to a channel. */
  getLinkInvite(bearerToken: string,
      inviteId:string,
      options: any = {}): Promise<ApiInviteUserRes> {
    
    if (inviteId === null || inviteId === undefined) {
      throw new Error("'inviteId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/invite/{inviteId}"
        .replace("{inviteId}", encodeURIComponent(String(inviteId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add users to a channel. */
  inviteUser(bearerToken: string,
      inviteId:string,
      options: any = {}): Promise<ApiInviteUserRes> {
    
    if (inviteId === null || inviteId === undefined) {
      throw new Error("'inviteId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/invite/{inviteId}"
        .replace("{inviteId}", encodeURIComponent(String(inviteId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  getListPermission(bearerToken: string,
      options: any = {}): Promise<ApiPermissionList> {
    
    const urlPath = "/v2/listpermission";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete one or more notifications for the current user. */
  deleteNotifications(bearerToken: string,
      ids?:Array<string>,
      options: any = {}): Promise<any> {
    
    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch list of notifications. */
  listNotifications(bearerToken: string,
      limit?:number,
      cacheableCursor?:string,
      options: any = {}): Promise<ApiNotificationList> {
    
    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cacheable_cursor", cacheableCursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  GetPermissionOfUserInTheClan(bearerToken: string,
      clanId:string,
      options: any = {}): Promise<ApiPermissionList> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/permissionuserinclan/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List user roles */
  listRoles(bearerToken: string,
      limit?:number,
      state?:number,
      cursor?:string,
      clanId?:string,
      options: any = {}): Promise<ApiRoleList> {
    
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);
    queryParams.set("clan_id", clanId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Create a new role for clan. */
  createRole(bearerToken: string,
      body:ApiCreateRoleRequest,
      options: any = {}): Promise<ApiRole> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update a role when Delete a role by ID. */
  updateRoleDelete(bearerToken: string,
      roleId:string,
      body:{},
      options: any = {}): Promise<any> {
    
    if (roleId === null || roleId === undefined) {
      throw new Error("'roleId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/roles/delete/{roleId}"
        .replace("{roleId}", encodeURIComponent(String(roleId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete a role by ID. */
  deleteRole(bearerToken: string,
      roleId:string,
      options: any = {}): Promise<any> {
    
    if (roleId === null || roleId === undefined) {
      throw new Error("'roleId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/roles/{roleId}"
        .replace("{roleId}", encodeURIComponent(String(roleId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given role. */
  updateRole(bearerToken: string,
      roleId:string,
      body:{},
      options: any = {}): Promise<any> {
    
    if (roleId === null || roleId === undefined) {
      throw new Error("'roleId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/roles/{roleId}"
        .replace("{roleId}", encodeURIComponent(String(roleId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List role permissions */
  listRolePermissions(bearerToken: string,
      roleId:string,
      options: any = {}): Promise<ApiPermissionList> {
    
    if (roleId === null || roleId === undefined) {
      throw new Error("'roleId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/roles/{roleId}/permissions"
        .replace("{roleId}", encodeURIComponent(String(roleId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List role permissions */
  listRoleUsers(bearerToken: string,
      roleId:string,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiRoleUserList> {
    
    if (roleId === null || roleId === undefined) {
      throw new Error("'roleId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/roles/{roleId}/users"
        .replace("{roleId}", encodeURIComponent(String(roleId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Execute a Lua function on the server. */
  rpcFunc2(bearerToken: string,basicAuthUsername: string,
		basicAuthPassword: string,
      id:string,
      payload?:string,
      httpKey?:string,
      options: any = {}): Promise<ApiRpc> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/rpc/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();
    queryParams.set("payload", payload);
    queryParams.set("http_key", httpKey);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
		if (bearerToken) {
				fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
		}
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Execute a Lua function on the server. */
  rpcFunc(bearerToken: string,basicAuthUsername: string,
		basicAuthPassword: string,
      id:string,
      payload:string,
      httpKey?:string,
      options: any = {}): Promise<ApiRpc> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (payload === null || payload === undefined) {
      throw new Error("'payload' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/rpc/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();
    queryParams.set("http_key", httpKey);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(payload || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (bearerToken) {
				fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
		}
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  sessionLogout(bearerToken: string,
      body:ApiSessionLogoutRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/session/logout";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Get storage objects. */
  readStorageObjects(bearerToken: string,
      body:ApiReadStorageObjectsRequest,
      options: any = {}): Promise<ApiStorageObjects> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Write objects into the storage engine. */
  writeStorageObjects(bearerToken: string,
      body:ApiWriteStorageObjectsRequest,
      options: any = {}): Promise<ApiStorageObjectAcks> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete one or more objects by ID or username. */
  deleteStorageObjects(bearerToken: string,
      body:ApiDeleteStorageObjectsRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage/delete";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List publicly readable storage objects in a given collection. */
  listStorageObjects(bearerToken: string,
      collection:string,
      userId?:string,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiStorageObjectList> {
    
    if (collection === null || collection === undefined) {
      throw new Error("'collection' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage/{collection}"
        .replace("{collection}", encodeURIComponent(String(collection)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_id", userId);
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List publicly readable storage objects in a given collection. */
  listStorageObjects2(bearerToken: string,
      collection:string,
      userId:string,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiStorageObjectList> {
    
    if (collection === null || collection === undefined) {
      throw new Error("'collection' is a required parameter but is null or undefined.");
    }
    if (userId === null || userId === undefined) {
      throw new Error("'userId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage/{collection}/{userId}"
        .replace("{collection}", encodeURIComponent(String(collection)))
        .replace("{userId}", encodeURIComponent(String(userId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given category. */
  updateCategory(bearerToken: string,
      body:ApiUpdateCategoryDescRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/updatecategory";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  updateUserProfileByClan(bearerToken: string,
      clanId:string,
      body:{},
      options: any = {}): Promise<any> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/updateclanprofile/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Create a new group with the current user as the owner. */
  uploadAttachmentFile(bearerToken: string,
      body:ApiUploadAttachmentRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/uploadattachmentfile";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch zero or more users by ID and/or username. */
  getUsers(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      facebookIds?:Array<string>,
      options: any = {}): Promise<ApiUsers> {
    
    const urlPath = "/v2/user";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);
    queryParams.set("facebook_ids", facebookIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  updateUser(bearerToken: string,
      body:ApiUpdateUsersRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/user/update";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List groups the current user belongs to. */
  listUserGroups(bearerToken: string,
      userId:string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiUserGroupList> {
    
    if (userId === null || userId === undefined) {
      throw new Error("'userId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/user/{userId}/group"
        .replace("{userId}", encodeURIComponent(String(userId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

    buildFullUrl(basePath: string, fragment: string, queryParams: Map<string, any>) {
        let fullPath = basePath + fragment + "?";

        for (let [k, v] of queryParams) {
            if (v instanceof Array) {
                fullPath += v.reduce((prev: any, curr: any) => {
                return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
                }, "");
            } else {
                if (v != null) {
                    fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
                }
            }
        }

        return fullPath;
    }
};
