// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { buildFetchOptions } from "./utils";
import { encode } from "js-base64";

/** A single user-role pair. */
export interface ChannelUserListChannelUser {
  //
  clan_avatar?: string;
  //
  clan_id?: string;
  //
  clan_nick?: string;
  //
  id?: string;
  //Their relationship to the role.
  role_id?: Array<string>;
  //
  thread_id?: string;
  //User.
  user_id?: string;
  //Added by
  added_by?: string;
}

/** A single user-role pair. */
export interface ClanUserListClanUser {
  //from the `avatar_url` field in the `clan_desc_profile` table.
  clan_avatar?: string;
  //
  clan_id?: string;
  //from the `nick_name` field in the `clan_desc_profile` table.
  clan_nick?: string;
  //Their relationship to the role.
  role_id?: Array<string>;
  //User.
  user?: ApiUser;
}

/**  */
export interface GetPubKeysResponseUserPubKey {
  //
  PK?: ApiPubKey;
  //
  user_id?: string;
}

/**  */
export interface CountClanBadgeResponseBadge {
  //
  clan_id?: string;
  //
  count?: number;
}

/**  */
export interface MezonChangeChannelCategoryBody {
  //
  channel_id?: string;
  //
  clan_id?:string;
}

/**  */
export interface MezonSetChanEncryptionMethodBody {
  //
  method?: string;
}

/**  */
export interface MezonDeleteWebhookByIdBody {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/** Update app information. */
export interface MezonUpdateAppBody {
  //about the app.
  about?: string;
  //App url.
  app_url?: string;
  //Avatar URL.
  applogo?: string;
  //Username.
  appname?: string;
  //Metadata.
  metadata?: string;
  //Token.
  token?: string;
  //Shadow true|false
  is_shadow?:string;
}

/**  */
export interface MezonUpdateCategoryBody {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
}

/**  */
export interface ApiAddAppRequest {
  //
  about_me?: string;
  //
  app_logo?: string;
  //App url.
  app_url?: string;
  //The appname.
  appname?: string;
  //Creator of the app.
  creator_id?: string;
  //Is shadow.
  is_shadow?: boolean;
  //Role of this app.
  role?: number;
  //The password.
  token?: string;
}

/**
* - USER_ROLE_ADMIN: All access
 - USER_ROLE_DEVELOPER: Best for developers, also enables APIs and API explorer
 - USER_ROLE_MAINTAINER: Best for users who regularly update player information.
 - USER_ROLE_READONLY: Read-only role for those only need to view data
*/
export enum ApiAppRole {
  /*  */
  USER_ROLE_UNKNOWN = 0,
  /* */
  USER_ROLE_ADMIN = 1, // All access
  USER_ROLE_DEVELOPER = 2, // Best for developers, also enables APIs and API explorer
  USER_ROLE_MAINTAINER = 3, // Best for users who regularly update player information.
  USER_ROLE_READONLY = 4, // Read-only role for those only need to view data
}

/** Update fields in a given channel. */
export interface MezonUpdateChannelDescBody {
  //
  age_restricted?: number;
  //
  app_url?: string;
  //
  category_id?: string;
  //
  channel_label?: string;
  //
  e2ee?: number;
  //
  topic?: string;
}

/**  */
export interface MezonUpdateClanDescBody {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
  // is onboarding.
  is_onboarding?: boolean;
  // welcome channel id.
  welcome_channel_id?: string;
  //Onboarding_banner.
  onboarding_banner?: string;
  // is community.
  is_community?: boolean;
  // community banner
  community_banner?: string;
  // description
  description?: string;
  // about
  about?: string;
  // short url for community
  short_url?: string;
}

/**  */
export interface MezonUpdateClanDescProfileBody {
  //
  avatar_url?: string;
  //
  nick_name?: string;
  //
  profile_banner?: string;
  //
  profile_theme?: string;
}

/**  */
export interface MezonUpdateClanEmojiByIdBody {
  //
  category?: string;
  //
  clan_id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/**  */
export interface MezonUpdateClanStickerByIdBody {
  //
  category?: string;
  //
  clan_id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/** update a event within clan. */
export interface MezonUpdateEventBody {
  //
  event_id?: string;
  //
  address?: string;
  //
  channel_id?: string;
  //
  channel_voice_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
  //
  channel_id_old?: string;
  //
  repeat_type?: number;
}

/** Update fields in a given role. */
export interface MezonUpdateRoleBody {
  //The permissions to add.
  active_permission_ids?: Array<string>;
  //The users to add.
  add_user_ids?: Array<string>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  max_permission_id: string;
  //The permissions to remove.
  remove_permission_ids?: Array<string>;
  //The users to remove.
  remove_user_ids?: Array<string>;
  //
  role_icon?: string;
  //
  title?: string;
}

/** Delete a role the user has access to. */
export interface MezonUpdateRoleDeleteBody {
  //
  clan_id?: string;
}

/** Request to get system message by clan and channel IDs. */
export interface MezonUpdateSystemMessageBody {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  hide_audit_log?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/**  */
export interface MezonUpdateUserProfileByClanBody {
  //
  avatar?: string;
  //
  nick_name?: string;
}

/**  */
export interface MezonUpdateWebhookByIdBody {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  channel_id_update?: string;
  //
  clan_id?: string;
  //
  webhook_name?: string;
}

/** A single user-role pair. */
export interface RoleUserListRoleUser {
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //The id of the user's account.
  id?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //The timezone set by the user.
  online?: boolean;
  //The username of the user's account.
  username?: string;
}

/**  */
export interface UpdateClanOrderRequestClanOrder {
  //
  clan_id?: string;
  //
  order?: number;
}

/**  */
export interface ApiUpdateClanOrderRequest {
  //
  clans_order?: Array<UpdateClanOrderRequestClanOrder>;
}

/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  //The custom id in the user's account.
  custom_id?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned.
  disable_time?: string;
  //The email address of the user.
  email?: string;
  //
  encrypt_private_key?: string;
  //
  logo?: string;
  //
  splash_screen?: string;
  //The user object.
  user?: ApiUser;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified.
  verify_time?: string;
  //The user's wallet data.
  wallet?: number;
  //Password is setted
  password_setted?: boolean;
}

/** Send a app token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountApp {
  //
  appid?: string;
  //
  appname?: string;
  //The account token when create apps to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.  Ignored with unlink operations.
  password?: string;
  // Old email
  prev_email?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Mezon token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountMezon {
  //The phone number
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}


/**  */
export interface ApiAddFavoriteChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiAddFavoriteChannelResponse {
  //
  channel_id?: string;
}

/** Add a role for channel. */
export interface ApiAddRoleChannelDescRequest {
  //
  channel_id?: string;
  //
  role_ids?: Array<string>;
}

/**  */
export interface ApiAllUsersAddChannelResponse {
  //
  channel_id?: string;
  //
  limit?: number;
  //
  user_ids?: Array<string>;
}

/**  */
export interface ApiAllUserClans {
  //
  users?: Array<ApiUser>;
}

/** App information. */
export interface ApiApp {
  //
  about?: string;
  //
  app_url?: string;
  //
  applogo?: string;
  //
  appname?: string;
  //
  creator_id?: string;
  //The UNIX time when the app was disabled.
  disable_time?: string;
  //
  id?: string;
  //
  is_shadow?: boolean;
  //
  role?: number;
  //
  token?: string;
}

/** A list of apps. */
export interface ApiAppList {
  //A list of apps.
  apps?: Array<ApiApp>;
  //Next cursor.
  next_cursor?: string;
  //Approximate total number of apps.
  total_count?: number;
}

/**  */
export interface ApiAuditLog {
  //
  action_log?: string;
  //
  channel_id?: string;
  //
  channel_label?: string;
  //
  clan_id?: string;
  //
  details?: string;
  //
  entity_id?: string;
  //
  entity_name?: string;
  //
  id?: string;
  //
  time_log?: string;
  //
  user_id?: string;
}

/** Authenticate against the server with email+password. */
export interface ApiAuthenticateEmailRequest {
  //The email account details.
  account?: ApiAccountEmail;
  //Register the account if the user does not already exist.
  create?: boolean;
  //Set the username on the account at register. Must be unique.
  username?: string;
}

/**  */
export interface ApiCategoryDesc {
  //
  category_id?: string;
  //
  category_name?: string;
  //
  category_order?: number;
  //
  clan_id?: string;
  //
  creator_id?: string;
}

/**  */
export interface ApiCategoryDescList {
  //A list of channel.
  categorydesc?: Array<ApiCategoryDesc>;
}

/**  */
export interface ApiCategoryOrderUpdate {
  //
  category_id?: string;
  //
  order?: number;
}

/**  */
export interface ApiChanEncryptionMethod {
  //
  channel_id?: string;
  //
  method?: string;
}

export interface ApiListChannelAppsResponse {
  //
  channel_apps?: Array<ApiChannelAppResponse>;
}

/** Update fields in a given channel. */
export interface ApiChangeChannelPrivateRequest {
  //The clan id
  clan_id?: string;
  //The ID of the channel to update.
  channel_id?: string;
  //
  channel_private?: number;
  //
  role_ids?: Array<string>;
  //The users to add.
  user_ids?: Array<string>;
}

/**  */
export interface ApiChannelAppResponse {
  //
  app_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  app_url?: string;
}

/**  */
export interface ApiChannelAttachment {
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created.
  create_time?: string;
  //
  filename?: string;
  //
  filesize?: string;
  //
  filetype?: string;
  //
  id?: string;
  //
  uploader?: string;
  //
  url?: string;
  //message id.
  message_id?: string;
  //width.
  width?: number;
  //height.
  height?: number;
}

/**  */
export interface ApiChannelAttachmentList {
  //
  attachments?: Array<ApiChannelAttachment>;
}

/**  */
export interface ApiChannelCanvasDetailResponse {
  //
  content?: string;
  //
  creator_id?: string;
  //
  editor_id?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
}

/**  */
export interface ApiChannelCanvasItem {
  //
  content?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
}

/**  */
export interface ApiChannelCanvasListResponse {
  //
  channel_canvases?: Array<ApiChannelCanvasItem>;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  count?: number;
}

/**  */
export interface ApiEditChannelCanvasRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
  //
  status?: number;
}

/**  */
export interface ApiEditChannelCanvasResponse {
  //
  id?: string;
}

/** A list of channel description, usually a result of a list operation. */
export interface ApiChannelDescList {
  //Cacheable cursor to list newer channel description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //A list of channel.
  channeldesc?: Array<ApiChannelDescription>;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //
  page?: number;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}

/**  */
export interface ApiAddChannelAppRequest {
  //App url.
  app_url?: string;
  //The appname.
  appname?: string;
  //Creator of the app.
  creator_id?: string;
  //Role of this app.
  role?: number;
  //The password.
  token?: string;
}

/**  */
export interface ApiChannelDescription {
  //
  active?: number;
  //
  age_restricted?: number;
  //
  category_id?: string;
  //
  category_name?: string;
  //
  channel_avatar?: Array<string>;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  count_mess_unread?: number;
  //
  create_time_seconds?: number;
  //creator ID.
  creator_id?: string;
  //
  creator_name?: string;
  //
  e2ee?: number;
  //
  is_mute?: boolean;
  //
  last_pin_message?: string;
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  meeting_uri?: string;
  //The parent channel this message belongs to.
  parent_id?: string;
  //
  is_online?: Array<boolean>;
  //
  topic?: string;
  //The channel type.
  type?: number;
  //
  update_time_seconds?: number;
  //
  user_id?: Array<string>;
  //
  usernames?: Array<string>;
  //
  status?: number;
  //
  metadata?: Array<string>;
  //
  about_me?: Array<string>;
  //
  display_names?: Array<string>;
  //
  app_id?: string;
}

/** A message sent on a channel. */
export interface ApiChannelMessage {
  // id
  id: string;
  //
  attachments?: string;
  //
  avatar?: string;
  //
  category_name?: string;
  //The channel this message belongs to.
  channel_id: string;
  //The name of the chat room, or an empty string if this message was not sent through a chat room.
  channel_label: string;
  //The clan this message belong to.
  clan_id?: string;
  //
  clan_logo?: string;
  //
  clan_nick?: string;
  //
  clan_avatar?: string;
  //The code representing a message type or category.
  code: number;
  //The content payload.
  content: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  create_time_seconds?: number;
  //
  display_name?: string;
  //
  mentions?: string;
  //The unique ID of this message.
  message_id: string;
  //
  reactions?: string;
  //
  referenced_message?: string;
  //
  references?: string;
  //Message sender, usually a user ID.
  sender_id: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //
  update_time_seconds?: number;
  //The username of the message sender, if any.
  username?: string;
  // channel mode
  mode?: number;
  // hide editted
  hide_editted?: boolean;
  //
  topic_id?: string;
}

/**  */
export interface ApiChannelMessageHeader {
  //
  attachment?: string;
  //
  content?: string;
  //
  id?: string;
  //
  mention?: string;
  //
  reaction?: string;
  //
  reference?: string;
  //
  repliers?: Array<string>;
  //
  sender_id?: string;
  //
  timestamp_seconds?: number;
}

/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //A list of messages.
  messages?: Array<ApiChannelMessage>;
}

/**  */
export interface ApiChannelSettingItem {
  //
  active?: number;
  //
  category_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  channel_type?: number;
  //
  creator_id?: string;
  //
  id?: string;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  message_count?: string;
  //
  parent_id?: string;
  //
  user_ids?: Array<string>;
}

/**  */
export interface ApiChannelSettingListResponse {
  //
  channel_count?: number;
  //
  channel_setting_list?: Array<ApiChannelSettingItem>;
  //
  clan_id?: string;
  //
  thread_count?: number;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiChannelUserList {
  //
  channel_id?: string;
  //User-role pairs for a channel.
  channel_users?: Array<ChannelUserListChannelUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiCheckDuplicateClanNameResponse {
  //
  is_duplicate?: boolean;
}

/**  */
export interface ApiClanDesc {
  //
  banner?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
  //
  badge_count?: number;
  // is onboarding.
  is_onboarding?: boolean;
  // welcome channel id.
  welcome_channel_id?: string;
  //Onboarding_banner.
  onboarding_banner?: string;
    // is community.
  is_community?: boolean;
  // community banner
  community_banner?: string;
  // description
  description?: string;
  // about
  about?: string;
  // short url for community
  short_url?: string;
}

/**  */
export interface ApiClanDescList {
  //A list of channel.
  clandesc?: Array<ApiClanDesc>;
}

/**  */
export interface ApiClanEmoji {
  //
  category?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  shortname?: string;
  //
  src?: string;
  //
  is_for_sale?: boolean;
}

/**  */
export interface ApiClanEmojiCreateRequest {
  //
  category?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  shortname?: string;
  //
  source?: string;
  //
  is_for_sale?: boolean;
}

/** Get clan profile. */
export interface ApiClanProfile {
  //
  avatar?: string;
  //
  clan_id?: string;
  //
  nick_name?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiClanSticker {
  //
  category?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  shortname?: string;
  //
  source?: string;
  // 
  media_type?: number;
  //
  is_for_sale?: boolean;
}

/**  */
export interface ApiClanStickerAddRequest {
  //
  category?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  shortname?: string;
  //
  source?: string;
  //
  media_type?: number;
  //
  is_for_sale?: boolean;
}

/** A list of users belonging to a clan, along with their role. */
export interface ApiClanUserList {
  //
  clan_id?: string;
  //User-role pairs for a clan.
  clan_users?: Array<ClanUserListClanUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiConfirmLoginRequest {
  //Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  //
  login_id?: string;
}

/**  */
export interface ApiCreateActivityRequest {
  //
  activity_description?: string;
  //
  activity_name?: string;
  //
  activity_type?: number;
  //
  application_id?: string;
  //
  start_time?: string;
  //
  status?: number;
}

/**  */
export interface ApiCreateCategoryDescRequest {
  //
  category_name?: string;
  //
  clan_id?: string;
}

/** Create a channel within clan. */
export interface ApiCreateChannelDescRequest {
  //
  app_id?: string;
  //
  category_id?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //The parent channel this message belongs to.
  parent_id?: string;
  //The channel type.
  type?: number;
  //The users to add.
  user_ids?: Array<string>;
}

/**  */
export interface ApiCreateClanDescRequest {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
}

/** Create a event within clan. */
export interface ApiCreateEventRequest {
  //
  address?: string;
  //
  channel_voice_id?: string;
  //
  clan_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
  //
  channel_id?: string;
  //
  action?: number;
  //
  event_status?: number;
  //
  repeat_type?: number;
  //
  creator_id?: number;
  //
  user_id?: string;
  //
  is_private?: boolean;
  //
  meet_room?: ApiGenerateMezonMeetResponse;
}

/** Create a event within clan. */
export interface ApiUpdateEventRequest {
  //
  address?: string;
  //
  channel_id?: string;
  //
  event_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
  //
  clan_id?: string;
}

/** Create a role within clan. */
export interface ApiCreateRoleRequest {
  //The permissions to add.
  active_permission_ids?: Array<string>;
  //The users to add.
  add_user_ids?: Array<string>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  max_permission_id: string;
  //
  role_icon?: string;
  //
  title?: string;
  //
  order_role?: number;
}

/** Delete a channel the user has access to. */
export interface ApiDeleteChannelDescRequest {
  //The clan id
  clan_id?: string;
  //The id of a channel.
  channel_id?: string;
}

/**  */
export interface ApiDeleteEventRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //The id of a event.
  event_id?: string;
  //
  event_label?: string;
}

/** Delete a role the user has access to. */
export interface ApiDeleteRoleRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //The id of a role.
  role_id?: string;
  //
  role_label?: string;
}

/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The version hash of the object.
  version?: string;
}

/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface ApiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/**  */
export interface ApiRegisterStreamingChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiRegisterStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  streaming_url?: string;
}

/**  */
export interface ApiListStreamingChannelsResponse {
  //
  streaming_channels?: Array<ApiStreamingChannelResponse>;
}

export interface ApiEmojiListedResponse {
  //
  emoji_list?: Array<ApiClanEmoji>;
}

/**  */
export interface ApiEmojiRecent {
  //ID of the emoji.
  emoji_recents_id?: string;
  //
  emoji_id?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the emoji was created.
  update_time?: string;
}

/**  */
export interface ApiEventList {
  //A list of event.
  events?: Array<ApiEventManagement>;
}

/**  */
export interface ApiEventManagement {
  //
  active?: number;
  //
  address?: string;
  //
  channel_voice_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  max_permission?: number;
  //
  start_event?: number;
  //
  start_time?: string;
  //
  title?: string;
  //
  user_ids?: Array<string>;
  //
  create_time?: string;
  //
  channel_id?: string;
  //
  event_status?: number;
  //
  repeat_type?: number;
  //
  is_private?: boolean;
  //
  meet_room?: ApiGenerateMezonMeetResponse;
}

/**  */
export interface ApiListFavoriteChannelResponse {
  //
  channel_ids?: Array<string>;
}

/**  */
export interface ApiFilterParam {
  //
  field_name?: string;
  //
  field_value?: string;
}

/** A friend of a user. */
export interface ApiFriend {
  //The friend status.  one of "Friend.State".
  state?: number;
  //Time of the latest relationship update.
  update_time?: string;
  //The user object.
  user?: ApiUser;
  //Source ID
  source_id?: string;
}

/** A collection of zero or more friends of the user. */
export interface ApiFriendList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //The Friend objects.
  friends?: Array<ApiFriend>;
}

/**  */
export interface ApiGetKeyServerResp {
  //
  url?: string;
}

/**  */
export interface ApiGenerateMezonMeetResponse {
  //
  meet_id?: string;
  //
  room_name?: string;
  //
  external_link?: string;
  //
  creator_id?: string;
  //
  event_id?: string;
}

/**  */
export interface ApiGenerateMeetTokenExternalResponse {
  //
  guest_user_id?: string;
  //
  token?: string;
  //
  guest_access_token?: string;
}

/**  */
export interface ApiMeetParticipantRequest {
  //
  room_name?: string;
  //
  username?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiGetPubKeysResponse {
  //
  pub_keys?: Array<GetPubKeysResponseUserPubKey>;
}

/**  */
export interface ApiGiveCoffeeEvent {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_ref_id?: string;
  //
  receiver_id?: string;
  //
  sender_id?: string;
  //
  token_count?: number;
}

/**  */
export interface ApiHashtagDm {
  //The channel id.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  meeting_code?: string;
  //
  parent_id?: string;
  //
  type?: number;
}

/**  */
export interface ApiHashtagDmList {
  //
  hashtag_dm?: Array<ApiHashtagDm>;
}

/** Add link invite users to. */
export interface ApiInviteUserRes {
  //
  channel_desc?: ApiChannelDescription;
  //id channel to add link to.
  channel_id?: string;
  //
  channel_label?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  clan_name?: string;
  //
  user_joined?: boolean;
  //
  expiry_time?: string;
  //
  clan_logo: string;
  //
  member_count: number;
}

/** Add link invite users to. */
export interface ApiLinkInviteUser {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  create_time?: string;
  //The user to add.
  creator_id?: string;
  //
  expiry_time?: string;
  //
  id?: string;
  //
  invite_link?: string;
}

/** Add link invite users to. */
export interface ApiLinkInviteUserRequest {
  //id channel to add link to.
  channel_id?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  expiry_time?: number;
}

export interface ApiNotifiReactMessage {
  //
  channel_id?: string;
  //
  id?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiMessage2InboxRequest {
  //
  attachments?: string;
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  mentions?: string;
  //
  message_id?: string;
  //
  reactions?: string;
  //
  references?: string;
}

/**  */
export interface ApiMessageAttachment {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  url?: string;
  //
  width?: number;
  //
  thumbnail?: string;
  /** The channel this message belongs to. */
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  /** The message that user react */
  message_id?: string;
  /** Message sender, usually a user ID. */
  sender_id?: string;
}

/**  */
export interface ApiMessageDeleted {
  //
  deletor?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiListUserActivity {
  //
  activities?: Array<ApiUserActivity>;
}
/**  */
export interface ApiLoginIDResponse {
  //
  address?: string;
  //
  create_time_second?: string;
  //
  login_id?: string;
  //
  platform?: string;
  //
  status?: number;
  //
  user_id?: string;
  //
  username?: string;
}

/**  */
export interface ApiMarkAsReadRequest {
  //
  category_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiMessageMention {
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  id?: string;
  //
  user_id?: string;
  //
  username?: string;
  // role id
  role_id?: string;
  // role name
  rolename?: string;
  // start position
  s?: number;
  // end position
  e?: number;
  /** The channel this message belongs to. */
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  /** The message that user react */
  message_id?: string;
  /** Message sender, usually a user ID. */
  sender_id?: string;
}

/**  */
export interface ApiLoginRequest {
  //
  address?: string;
  //
  platform?: string;
}

/**  */
export interface ApiMessageReaction {
  //
  action?: boolean;
  //
  emoji_id: string;
  //
  emoji: string;
  //
  id?: string;
  //
  sender_id?: string;
  //
  sender_name?: string;
  //
  sender_avatar?: string;
  // count of emoji
  count: number;
  /** The channel this message belongs to. */
  channel_id: string;
  // The mode
  mode: number;
  // Is public
  is_public: boolean;
  // The channel label
  channel_label: string;
  /** The message that user react */
  message_id: string;
  //
  topic_id?: string;
  //
  emoji_recent_id?: string;
}

export interface ApiListChannelAppsResponse {
  //
  channel_apps?: Array<ApiChannelAppResponse>;
}

/**  */
export interface ApiListStreamingChannelsResponse {
  //
  streaming_channels?: Array<ApiStreamingChannelResponse>;
}

/**  */
export interface ApiMezonOauthClient {
  //
  access_token_strategy?: string;
  //
  allowed_cors_origins?: Array<string>;
  //
  audience?: Array<string>;
  //
  authorization_code_grant_access_token_lifespan?: string;
  //
  authorization_code_grant_id_token_lifespan?: string;
  //
  authorization_code_grant_refresh_token_lifespan?: string;
  //
  backchannel_logout_session_required?: boolean;
  //
  backchannel_logout_uri?: string;
  //
  client_credentials_grant_access_token_lifespan?: string;
  //
  client_id?: string;
  //
  client_name?: string;
  //
  client_secret?: string;
  //
  client_secret_expires_at?: number;
  //
  client_uri?: string;
  //
  contacts?: Array<string>;
  //
  created_at?: string;
  //
  frontchannel_logout_session_required?: boolean;
  //
  frontchannel_logout_uri?: string;
  //
  grant_types?: Array<string>;
  //
  implicit_grant_access_token_lifespan?: string;
  //
  implicit_grant_id_token_lifespan?: string;
  //
  jwks?: Array<string>;
  //
  jwks_uri?: string;
  //
  jwt_bearer_grant_access_token_lifespan?: string;
  //
  logo_uri?: string;
  //
  owner?: string;
  //
  policy_uri?: string;
  //
  post_logout_redirect_uris?: Array<string>;
  //
  redirect_uris?: Array<string>;
  //
  refresh_token_grant_access_token_lifespan?: string;
  //
  refresh_token_grant_id_token_lifespan?: string;
  //
  refresh_token_grant_refresh_token_lifespan?: string;
  //
  registration_access_token?: string;
  //
  registration_client_uri?: string;
  //
  request_object_signing_alg?: string;
  //
  request_uris?: Array<string>;
  //
  response_types?: Array<string>;
  //
  scope?: string;
  //
  sector_identifier_uri?: string;
  //
  skip_consent?: boolean;
  //
  skip_logout_consent?: boolean;
  //
  subject_type?: string;
  //
  token_endpoint_auth_method?: string;
  //
  token_endpoint_auth_signing_alg?: string;
  //
  tos_uri?: string;
  //
  updated_at?: string;
  //
  userinfo_signed_response_alg?: string;
}

/**  */
export interface ApiMezonOauthClientList {
  //
  list_mezon_oauth_client?: Array<ApiMezonOauthClient>;
}

/**  */
export interface ApiMessageRef {
  //
  message_id?: string;
  //
  message_ref_id?: string;
  //
  ref_type?: number;
  //
  message_sender_id?: string;
  // original message sendre username
  message_sender_username?: string;
  // original message sender avatar
  mesages_sender_avatar?: string;
  // original sender clan nick name
  message_sender_clan_nick?: string;
  // original sender display name
  message_sender_display_name?: string;
  //
  content?: string;
  //
  has_attachment: boolean;
  /** The channel this message belongs to. */
  channel_id: string;
  // The mode
  mode: number;
  // The channel label
  channel_label: string;
}

/** A notification in the server. */
export interface ApiNotification {
  //
  avatar_url?: string;
  //
  channel_id?: string;
  //
  channel_type?: number;
  //
  clan_id?: string;
  //Category code for this notification.
  code?: number;
  //Content of the notification in JSON.
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
  create_time?: string;
  //ID of the Notification.
  id?: string;
  //True if this notification was persisted to the database.
  persistent?: boolean;
  //ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  //Subject of the notification.
  subject?: string;
  //category.
  category?: number;
  //
  topic_id?: string;  
  //
  channel?: ApiChannelDescription;
}

/**  */
export interface ApiNotificationChannel {
  //
  channel_id?: string;
}

/**  */
export interface ApiNotificationChannelCategorySetting {
  //
  action?: number;
  //
  channel_category_label?: string;
  //
  channel_category_title?: string;
  //
  id?: string;
  //
  notification_setting_type?: number;
}

/**  */
export interface ApiNotificationChannelCategorySettingList {
  //
  notification_channel_category_settings_list?: Array<ApiNotificationChannelCategorySetting>;
}

/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  //Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  //Collection of notifications.
  notifications?: Array<ApiNotification>;
}

/**  */
export interface ApiNotificationSetting {
  //
  id?: string;
  //
  notification_setting_type?: number;
}

/**  */
export interface ApiNotificationUserChannel {
  //
  active?: number;
  //
  id?: string;
  //
  notification_setting_type?: number;
  //
  time_mute?: string;
  //
  channel_id?: string;
}

/**  */
export interface ApiStreamHttpCallbackRequest {
  //
  action?: string;
  //
  app?: string;
  //
  client_id?: string;
  //
  ip?: string;
  //
  page_url?: string;
  //
  param?: string;
  //
  server_id?: string;
  //
  service_id?: string;
  //
  stream?: string;
  //
  stream_id?: string;
  //
  stream_url?: string;
  //
  tc_url?: string;
  //
  vhost?: string;
}

/**  */
export interface ApiStreamHttpCallbackResponse {
  //
  code?: number;
  //
  msg?: string;
}

/**  */
export interface ApiPermission {
  //
  active?: number;
  //
  description?: string;
  //
  id?: string;
  //
  level?: number;
  //
  scope?: number;
  //
  slug?: string;
  //
  title?: string;
}

/** A list of permission description, usually a result of a list operation. */
export interface ApiPermissionList {
  //
  max_level_permission?: number;
  //A list of permission.
  permissions?: Array<ApiPermission>;
}

/**  */
export interface ApiPermissionRoleChannel {
  //
  active?: boolean;
  //
  permission_id?: string;
}

/**  */
export interface ApiPermissionRoleChannelListEventResponse {
  //
  channel_id?: string;
  //
  permission_role_channel?: Array<ApiPermissionRoleChannel>;
  //
  role_id?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiPermissionUpdate {
  //
  permission_id?: string;
  //
  slug?: string;
  //
  type?: number;
}

/**  */
export interface ApiPinMessage {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  create_time_seconds?: number;
  //
  id?: string;
  //
  message_id?: string;
  //
  sender_id?: string;
  //
  username?: string;
  //
  attachment?: string;
}

/**  */
export interface ApiPinMessageRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiPinMessagesList {
  //
  pin_messages_list?: Array<ApiPinMessage>;
}

/**  */
export interface ApiPubKey {
  //
  encr?: string;
  //
  sign?: string;
}

/**  */
export interface ApiPushPubKeyRequest {
  //
  PK?: ApiPubKey;
}

/**  */
export interface ApiRegistFcmDeviceTokenResponse {
  //
  device_id?: string;
  //
  platform?: string;
  //
  token?: string;
}

/**  */
export interface ApiRegisterStreamingChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiRegisterStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  streaming_url?: string;
}

/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The user owner of the object.
  user_id?: string;
}

/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}

/**  */
export interface ApiRegistrationEmailRequest {
  //
  avatar_url?: string;
  //
  display_name?: string;
  //
  dob?: string;
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.
  password?: string;
  //A old password for the user account.
  old_password?: string;
  //Set the username on the account at register. Must be unique.
  username?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiUpdateRoleOrderRequest {
  //
  clan_id?: string;
  //
  roles?: Array<ApiRoleOrderUpdate>;
}

/**  */
export interface ApiRoleOrderUpdate {
  //
  order?: number;
  //
  role_id?: string;
}

/**  */
export interface ApiRole {
  //
  active?: number;
  //
  allow_mention?: number;
  //
  channel_ids?: Array<string>;
  //
  clan_id?: string;
  //
  color?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  id?: string;
  //
  max_level_permission?: number;
  //
  permission_list?: ApiPermissionList;
  //
  role_channel_active?: number;
  //
  role_icon?: string;
  //
  role_user_list?: ApiRoleUserList;
  //
  slug?: string;
  //
  title?: string;
  //
  order_role?: number;
}

/** A list of role description, usually a result of a list operation. */
export interface ApiRoleList {
  //Cacheable cursor to list newer role description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  //A list of role.
  roles?: Array<ApiRole>;
}

/**  */
export interface ApiRoleListEventResponse {
  //
  clan_id?: string;
  //
  cursor?: string;
  //
  limit?: number;
  //
  roles?: ApiRoleList;
  //
  state?: string;
}

/**  */
export interface ApiRoleUserList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //role_users pairs for a clan.
  role_users?: Array<RoleUserListRoleUser>;
}

/** Execute an Lua function on the server. */
export interface ApiRpc {
  //The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  //The identifier of the function.
  id?: string;
  //The payload of the function which must be a JSON object.
  payload?: string;
}

/**  */
export interface ApiSdTopic {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  message_id?: string;
  //
  status?: number;
  //
  update_time?: string;
  //
  message?: ApiChannelMessage;
}

/**  */
export interface ApiSdTopicList {
  //
  count?: number;
  //
  topics?: Array<ApiSdTopic>;
}

/**  */
export interface ApiSdTopicRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiSearchMessageDocument {
  //
  attachments?: Array<ApiMessageAttachment>;
  //
  avatar_url?: string;
  //The channel ID.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_type?: number;
  //The clan ID.
  clan_id?: string;
  //
  clan_name?: string;
  //
  content?: string;
  //
  create_time?: string;
  //
  display_name?: string;
  //
  mentions?: string;
  //The message ID.
  message_id?: string;
  //
  reactions?: string;
  //
  references?: string;
  //The user ID of sender.
  sender_id?: string;
  //
  update_time?: string;
  //
  username?: string;
}

/**  */
export interface ApiSearchMessageRequest {
  //
  filters?: Array<ApiFilterParam>;
  //
  from?: number;
  //
  size?: number;
  //
  sorts?: Array<ApiSortParam>;
}

/**  */
export interface ApiSearchMessageResponse {
  //List of paged messages.
  messages?: Array<ApiSearchMessageDocument>;
  //The total number of messages.
  total?: number;
}

/** A user's session used to authenticate messages. */
export interface ApiSession {
  //True if the corresponding account was just created, false otherwise.
  created?: boolean;
  //Refresh token that can be used for session token renewal.
  refresh_token?: string;
  //Authentication credentials.
  token?: string;
  // Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  api_url?: string;
}

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface ApiSessionLogoutRequest {
  //Refresh token to invalidate.
  refresh_token?: string;
  //Session token to log out.
  token?: string;
  // device_id to log out.
  device_id?: string;
  // platform 
  platform?: string;
}

/** Authenticate against the server with a refresh token. */
export interface ApiSessionRefreshRequest {
  //Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  //Refresh token.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiSetDefaultNotificationRequest {
  //
  category_id?: string;
  //
  clan_id?: string;
  //
  notification_type?: number;
}

/**  */
export interface ApiSetMuteNotificationRequest {
  //
  active?: number;
  //
  id?: string;
  //
  notification_type?: number;
}

/**  */
export interface ApiSetNotificationRequest {
  //
  channel_category_id?: string;
  //
  notification_type?: number;
  //
  time_mute?: string;
  // clan_id
  clan_id?: string;
}

/**  */
export interface ApiSortParam {
  //
  field_name?: string;
  //
  order?: string;
}

/**  */
export interface ApiStickerListedResponse {
  //
  stickers?: Array<ApiClanSticker>;
}

/**  */
export interface ApiStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  is_streaming?: boolean;
  //
  streaming_url?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiStreamingChannelUser {
  //
  channel_id?: string;
  //
  id?: string;
  //
  participant?: string;
  //user for a channel.
  user_id?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiStreamingChannelUserList {
  //
  streaming_channel_users?: Array<ApiStreamingChannelUser>;
}

/** System message details. */
export interface ApiSystemMessage {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  hide_audit_log?: string;
  //
  id?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/** Request to get system message by clan and channel IDs. */
export interface ApiSystemMessageRequest {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  hide_audit_log?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/** List of system message. */
export interface ApiSystemMessagesList {
  //
  system_messages_list?: Array<ApiSystemMessage>;
}

/**  */
export interface ApiTokenSentEvent {
  //
  amount?: number;
  //
  note?: string;
  //
  receiver_id?: string;
  //
  sender_id?: string;
  //
  sender_name?: string;
  //
  extra_attribute?: string;
  //
  transaction_id?: string;
}

/**  */
export interface ApiTransactionDetail {
  //
  amount?: number;
  //
  create_time?: string;
  //
  update_time?: string;
  //
  receiver_id?: string;
  //
  receiver_username?: string;
  //
  sender_id?: string;
  //
  sender_username?: string;
  //
  metadata?: string;
  //
  trans_id?: string;
}

/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  //
  about_me?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //
  dob?: string;
  //The display name of the user.
  display_name?: string;
  //
  encrypt_private_key?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //
  logo?: string;
  //
  splash_screen?: string;
  //The timezone set by the user.
  timezone?: string;
  //The username of the user's account.
  username?: string;
  //The email of the user's account.
  email?: string;
}

/**  */
export interface ApiUpdateCategoryDescRequest {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
  // clan ID
  ClanId: string;
}
/**  */
export interface ApiUpdateCategoryOrderRequest {
  //
  categories?: Array<ApiCategoryOrderUpdate>;
  //
  clan_id?: string;
}

/**  */
export interface ApiUpdateRoleChannelRequest {
  //
  channel_id: string;
  //
  max_permission_id: string;
  //The permissions to add.
  permission_update?: Array<ApiPermissionUpdate>;
  //The ID of the role to update.
  role_id?: string;
  //
  role_label?: string;
  //The ID of the role to update.
  user_id?: string;
}

/** Fetch a batch of zero or more users from the server. */
export interface ApiUpdateUsersRequest {
  //The avarar_url of a user.
  avatar_url?: string;
  //The account username of a user.
  display_name?: string;
}

/**  */
export interface ApiUploadAttachment {
  //
  filename?: string;
  //
  url?: string;
}

/**  */
export interface ApiUploadAttachmentRequest {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  width?: number;
}

/** A user in the server. */
export interface ApiUser {
  //
  about_me?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //
  dob?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created.
  create_time?: string;
  //The display name of the user.
  display_name?: string;
  //Number of related edges to this user.
  edge_count?: number;
  //The id of the user's account.
  id?: string;
  //
  is_mobile?: boolean;
  //
  join_time?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //Additional information stored as a JSON object.
  metadata?: string;
  //Indicates whether the user is currently online.
  online?: boolean;
  //The timezone set by the user.
  timezone?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated.
  update_time?: string;
  //The username of the user's account.
  username?: string;
  // mezon_id
  mezon_id?: string;
  // list nick name
  list_nick_names?: Array<string>;
}

/**  */
export interface ApiUserActivity {
  //
  activity_description?: string;
  //
  activity_name?: string;
  //
  activity_type?: number;
  //
  application_id?: string;
  //
  end_time?: string;
  //
  start_time?: string;
  //
  status?: number;
  //
  user_id?: string;
}

/**  */
export interface ApiQuickMenuAccess {
  //
  action_msg?: string;
  //
  background?: string;
  //
  bot_id?: string;
  //
  channel_id?: string;
  //
  clan_id?:string;
  //
  id?: string;
  //
  menu_name?: string;
  //
  menu_type?: number;
}

/**  */
export interface ApiQuickMenuAccessList {
  //
  list_menus?: Array<ApiQuickMenuAccess>;
}

/**  */
export interface ApiQuickMenuAccessRequest {
  //
  action_msg?: string;
  //
  background?: string;
  //
  bot_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  menu_name?: string;
  //
  menu_type?:number;
}

/**  */
export interface ApiUserPermissionInChannelListResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //A list of permission.
  permissions?: ApiPermissionList;
}

/**  */
export interface ApiUserStatus {
  //
  status?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiUserStatusUpdate {
  //
  minutes?: number;
  //
  status?: string;
  //
  until_turn_on?: boolean;
}

/** A collection of zero or more users. */
export interface ApiUsers {
  //The User objects.
  users?: Array<ApiUser>;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiVoiceChannelUser {
  //Cursor for the next page of results, if any.
  id?: string;
  //
  channel_id?: string;
  //
  participant?: string;
  //User for a channel.
  user_id?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiVoiceChannelUserList {
  //
  voice_channel_users?: Array<ApiVoiceChannelUser>;
}

/**  */
export interface ApiStoreWalletKeyRequest {
  //
  address?: string;
  //
  enc_privkey?: string;
}

/**  */
export interface ApiWalletLedger {
  //
  create_time?: string;
  //
  id?: string;
  //
  transaction_id?: string;
  //
  user_id?: string;
  //
  value?: number;
}

/**  */
export interface ApiWalletLedgerList {
  //
  count?: number;
  //
  wallet_ledger?: Array<ApiWalletLedger>;
}

/**  */
export interface ApiWebhook {
  //
  active?: number;
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  status?: number;
  //
  update_time?: string;
  //
  url?: string;
  //
  webhook_name?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiWebhookCreateRequest {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  webhook_name?: string;
}

/**  */
export interface ApiWebhookGenerateResponse {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  hook_name?: string;
  //
  url?: string;
}

/**  */
export interface ApiWebhookListResponse {
  //
  webhooks?: Array<ApiWebhook>;
}

/** A collection of zero or more notifications. */
export interface ApiEmojiRecentList {
  //Collection of emojiRecents.
  emoji_recents?: Array<ApiEmojiRecent>;
}


/** Represents an event to be passed through the server to registered event handlers. */
export interface MezonapiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/**  */
export interface MezonapiListAuditLog {
  //
  date_log?: string;
  //
  logs?: Array<ApiAuditLog>;
  //
  total_count?: number;
}

/**  */
export interface ProtobufAny {
  //
  type_url?: string;
  //
  value?: string;
}

/**  */
export interface RpcStatus {
  //
  code?: number;
  //
  details?: Array<ProtobufAny>;
  //
  message?: string;
}

/**  */
export interface ApiListOnboardingResponse {
  //
  list_onboarding?: Array<ApiOnboardingItem>;
}

/**  */
export interface OnboardingAnswer {
  //
  emoji?: string;
  //
  description?: string;
  //
  title?: string;
  //
  image_url?: string;
}

/**  */
export interface ApiOnboardingContent {
  //
  answers?: Array<OnboardingAnswer>;
  //
  channel_id?: string;
  //
  content?: string;
  //
  guide_type?: number;
  //
  task_type?: number;
  //
  title?: string;
  //
  image_url?: string;
}

/**  */
export interface MezonUpdateOnboardingBody {
  //
  answers?: Array<OnboardingAnswer>;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  task_type?: number;
  //
  title?: string;
  //
  image_url?: string;
}

/**  */
export interface ApiCreateOnboardingRequest {
  //
  clan_id?: string;
  //
  contents?: Array<ApiOnboardingContent>;
}

/**  */
export interface ApiOnboardingItem {
  //
  answers?: Array<OnboardingAnswer>;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  guide_type?: number;
  //
  id?: string;
  //
  task_type?: number;
  //
  title?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //
  image_url?: string;
}

/**  */
export interface MezonUpdateClanWebhookByIdBody {
  //avatar.
  avatar?: string;
  //clan id.
  clan_id?: string;
  //reset token.
  reset_token?: boolean;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiClanWebhook {
  //active.
  active?: number;
  //
  avatar?: string;
  //clan id.
  clan_id?: string;
  //create time.
  create_time?: string;
  //creator id.
  creator_id?: string;
  //id.
  id?: string;
  //update time.
  update_time?: string;
  //URL of the webhook, which is automatically generated and different from the avatar.
  url?: string;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiGenerateClanWebhookRequest {
  //avatar.
  avatar?: string;
  //clan id.
  clan_id?: string;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiGenerateClanWebhookResponse {
  //avatar.
  avatar?: string;
  //clan id.
  clan_id?: string;
  //url.
  url?: string;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiListClanWebhookResponse {
  //list clan webhook.
  list_clan_webhooks?: Array<ApiClanWebhook>;
}

/**  */
export interface MezonUpdateOnboardingStepByClanIdBody {
  //onboarding step.
  onboarding_step?: number;
}

/**  */
export interface ApiListOnboardingStepResponse {
  //list onboarding steps.
  list_onboarding_step?: Array<ApiOnboardingSteps>;
}

/**  */
export interface ApiOnboardingSteps {
  //clan id.
  clan_id?: string;
  //id.
  id?: string;
  //onboarding step.
  onboarding_step?: number;
  //user id.
  user_id?: string;
}

/**  */
export interface MezonapiCreateRoomChannelApps {
  //
  channel_id?: string;
  //
  room_name?: string;
}

/**  */
export interface ApiGenerateMeetTokenRequest {
  //
  channel_id?: string;
  //
  room_name?: string;
}

/**  */
export interface ApiGenerateMeetTokenResponse {
  //
  token?: string;
}

/**  */
export interface ApiUnlockedItemRequest {
  //
  item_id?: string;
  //
  item_type?: number;
}

/**  */
export interface ApiUnlockedItemResponse {
  //
  source?: string;
}

/**  */
export interface ApiMezonOauthClient {
  //
  access_token_strategy?: string;
  //
  allowed_cors_origins?: Array<string>;
  //
  audience?: Array<string>;
  //
  authorization_code_grant_access_token_lifespan?: string;
  //
  authorization_code_grant_id_token_lifespan?: string;
  //
  authorization_code_grant_refresh_token_lifespan?: string;
  //
  backchannel_logout_session_required?: boolean;
  //
  backchannel_logout_uri?: string;
  //
  client_credentials_grant_access_token_lifespan?: string;
  //
  client_id?: string;
  //
  client_name?: string;
  //
  client_secret?: string;
  //
  client_secret_expires_at?: number;
  //
  client_uri?: string;
  //
  contacts?: Array<string>;
  //
  created_at?: string;
  //
  frontchannel_logout_session_required?: boolean;
  //
  frontchannel_logout_uri?: string;
  //
  grant_types?: Array<string>;
  //
  implicit_grant_access_token_lifespan?: string;
  //
  implicit_grant_id_token_lifespan?: string;
  //
  jwks?: Array<string>;
  //
  jwks_uri?: string;
  //
  jwt_bearer_grant_access_token_lifespan?: string;
  //
  logo_uri?: string;
  //
  owner?: string;
  //
  policy_uri?: string;
  //
  post_logout_redirect_uris?: Array<string>;
  //
  redirect_uris?: Array<string>;
  //
  refresh_token_grant_access_token_lifespan?: string;
  //
  refresh_token_grant_id_token_lifespan?: string;
  //
  refresh_token_grant_refresh_token_lifespan?: string;
  //
  registration_access_token?: string;
  //
  registration_client_uri?: string;
  //
  request_object_signing_alg?: string;
  //
  request_uris?: Array<string>;
  //
  response_types?: Array<string>;
  //
  scope?: string;
  //
  sector_identifier_uri?: string;
  //
  skip_consent?: boolean;
  //
  skip_logout_consent?: boolean;
  //
  subject_type?: string;
  //
  token_endpoint_auth_method?: string;
  //
  token_endpoint_auth_signing_alg?: string;
  //
  tos_uri?: string;
  //
  updated_at?: string;
  //
  userinfo_signed_response_alg?: string;
}

/**  */
export interface ApiCreateHashChannelAppsResponse {
  //
  web_app_data?: string;
}

/**  */
export interface ApiUserEventRequest {
  // The ID of the clan to be updated.
  clan_id?: string;
  //The ID of the event to be updated.
  event_id?: string;
}

/**  */
export interface ApiClanDiscover {
  //
  about?: string;
  //
  banner?: string;
  //
  clan_id?: string;
  //
  clan_logo?: string;
  //
  clan_name?: string;
  //
  description?: string;
  //
  invite_id?: string;
  //
  online_members?: number;
  //
  total_members?: number;
  //
  verified?: boolean;
  //
  short_url?: string;
}

/**  */
export interface ApiListForSaleItemsRequest {
  //
  page?: number;
}

/**  */
export interface ApiForSaleItem {
  //
  preview_url?: string;
  //
  type?: number;
}

/**  */
export interface ApiForSaleItemList {
  //
  for_sale_items?: Array<ApiForSaleItem>;
}

/**  */
export interface ApiListClanDiscover {
  //
  clan_discover?: Array<ApiClanDiscover>;
  //
  page?: number;
  //
  page_count?: number;
}

/**  */
export interface ApiClanDiscoverRequest {
  //
  clan_id?: string;
  //
  item_per_page?: number;
  //
  page_number?: number;
}

/**  */
export interface ApiIsFollowerRequest {
  //
  follow_id?: string;
}

/**  */
export interface ApiLinkAccountConfirmRequest {
  //
  otp_code?: string;
  //
  req_id?: string;
  //
  status?: number;
}

/**  */
export interface ApiIsFollowerResponse {
  //
  is_follower?: boolean;
  //
  follow_id?: string;
}

/**  */
export interface ApiTransferOwnershipRequest {
  //
  clan_id?: string;
  //
  new_owner_id?: string;
}

export class MezonApi {
  basePath: string;
  constructor(
    readonly serverKey: string,
    readonly timeoutMs: number,
    basePath: string,
  ) {
    this.basePath = basePath
  }

  setBasePath(basePath: string) {
    this.basePath = basePath;
  }

  /** A healthcheck which load balancers can use to check the service. */
  healthcheck(bearerToken: string, options: any = {}): Promise<any> {
    const urlPath = "/healthcheck";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete the current user's account. */
  deleteAccount(bearerToken: string, options: any = {}): Promise<any> {
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Fetch the current user's account. */
  getAccount(bearerToken: string, options: any = {}): Promise<ApiAccount> {
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in the current user's account. */
  updateAccount(
    bearerToken: string,
    body: ApiUpdateAccountRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  checkLoginRequest(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiConfirmLoginRequest,
    options: any = {}
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/checklogin";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  confirmLogin(
    bearerToken: string,
    basePath: string,
    body: ApiConfirmLoginRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/confirmlogin";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  createQRLogin(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiLoginRequest,
    options: any = {}
  ): Promise<ApiLoginIDResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/createqrlogin";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }


  /** Authenticate a user with an email+password against the server. */
  authenticateEmail(
    basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiAuthenticateEmailRequest,
      options: any = {}): Promise<ApiSession> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/email";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with Mezon against the server. */
  authenticateMezon(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account:ApiAccountMezon,
    create?:boolean,
    username?:string,
    isRemember?:boolean,
    options: any = {}
  ): Promise<ApiSession> {
    
    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/mezon";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("is_remember", isRemember);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add an email+password to the social profiles on the current user's account. */
  linkEmail(
    bearerToken: string,
    body: ApiAccountEmail,
    options: any = {}
  ): Promise<ApiLinkAccountConfirmRequest> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/email";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a mezon ID to the social profiles on the current user's account. */
    linkMezon(bearerToken: string,
        body:ApiAccountMezon,
        options: any = {}): Promise<ApiLinkAccountConfirmRequest> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/mezon";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /**  */
    confirmLinkMezonOTP(bearerToken: string,
        body:ApiLinkAccountConfirmRequest,
        options: any = {}): Promise<any> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/confirm";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /** Authenticate a user with an email+password against the server. */
  registrationEmail(
    bearerToken: string,
    body: ApiRegistrationEmailRequest,
    options: any = {}
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/registry";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  sessionRefresh(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiSessionRefreshRequest,
    options: any = {}
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/session/refresh";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove the email+password from the social profiles on the current user's account. */
  unlinkEmail(
    bearerToken: string,
    body: ApiAccountEmail,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/email";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove the mezon ID from the social profiles on the current user's account. */
    unlinkMezon(bearerToken: string,
        body:ApiAccountMezon,
        options: any = {}): Promise<any> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/mezon";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /** List activity */
  listActivity(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiListUserActivity> {
    const urlPath = "/v2/activity";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create user activity */
  createActiviy(
    bearerToken: string,
    body: ApiCreateActivityRequest,
    options: any = {}
  ): Promise<ApiUserActivity> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/activity";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a new apps. */
  addApp(
    bearerToken: string,
    body: ApiAddAppRequest,
    options: any = {}
  ): Promise<ApiApp> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/apps/add";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List (and optionally filter) accounts. */
  listApps(
    bearerToken: string,
    filter?: string,
    tombstones?: boolean,
    cursor?: string,
    options: any = {}
  ): Promise<ApiAppList> {
    const urlPath = "/v2/apps/app";
    const queryParams = new Map<string, any>();
    queryParams.set("filter", filter);
    queryParams.set("tombstones", tombstones);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add an app to clan. */
  addAppToClan(
    bearerToken: string,
    appId: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (appId === null || appId === undefined) {
      throw new Error(
        "'appId' is a required parameter but is null or undefined."
      );
    }
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/apps/app/{appId}/clan/{clanId}"
      .replace("{appId}", encodeURIComponent(String(appId)))
      .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete all information stored for an app. */
  deleteApp(
    bearerToken: string,
    id: string,
    recordDeletion?: boolean,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("record_deletion", recordDeletion);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get detailed app information. */
  getApp(bearerToken: string, id: string, options: any = {}): Promise<ApiApp> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update one or more fields on a app. */
    updateApp(bearerToken: string,
      id:string,
      body:MezonUpdateAppBody,
      options: any = {}): Promise<ApiApp> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Ban a app. */
  banApp(bearerToken: string, id: string, options: any = {}): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}/ban".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Unban an app. */
  unbanApp(bearerToken: string, id: string, options: any = {}): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}/unban".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  listAuditLog(
    bearerToken: string,
    actionLog?: string,
    userId?: string,
    clanId?: string,
    dateLog?: string,
    options: any = {}
  ): Promise<MezonapiListAuditLog> {
    const urlPath = "/v2/audit_log";
    const queryParams = new Map<string, any>();
    queryParams.set("action_log", actionLog);
    queryParams.set("user_id", userId);
    queryParams.set("clan_id", clanId);
    queryParams.set("date_log", dateLog);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
  /**  */
  updateCategoryOrder(
    bearerToken: string,
    body: ApiUpdateCategoryOrderRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/category/orders";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  listCategoryDescs(
    bearerToken: string,
    clanId: string,
    creatorId?: string,
    categoryName?: string,
    categoryId?: string,
    categoryOrder?: number,
    options: any = {}
  ): Promise<ApiCategoryDescList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/categorydesc/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("creator_id", creatorId);
    queryParams.set("category_name", categoryName);
    queryParams.set("category_id", categoryId);
    queryParams.set("category_order", categoryOrder);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List channel apps. */
  listChannelApps(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiListChannelAppsResponse> {
    const urlPath = "/v2/channel-apps";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getChannelCanvasList(
    bearerToken: string,
    channelId: string,
    clanId?: string,
    limit?: number,
    page?: number,
    options: any = {}
  ): Promise<ApiChannelCanvasListResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel-canvases/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);
    queryParams.set("page", page);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  addChannelFavorite(
    bearerToken: string,
    body: ApiAddFavoriteChannelRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/favorite";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  removeChannelFavorite(
    bearerToken: string,
    clanId: string,
    channelId: string,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/favorite/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getListFavoriteChannel(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiListFavoriteChannelResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/favorite/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List a channel's message history. */
  listChannelMessages(
    bearerToken: string,
    clanId: string,
    channelId: string,
    messageId?: string,
    direction?: number,
    limit?: number,
    topicId?: string,
    options: any = {}
  ): Promise<ApiChannelMessageList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("message_id", messageId);
    queryParams.set("limit", limit);
    queryParams.set("direction", direction);
    queryParams.set("topic_id", topicId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  addChannelUsers(
    bearerToken: string,
    channelId: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/add".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all attachment that are part of a channel. */
  listChannelAttachment(bearerToken: string,
      channelId:string,
      clanId?:string,
      fileType?:string,
      limit?:number,
      state?:number,
      before?:number,
      after?:number,
      around?:number,
      options: any = {}): Promise<ApiChannelAttachmentList> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel/{channelId}/attachment"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("file_type", fileType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("before", before);
    queryParams.set("after", after);
    queryParams.set("around", around);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get channel encryption method */
  getChanEncryptionMethod(
    bearerToken: string,
    channelId: string,
    method?: string,
    options: any = {}
  ): Promise<ApiChanEncryptionMethod> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/encrypt_method".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("method", method);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** store channel encryption method */
  setChanEncryptionMethod(
    bearerToken: string,
    channelId: string,
    body: MezonSetChanEncryptionMethodBody,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/encrypt_method".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Leave a channel the user is a member of. */
  leaveThread(
    bearerToken: string,
    clanId: string,
    channelId: string,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/leave".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Kick a set of users from a channel. */
  removeChannelUsers(
    bearerToken: string,
    channelId: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/remove".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listChannelUsers(
    bearerToken: string,
    clanId: string,
    channelId: string,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiChannelUserList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/user".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_type", channelType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List user channels */
  listChannelDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    clanId?: string,
    channelType?: number,
    options: any = {}
  ): Promise<ApiChannelDescList> {
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_type", channelType);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a new channel with the current user as the owner. */
  createChannelDesc(
    bearerToken: string,
    body: ApiCreateChannelDescRequest,
    options: any = {}
  ): Promise<ApiChannelDescription> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** list user add channel by channel ids */
  listChannelUsersUC(
    bearerToken: string,
    channelId?: string,
    limit?: number,
    options: any = {}
  ): Promise<ApiAllUsersAddChannelResponse> {
    const urlPath = "/v2/channeldesc/users";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);
    queryParams.set("limit", limit);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a channel by ID. */
  deleteChannelDesc(bearerToken: string,
      clanId: string,
      channelId: string,      
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given channel. */
  updateChannelDesc(
    bearerToken: string,
    clanId: string,
    channelId: string,
    body: {},
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channeldesc/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List channel setting */
  listChannelSetting(
    bearerToken: string,
    clanId: string,
    parentId?: string,
    categoryId?: string,
    privateChannel?: number,
    active?: number,
    status?: number,
    type?: number,
    limit?: number,
    page?: number,
    channelLabel?: string,
    options: any = {}
  ): Promise<ApiChannelSettingListResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channelsetting/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("parent_id", parentId);
    queryParams.set("category_id", categoryId);
    queryParams.set("private_channel", privateChannel);
    queryParams.set("active", active);
    queryParams.set("status", status);
    queryParams.set("type", type);
    queryParams.set("limit", limit);
    queryParams.set("page", page);
    queryParams.set("channel_label", channelLabel);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listChannelVoiceUsers(
    bearerToken: string,
    clanId?: string,
    channelId?: string,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiVoiceChannelUserList> {
    const urlPath = "/v2/channelvoice";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);
    queryParams.set("channel_type", channelType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List clans */
  listClanDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiClanDescList> {
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a clan */
  createClanDesc(
    bearerToken: string,
    body: ApiCreateClanDescRequest,
    options: any = {}
  ): Promise<ApiClanDesc> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a clan desc by ID. */
  deleteClanDesc(
    bearerToken: string,
    clanDescId: string,
    options: any = {}
  ): Promise<any> {
    if (clanDescId === null || clanDescId === undefined) {
      throw new Error(
        "'clanDescId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanDescId}".replace(
      "{clanDescId}",
      encodeURIComponent(String(clanDescId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given clan. */
  updateClanDesc(
    bearerToken: string,
    clanId: string,
    body: {},
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Kick a set of users from a clan. */
  removeClanUsers(
    bearerToken: string,
    clanId: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanId}/kick".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a clan. */
  listClanUsers(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiClanUserList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanId}/user".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** check duplicate clan name */
  checkDuplicateClanName(
    bearerToken: string,
    clanName: string,
    options: any = {}
  ): Promise<ApiCheckDuplicateClanNameResponse> {
    if (clanName === null || clanName === undefined) {
      throw new Error(
        "'clanName' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanName}".replace(
      "{clanName}",
      encodeURIComponent(String(clanName))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  createCategoryDesc(
    bearerToken: string,
    body: ApiCreateCategoryDescRequest,
    options: any = {}
  ): Promise<ApiCategoryDesc> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/createcategory";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteCategoryDesc(
    bearerToken: string,
    categoryId: string,
    clanId: string,
    categoryLabel?: string,
    options: any = {}
  ): Promise<any> {
    if (categoryId === null || categoryId === undefined) {
      throw new Error(
        "'categoryId' is a required parameter but is null or undefined."
      );
    }
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath =
      "/v2/deletecategory/category_id/{categoryId}/clan_id/{clanId}"
        .replace("{categoryId}", encodeURIComponent(String(categoryId)))
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();
    queryParams.set("category_label", categoryLabel);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteCategoryOrder(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/deletecategoryorder/clan_id/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** regist fcm device token */
  registFCMDeviceToken(
    bearerToken: string,
    token?: string,
    deviceId?: string,
    platform?: string,
    voipToken?: string,
    options: any = {}
  ): Promise<ApiRegistFcmDeviceTokenResponse> {
    const urlPath = "/v2/devicetoken";
    const queryParams = new Map<string, any>();
    queryParams.set("token", token);
    queryParams.set("device_id", deviceId);
    queryParams.set("platform", platform);
    queryParams.set("voip_token", voipToken);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** close direct message. */
  closeDirectMess(
    bearerToken: string,
    body: ApiDeleteChannelDescRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/direct/close";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** open direct message. */
  openDirectMess(
    bearerToken: string,
    body: ApiDeleteChannelDescRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/direct/open";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Post clan Emoji  /v2/emoji/create */
  createClanEmoji(
    bearerToken: string,
    body: ApiClanEmojiCreateRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/emoji/create";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a emoji by ID. */
  deleteClanEmojiById(
    bearerToken: string,
    id: string,
    clanId?: string,
    emojiLabel?: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/emoji/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("emoji_label", emojiLabel);

    const body = { clan_id: clanId };
    let bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update ClanEmoj By id */
  updateClanEmojiById(
    bearerToken: string,
    id: string,
    body: MezonUpdateClanEmojiByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/emoji/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get list emoji recent by user id */
  emojiRecentList(bearerToken: string,
      options: any = {}): Promise<ApiEmojiRecentList> {
    
    const urlPath = "/v2/emojirecents";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get list emoji by user id */
  getListEmojisByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiEmojiListedResponse> {
    const urlPath = "/v2/emojis";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Search message from elasticsearch service. */
  searchMessage(
    bearerToken: string,
    body: ApiSearchMessageRequest,
    options: any = {}
  ): Promise<ApiSearchMessageResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/es/search";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Submit an event for processing in the server's registered runtime custom events handler. */
  event(bearerToken: string, body: ApiEvent, options: any = {}): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/event";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List user events */
  listEvents(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiEventList> {
    const urlPath = "/v2/eventmanagement";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a new event for clan. */
  createEvent(
    bearerToken: string,
    body: ApiCreateEventRequest,
    options: any = {}
  ): Promise<ApiEventManagement> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/create";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given event. */
  updateEventUser(
    bearerToken: string,
    body: ApiDeleteEventRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/user";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a event by ID. */
  deleteEvent(
    bearerToken: string,
    eventId: string,
    clanId?: string,
    creatorId?: string,
    eventLabel?: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    if (eventId === null || eventId === undefined) {
      throw new Error(
        "'eventId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/{eventId}".replace(
      "{eventId}",
      encodeURIComponent(String(eventId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("creator_id", creatorId);
    queryParams.set("event_label", eventLabel);
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given event. */
  updateEvent(
    bearerToken: string,
    eventId: string,
    body: MezonUpdateEventBody,
    options: any = {}
  ): Promise<any> {
    if (eventId === null || eventId === undefined) {
      throw new Error(
        "'eventId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/{eventId}".replace(
      "{eventId}",
      encodeURIComponent(String(eventId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete one or more users by ID or username. */
  deleteFriends(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all friends for the current user. */
  listFriends(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiFriendList> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add friends by ID or username to a user's account. */
  addFriends(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Block one or more users by ID or username. */
  blockFriends(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend/block";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Block one or more users by ID or username. */
  unblockFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {
    
    const urlPath = "/v2/friend/unblock";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetChannelCategoryNotiSettingsList */
  getChannelCategoryNotiSettingsList(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiNotificationChannelCategorySettingList> {
    const urlPath = "/v2/getchannelcategorynotisettingslist";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getUserProfileOnClan(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiClanProfile> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/getclanprofile/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationChannel */
  getNotificationCategory(
    bearerToken: string,
    categoryId?: string,
    options: any = {}
  ): Promise<ApiNotificationUserChannel> {
    const urlPath = "/v2/getnotificationcategory";
    const queryParams = new Map<string, any>();
    queryParams.set("category_id", categoryId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationChannel */
  getNotificationChannel(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiNotificationUserChannel> {
    const urlPath = "/v2/getnotificationchannel";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationClan */
  getNotificationClan(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiNotificationSetting> {
    const urlPath = "/v2/getnotificationclan";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationReactMessage */
  getNotificationReactMessage(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiNotifiReactMessage> {
    const urlPath = "/v2/getnotificationreactmessage";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Give a coffee */
  giveMeACoffee(
    bearerToken: string,
    body: ApiGiveCoffeeEvent,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/givecoffee";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get key server */
  getKeyServer(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiGetKeyServerResp> {
    const urlPath = "/v2/e2ee/key_server";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List HashtagDMList */
  hashtagDMList(
    bearerToken: string,
    userId?: Array<string>,
    limit?: number,
    options: any = {}
  ): Promise<ApiHashtagDmList> {
    const urlPath = "/v2/hashtagdmlist";
    const queryParams = new Map<string, any>();
    queryParams.set("user_id", userId);
    queryParams.set("limit", limit);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  createLinkInviteUser(
    bearerToken: string,
    body: ApiLinkInviteUserRequest,
    options: any = {}
  ): Promise<ApiLinkInviteUser> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/invite";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  getLinkInvite(
    basicAuthUsername: string,
    basicAuthPassword: string,
    inviteId: string,
    options: any = {}
  ): Promise<ApiInviteUserRes> {
    if (inviteId === null || inviteId === undefined) {
      throw new Error(
        "'inviteId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/invite/{inviteId}".replace(
      "{inviteId}",
      encodeURIComponent(String(inviteId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  inviteUser(
    bearerToken: string,
    inviteId: string,
    options: any = {}
  ): Promise<ApiInviteUserRes> {
    if (inviteId === null || inviteId === undefined) {
      throw new Error(
        "'inviteId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/invite/{inviteId}".replace(
      "{inviteId}",
      encodeURIComponent(String(inviteId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List HashtagDMList */
  listChannelByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiChannelDescList> {
    const urlPath = "/v2/listchannelbyuserid";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Mark as read */
  markAsRead(
    bearerToken: string,
    body: ApiMarkAsReadRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/markasread";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
  
  /** List mezon OAuth client */
  listMezonOauthClient(bearerToken: string,
      options: any = {}): Promise<ApiMezonOauthClientList> {
    
    const urlPath = "/v2/mznoauthclient";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
  
  /** set mute notification user channel. */
  setMuteNotificationCategory(
    bearerToken: string,
    body: ApiSetMuteNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/mutenotificationcategory/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set mute notification user channel. */
  setMuteNotificationChannel(
    bearerToken: string,
    body: ApiSetMuteNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/mutenotificationchannel/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete one or more notifications for the current user. */
  deleteNotifications(
    bearerToken: string,
    ids?: Array<string>,
    category?: number,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("category", category);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Fetch list of notifications. */
  listNotifications(
    bearerToken: string,
    limit?: number,
    clanId?: string,
    notificationId?: string,
    category?: number,
    direction?: number,
    options: any = {}
  ): Promise<ApiNotificationList> {
    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("clan_id", clanId);
    queryParams.set("notification_id", notificationId);
  queryParams.set("category", category);
    queryParams.set("direction", direction);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationChannelSetting(
    bearerToken: string,
    body: ApiSetNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notificationchannel/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationClanSetting(
    bearerToken: string,
    body: ApiSetDefaultNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notificationclan/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationCategorySetting(
    bearerToken: string,
    body: ApiSetNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notificationucategory/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteNotificationCategorySetting(
    bearerToken: string,
    categoryId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notificationusercategory/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("category_id", categoryId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteNotificationChannel(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notificationuserchannel/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteNotiReactMessage(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notifireactmessage/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  setNotificationReactMessage(
    bearerToken: string,
    body: ApiNotificationChannel,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notifireactmessage/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Stream http callback. */
  streamingServerCallback(
    bearerToken: string,
    body: ApiStreamHttpCallbackRequest,
    options: any = {}
  ): Promise<ApiStreamHttpCallbackResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/stream/callback";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set permission role channel. */
  setRoleChannelPermission(
    bearerToken: string,
    body: ApiUpdateRoleChannelRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/permissionrolechannel/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get permission list */
  getListPermission(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiPermissionList> {
    const urlPath = "/v2/permissions";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** GetPermissionByRoleIdChannelId */
  getPermissionByRoleIdChannelId(
    bearerToken: string,
    roleId?: string,
    channelId?: string,
    userId?: string,
    options: any = {}
  ): Promise<ApiPermissionRoleChannelListEventResponse> {
    const urlPath = "/v2/permissions/roles/channels/users";
    const queryParams = new Map<string, any>();
    queryParams.set("role_id", roleId);
    queryParams.set("channel_id", channelId);
    queryParams.set("user_id", userId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deletePinMessage(
    bearerToken: string,
    id?: string,
    messageId?: string,
    channelId?: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/pinmessage/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("id", id);
    queryParams.set("message_id", messageId);
    queryParams.set("channel_id", channelId);
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getPinMessagesList(
    bearerToken: string,
    messageId?: string,
    channelId?: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiPinMessagesList> {
    const urlPath = "/v2/pinmessage/get";
    const queryParams = new Map<string, any>();
    queryParams.set("message_id", messageId);
    queryParams.set("channel_id", channelId);
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** create message to inbox. */
  createMessage2Inbox(bearerToken: string,
      body:ApiMessage2InboxRequest,
      options: any = {}): Promise<ApiChannelMessageHeader> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/pinmessage/inbox";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  createPinMessage(
    bearerToken: string,
    body: ApiPinMessageRequest,
    options: any = {}
  ): Promise<ApiChannelMessageHeader> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/pinmessage/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get pubkey */
  getPubKeys(
    bearerToken: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<ApiGetPubKeysResponse> {
    const urlPath = "/v2/pubkey";
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** store pubkey for e2ee */
  pushPubKey(
    bearerToken: string,
    body: ApiPushPubKeyRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/pubkey/push";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  addRolesChannelDesc(
    bearerToken: string,
    body: ApiAddRoleChannelDescRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rolechannel/addrole";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** update the category of a channel */
  changeChannelCategory(
    bearerToken: string,
    newCategoryId: string,
    body: MezonChangeChannelCategoryBody,
    options: any = {}
  ): Promise<any> {
    if (newCategoryId === null || newCategoryId === undefined) {
      throw new Error(
        "'newCategoryId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/category/{newCategoryId}".replace(
      "{newCategoryId}",
      encodeURIComponent(String(newCategoryId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a role when Delete a role by ID. */
  deleteRoleChannelDesc(
    bearerToken: string,
    body: ApiDeleteRoleRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rolechannel/delete";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** ListRoles */
  listRoles(
    bearerToken: string,
    clanId?: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiRoleListEventResponse> {
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a new role for clan. */
  createRole(
    bearerToken: string,
    body: ApiCreateRoleRequest,
    options: any = {}
  ): Promise<ApiRole> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a role when Delete a role by ID. */
  updateRoleDelete(
    bearerToken: string,
    roleId: string,
    body: MezonUpdateRoleDeleteBody,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/delete/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a role by ID. */
  deleteRole(
    bearerToken: string,
    roleId: string,
    channelId?: string,
    clanId?: string,
    roleLabel?: string,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);
    queryParams.set("clan_id", clanId);
    queryParams.set("role_label", roleLabel);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given role. */
  updateRole(
    bearerToken: string,
    roleId: string,
    body: MezonUpdateRoleBody,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List role permissions */
  listRolePermissions(
    bearerToken: string,
    roleId: string,
    options: any = {}
  ): Promise<ApiPermissionList> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}/permissions".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List role permissions */
  listRoleUsers(
    bearerToken: string,
    roleId: string,
    limit?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiRoleUserList> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}/users".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getRoleOfUserInTheClan(
    bearerToken: string,
    clanId: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiRoleList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roleuserinclan/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Execute a Lua function on the server. */
  rpcFunc2(
    bearerToken: string,
    basicAuthUsername: string,
    basicAuthPassword: string,
    id: string,
    payload?: string,
    httpKey?: string,
    options: any = {}
  ): Promise<ApiRpc> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/rpc/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("payload", payload);
    queryParams.set("http_key", httpKey);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Execute a Lua function on the server. */
  rpcFunc(
    bearerToken: string,
    basicAuthUsername: string,
    basicAuthPassword: string,
    id: string,
    payload: string,
    httpKey?: string,
    options: any = {}
  ): Promise<ApiRpc> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (payload === null || payload === undefined) {
      throw new Error(
        "'payload' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rpc/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("http_key", httpKey);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(payload || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
  
  /**  */
  searchThread(bearerToken: string,
    clanId?:string,
    channelId?:string,
    label?:string,
    options: any = {}): Promise<ApiChannelDescList> {
  
  const urlPath = "/v2/searchthread";
  const queryParams = new Map<string, any>();
  queryParams.set("clan_id", clanId);
  queryParams.set("channel_id", channelId);
  queryParams.set("label", label);

  let bodyJson : string = "";

  const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
  const fetchOptions = buildFetchOptions("GET", options, bodyJson);
  if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
  }

  return Promise.race([
    fetch(fullUrl, fetchOptions).then((response) => {
      if (response.status == 204) {
        return response;
      } else if (response.status >= 200 && response.status < 300) {
        return response.json();
      } else {
        throw response;
      }
    }),
    new Promise((_, reject) =>
      setTimeout(reject, this.timeoutMs, "Request timed out.")
    ),
  ]);
}

  /** UpdateWallets */
  sendToken(
    bearerToken: string,
    body: ApiTokenSentEvent,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sendtoken";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  sessionLogout(
    bearerToken: string,
    body: ApiSessionLogoutRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/session/logout";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a new sticker */
  addClanSticker(
    bearerToken: string,
    body: ApiClanStickerAddRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sticker";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a sticker by ID */
  deleteClanStickerById(
    bearerToken: string,
    id: string,
    clanId?: string,
    stickerLabel?: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/sticker/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("sticker_label", stickerLabel);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a sticker by ID */
  updateClanStickerById(
    bearerToken: string,
    id: string,
    body: MezonUpdateClanStickerByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sticker/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get list sticker by user id */
  getListStickersByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiStickerListedResponse> {
    const urlPath = "/v2/stickers";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List streaming channels. */
  listStreamingChannels(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiListStreamingChannelsResponse> {
    const urlPath = "/v2/streaming-channels";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Register streaming in channel ( for bot - get streaming key) */
  registerStreamingChannel(
    bearerToken: string,
    body: ApiRegisterStreamingChannelRequest,
    options: any = {}
  ): Promise<ApiRegisterStreamingChannelResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/streaming-channels";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listStreamingChannelUsers(
    bearerToken: string,
    clanId?: string,
    channelId?: string,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiStreamingChannelUserList> {
    const urlPath = "/v2/streaming-channels/users";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);
    queryParams.set("channel_type", channelType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get the list of system messages. */
  getSystemMessagesList(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiSystemMessagesList> {
    const urlPath = "/v2/systemmessages";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a system messages. */
  createSystemMessage(
    bearerToken: string,
    body: ApiSystemMessageRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List Sd Topic */
  listSdTopic(
    bearerToken: string,
    clanId?: string,
    limit?: number,
    options: any = {}
  ): Promise<ApiSdTopicList> {
    const urlPath = "/v2/sdmtopic";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create Sd Topic */
  createSdTopic(
    bearerToken: string,
    body: ApiSdTopicRequest,
    options: any = {}
  ): Promise<ApiSdTopic> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sdmtopic";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a specific system messages. */
  deleteSystemMessage(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get details of a specific system messages. */
  getSystemMessageByClanId(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiSystemMessage> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a system messages. */
  updateSystemMessage(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateSystemMessageBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List user channels */
  listThreadDescs(
    bearerToken: string,
    channelId: string,
    limit?: number,
    state?: number,
    clanId?: string,
    threadId?: string,
    page?: number,
    options: any = {}
  ): Promise<ApiChannelDescList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/thread/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("clan_id", clanId);
    queryParams.set("thread_id", threadId);
    queryParams.set("page", page);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
  /** Update fields in a given category. */
  updateCategory(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateCategoryBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/updatecategory/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update channel private. */
  updateChannelPrivate(
    bearerToken: string,
    body: ApiChangeChannelPrivateRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/updatechannelprivate";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  updateUserProfileByClan(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateUserProfileByClanBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/updateclanprofile/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Upload attachment */
  uploadAttachmentFile(
    bearerToken: string,
    body: ApiUploadAttachmentRequest,
    options: any = {}
  ): Promise<ApiUploadAttachment> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/uploadattachmentfile";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  updateUser(
    bearerToken: string,
    body: ApiUpdateUsersRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/user/update";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** ListUserClansByUserId */
  listUserClansByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiAllUserClans> {
    const urlPath = "/v2/users/clans";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** ListUserPermissionInChannel */
  listUserPermissionInChannel(
    bearerToken: string,
    clanId?: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiUserPermissionInChannelListResponse> {
    const urlPath = "/v2/users/clans/channels";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get user status */
  getUserStatus(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiUserStatus> {
    const urlPath = "/v2/userstatus";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update user status */
  updateUserStatus(
    bearerToken: string,
    body: ApiUserStatusUpdate,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/userstatus";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** list transaction detail */
  listTransactionDetail(bearerToken: string,
      transId:string,
      options: any = {}): Promise<ApiTransactionDetail> {
    
    if (transId === null || transId === undefined) {
      throw new Error("'transId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/transaction/{transId}"
        .replace("{transId}", encodeURIComponent(String(transId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Store wallet key */
  storeWalletKey(bearerToken: string,
      body:ApiStoreWalletKeyRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/wallet/key";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get user status */
  listWalletLedger(bearerToken: string,
      limit?:number,
      filter?:number,
      transactionId?:string,
      page?:number,
      options: any = {}): Promise<ApiWalletLedgerList> {
    
    const urlPath = "/v2/walletledger";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("filter", filter);
    queryParams.set("transaction_id", transactionId);
    queryParams.set("page", page);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** create webhook */
  generateWebhook(
    bearerToken: string,
    body: ApiWebhookCreateRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/generate";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** update webhook name by id */
  updateWebhookById(
    bearerToken: string,
    id: string,
    body: MezonUpdateWebhookByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/update/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** list webhook belong to the channel */
  listWebhookByChannelId(
    bearerToken: string,
    channelId: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiWebhookListResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** disabled webhook */
  deleteWebhookById(
    bearerToken: string,
    id: string,
    body: MezonDeleteWebhookByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  buildFullUrl(
    basePath: string,
    fragment: string,
    queryParams: Map<string, any>
  ) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
      if (v instanceof Array) {
        fullPath += v.reduce((prev: any, curr: any) => {
          return (
            prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&"
          );
        }, "");
      } else {
        if (v != null) {
          fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
        }
      }
    }

    return fullPath;
  }

  /** Channel canvas editor */
  editChannelCanvases(
    bearerToken: string,
    body: ApiEditChannelCanvasRequest,
    options: any = {}
  ): Promise<ApiEditChannelCanvasResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/canvases/editor";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getChannelCanvasDetail(
    bearerToken: string,
    id: string,
    clanId?: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiChannelCanvasDetailResponse> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/canvases/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteChannelCanvas(
    bearerToken: string,
    canvasId: string,
    clanId?: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    if (canvasId === null || canvasId === undefined) {
      throw new Error(
        "'canvasId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/canvases/{canvasId}".replace(
      "{canvasId}",
      encodeURIComponent(String(canvasId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** list onboarding. */
  listOnboarding(
    bearerToken: string,
    clanId?: string,
    guideType?: number,
    limit?: number,
    page?: number,
    options: any = {}
  ): Promise<ApiListOnboardingResponse> {
    const urlPath = "/v2/onboarding";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("guide_type", guideType);
    queryParams.set("limit", limit);
    queryParams.set("page", page);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** create onboarding. */
  createOnboarding(
    bearerToken: string,
    body: ApiCreateOnboardingRequest,
    options: any = {}
  ): Promise<ApiListOnboardingResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/onboarding";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** delete onboarding. */
  deleteOnboarding(
    bearerToken: string,
    id: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/onboarding/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get detailed onboarding information. */
  getOnboardingDetail(
    bearerToken: string,
    id: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiOnboardingItem> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/onboarding/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** update onboarding. */
  updateOnboarding(
    bearerToken: string,
    id: string,
    body: MezonUpdateOnboardingBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/onboarding/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Generate clan webhook. */
  generateClanWebhook(
    bearerToken: string,
    body: ApiGenerateClanWebhookRequest,
    options: any = {}
  ): Promise<ApiGenerateClanWebhookResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clanwebhooks";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List clan webhook. */
  listClanWebhook(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiListClanWebhookResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clanwebhooks/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Disabled clan webhook. */
  deleteClanWebhookById(
    bearerToken: string,
    id: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clanwebhooks/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update clan webhook by id. */
  updateClanWebhookById(
    bearerToken: string,
    id: string,
    body: MezonUpdateClanWebhookByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clanwebhooks/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Sd Topic */
  getTopicDetail(
    bearerToken: string,
    topicId?: string,
    options: any = {}
  ): Promise<ApiSdTopic> {
    const urlPath = "/v2/sdmtopic/detail";
    const queryParams = new Map<string, any>();
    queryParams.set("topic_id", topicId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List onboarding step. */
  listOnboardingStep(
    bearerToken: string,
    clanId?: string,
    limit?: number,
    page?: number,
    options: any = {}
  ): Promise<ApiListOnboardingStepResponse> {
    const urlPath = "/v2/onboardingsteps";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);
    queryParams.set("page", page);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update onboarding step. */
  updateOnboardingStepByClanId(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateOnboardingStepByClanIdBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/onboardingsteps/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** create meeting room */
  createRoomChannelApps(bearerToken: string,
    body:MezonapiCreateRoomChannelApps,
    options: any = {}): Promise<MezonapiCreateRoomChannelApps> {
  
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel-apps/createroom";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Generate Meet Token */
  generateMeetToken(
    bearerToken: string,
    body:ApiGenerateMeetTokenRequest,
    options: any = {}
  ): Promise<ApiGenerateMeetTokenResponse> {
    
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/meet/generate";
      const queryParams = new Map<string, any>();

      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});

      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }

      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /** Create mezon OAuth client */
  getMezonOauthClient(bearerToken: string,
    clientId?:string,
    clientName?:string,
    options: any = {}
  ): Promise<ApiMezonOauthClient> {

    const urlPath = "/v2/mznoauthclient";
    const queryParams = new Map<string, any>();
    queryParams.set("client_id", clientId);
    queryParams.set("client_name", clientName);
    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** update mezon OAuth */
  updateMezonOauthClient(bearerToken: string,
      body:ApiMezonOauthClient,
      options: any = {}
    ): Promise<ApiMezonOauthClient> {
    
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/mznoauthclient";
      const queryParams = new Map<string, any>();

      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});

      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }

      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
    }
      /**  */
  generateHashChannelApps(bearerToken: string,
    appId?:string,
    options: any = {}
  ): Promise<ApiCreateHashChannelAppsResponse> {
  
    const urlPath = "/v2/channel-apps/hash";
    const queryParams = new Map<string, any>();
    queryParams.set("app_id", appId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add user event */
  addUserEvent(
    bearerToken: string,
    body:ApiUserEventRequest,
    options: any = {}
  ): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/userevent";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete user event */
  deleteUserEvent(
    bearerToken: string,
    clanId?:string,
    eventId?:string,
    options: any = {}
  ): Promise<any> {
    
    const urlPath = "/v2/userevent";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("event_id", eventId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  updateRoleOrder(bearerToken: string,
      body:ApiUpdateRoleOrderRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/role/orders";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create external Mezon meet */
  createExternalMezonMeet(bearerToken: string,
      options: any = {}): Promise<ApiGenerateMezonMeetResponse> {

    const urlPath = "/v2/meet/external/create";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** handler external mezon meet */
  generateMeetTokenExternal(bearerToken: string,
      basePath: string,
      token:string,
      displayName?:string,
      isGuest?:boolean,
      options: any = {}): Promise<ApiGenerateMeetTokenExternalResponse> {
    
    if (token === null || token === undefined) {
      throw new Error("'token' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/meet/external/{token}"
        .replace("{token}", encodeURIComponent(String(token)));
    const queryParams = new Map<string, any>();
    queryParams.set("display_name", displayName);
    queryParams.set("is_guest", isGuest);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** mute participant in the room */
  muteParticipantMezonMeet(bearerToken: string,
      body:ApiMeetParticipantRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/meet/participant/mute";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
  
  /** Remove participant out the room */
  removeParticipantMezonMeet(bearerToken: string,
      body:ApiMeetParticipantRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/meet/participant/remove";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List channels detail */
  listChannelDetail(bearerToken: string,
      channelId:string,
      options: any = {}): Promise<ApiChannelDescription> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  updateClanOrder(bearerToken: string,
      body:ApiUpdateClanOrderRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/updateclanorder";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Discover mezon clan. */
  clanDiscover(basicAuthUsername: string,
    basicAuthPassword: string,
      basePath: string,
      body:ApiClanDiscoverRequest,
      options: any = {}): Promise<ApiListClanDiscover> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/clan/discover";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
    deleteQuickMenuAccess(bearerToken: string,
        id?:string,
        botId?:string,
        menuName?:string,
        background?:string,
        actionMsg?:string,
        options: any = {}): Promise<any> {
      
      const urlPath = "/v2/quickmenuaccess";
      const queryParams = new Map<string, any>();
      queryParams.set("id", id);
      queryParams.set("bot_id", botId);
      queryParams.set("menu_name", menuName);
      queryParams.set("background", background);
      queryParams.set("action_msg", actionMsg);
  
      let bodyJson : string = "";
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }
  
    /**  */
    listQuickMenuAccess(bearerToken: string,
        botId?:string,
        channelId?:string,
        menuType?:number,
        options: any = {}): Promise<ApiQuickMenuAccessList> {
      
      const urlPath = "/v2/quickmenuaccess";
      const queryParams = new Map<string, any>();
      queryParams.set("bot_id", botId);
      queryParams.set("channel_id", channelId);
      queryParams.set("menu_type", menuType);
  
      let bodyJson : string = "";
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("GET", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }  
  
    /**  */
    addQuickMenuAccess(bearerToken: string,
        body:ApiQuickMenuAccessRequest,
        options: any = {}): Promise<any> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/quickmenuaccess";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }
  
    /**  */
    updateQuickMenuAccess(bearerToken: string,
        body:ApiQuickMenuAccessRequest,
        options: any = {}): Promise<any> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/quickmenuaccess";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /** UnlockItem */
    unlockItem(bearerToken: string,
        body:ApiUnlockedItemRequest,
        options: any = {}): Promise<ApiUnlockedItemResponse> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/unlockitem";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /** For sale items */
    listForSaleItems(bearerToken: string,
        page?:number,
        options: any = {}): Promise<ApiForSaleItemList> {
      
      const urlPath = "/v2/forsale";
      const queryParams = new Map<string, any>();
      queryParams.set("page", page);
  
      let bodyJson : string = "";
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("GET", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /**  */
    isFollower(bearerToken: string,
        body:ApiIsFollowerRequest,
        options: any = {}): Promise<ApiIsFollowerResponse> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/follower";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

  /**  */
    transferOwnership(bearerToken: string,
        body:ApiTransferOwnershipRequest,
        options: any = {}): Promise<any> {
      
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/transfer/ownership";
      const queryParams = new Map<string, any>();
  
      let bodyJson : string = "";
      bodyJson = JSON.stringify(body || {});
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("POST", options, bodyJson);
      if (bearerToken) {
          fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }

}
