// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { buildFetchOptions } from "./utils";
import { encode } from "js-base64";
import * as tsproto from "./api/api";
import { ApiUpdateChannelDescRequest } from "./client";
import { PinMessagesList } from "./api/api";

/** A single user-role pair. */
export interface ChannelUserListChannelUser {
  //
  clan_avatar?: string;
  //
  clan_id?: string;
  //
  clan_nick?: string;
  //
  id?: string;
  //Their relationship to the role.
  role_id?: Array<bigint>;
  //
  thread_id?: string;
  //User.
  user_id?: string;
  //Added by
  added_by?: string;
  // is banned
  is_banned?: boolean;
  // expired time
  expired_ban_time?: number;
}

/** A message sent on a channel. */
export interface ChannelMessage {
  //The unique ID of this message.
  id: string;
  //
  avatar?: string;
  //The channel this message belongs to.
  channel_id: string;
  //The name of the chat room, or an empty string if this message was not sent through a chat room.
  channel_label: string;
  //The clan this message belong to.
  clan_id?: string;
  //The code representing a message type or category.
  code: number;
  //The content payload.
  content: string;
  //
  reactions?: Array<ApiMessageReaction>;
  //
  mentions?: Array<ApiMessageMention>;
  //
  attachments?: Array<ApiMessageAttachment>;
  //
  references?: Array<ApiMessageRef>;
  //
  referenced_message?: string[];
  //True if the message was persisted to the channel's history, false otherwise.
  persistent?: boolean;
  //Message sender, usually a user ID.
  sender_id: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  clan_logo?: string;
  //The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  category_name?: string;
  //The username of the message sender, if any.
  username?: string;
  // The clan nick name
  clan_nick?: string;
  // The clan avatar
  clan_avatar?: string;
  //
  display_name?: string;
  //
  create_time_seconds?: number;
  //
  update_time_seconds?: number;
  //
  mode?: number;
  //
  message_id?: string;
  //
  hide_editted?: boolean;
  //
  is_public?: boolean;
  //
  topic_id?: string;
}

/**  */
export interface ApiBannedUser {
  //
  ban_time?: number;
  //The banned user.
  banned_id?: string;
  //
  banner_id?: string;
  //
  channel_id?: string;
  //
  reason?: string;
}

/**  */
export interface ApiBannedUserList {
  //
  banned_users?: Array<ApiBannedUser>;
}

/** A single user-role pair. */
export interface ClanUserListClanUser {
  //from the `avatar_url` field in the `clan_desc_profile` table.
  clan_avatar?: string;
  //
  clan_id?: string;
  //from the `nick_name` field in the `clan_desc_profile` table.
  clan_nick?: string;
  //Their relationship to the role.
  role_id?: Array<bigint>;
  //User.
  user?: ApiUser;
}

/**  */
export interface GetPubKeysResponseUserPubKey {
  //
  PK?: ApiPubKey;
  //
  user_id?: string;
}

/**  */
export interface CountClanBadgeResponseBadge {
  //
  clan_id?: string;
  //
  count?: number;
}

/**  */
export interface MezonChangeChannelCategoryBody {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface MezonSetChanEncryptionMethodBody {
  //
  method?: string;
}

/**  */
export interface MezonDeleteWebhookByIdBody {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/** Update app information. */
export interface MezonUpdateAppBody {
  //about the app.
  about?: string;
  //App url.
  app_url?: string;
  //Avatar URL.
  applogo?: string;
  //Username.
  appname?: string;
  //Metadata.
  metadata?: string;
  //Token.
  token?: string;
  //Shadow true|false
  is_shadow?: string;
}

/**  */
export interface MezonUpdateCategoryBody {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
}

/**  */
export interface ApiAddAppRequest {
  //
  about_me?: string;
  //
  app_logo?: string;
  //App url.
  app_url?: string;
  //The appname.
  appname?: string;
  //Creator of the app.
  creator_id?: string;
  //Is shadow.
  is_shadow?: boolean;
  //Role of this app.
  role?: number;
  //The password.
  token?: string;
}

/**
* - USER_ROLE_ADMIN: All access
 - USER_ROLE_DEVELOPER: Best for developers, also enables APIs and API explorer
 - USER_ROLE_MAINTAINER: Best for users who regularly update player information.
 - USER_ROLE_READONLY: Read-only role for those only need to view data
*/
export enum ApiAppRole {
  /*  */
  USER_ROLE_UNKNOWN = 0,
  /* */
  USER_ROLE_ADMIN = 1, // All access
  USER_ROLE_DEVELOPER = 2, // Best for developers, also enables APIs and API explorer
  USER_ROLE_MAINTAINER = 3, // Best for users who regularly update player information.
  USER_ROLE_READONLY = 4, // Read-only role for those only need to view data
}

/** Update fields in a given channel. */
export interface MezonUpdateChannelDescBody {
  //
  age_restricted?: number;
  //
  category_id?: string;
  //
  channel_label?: string;
  //
  e2ee?: number;
  //
  topic?: string;
  /** The clan ID */
  clan_id: string;
  /** The ID of the channel to update. */
  channel_id: string;
  /** app url for channel type app */
  app_id: string;
  /** channel avatar */
  channel_avatar: string | undefined;
}

/**  */
export interface ApiLogedDevice {
  //
  device_id?: string;
  //
  device_name?: string;
  //
  ip?: string;
  //
  last_active?: string;
  //
  login_at?: string;
  //
  platform?: string;
  //
  status?: number;
  //
  location?: string;
  //
  is_current?: boolean;
}

/**  */
export interface ApiLogedDeviceList {
  //
  devices?: Array<ApiLogedDevice>;
}

/**  */
export interface MezonUpdateClanDescBody {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
  // is onboarding.
  is_onboarding?: boolean;
  // welcome channel id.
  welcome_channel_id?: string;
  //Onboarding_banner.
  onboarding_banner?: string;
  // is community.
  is_community?: boolean;
  // community banner
  community_banner?: string;
  // description
  description?: string;
  // about
  about?: string;
  // short url for community
  short_url?: string;
  // prevent anonymous
  prevent_anonymous?: boolean;
}

/**  */
export interface MezonUpdateClanDescProfileBody {
  //
  avatar_url?: string;
  //
  nick_name?: string;
  //
  profile_banner?: string;
  //
  profile_theme?: string;
}

/**  */
export interface MezonUpdateClanEmojiByIdBody {
  id: string;
  shortname: string;
  clan_id: string;
  source: string;
}

/**  */
export interface MezonUpdateClanStickerByIdBody {
  //
  category?: string;
  //
  clan_id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/** update a event within clan. */
export interface MezonUpdateEventBody {
  //
  event_id?: string;
  //
  address?: string;
  //
  channel_id?: string;
  //
  channel_voice_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  end_time_seconds?: number;
  //
  logo?: string;
  //
  start_time_seconds?: number;
  //
  title?: string;
  //
  channel_id_old?: string;
  //
  repeat_type?: number;
}

/** Update fields in a given role. */
export interface MezonUpdateRoleBody {
  //The permissions to add.
  active_permission_ids?: Array<bigint>;
  //The users to add.
  add_user_ids?: Array<bigint>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  max_permission_id: string;
  //The permissions to remove.
  remove_permission_ids?: Array<bigint>;
  //The users to remove.
  remove_user_ids?: Array<bigint>;
  //
  role_icon?: string;
  //
  title?: string;
}

/** Delete a role the user has access to. */
export interface MezonUpdateRoleDeleteBody {
  //
  clan_id?: string;
}

/** Request to get system message by clan and channel IDs. */
export interface MezonUpdateSystemMessageBody {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  hide_audit_log?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/**  */
export interface MezonUpdateUserProfileByClanBody {
  //
  avatar?: string;
  //
  nick_name?: string;
}

/**  */
export interface MezonUpdateWebhookByIdBody {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  channel_id_update?: string;
  //
  clan_id?: string;
  //
  webhook_name?: string;
}

/** A single user-role pair. */
export interface RoleUserListRoleUser {
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //The id of the user's account.
  id?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //The timezone set by the user.
  online?: boolean;
  //The username of the user's account.
  username?: string;
}

/**  */
export interface UpdateClanOrderRequestClanOrder {
  //
  clan_id?: string;
  //
  order?: number;
}

/**  */
export interface ApiUpdateClanOrderRequest {
  //
  clans_order?: Array<UpdateClanOrderRequestClanOrder>;
}

/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  //The custom id in the user's account.
  custom_id?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned.
  disable_time?: string;
  //The email address of the user.
  email?: string;
  //
  encrypt_private_key?: string;
  //
  logo?: string;
  //
  splash_screen?: string;
  //The user object.
  user?: ApiUser;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified.
  verify_time?: string;
  //The user's wallet data.
  wallet?: number;
  //Password is setted
  password_setted?: boolean;
}

/** Send a app token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountApp {
  //
  appid?: string;
  //
  appname?: string;
  //The account token when create apps to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

export interface ApiAccountSMS {
  phoneno: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.  Ignored with unlink operations.
  password?: string;
  // Old email
  prev_email?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Mezon token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountMezon {
  //The phone number
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Mezon token to the server. Used with authenticate/link/unlink. */
export interface ApiLinkAccountMezon {
  //The phone number
  phone_number?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiAddFavoriteChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiAddFavoriteChannelResponse {
  //
  channel_id?: string;
}

/** Add a role for channel. */
export interface ApiAddRoleChannelDescRequest {
  //
  channel_id?: string;
  //
  role_ids?: Array<bigint>;
}

/**  */
export interface ApiAllUsersAddChannelResponse {
  //
  channel_id?: string;
  //
  limit?: number;
  //
  user_ids?: Array<bigint>;
  //
  usernames?: Array<string>;
  //
  display_names?: Array<string>;
  //
  avatars?: Array<string>;
  //
  onlines?: Array<boolean>;
}

/**  */
export interface ApiAllUserClans {
  //
  users?: Array<ApiUser>;
}

/** App information. */
export interface ApiApp {
  //
  about?: string;
  //
  app_url?: string;
  //
  applogo?: string;
  //
  appname?: string;
  //
  creator_id?: string;
  //The UNIX time when the app was disabled.
  disable_time?: string;
  //The UNIX time when the app was created.
  create_time?: string;
  //
  id?: string;
  //
  is_shadow?: boolean;
  //
  role?: number;
  //
  token?: string;
}

/** A list of apps. */
export interface ApiAppList {
  //A list of apps.
  apps?: Array<ApiApp>;
  //Next cursor.
  next_cursor?: string;
  //Approximate total number of apps.
  total_count?: number;
}

/**  */
export interface ApiAuditLog {
  //
  action_log?: string;
  //
  channel_id?: string;
  //
  channel_label?: string;
  //
  clan_id?: string;
  //
  details?: string;
  //
  entity_id?: string;
  //
  entity_name?: string;
  //
  id?: string;
  //
  time_log?: string;
  //
  user_id?: string;
}

/** Authenticate against the server with email+password. */
export interface ApiAuthenticateSMSRequest {
  //The email account details.
  account?: ApiAccountSMS;
  //Register the account if the user does not already exist.
  create?: boolean;
  //Set the username on the account at register. Must be unique.
  username?: string;
}

/** Authenticate against the server with email+password. */
export interface ApiAuthenticateEmailRequest {
  //The email account details.
  account?: ApiAccountEmail;
  //Register the account if the user does not already exist.
  create?: boolean;
  //Set the username on the account at register. Must be unique.
  username?: string;
}

/**  */
export interface ApiCategoryDesc {
  //
  category_id?: string;
  //
  category_name?: string;
  //
  category_order?: number;
  //
  clan_id?: string;
  //
  creator_id?: string;
}

/**  */
export interface ApiCategoryDescList {
  //A list of channel.
  categorydesc?: Array<ApiCategoryDesc>;
}

/**  */
export interface ApiUpdateUsernameRequest {
  //
  username?: string;
}

/**  */
export interface ApiCategoryOrderUpdate {
  //
  category_id?: string;
  //
  order?: number;
}

/**  */
export interface ApiChanEncryptionMethod {
  //
  channel_id?: string;
  //
  method?: string;
}

export interface ApiListChannelAppsResponse {
  //
  channel_apps?: Array<ApiChannelAppResponse>;
}

/** Update fields in a given channel. */
export interface ApiChangeChannelPrivateRequest {
  //The clan id
  clan_id?: string;
  //The ID of the channel to update.
  channel_id?: string;
  //
  channel_private?: number;
  //
  role_ids?: Array<bigint>;
  //The users to add.
  user_ids?: Array<bigint>;
}

/**  */
export interface ApiChannelAppResponse {
  //
  app_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  app_url?: string;
  //
  app_name?: string;
  //
  app_logo?: string;
}

/**  */
export interface ApiChannelAttachment {
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created.
  create_time?: string;
  //
  filename?: string;
  //
  filesize?: string;
  //
  filetype?: string;
  //
  id?: string;
  //
  uploader?: string;
  //
  url?: string;
  //message id.
  message_id?: string;
  //width.
  width?: number;
  //height.
  height?: number;
}

/**  */
export interface ApiChannelAttachmentList {
  //
  attachments?: Array<ApiChannelAttachment>;
}

/**  */
export interface ApiChannelCanvasDetailResponse {
  //
  content?: string;
  //
  creator_id?: string;
  //
  editor_id?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
}

/**  */
export interface ApiChannelCanvasItem {
  //
  content?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
  // update time
  update_time?: string;
  // create time
  create_time?: string;
}

/**  */
export interface ApiChannelCanvasListResponse {
  //
  channel_canvases?: Array<ApiChannelCanvasItem>;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  count?: number;
}

/**  */
export interface ApiEditChannelCanvasRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
  //
  status?: number;
}

/**  */
export interface ApiEditChannelCanvasResponse {
  //
  id?: string;
}

/** A list of channel description, usually a result of a list operation. */
export interface ApiChannelDescList {
  //Cacheable cursor to list newer channel description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //A list of channel.
  channeldesc?: Array<ApiChannelDescription>;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //
  page?: number;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}

/**  */
export interface ApiAddChannelAppRequest {
  //App url.
  app_url?: string;
  //The appname.
  appname?: string;
  //Creator of the app.
  creator_id?: string;
  //Role of this app.
  role?: number;
  //The password.
  token?: string;
}

/**  */
export interface ApiChannelDescription {
  //
  active?: number;
  //
  age_restricted?: number;
  //
  category_id?: string;
  //
  category_name?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  count_mess_unread?: number;
  //
  create_time_seconds?: number;
  //creator ID.
  creator_id?: string;
  //
  creator_name?: string;
  //
  e2ee?: number;
  //
  is_mute?: boolean;
  //
  last_pin_message?: string;
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  channel_avatar?: string;
  //The parent channel this message belongs to.
  parent_id?: string;
  //The channel type.
  type?: number;
  //
  update_time_seconds?: number;
  //
  app_id?: string;
  //
  topic?: string;
  //
  user_ids?: Array<bigint>;
  //
  usernames?: Array<string>;
  //
  display_names?: Array<string>;
  //
  onlines?: Array<boolean>;
  // DM status
  avatars?: Array<string>;
  // member count
  member_count?: number;
}

/**  */
export interface ApiChannelMessageHeader {
  //
  attachment?: Uint8Array;
  //
  content?: string;
  //
  id?: string;
  //
  mention?: Uint8Array;
  //
  reaction?: Uint8Array;
  //
  reference?: Uint8Array;
  //
  repliers?: Array<bigint>;
  //
  sender_id?: string;
  //
  timestamp_seconds?: number;
}

/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //A list of messages.
  messages?: Array<ChannelMessage>;
}

/**  */
export interface ApiChannelSettingItem {
  //
  active?: number;
  //
  category_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  channel_type?: number;
  //
  creator_id?: string;
  //
  id?: string;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  message_count?: string;
  //
  parent_id?: string;
  //
  user_ids?: Array<bigint>;
}

/**  */
export interface ApiChannelSettingListResponse {
  //
  channel_count?: number;
  //
  channel_setting_list?: Array<ApiChannelSettingItem>;
  //
  clan_id?: string;
  //
  thread_count?: number;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiChannelUserList {
  //
  channel_id?: string;
  //User-role pairs for a channel.
  channel_users?: Array<ChannelUserListChannelUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiCheckDuplicateClanNameResponse {
  //
  is_duplicate?: boolean;
}

/**  */
export interface ApiClanDesc {
  //
  banner?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
  //
  badge_count?: number;
  // is onboarding.
  is_onboarding?: boolean;
  // welcome channel id.
  welcome_channel_id?: string;
  //Onboarding_banner.
  onboarding_banner?: string;
  // is community.
  is_community?: boolean;
  // community banner
  community_banner?: string;
  // description
  description?: string;
  // about
  about?: string;
  // short url for community
  short_url?: string;
  // prevent anonymous
  prevent_anonymous?: boolean;
  // has unread message
  has_unread_message?: boolean;
}

/**  */
export interface ApiClanDescList {
  //A list of channel.
  clandesc?: Array<ApiClanDesc>;
}

/**  */
export interface ApiClanEmoji {
  //
  category?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  shortname?: string;
  //
  src?: string;
  //
  is_for_sale?: boolean;
}

/**  */
export interface ApiClanEmojiCreateRequest {
  //
  category?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  shortname?: string;
  //
  source?: string;
  //
  is_for_sale?: boolean;
}

/** Get clan profile. */
export interface ApiClanProfile {
  //
  avatar?: string;
  //
  clan_id?: string;
  //
  nick_name?: string;
  //
  user_id?: string;
  //
  about?: string;
}

/**  */
export interface ApiClanSticker {
  //
  category?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  shortname?: string;
  //
  source?: string;
  //
  media_type?: number;
  //
  is_for_sale?: boolean;
}

/**  */
export interface ApiClanStickerAddRequest {
  //
  category?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  shortname?: string;
  //
  source?: string;
  //
  media_type?: number;
  //
  is_for_sale?: boolean;
}

/** A list of users belonging to a clan, along with their role. */
export interface ApiClanUserList {
  //
  clan_id?: string;
  //User-role pairs for a clan.
  clan_users?: Array<ClanUserListClanUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiConfirmLoginRequest {
  //Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  //
  login_id?: string;
}

/**  */
export interface ApiCreateActivityRequest {
  //
  activity_description?: string;
  //
  activity_name?: string;
  //
  activity_type?: number;
  //
  application_id?: string;
  //
  //start_time?: string;
  //
  status?: number;
}

/**  */
export interface ApiCreateCategoryDescRequest {
  //
  category_name?: string;
  //
  clan_id?: string;
}

/** Create a channel within clan. */
export interface ApiCreateChannelDescRequest {
  //
  app_id?: string;
  //
  category_id?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //The parent channel this message belongs to.
  parent_id?: string;
  //The channel type.
  type?: number;
  //The users to add.
  user_ids?: Array<bigint>;
}

/**  */
export interface ApiCreateClanDescRequest {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
}

/** Create a event within clan. */
export interface ApiCreateEventRequest {
  //
  address?: string;
  //
  channel_voice_id?: string;
  //
  clan_id?: string;
  //
  description?: string;
  //
  end_time_seconds?: number;
  //
  logo?: string;
  //
  start_time_seconds?: number;
  //
  title?: string;
  //
  channel_id?: string;
  //
  action?: number;
  //
  event_status?: number;
  //
  repeat_type?: number;
  //
  creator_id?: string;
  //
  user_id?: string;
  //
  is_private?: boolean;
  //
  meet_room?: ApiGenerateMezonMeetResponse;
}

/** Create a event within clan. */
export interface ApiUpdateEventRequest {
  //
  address?: string;
  //
  channel_id?: string;
  //
  event_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
  //
  clan_id?: string;
}

/** Create a role within clan. */
export interface ApiCreateRoleRequest {
  //The permissions to add.
  active_permission_ids?: Array<bigint>;
  //The users to add.
  add_user_ids?: Array<bigint>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  max_permission_id: string;
  //
  role_icon?: string;
  //
  title?: string;
  //
  order_role?: number;
}

/** Delete a channel the user has access to. */
export interface ApiDeleteChannelDescRequest {
  //The clan id
  clan_id?: string;
  //The id of a channel.
  channel_id?: string;
}

/**  */
export interface ApiDeleteEventRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //The id of a event.
  event_id?: string;
  //
  event_label?: string;
}

/** Delete a role the user has access to. */
export interface ApiDeleteRoleRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //The id of a role.
  role_id?: string;
  //
  role_label?: string;
}

/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The version hash of the object.
  version?: string;
}

/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface ApiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/**  */
export interface ApiRegisterStreamingChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiRegisterStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  streaming_url?: string;
}

/**  */
export interface ApiListStreamingChannelsResponse {
  //
  streaming_channels?: Array<ApiStreamingChannelResponse>;
}

export interface ApiEmojiListedResponse {
  //
  emoji_list?: Array<ApiClanEmoji>;
}

/**  */
export interface ApiEmojiRecent {
  //ID of the emoji.
  emoji_recents_id?: string;
  //
  emoji_id?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the emoji was created.
  update_time?: string;
}

export interface ApiAddFriendsResponse {
  ids?: Array<bigint>;
  usernames?: Array<string>;
}

/**  */
export interface ApiEventList {
  //A list of event.
  events?: Array<ApiEventManagement>;
}

/**  */
export interface ApiEventManagement {
  //
  active?: number;
  //
  address?: string;
  //
  channel_voice_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  end_time_seconds?: number;
  //
  id?: string;
  //
  logo?: string;
  //
  max_permission?: number;
  //
  start_event?: number;
  //
  start_time_seconds?: number;
  //
  title?: string;
  //
  user_ids?: Array<bigint>;
  //
  create_time?: string;
  //
  channel_id?: string;
  //
  event_status?: number;
  //
  repeat_type?: number;
  //
  is_private?: boolean;
  //
  meet_room?: ApiGenerateMezonMeetResponse;
}

/**  */
export interface ApiListFavoriteChannelResponse {
  //
  channel_ids?: Array<bigint>;
}

/**  */
export interface ApiFilterParam {
  //
  field_name?: string;
  //
  field_value?: string;
}

/** A friend of a user. */
export interface ApiFriend {
  //The friend status.  one of "Friend.State".
  state?: number;
  //Time of the latest relationship update.
  update_time?: string;
  //The user object.
  user?: ApiUser;
  //Source ID
  source_id?: string;
}

/** A collection of zero or more friends of the user. */
export interface ApiFriendList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //The Friend objects.
  friends?: Array<ApiFriend>;
}

/**  */
export interface ApiGetKeyServerResp {
  //
  url?: string;
}

/**  */
export interface ApiGenerateMezonMeetResponse {
  //
  meet_id?: string;
  //
  room_name?: string;
  //
  external_link?: string;
  //
  creator_id?: string;
  //
  event_id?: string;
}

/**  */
export interface ApiGenerateMeetTokenExternalResponse {
  //
  guest_user_id?: string;
  //
  token?: string;
  //
  guest_access_token?: string;
}

/**  */
export interface ApiMeetParticipantRequest {
  //
  room_name?: string;
  //
  username?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiGetPubKeysResponse {
  //
  pub_keys?: Array<GetPubKeysResponseUserPubKey>;
}

/**  */
export interface ApiGiveCoffeeEvent {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_ref_id?: string;
  //
  receiver_id?: string;
  //
  sender_id?: string;
  //
  token_count?: number;
}

/**  */
export interface ApiHashtagDm {
  //The channel id.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  meeting_code?: string;
  //
  parent_id?: string;
  //
  type?: number;
}

/**  */
export interface ApiHashtagDmList {
  //
  hashtag_dm?: Array<ApiHashtagDm>;
}

/** Add link invite users to. */
export interface ApiInviteUserRes {
  //
  channel_desc?: ApiChannelDescription;
  //id channel to add link to.
  channel_id?: string;
  //
  channel_label?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  clan_name?: string;
  //
  user_joined?: boolean;
  //
  expiry_time?: string;
  //
  clan_logo: string;
  //
  member_count: number;
}

/** Add link invite users to. */
export interface ApiLinkInviteUser {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  create_time?: string;
  //The user to add.
  creator_id?: string;
  //
  expiry_time?: string;
  //
  id?: string;
  //
  invite_link?: string;
}

/** Add link invite users to. */
export interface ApiLinkInviteUserRequest {
  //id channel to add link to.
  channel_id?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  expiry_time?: number;
}

export interface ApiNotifiReactMessage {
  //
  channel_id?: string;
  //
  id?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiMessage2InboxRequest {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  message_id?: string;
  //
  reactions?: Array<ApiMessageReaction>;
  //
  mentions?: Array<ApiMessageMention>;
  //
  attachments?: Array<ApiMessageAttachment>;
  //
  references?: Array<ApiMessageRef>;
}

/**  */
export interface ApiMessageAttachment {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  url?: string;
  //
  width?: number;
  //
  thumbnail?: string;
  // The channel this message belongs to.
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  // The message that user react
  message_id?: string;
  // Message sender, usually a user ID.
  sender_id?: string;
  // duration for video in seconds
  duration?: number;
}

/**  */
export interface ApiMessageDeleted {
  //
  deletor?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiListUserActivity {
  //
  activities?: Array<ApiUserActivity>;
}
/**  */
export interface ApiLoginIDResponse {
  //
  address?: string;
  //
  create_time_second?: string;
  //
  login_id?: string;
  //
  platform?: string;
  //
  status?: number;
  //
  user_id?: string;
  //
  username?: string;
}

/**  */
export interface ApiMarkAsReadRequest {
  //
  category_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiMessageMention {
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  id?: string;
  //
  user_id?: string;
  //
  username?: string;
  // role id
  role_id?: string;
  // role name
  rolename?: string;
  // start position
  s?: number;
  // end position
  e?: number;
  /** The channel this message belongs to. */
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  /** The message that user react */
  message_id?: string;
  /** Message sender, usually a user ID. */
  sender_id?: string;
}

/**  */
export interface ApiLoginRequest {
  //
  address?: string;
  //
  platform?: string;
}

/**  */
export interface ApiMessageReaction {
  //
  action?: boolean;
  //
  emoji_id: string;
  //
  emoji: string;
  //
  id?: string;
  //
  sender_id?: string;
  //
  sender_name?: string;
  //
  sender_avatar?: string;
  // count of emoji
  count: number;
  /** The channel this message belongs to. */
  channel_id: string;
  // The mode
  mode: number;
  // Is public
  is_public: boolean;
  // The channel label
  channel_label?: string;
  /** The message that user react */
  message_id: string;
  //
  topic_id?: string;
  //
  emoji_recent_id?: string;
}

export interface ApiListChannelAppsResponse {
  //
  channel_apps?: Array<ApiChannelAppResponse>;
}

/**  */
export interface ApiListStreamingChannelsResponse {
  //
  streaming_channels?: Array<ApiStreamingChannelResponse>;
}

/**  */
export interface ApiMezonOauthClient {
  //
  access_token_strategy?: string;
  //
  allowed_cors_origins?: Array<string>;
  //
  audience?: Array<string>;
  //
  authorization_code_grant_access_token_lifespan?: string;
  //
  authorization_code_grant_id_token_lifespan?: string;
  //
  authorization_code_grant_refresh_token_lifespan?: string;
  //
  backchannel_logout_session_required?: boolean;
  //
  backchannel_logout_uri?: string;
  //
  client_credentials_grant_access_token_lifespan?: string;
  //
  client_id?: string;
  //
  client_name?: string;
  //
  client_secret?: string;
  //
  client_secret_expires_at?: number;
  //
  client_uri?: string;
  //
  contacts?: Array<string>;
  //
  //created_at?: Date;
  //
  frontchannel_logout_session_required?: boolean;
  //
  frontchannel_logout_uri?: string;
  //
  grant_types?: Array<string>;
  //
  implicit_grant_access_token_lifespan?: string;
  //
  implicit_grant_id_token_lifespan?: string;
  //
  jwks?: Array<string>;
  //
  jwks_uri?: string;
  //
  jwt_bearer_grant_access_token_lifespan?: string;
  //
  logo_uri?: string;
  //
  owner?: string;
  //
  policy_uri?: string;
  //
  post_logout_redirect_uris?: Array<string>;
  //
  redirect_uris?: Array<string>;
  //
  refresh_token_grant_access_token_lifespan?: string;
  //
  refresh_token_grant_id_token_lifespan?: string;
  //
  refresh_token_grant_refresh_token_lifespan?: string;
  //
  registration_access_token?: string;
  //
  registration_client_uri?: string;
  //
  request_object_signing_alg?: string;
  //
  request_uris?: Array<string>;
  //
  response_types?: Array<string>;
  //
  scope?: string;
  //
  sector_identifier_uri?: string;
  //
  skip_consent?: boolean;
  //
  skip_logout_consent?: boolean;
  //
  subject_type?: string;
  //
  token_endpoint_auth_method?: string;
  //
  token_endpoint_auth_signing_alg?: string;
  //
  tos_uri?: string;
  //
  //updated_at?: string;
  //
  userinfo_signed_response_alg?: string;
}

/**  */
export interface ApiMezonOauthClientList {
  //
  list_mezon_oauth_client?: Array<ApiMezonOauthClient>;
}

/**  */
export interface ApiMessageRef {
  //
  message_id?: string;
  //
  message_ref_id?: string;
  //
  ref_type?: number;
  //
  message_sender_id?: string;
  // original message sendre username
  message_sender_username?: string;
  // original message sender avatar
  mesages_sender_avatar?: string;
  // original sender clan nick name
  message_sender_clan_nick?: string;
  // original sender display name
  message_sender_display_name?: string;
  //
  content?: string;
  //
  has_attachment: boolean;
  /** The channel this message belongs to. */
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
}

/** A notification in the server. */
export interface ApiNotification {
  //
  avatar_url?: string;
  //
  channel_id?: string;
  //
  channel_type?: number;
  //
  clan_id?: string;
  //Category code for this notification.
  code?: number;
  //Content of the notification in JSON.
  content?: tsproto.DirectFcmProto;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
  create_time?: string;
  //ID of the Notification.
  id?: string;
  //True if this notification was persisted to the database.
  persistent?: boolean;
  //ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  //Subject of the notification.
  subject?: string;
  //category.
  category?: number;
  //
  topic_id?: string;
  //
  channel?: ApiChannelDescription;
}

/**  */
export interface ApiNotificationChannel {
  //
  channel_id?: string;
}

/**  */
export interface ApiNotificationChannelCategorySetting {
  //
  action?: number;
  //
  channel_category_label?: string;
  //
  channel_category_title?: string;
  //
  id?: string;
  //
  notification_setting_type?: number;
}

/**  */
export interface ApiNotificationChannelCategorySettingList {
  //
  notification_channel_category_settings_list?: Array<ApiNotificationChannelCategorySetting>;
}

/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  //Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  //Collection of notifications.
  notifications?: Array<ApiNotification>;
}

/**  */
export interface ApiNotificationSetting {
  //
  id?: string;
  //
  notification_setting_type?: number;
}

/**  */
export interface ApiNotificationUserChannel {
  //
  active?: number;
  //
  id?: string;
  //
  notification_setting_type?: number;
  //
  time_mute?: string;
  //
  channel_id?: string;
}

/**  */
export interface ApiStreamHttpCallbackRequest {
  //
  action?: number;
  //
  app?: string;
  //
  client_id?: string;
  //
  ip?: string;
  //
  page_url?: string;
  //
  param?: string;
  //
  server_id?: string;
  //
  service_id?: string;
  //
  stream?: string;
  //
  stream_id?: string;
  //
  stream_url?: string;
  //
  tc_url?: string;
  //
  vhost?: string;
}

/**  */
export interface ApiStreamHttpCallbackResponse {
  //
  code?: number;
  //
  msg?: string;
}

/**  */
export interface ApiPermission {
  //
  active?: number;
  //
  description?: string;
  //
  id?: string;
  //
  level?: number;
  //
  scope?: number;
  //
  slug?: string;
  //
  title?: string;
}

/** A list of permission description, usually a result of a list operation. */
export interface ApiPermissionList {
  //
  max_level_permission?: number;
  //A list of permission.
  permissions?: Array<ApiPermission>;
}

/**  */
export interface ApiPermissionRoleChannel {
  //
  active?: boolean;
  //
  permission_id?: string;
}

/**  */
export interface ApiPermissionRoleChannelListEventResponse {
  //
  channel_id?: string;
  //
  permission_role_channel?: Array<ApiPermissionRoleChannel>;
  //
  role_id?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiPermissionUpdate {
  //
  permission_id?: string;
  //
  slug?: string;
  //
  type?: number;
}

/**  */
export interface ApiPinMessage {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  create_time_seconds?: number;
  //
  id?: string;
  //
  message_id?: string;
  //
  sender_id?: string;
  //
  username?: string;
  //
  attachment?: Uint8Array;
}

/**  */
export interface ApiPinMessageRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiPinMessagesList {
  //
  pin_messages_list?: Array<ApiPinMessage>;
}

/**  */
export interface ApiPubKey {
  encr: Uint8Array;
  sign: Uint8Array;
}

/**  */
export interface ApiPushPubKeyRequest {
  //
  PK?: ApiPubKey;
}

/**  */
export interface ApiRegistFcmDeviceTokenResponse {
  //
  device_id?: string;
  //
  platform?: string;
  //
  token?: string;
}

/**  */
export interface ApiRegisterStreamingChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiRegisterStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  streaming_url?: string;
}

/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The user owner of the object.
  user_id?: string;
}

/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}

/**  */
export interface ApiRegistrationEmailRequest {
  //
  avatar_url?: string;
  //
  display_name?: string;
  //
  dob?: string;
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.
  password?: string;
  //A old password for the user account.
  old_password?: string;
  //Set the username on the account at register. Must be unique.
  username?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiUpdateRoleOrderRequest {
  //
  clan_id?: string;
  //
  roles?: Array<ApiRoleOrderUpdate>;
}

/**  */
export interface ApiRoleOrderUpdate {
  //
  order?: number;
  //
  role_id?: string;
}

/**  */
export interface ApiRole {
  //
  active?: number;
  //
  allow_mention?: number;
  //
  channel_ids?: Array<bigint>;
  //
  clan_id?: string;
  //
  color?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  id?: string;
  //
  max_level_permission?: number;
  //
  permission_list?: ApiPermissionList;
  //
  role_channel_active?: number;
  //
  role_icon?: string;
  //
  role_user_list?: ApiRoleUserList;
  //
  slug?: string;
  //
  title?: string;
  //
  order_role?: number;
}

/**  */
export interface ApiIsBannedResponse {
  //
  is_banned?: boolean;
  expired_ban_time?: number;
}

/** A list of role description, usually a result of a list operation. */
export interface ApiRoleList {
  max_level_permission?: number;
  //A list of role.
  roles?: Array<ApiRole>;
}

/**  */
export interface ApiRoleListEventResponse {
  //
  clan_id?: string;
  //
  cursor?: string;
  //
  limit?: number;
  //
  roles?: ApiRoleList;
  //
  state?: string;
}

/**  */
export interface ApiRoleUserList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //role_users pairs for a clan.
  role_users?: Array<RoleUserListRoleUser>;
}

/** Execute an Lua function on the server. */
export interface ApiRpc {
  //The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  //The identifier of the function.
  id?: string;
  //The payload of the function which must be a JSON object.
  payload?: string;
}

/**  */
export interface ApiSdTopic {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  message_id?: string;
  //
  status?: number;
  //
  update_time?: string;
  //
  message?: ChannelMessage;
}

/**  */
export interface ApiSdTopicList {
  //
  count?: number;
  //
  topics?: Array<ApiSdTopic>;
}

/**  */
export interface ApiSdTopicRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiSearchMessageDocument {
  //
  attachments?: Array<ApiMessageAttachment>;
  //
  avatar_url?: string;
  //The channel ID.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_type?: number;
  //The clan ID.
  clan_id?: string;
  //
  clan_name?: string;
  //
  content?: string;
  //
  create_time?: string;
  //
  display_name?: string;
  //
  mentions?: string;
  //The message ID.
  message_id?: string;
  //
  reactions?: string;
  //
  references?: string;
  //The user ID of sender.
  sender_id?: string;
  //
  update_time?: string;
  //
  username?: string;
}

/**  */
export interface ApiSearchMessageRequest {
  //
  filters?: Array<ApiFilterParam>;
  //
  from?: number;
  //
  size?: number;
  //
  sorts?: Array<ApiSortParam>;
}

/**  */
export interface ApiSearchMessageResponse {
  //List of paged messages.
  messages?: Array<ApiSearchMessageDocument>;
  //The total number of messages.
  total?: number;
}

/** A user's session used to authenticate messages. */
export interface ApiSession {
  //True if the corresponding account was just created, false otherwise.
  created?: boolean;
  //Refresh token that can be used for session token renewal.
  refresh_token?: string;
  //Authentication credentials.
  token?: string;
  // Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  // endpoint url that belong to user
  api_url?: string;
  // id token for zklogin
  id_token?: string;
}

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface ApiSessionLogoutRequest {
  //Refresh token to invalidate.
  refresh_token?: string;
  //Session token to log out.
  token?: string;
  // device_id to log out.
  device_id?: string;
  // platform
  platform?: string;
}

/** Authenticate against the server with a refresh token. */
export interface ApiSessionRefreshRequest {
  //Whether to enable "Remember Me" for extended session duration.
  is_remember?: boolean;
  //Refresh token.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiSetDefaultNotificationRequest {
  //
  category_id?: string;
  //
  clan_id?: string;
  //
  notification_type?: number;
}

/**  */
export interface ApiSetMuteRequest {
  //
  active?: number;
  //
  id?: string;
  //
  mute_time?: number;
  //
  clan_id?: string;
}

/**  */
export interface ApiSetNotificationRequest {
  //
  channel_category_id?: string;
  //
  notification_type?: number;
  // clan_id
  clan_id?: string;
}

/**  */
export interface ApiSortParam {
  //
  field_name?: string;
  //
  order?: string;
}

/**  */
export interface ApiStickerListedResponse {
  //
  stickers?: Array<ApiClanSticker>;
}

/**  */
export interface ApiStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  is_streaming?: boolean;
  //
  streaming_url?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiStreamingChannelUser {
  //
  channel_id?: string;
  //
  id?: string;
  //
  participant?: string;
  //user for a channel.
  user_id?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiStreamingChannelUserList {
  //
  streaming_channel_users?: Array<ApiStreamingChannelUser>;
}

/** System message details. */
export interface ApiSystemMessage {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  hide_audit_log?: string;
  //
  id?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/** Request to get system message by clan and channel IDs. */
export interface ApiSystemMessageRequest {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  hide_audit_log?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/** List of system message. */
export interface ApiSystemMessagesList {
  //
  system_messages_list?: Array<ApiSystemMessage>;
}

/**  */
export interface ApiTokenSentEvent {
  //
  amount?: number;
  //
  note?: string;
  //
  receiver_id?: string;
  //
  sender_id?: string;
  //
  sender_name?: string;
  //
  extra_attribute?: string;
  //
  transaction_id?: string;
}

/**  */
export interface ApiTransactionDetail {
  //
  amount?: number;
  //
  create_time?: string;
  //
  update_time?: string;
  //
  receiver_id?: string;
  //
  receiver_username?: string;
  //
  sender_id?: string;
  //
  sender_username?: string;
  //
  metadata?: string;
  //
  trans_id?: string;
}

/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  //
  about_me?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //
  dob_seconds?: number;
  //The email of the user's account.
  email?: string;
  //
  encrypt_private_key?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //
  logo?: string;
  //
  splash_screen?: string;
  //The timezone set by the user.
  timezone?: string;
}

/**  */
export interface ApiUpdateCategoryDescRequest {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
  // clan ID
  Clanid: string;
}
/**  */
export interface ApiUpdateCategoryOrderRequest {
  //
  categories?: Array<ApiCategoryOrderUpdate>;
  //
  clan_id?: string;
}

/**  */
export interface ApiUpdateRoleChannelRequest {
  //
  channel_id: string;
  //
  max_permission_id: string;
  //The permissions to add.
  permission_update?: Array<ApiPermissionUpdate>;
  //The ID of the role to update.
  role_id?: string;
  //
  role_label?: string;
  //The ID of the role to update.
  user_id?: string;
}

/** Fetch a batch of zero or more users from the server. */
export interface ApiUpdateUsersRequest {
  //The avarar_url of a user.
  avatar_url?: string;
  //The account username of a user.
  display_name?: string;
}

/**  */
export interface ApiUploadAttachment {
  //
  filename?: string;
  //
  url?: string;
}

/**  */
export interface ApiUploadAttachmentRequest {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  width?: number;
}

/** A user in the server. */
export interface ApiUser {
  //
  about_me?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //
  dob?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created.
  create_time?: string;
  //The display name of the user.
  display_name?: string;
  //Number of related edges to this user.
  edge_count?: number;
  //The id of the user's account.
  id?: string;
  //
  is_mobile?: boolean;
  //
  join_time?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //Additional information stored as a JSON object.
  user_status?: string;
  // online, offline, invisible, idle, do not disturb
  status?: string;
  //Indicates whether the user is currently online.
  online?: boolean;
  //The timezone set by the user.
  timezone?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated.
  update_time?: string;
  //The username of the user's account.
  username?: string;
  // mezon_id
  mezon_id?: string;
  // list nick name
  list_nick_names?: Array<string>;
  // phone number
  phone_number?: string;
}

/**  */
export interface ApiUserActivity {
  //
  activity_description?: string;
  //
  activity_name?: string;
  //
  activity_type?: number;
  //
  application_id?: string;
  //
  end_time_seconds?: number;
  //
  start_time_seconds?: number;
  //
  status?: number;
  //
  user_id?: string;
}

/**  */
export interface ApiQuickMenuAccess {
  //
  action_msg?: string;
  //
  background?: string;
  //
  bot_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  menu_name?: string;
  //
  menu_type?: number;
}

/**  */
export interface ApiQuickMenuAccessList {
  //
  list_menus?: Array<ApiQuickMenuAccess>;
}

/**  */
export interface ApiQuickMenuAccessRequest {
  //
  action_msg?: string;
  //
  background?: string;
  //
  bot_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  menu_name?: string;
  //
  menu_type?: number;
}

/**  */
export interface ApiUserPermissionInChannelListResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //A list of permission.
  permissions?: ApiPermissionList;
}

/**  */
export interface ApiUserStatus {
  //
  status?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiUserStatusUpdate {
  //
  minutes?: number;
  //
  status?: string;
  //
  until_turn_on?: boolean;
}

/** A collection of zero or more users. */
export interface ApiUsers {
  //The User objects.
  users?: Array<ApiUser>;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiVoiceChannelUser {
  //Cursor for the next page of results, if any.
  id?: string;
  //
  channel_id?: string;
  //
  participant?: string;
  //User for a channel.
  user_id?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiVoiceChannelUserList {
  //
  voice_channel_users?: Array<ApiVoiceChannelUser>;
}

/**  */
export interface ApiWebhook {
  //
  active?: number;
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  status?: number;
  //
  update_time?: string;
  //
  url?: string;
  //
  webhook_name?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiWebhookCreateRequest {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  webhook_name?: string;
}

/**  */
export interface ApiWebhookGenerateResponse {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  hook_name?: string;
  //
  url?: string;
}

/**  */
export interface ApiWebhookListResponse {
  //
  webhooks?: Array<ApiWebhook>;
}

/** A collection of zero or more notifications. */
export interface ApiEmojiRecentList {
  //Collection of emojiRecents.
  emoji_recents?: Array<ApiEmojiRecent>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface MezonapiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/**  */
export interface MezonapiListAuditLog {
  //
  date_log?: string;
  //
  logs?: Array<ApiAuditLog>;
  //
  total_count?: number;
}

/**  */
export interface ProtobufAny {
  //
  type_url?: string;
  //
  value?: string;
}

/**  */
export interface RpcStatus {
  //
  code?: number;
  //
  details?: Array<ProtobufAny>;
  //
  message?: string;
}

/**  */
export interface ApiListOnboardingResponse {
  //
  list_onboarding?: Array<ApiOnboardingItem>;
}

/**  */
export interface OnboardingAnswer {
  //
  emoji?: string;
  //
  description?: string;
  //
  title?: string;
  //
  image_url?: string;
}

/**  */
export interface ApiOnboardingContent {
  //
  answers?: Array<OnboardingAnswer>;
  //
  channel_id?: string;
  //
  content?: string;
  //
  guide_type?: number;
  //
  task_type?: number;
  //
  title?: string;
  //
  image_url?: string;
}

/**  */
export interface MezonUpdateOnboardingBody {
  //
  answers?: Array<OnboardingAnswer>;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  task_type?: number;
  //
  title?: string;
  //
  image_url?: string;
}

/**  */
export interface ApiCreateOnboardingRequest {
  //
  clan_id?: string;
  //
  contents?: Array<ApiOnboardingContent>;
}

/**  */
export interface ApiOnboardingItem {
  //
  answers?: Array<OnboardingAnswer>;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  guide_type?: number;
  //
  id?: string;
  //
  task_type?: number;
  //
  title?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //
  image_url?: string;
}

/**  */
export interface MezonUpdateClanWebhookByIdBody {
  //avatar.
  avatar?: string;
  //clan id.
  clan_id?: string;
  //reset token.
  reset_token?: boolean;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiClanWebhook {
  //active.
  active?: number;
  //
  avatar?: string;
  //clan id.
  clan_id?: string;
  //create time.
  create_time?: string;
  //creator id.
  creator_id?: string;
  //id.
  id?: string;
  //update time.
  update_time?: string;
  //URL of the webhook, which is automatically generated and different from the avatar.
  url?: string;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiGenerateClanWebhookRequest {
  //avatar.
  avatar?: string;
  //clan id.
  clan_id?: string;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiGenerateClanWebhookResponse {
  //avatar.
  avatar?: string;
  //clan id.
  clan_id?: string;
  //url.
  url?: string;
  //webhook name.
  webhook_name?: string;
}

/**  */
export interface ApiListClanWebhookResponse {
  //list clan webhook.
  list_clan_webhooks?: Array<ApiClanWebhook>;
}

/**  */
export interface MezonUpdateOnboardingStepByClanIdBody {
  //onboarding step.
  onboarding_step?: number;
}

/**  */
export interface ApiListOnboardingStepResponse {
  //list onboarding steps.
  list_onboarding_step?: Array<ApiOnboardingSteps>;
}

/**  */
export interface ApiOnboardingSteps {
  //clan id.
  clan_id?: string;
  //id.
  id?: string;
  //onboarding step.
  onboarding_step?: number;
  //user id.
  user_id?: string;
}

/**  */
export interface MezonapiCreateRoomChannelApps {
  //
  channel_id?: string;
  //
  room_name?: string;
}

/**  */
export interface ApiGenerateMeetTokenRequest {
  //
  channel_id?: string;
  //
  room_name?: string;
}

/**  */
export interface ApiGenerateMeetTokenResponse {
  //
  token?: string;
}

/**  */
export interface ApiUnlockedItemRequest {
  //
  item_id?: string;
  //
  item_type?: number;
}

/**  */
export interface ApiUnlockedItemResponse {
  //
  source?: string;
}

/**  */
export interface ApiMezonOauthClient {
  //
  access_token_strategy?: string;
  //
  allowed_cors_origins?: Array<string>;
  //
  audience?: Array<string>;
  //
  authorization_code_grant_access_token_lifespan?: string;
  //
  authorization_code_grant_id_token_lifespan?: string;
  //
  authorization_code_grant_refresh_token_lifespan?: string;
  //
  backchannel_logout_session_required?: boolean;
  //
  backchannel_logout_uri?: string;
  //
  client_credentials_grant_access_token_lifespan?: string;
  //
  client_id?: string;
  //
  client_name?: string;
  //
  client_secret?: string;
  //
  client_secret_expires_at?: number;
  //
  client_uri?: string;
  //
  contacts?: Array<string>;
  //
  //created_at?: Date;
  //
  frontchannel_logout_session_required?: boolean;
  //
  frontchannel_logout_uri?: string;
  //
  grant_types?: Array<string>;
  //
  implicit_grant_access_token_lifespan?: string;
  //
  implicit_grant_id_token_lifespan?: string;
  //
  jwks?: Array<string>;
  //
  jwks_uri?: string;
  //
  jwt_bearer_grant_access_token_lifespan?: string;
  //
  logo_uri?: string;
  //
  owner?: string;
  //
  policy_uri?: string;
  //
  post_logout_redirect_uris?: Array<string>;
  //
  redirect_uris?: Array<string>;
  //
  refresh_token_grant_access_token_lifespan?: string;
  //
  refresh_token_grant_id_token_lifespan?: string;
  //
  refresh_token_grant_refresh_token_lifespan?: string;
  //
  registration_access_token?: string;
  //
  registration_client_uri?: string;
  //
  request_object_signing_alg?: string;
  //
  request_uris?: Array<string>;
  //
  response_types?: Array<string>;
  //
  scope?: string;
  //
  sector_identifier_uri?: string;
  //
  skip_consent?: boolean;
  //
  skip_logout_consent?: boolean;
  //
  subject_type?: string;
  //
  token_endpoint_auth_method?: string;
  //
  token_endpoint_auth_signing_alg?: string;
  //
  tos_uri?: string;
  //
  //updated_at?: string;
  //
  userinfo_signed_response_alg?: string;
}

/**  */
export interface ApiCreateHashChannelAppsResponse {
  //
  web_app_data?: string;
}

/**  */
export interface ApiUserEventRequest {
  // The ID of the clan to be updated.
  clan_id?: string;
  //The ID of the event to be updated.
  event_id?: string;
}

/**  */
export interface ApiClanDiscover {
  //
  about?: string;
  //
  banner?: string;
  //
  clan_id?: string;
  //
  clan_logo?: string;
  //
  clan_name?: string;
  //
  description?: string;
  //
  invite_id?: string;
  //
  online_members?: number;
  //
  total_members?: number;
  //
  verified?: boolean;
  //
  short_url?: string;
  //
  create_time?: string;
}

/**  */
export interface ApiListForSaleItemsRequest {
  //
  page?: number;
}

/**  */
export interface ApiForSaleItem {
  //
  preview_url?: string;
  //
  type?: number;
}

/**  */
export interface ApiForSaleItemList {
  //
  for_sale_items?: Array<ApiForSaleItem>;
}

/**  */
export interface ApiListClanDiscover {
  //
  clan_discover?: Array<ApiClanDiscover>;
  //
  page?: number;
  //
  page_count?: number;
}

/**  */
export interface ApiListClanUnreadMsgIndicatorResponse {
  //
  has_unread_message?: boolean;
}

/**  */
export interface ApiClanDiscoverRequest {
  //
  clan_id?: string;
  //
  item_per_page?: number;
  //
  page_number?: number;
}

/**  */
export interface ApiIsFollowerRequest {
  //
  follow_id?: string;
}

/**  */
export interface ApiLinkAccountConfirmRequest {
  //
  otp_code?: string;
  //
  req_id?: string;
  //
  status?: number;
}

/**  */
export interface ApiIsFollowerResponse {
  //
  is_follower?: boolean;
  //
  follow_id?: string;
}

/**  */
export interface ApiTransferOwnershipRequest {
  //
  clan_id?: string;
  //
  new_owner_id?: string;
}

export class MezonApi {
  basePath: string;
  constructor(
    readonly serverKey: string,
    readonly timeoutMs: number,
    basePath: string,
  ) {
    this.basePath = basePath;
  }

  setBasePath(basePath: string) {
    this.basePath = basePath;
  }

  /** Delete the current user's account. */
  deleteAccount(bearerToken: string, options: any = {}): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteAccount";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Fetch the current user's account. */
  getAccount(bearerToken: string, options: any = {}): Promise<ApiAccount> {
    const urlPath = "/mezon.api.Mezon/GetAccount";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiAccount;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Account.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiAccount;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update fields in the current user's account. */
  updateAccount(
    bearerToken: string,
    body: ApiUpdateAccountRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateAccount";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateAccountRequest.encode(
      tsproto.UpdateAccountRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  checkLoginRequest(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiConfirmLoginRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/checklogin";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  confirmLogin(
    bearerToken: string,
    basePath: string,
    body: ApiConfirmLoginRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/confirmlogin";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  createQRLogin(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiLoginRequest,
    options: any = {},
  ): Promise<ApiLoginIDResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/createqrlogin";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LoginIDResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLoginIDResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Authenticate a user with an SMS against the server. */
  AuthenticateSMSOTPRequest(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiAuthenticateSMSRequest,
    options: any = {},
  ): Promise<ApiLinkAccountConfirmRequest> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/smsotp";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LinkAccountConfirmRequest.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLinkAccountConfirmRequest;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Authenticate a user with an email+password against the server. */
  AuthenticateEmailOTPRequest(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiAuthenticateEmailRequest,
    options: any = {},
  ): Promise<ApiLinkAccountConfirmRequest> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/emailotp";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LinkAccountConfirmRequest.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLinkAccountConfirmRequest;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Authenticate a user with an email+password against the server. */
  authenticateEmail(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiAuthenticateEmailRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/email";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Authenticate a user with Mezon against the server. */
  authenticateMezon(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountMezon,
    create?: boolean,
    username?: string,
    isRemember?: boolean,
    options: any = {},
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/mezon";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("is_remember", isRemember);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add an email+password to the social profiles on the current user's account. */
  linkEmail(
    bearerToken: string,
    body: ApiAccountEmail,
    options: any = {},
  ): Promise<ApiLinkAccountConfirmRequest> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/LinkEmail";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateAccountRequest.encode(
      tsproto.UpdateAccountRequest.fromPartial({
        email: body.email,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LinkAccountConfirmRequest.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLinkAccountConfirmRequest;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add a mezon ID to the social profiles on the current user's account. */
  linkSMS(
    bearerToken: string,
    body: ApiLinkAccountMezon,
    options: any = {},
  ): Promise<ApiLinkAccountConfirmRequest> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/LinkSMS";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AccountMezon.encode(
      tsproto.AccountMezon.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LinkAccountConfirmRequest.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLinkAccountConfirmRequest;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  confirmLinkMezonOTP(
    bearerToken: string,
    body: ApiLinkAccountConfirmRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ConfirmLinkMezonOTP";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.LinkAccountConfirmRequest.encode(
      tsproto.LinkAccountConfirmRequest.fromPartial({
        ...body,
        req_id: BigInt(body.req_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  confirmAuthenticateOTP(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiLinkAccountConfirmRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/authenticate/confirmotp";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Authenticate a user with an email+password against the server. */
  registrationEmail(
    bearerToken: string,
    body: ApiRegistrationEmailRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/account/registry";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  sessionRefresh(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiSessionRefreshRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SessionRefresh";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SessionRefreshRequest.encode(
      tsproto.SessionRefreshRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Remove the email+password from the social profiles on the current user's account. */
  unlinkEmail(
    bearerToken: string,
    body: ApiAccountEmail,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UnlinkEmail";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AccountEmail.encode(
      tsproto.AccountEmail.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List activity */
  listActivity(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiListUserActivity> {
    const urlPath = "/mezon.api.Mezon/ListActivity";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListUserActivity;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListUserActivity.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListUserActivity;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create user activity */
  createActiviy(
    bearerToken: string,
    body: ApiCreateActivityRequest,
    options: any = {},
  ): Promise<ApiUserActivity> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateActiviy";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateActivityRequest.encode(
      tsproto.CreateActivityRequest.fromPartial({
        ...body,
        application_id: BigInt(body.application_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiUserActivity;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.UserActivity.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiUserActivity;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add a new apps. */
  addApp(
    bearerToken: string,
    body: ApiAddAppRequest,
    options: any = {},
  ): Promise<ApiApp> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddApp";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AddAppRequest.encode(
      tsproto.AddAppRequest.fromPartial({
        ...body,
        creator_id: BigInt(body.creator_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiApp;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.App.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiApp;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List (and optionally filter) accounts. */
  listApps(
    bearerToken: string,
    filter?: string,
    tombstones?: boolean,
    cursor?: string,
    options: any = {},
  ): Promise<ApiAppList> {
    const urlPath = "/mezon.api.Mezon/ListApps";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListAppsRequest.encode(
      tsproto.ListAppsRequest.fromPartial({
        filter: filter,
        tombstones: tombstones,
        cursor: cursor,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiAppList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.AppList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiAppList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add an app to clan. */
  addAppToClan(
    bearerToken: string,
    appId: bigint,
    clanId: bigint,
    options: any = {},
  ): Promise<any> {
    if (appId === null || appId === undefined) {
      throw new Error(
        "'appId' is a required parameter but is null or undefined.",
      );
    }
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddAppToClan";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AppClan.encode(
      tsproto.AppClan.fromPartial({
        app_id: appId,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Delete all information stored for an app. */
  deleteApp(bearerToken: string, id: bigint, options: any = {}): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/DeleteApp";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.App.encode(
      tsproto.App.fromPartial({
        id: id,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Get detailed app information. */
  getApp(bearerToken: string, id: bigint, options: any = {}): Promise<ApiApp> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/GetApp";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.App.encode(
      tsproto.App.fromPartial({
        id: id,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiApp;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.App.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiApp;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update one or more fields on a app. */
  updateApp(
    bearerToken: string,
    id: bigint,
    body: MezonUpdateAppBody,
    options: any = {},
  ): Promise<ApiApp> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateApp";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateAppRequest.encode(
      tsproto.UpdateAppRequest.fromPartial({ ...body, id: id }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiApp;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.App.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiApp;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  listAuditLog(
    bearerToken: string,
    actionLog?: string,
    userId?: bigint,
    clanId?: bigint,
    dateLog?: string,
    options: any = {},
  ): Promise<MezonapiListAuditLog> {
    const urlPath = "/mezon.api.Mezon/ListAuditLog";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListAuditLogRequest.encode(
      tsproto.ListAuditLogRequest.fromPartial({
        clan_id: clanId,
        user_id: userId,
        action_log: actionLog,
        date_log: dateLog,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as MezonapiListAuditLog;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListAuditLog.decode(
            new Uint8Array(buffer),
          ) as unknown as MezonapiListAuditLog;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }
  /**  */
  updateCategoryOrder(
    bearerToken: string,
    body: ApiUpdateCategoryOrderRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateCategoryOrder";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateCategoryOrderRequest.encode(
      tsproto.UpdateCategoryOrderRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        categories: body.categories?.map((cat) => {
          return {
            ...cat,
            category_id: BigInt(cat.category_id as string),
          };
        }),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  listCategoryDescs(
    bearerToken: string,
    clanId: bigint,
    creatorId?: bigint,
    categoryName?: string,
    categoryId?: bigint,
    categoryOrder?: number,
    options: any = {},
  ): Promise<ApiCategoryDescList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListCategoryDescs";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CategoryDesc.encode(
      tsproto.CategoryDesc.fromPartial({
        clan_id: clanId,
        creator_id: creatorId,
        category_name: categoryName,
        category_id: categoryId,
        category_order: categoryOrder,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiCategoryDescList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.CategoryDescList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiCategoryDescList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List channel apps. */
  listChannelApps(
    bearerToken: string,
    clanId?: bigint,
    options: any = {},
  ): Promise<ApiListChannelAppsResponse> {
    const urlPath = "/mezon.api.Mezon/ListChannelApps";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelAppsRequest.encode(
      tsproto.ListChannelAppsRequest.fromPartial({
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListChannelAppsResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListChannelAppsResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListChannelAppsResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  getChannelCanvasList(
    bearerToken: string,
    channelId: bigint,
    clanId?: bigint,
    limit?: number,
    page?: number,
    options: any = {},
  ): Promise<ApiChannelCanvasListResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GetChannelCanvasList";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChannelCanvasListRequest.encode(
      tsproto.ChannelCanvasListRequest.fromPartial({
        channel_id: channelId,
        clan_id: clanId,
        limit: limit,
        page: page,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelCanvasListResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelCanvasListResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelCanvasListResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  addChannelFavorite(
    bearerToken: string,
    body: ApiAddFavoriteChannelRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddChannelFavorite";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AddFavoriteChannelRequest.encode(
      tsproto.AddFavoriteChannelRequest.fromPartial({
        ...body,
        channel_id: BigInt(body.channel_id as string),
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.AddFavoriteChannelResponse.decode(
            new Uint8Array(buffer),
          );
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  removeChannelFavorite(
    bearerToken: string,
    channelId: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/RemoveChannelFavorite";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.RemoveFavoriteChannelRequest.encode(
      tsproto.RemoveFavoriteChannelRequest.fromPartial({
        channel_id: channelId,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  getListFavoriteChannel(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<ApiListFavoriteChannelResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GetListFavoriteChannel";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListFavoriteChannelRequest.encode(
      tsproto.ListFavoriteChannelRequest.fromPartial({
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListFavoriteChannelResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListFavoriteChannelResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListFavoriteChannelResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List a channel's message history. */
  listChannelMessages(
    bearerToken: string,
    clanId: bigint,
    channelId: bigint,
    messageId?: bigint,
    direction?: number,
    limit?: number,
    topicId?: bigint,
    options: any = {},
  ): Promise<ApiChannelMessageList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListChannelMessages";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelMessagesRequest.encode(
      tsproto.ListChannelMessagesRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        message_id: messageId,
        direction,
        limit,
        topic_id: topicId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelMessageList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelMessageList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelMessageList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add users to a channel. */
  addChannelUsers(
    bearerToken: string,
    channelId: bigint,
    userIds?: Array<bigint>,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddChannelUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AddChannelUsersRequest.encode(
      tsproto.AddChannelUsersRequest.fromPartial({
        channel_id: channelId,
        user_ids: userIds,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List all attachment that are part of a channel. */
  listChannelAttachment(
    bearerToken: string,
    channelId: bigint,
    clanId?: bigint,
    fileType?: string,
    limit?: number,
    state?: number,
    before?: number,
    after?: number,
    around?: number,
    options: any = {},
  ): Promise<ApiChannelAttachmentList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListChannelAttachment";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelAttachmentRequest.encode(
      tsproto.ListChannelAttachmentRequest.fromPartial({
        channel_id: channelId,
        clan_id: clanId,
        file_type: fileType,
        limit: limit,
        state: state,
        before: before,
        after: after,
        around: around,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelAttachmentList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelAttachmentList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelAttachmentList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** get channel encryption method */
  getChanEncryptionMethod(
    bearerToken: string,
    channelId: bigint,
    method?: string,
    options: any = {},
  ): Promise<ApiChanEncryptionMethod> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GetChanEncryptionMethod";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChanEncryptionMethod.encode(
      tsproto.ChanEncryptionMethod.fromPartial({
        channel_id: channelId,
        method: method,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChanEncryptionMethod;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChanEncryptionMethod.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChanEncryptionMethod;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** store channel encryption method */
  setChanEncryptionMethod(
    bearerToken: string,
    channelId: bigint,
    body: MezonSetChanEncryptionMethodBody,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetChanEncryptionMethod";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChanEncryptionMethod.encode(
      tsproto.ChanEncryptionMethod.fromPartial({
        ...body,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Leave a channel the user is a member of. */
  leaveThread(
    bearerToken: string,
    clanId: bigint,
    channelId: bigint,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/LeaveThread";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.LeaveThreadRequest.encode(
      tsproto.LeaveThreadRequest.fromPartial({
        channel_id: channelId,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Kick a set of users from a channel. */
  removeChannelUsers(
    bearerToken: string,
    channelId: bigint,
    userIds?: Array<bigint>,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/RemoveChannelUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.RemoveChannelUsersRequest.encode(
      tsproto.RemoveChannelUsersRequest.fromPartial({
        channel_id: channelId,
        user_ids: userIds,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listChannelUsers(
    bearerToken: string,
    clanId: bigint,
    channelId: bigint,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiChannelUserList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListChannelUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelUsersRequest.encode(
      tsproto.ListChannelUsersRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        channel_type: channelType,
        limit: limit,
        state: state,
        cursor: cursor,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelUserList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelUserList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelUserList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List user channels */
  listChannelDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    clanId?: bigint,
    channelType?: number,
    isMobile?: boolean,
    options: any = {},
  ): Promise<ApiChannelDescList> {
    const urlPath = "/mezon.api.Mezon/ListChannelDescs";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelDescsRequest.encode(
      tsproto.ListChannelDescsRequest.fromPartial({
        limit,
        state,
        cursor,
        clan_id: clanId,
        channel_type: channelType,
        is_mobile: isMobile,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelDescList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create a new channel with the current user as the owner. */
  createChannelDesc(
    bearerToken: string,
    body: ApiCreateChannelDescRequest,
    options: any = {},
  ): Promise<ApiChannelDescription> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateChannelDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateChannelDescRequest.encode(
      tsproto.CreateChannelDescRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        parent_id: BigInt(body.parent_id as string),
        channel_id: BigInt(body.channel_id as string),
        category_id: BigInt(body.category_id as string),
        app_id: BigInt(body.app_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescription;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescription.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelDescription;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** list user add channel by channel ids */
  listChannelUsersUC(
    bearerToken: string,
    channelId?: bigint,
    limit?: number,
    options: any = {},
  ): Promise<ApiAllUsersAddChannelResponse> {
    const urlPath = "/mezon.api.Mezon/ListChannelUsersUC";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AllUsersAddChannelRequest.encode(
      tsproto.AllUsersAddChannelRequest.fromPartial({
        channel_id: channelId,
        limit: limit,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiAllUsersAddChannelResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.AllUsersAddChannelResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiAllUsersAddChannelResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete a channel by ID. */
  deleteChannelDesc(
    bearerToken: string,
    clanId: bigint,
    channelId: bigint,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteChannelDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteChannelDescRequest.encode(
      tsproto.DeleteChannelDescRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Update fields in a given channel. */
  updateChannelDesc(
    bearerToken: string,
    channelId: bigint,
    body: ApiUpdateChannelDescRequest,
    options: any = {},
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateChannelDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateChannelDescRequest.encode(
      tsproto.UpdateChannelDescRequest.fromPartial({
        ...body,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List channel setting */
  listChannelSetting(
    bearerToken: string,
    clanId: bigint,
    parentId?: bigint,
    categoryId?: bigint,
    privateChannel?: number,
    active?: number,
    status?: number,
    type?: number,
    limit?: number,
    page?: number,
    channelLabel?: string,
    options: any = {},
  ): Promise<ApiChannelSettingListResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListChannelSetting";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChannelSettingListRequest.encode(
      tsproto.ChannelSettingListRequest.fromPartial({
        clan_id: clanId,
        parent_id: parentId,
        category_id: categoryId,
        active: active,
        private_channel: privateChannel,
        status: status,
        type: type,
        limit: limit,
        page: page,
        channel_label: channelLabel,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelSettingListResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelSettingListResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelSettingListResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listChannelVoiceUsers(
    bearerToken: string,
    clanId?: bigint,
    channelId?: bigint,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiVoiceChannelUserList> {
    const urlPath = "/mezon.api.Mezon/ListChannelVoiceUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelUsersRequest.encode(
      tsproto.ListChannelUsersRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        channel_type: channelType,
        limit: limit,
        state: state,
        cursor: cursor,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiVoiceChannelUserList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.VoiceChannelUserList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiVoiceChannelUserList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List clans */
  listClanUnreadMsgIndicator(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<ApiListClanUnreadMsgIndicatorResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListClanUnreadMsgIndicator";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListClanUnreadMsgIndicatorRequest.encode(
      tsproto.ListClanUnreadMsgIndicatorRequest.fromPartial({
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListClanUnreadMsgIndicatorResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListClanUnreadMsgIndicatorResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListClanUnreadMsgIndicatorResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List clans */
  listClanDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiClanDescList> {
    const urlPath = "/mezon.api.Mezon/ListClanDescs";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListClanDescRequest.encode(
      tsproto.ListClanDescRequest.fromPartial({ limit, state, cursor }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiClanDescList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ClanDescList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiClanDescList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create a clan */
  createClanDesc(
    bearerToken: string,
    body: ApiCreateClanDescRequest,
    options: any = {},
  ): Promise<ApiClanDesc> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateClanDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateClanDescRequest.encode(
      tsproto.CreateClanDescRequest.fromPartial({
        clan_name: body.clan_name,
        logo: body.logo,
        banner: body.banner,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiClanDesc;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ClanDesc.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiClanDesc;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete a clan desc by ID. */
  deleteClanDesc(
    bearerToken: string,
    clanDescId: bigint,
    options: any = {},
  ): Promise<any> {
    if (clanDescId === null || clanDescId === undefined) {
      throw new Error(
        "'clanDescId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteClanDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteClanDescRequest.encode(
      tsproto.DeleteClanDescRequest.fromPartial({ clan_desc_id: clanDescId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Update fields in a given clan. */
  updateClanDesc(
    bearerToken: string,
    clanId: bigint,
    body: {},
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateClanDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateClanDescRequest.encode(
      tsproto.UpdateClanDescRequest.fromPartial({ clan_id: clanId, ...body }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Kick a set of users from a clan. */
  removeClanUsers(
    bearerToken: string,
    clanId: bigint,
    userIds?: Array<bigint>,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/RemoveClanUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.RemoveClanUsersRequest.encode(
      tsproto.RemoveClanUsersRequest.fromPartial({
        clan_id: clanId,
        user_ids: userIds,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List banned user */
  listBannedUsers(
    bearerToken: string,
    clanId?: bigint,
    channelId?: bigint,
    options: any = {},
  ): Promise<ApiBannedUserList> {
    const urlPath = "/mezon.api.Mezon/ListBannedUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.BannedUserListRequest.encode(
      tsproto.BannedUserListRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiBannedUserList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.BannedUserList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiBannedUserList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Ban a set of users from a channel. */
  unbanClanUsers(
    bearerToken: string,
    clanId: bigint,
    channelId?: bigint,
    userIds?: Array<bigint>,
    banTime?: number,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UnbanClanUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.BanClanUsersRequest.encode(
      tsproto.BanClanUsersRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        user_ids: userIds,
        ban_time: banTime,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Ban a set of users from a channel. */
  banClanUsers(
    bearerToken: string,
    clanId: bigint,
    channelId?: bigint,
    userIds?: Array<bigint>,
    banTime?: number,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/BanClanUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.BanClanUsersRequest.encode(
      tsproto.BanClanUsersRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        user_ids: userIds,
        ban_time: banTime,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List all users that are part of a clan. */
  listClanUsers(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<ApiClanUserList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListClanUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListClanUsersRequest.encode(
      tsproto.ListClanUsersRequest.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiClanUserList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ClanUserList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiClanUserList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  createCategoryDesc(
    bearerToken: string,
    body: ApiCreateCategoryDescRequest,
    options: any = {},
  ): Promise<ApiCategoryDesc> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateCategoryDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateCategoryDescRequest.encode(
      tsproto.CreateCategoryDescRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiCategoryDesc;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.CategoryDesc.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiCategoryDesc;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  deleteCategoryDesc(
    bearerToken: string,
    categoryId: bigint,
    clanId: bigint,
    categoryLabel?: string,
    options: any = {},
  ): Promise<any> {
    if (categoryId === null || categoryId === undefined) {
      throw new Error(
        "'categoryId' is a required parameter but is null or undefined.",
      );
    }
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteCategoryDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteCategoryDescRequest.encode(
      tsproto.DeleteCategoryDescRequest.fromPartial({
        category_id: categoryId,
        clan_id: clanId,
        category_label: categoryLabel,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** regist fcm device token */
  registFCMDeviceToken(
    bearerToken: string,
    token?: string,
    deviceId?: string,
    platform?: string,
    voipToken?: string,
    options: any = {},
  ): Promise<ApiRegistFcmDeviceTokenResponse> {
    const urlPath = "/mezon.api.Mezon/RegistFCMDeviceToken";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.RegistFcmDeviceTokenRequest.encode(
      tsproto.RegistFcmDeviceTokenRequest.fromPartial({
        token,
        device_id: deviceId,
        platform,
        voip_token: voipToken,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiRegistFcmDeviceTokenResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.RegistFcmDeviceTokenResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiRegistFcmDeviceTokenResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** close direct message. */
  closeDirectMess(
    bearerToken: string,
    body: ApiDeleteChannelDescRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CloseDMByChannelId";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteChannelDescRequest.encode(
      tsproto.DeleteChannelDescRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** open direct message. */
  openDirectMess(
    bearerToken: string,
    body: ApiDeleteChannelDescRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/OpenDMByChannelId";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteChannelDescRequest.encode(
      tsproto.DeleteChannelDescRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Post clan Emoji  /v2/emoji/create */
  createClanEmoji(
    bearerToken: string,
    body: ApiClanEmojiCreateRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateClanEmoji";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanEmojiCreateRequest.encode(
      tsproto.ClanEmojiCreateRequest.fromPartial({
        ...body,
        id: BigInt(body.id as string),
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete a emoji by ID. */
  deleteClanEmojiById(
    bearerToken: string,
    id: bigint,
    clanId?: bigint,
    emojiLabel?: string,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/DeleteByIdClanEmoji";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanEmojiDeleteRequest.encode(
      tsproto.ClanEmojiDeleteRequest.fromPartial({
        id,
        clan_id: clanId,
        emoji_label: emojiLabel,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update ClanEmoj By id */
  updateClanEmojiById(
    bearerToken: string,
    id: bigint,
    body: MezonUpdateClanEmojiByIdBody,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateClanEmojiById";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanEmojiUpdateRequest.encode(
      tsproto.ClanEmojiUpdateRequest.fromPartial({
        id: BigInt(body.id),
        shortname: body.shortname,
        clan_id: BigInt(body.clan_id),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return buffer.byteLength > 0 ? {} : {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** get list emoji recent by user id */
  emojiRecentList(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiEmojiRecentList> {
    const urlPath = "/mezon.api.Mezon/EmojiRecentList";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiEmojiRecentList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.EmojiRecentList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiEmojiRecentList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** get list emoji by user id */
  getListEmojisByUserId(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiEmojiListedResponse> {
    const urlPath = "/mezon.api.Mezon/GetListEmojisByUserId";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiEmojiListedResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.EmojiListedResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiEmojiListedResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Search message from elasticsearch service. */
  searchMessage(
    bearerToken: string,
    body: ApiSearchMessageRequest,
    options: any = {},
  ): Promise<ApiSearchMessageResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SearchMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SearchMessageRequest.encode(
      tsproto.SearchMessageRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSearchMessageResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.SearchMessageResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSearchMessageResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Submit an event for processing in the server's registered runtime custom events handler. */
  event(bearerToken: string, body: ApiEvent, options: any = {}): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateEvent";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.Event.encode(
      tsproto.Event.fromPartial({
        external: body.external,
        name: body.name,
        properties: body.properties,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List user events */
  listEvents(
    bearerToken: string,
    clanId?: bigint,
    options: any = {},
  ): Promise<ApiEventList> {
    const urlPath = "/mezon.api.Mezon/ListEvents";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListEventsRequest.encode(
      tsproto.ListEventsRequest.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiEventList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.EventList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiEventList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create a new event for clan. */
  createEvent(
    bearerToken: string,
    body: ApiCreateEventRequest,
    options: any = {},
  ): Promise<ApiEventManagement> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateEvent";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateEventRequest.encode(
      tsproto.CreateEventRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        creator_id: BigInt(body.creator_id as string),
        user_id: BigInt(body.user_id as string),
        channel_voice_id: BigInt(body.channel_voice_id as string),
        meet_room: {
          ...body.meet_room,
          meet_id: BigInt(body.meet_room?.meet_id as string),
          creator_id: BigInt(body.meet_room?.creator_id as string),
          event_id: BigInt(body.meet_room?.event_id as string),
        },
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiEventManagement;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.EventManagement.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiEventManagement;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update fields in a given event. */
  updateEventUser(
    bearerToken: string,
    body: ApiDeleteEventRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateEventUser";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteEventRequest.encode(
      tsproto.DeleteEventRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        event_id: BigInt(body.event_id as string),
        creator_id: BigInt(body.creator_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as any;
        } else if (response.status >= 200 && response.status < 300) {
          return {} as any;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete a event by ID. */
  deleteEvent(
    bearerToken: string,
    eventId: bigint,
    clanId?: bigint,
    creatorId?: bigint,
    eventLabel?: string,
    channelId?: bigint,
    options: any = {},
  ): Promise<any> {
    if (eventId === null || eventId === undefined) {
      throw new Error(
        "'eventId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteEvent";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteEventRequest.encode(
      tsproto.DeleteEventRequest.fromPartial({
        event_id: eventId,
        clan_id: clanId,
        creator_id: creatorId,
        event_label: eventLabel,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as any;
        } else if (response.status >= 200 && response.status < 300) {
          return {} as any;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update fields in a given event. */
  updateEvent(
    bearerToken: string,
    eventId: bigint,
    body: MezonUpdateEventBody,
    options: any = {},
  ): Promise<any> {
    if (eventId === null || eventId === undefined) {
      throw new Error(
        "'eventId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateEvent";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateEventRequest.encode(
      tsproto.UpdateEventRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        event_id: BigInt(body.event_id as string),
        creator_id: BigInt(body.creator_id as string),
        channel_voice_id: BigInt(body.channel_voice_id as string),
        channel_id_old: BigInt(body.channel_id_old as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as any;
        } else if (response.status >= 200 && response.status < 300) {
          return {} as any;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete one or more users by ID or username. */
  deleteFriends(
    bearerToken: string,
    ids?: Array<bigint>,
    usernames?: Array<string>,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteFriends";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteFriendsRequest.encode(
      tsproto.DeleteFriendsRequest.fromPartial({ ids, usernames }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List all friends for the current user. */
  listFriends(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiFriendList> {
    const urlPath = "/mezon.api.Mezon/ListFriends";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListFriendsRequest.encode(
      tsproto.ListFriendsRequest.fromPartial({ limit, state, cursor }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiFriendList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.FriendList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiFriendList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add friends by ID or username to a user's account. */
  addFriends(
    bearerToken: string,
    ids?: Array<bigint>,
    usernames?: Array<string>,
    options: any = {},
  ): Promise<ApiAddFriendsResponse> {
    const urlPath = "/mezon.api.Mezon/AddFriends";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AddFriendsRequest.encode(
      tsproto.AddFriendsRequest.fromPartial({ ids, usernames }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiAddFriendsResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.AddFriendsResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiAddFriendsResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Block one or more users by ID or username. */
  blockFriends(
    bearerToken: string,
    ids?: Array<bigint>,
    usernames?: Array<string>,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/BlockFriends";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.BlockFriendsRequest.encode(
      tsproto.BlockFriendsRequest.fromPartial({ ids, usernames }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Block one or more users by ID or username. */
  unblockFriends(
    bearerToken: string,
    ids?: Array<bigint>,
    usernames?: Array<string>,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/UnblockFriends";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.BlockFriendsRequest.encode(
      tsproto.BlockFriendsRequest.fromPartial({ ids, usernames }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List GetChannelCategoryNotiSettingsList */
  getChannelCategoryNotiSettingsList(
    bearerToken: string,
    clanId?: bigint,
    options: any = {},
  ): Promise<ApiNotificationChannelCategorySettingList> {
    const urlPath = "/mezon.api.Mezon/GetChannelCategoryNotiSettingsList";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotificationClan.encode(
      tsproto.NotificationClan.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiNotificationChannelCategorySettingList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.NotificationChannelCategorySettingList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiNotificationChannelCategorySettingList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  getUserProfileOnClan(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<ApiClanProfile> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GetUserProfileOnClan";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanProfileRequest.encode(
      tsproto.ClanProfileRequest.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiClanProfile;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ClanProfile.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiClanProfile;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List GetNotificationChannel */
  getNotificationCategory(
    bearerToken: string,
    categoryId?: bigint,
    options: any = {},
  ): Promise<ApiNotificationUserChannel> {
    const urlPath = "/mezon.api.Mezon/GetNotificationCategory";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DefaultNotificationCategory.encode(
      tsproto.DefaultNotificationCategory.fromPartial({
        category_id: categoryId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiNotificationUserChannel;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.NotificationUserChannel.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiNotificationUserChannel;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List GetNotificationChannel */
  getNotificationChannel(
    bearerToken: string,
    channelId?: bigint,
    options: any = {},
  ): Promise<ApiNotificationUserChannel> {
    const urlPath = "/mezon.api.Mezon/GetNotificationChannel";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotificationChannel.encode(
      tsproto.NotificationChannel.fromPartial({ channel_id: channelId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiNotificationUserChannel;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.NotificationUserChannel.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiNotificationUserChannel;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List GetNotificationClan */
  getNotificationClan(
    bearerToken: string,
    clanId?: bigint,
    options: any = {},
  ): Promise<ApiNotificationSetting> {
    const urlPath = "/mezon.api.Mezon/GetNotificationClan";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotificationClan.encode(
      tsproto.NotificationClan.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiNotificationSetting;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.NotificationSetting.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiNotificationSetting;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List GetNotificationReactMessage */
  getNotificationReactMessage(
    bearerToken: string,
    channelId?: bigint,
    options: any = {},
  ): Promise<ApiNotifiReactMessage> {
    const urlPath = "/mezon.api.Mezon/GetNotificationReactMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotifiReactMessage.encode(
      tsproto.NotifiReactMessage.fromPartial({ channel_id: channelId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiNotifiReactMessage;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.NotifiReactMessage.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiNotifiReactMessage;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** get key server */
  getKeyServer(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiGetKeyServerResp> {
    const urlPath = "/mezon.api.Mezon/GetKeyServer";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiGetKeyServerResp;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GetKeyServerResp.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiGetKeyServerResp;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add users to a channel. */
  createLinkInviteUser(
    bearerToken: string,
    body: ApiLinkInviteUserRequest,
    options: any = {},
  ): Promise<ApiLinkInviteUser> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateLinkInviteUser";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.LinkInviteUserRequest.encode(
      tsproto.LinkInviteUserRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiLinkInviteUser;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LinkInviteUser.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLinkInviteUser;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add users to a channel. */
  inviteUser(
    bearerToken: string,
    inviteId: bigint,
    options: any = {},
  ): Promise<ApiInviteUserRes> {
    if (inviteId === null || inviteId === undefined) {
      throw new Error(
        "'inviteId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/InviteUser";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.InviteUserRequest.encode(
      tsproto.InviteUserRequest.fromPartial({ invite_id: inviteId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiInviteUserRes;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.InviteUserRes.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiInviteUserRes;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add users to a channel. */
  getLinkInvite(
    basicAuthUsername: string,
    basicAuthPassword: string,
    inviteId: bigint,
    options: any = {},
  ): Promise<ApiInviteUserRes> {
    if (inviteId === null || inviteId === undefined) {
      throw new Error(
        "'inviteId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/invite/{inviteId}".replace(
      "{inviteId}",
      encodeURIComponent(String(inviteId)),
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiInviteUserRes;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.InviteUserRes.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiInviteUserRes;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List HashtagDMList */
  listChannelByUserId(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiChannelDescList> {
    const urlPath = "/mezon.api.Mezon/ListChannelByUserId";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelDescList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Mark as read */
  markAsRead(
    bearerToken: string,
    body: ApiMarkAsReadRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/MarkAsRead";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.MarkAsReadRequest.encode(
      tsproto.MarkAsReadRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        category_id: BigInt(body.category_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as any;
        } else if (response.status >= 200 && response.status < 300) {
          return {} as any;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List mezon OAuth client */
  listMezonOauthClient(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiMezonOauthClientList> {
    const urlPath = "/mezon.api.Mezon/ListMezonOauthClient";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiMezonOauthClientList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.MezonOauthClientList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiMezonOauthClientList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** set mute notification user channel. */
  setMuteCategory(
    bearerToken: string,
    body: ApiSetMuteRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetMuteCategory";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SetMuteRequest.encode(
      tsproto.SetMuteRequest.fromPartial({
        ...body,
        id: BigInt(body.id as string),
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as any;
        } else if (response.status >= 200 && response.status < 300) {
          return {} as any;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** set mute notification user channel. */
  setMuteChannel(
    bearerToken: string,
    body: ApiSetMuteRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetMuteChannel";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SetMuteRequest.encode(
      tsproto.SetMuteRequest.fromPartial({
        ...body,
        id: BigInt(body.id as string),
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as any;
        } else if (response.status >= 200 && response.status < 300) {
          return {} as any;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete one or more notifications for the current user. */
  deleteNotifications(
    bearerToken: string,
    ids?: Array<bigint>,
    category?: number,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteNotifications";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteNotificationsRequest.encode(
      tsproto.DeleteNotificationsRequest.fromPartial({
        ids: ids || [],
        category: category,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Fetch list of notifications. */
  listNotifications(
    bearerToken: string,
    limit?: number,
    clanId?: bigint,
    notificationId?: bigint,
    category?: number,
    direction?: number,
    options: any = {},
  ): Promise<ApiNotificationList> {
    const urlPath = "/mezon.api.Mezon/ListNotifications";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListNotificationsRequest.encode(
      tsproto.ListNotificationsRequest.fromPartial({
        limit: limit,
        clan_id: clanId,
        notification_id: notificationId,
        category: category,
        direction: direction,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiNotificationList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.NotificationList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiNotificationList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationChannelSetting(
    bearerToken: string,
    body: ApiSetNotificationRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetNotificationChannelSetting";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SetNotificationRequest.encode(
      tsproto.SetNotificationRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_category_id: BigInt(body.channel_category_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationClanSetting(
    bearerToken: string,
    body: ApiSetDefaultNotificationRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetNotificationClanSetting";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SetDefaultNotificationRequest.encode(
      tsproto.SetDefaultNotificationRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        category_id: BigInt(body.category_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationCategorySetting(
    bearerToken: string,
    body: ApiSetNotificationRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetNotificationCategorySetting";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SetNotificationRequest.encode(
      tsproto.SetNotificationRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_category_id: BigInt(body.channel_category_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  deleteNotificationCategorySetting(
    bearerToken: string,
    categoryId?: bigint,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteNotificationCategorySetting";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DefaultNotificationCategory.encode(
      tsproto.DefaultNotificationCategory.fromPartial({
        category_id: categoryId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  deleteNotificationChannel(
    bearerToken: string,
    channelId?: bigint,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteNotificationChannel";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotificationChannel.encode(
      tsproto.NotificationChannel.fromPartial({ channel_id: channelId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  deleteNotiReactMessage(
    bearerToken: string,
    channelId?: bigint,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteNotiReactMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotificationChannel.encode(
      tsproto.NotificationChannel.fromPartial({ channel_id: channelId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  setNotificationReactMessage(
    bearerToken: string,
    body: ApiNotificationChannel,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetNotificationReactMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.NotificationChannel.encode(
      tsproto.NotificationChannel.fromPartial({
        ...body,
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** set permission role channel. */
  setRoleChannelPermission(
    bearerToken: string,
    body: ApiUpdateRoleChannelRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SetRoleChannelPermission";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateRoleChannelRequest.encode(
      tsproto.UpdateRoleChannelRequest.fromPartial({
        ...body,
        channel_id: BigInt(body.channel_id as string),
        role_id: BigInt(body.role_id as string),
        user_id: BigInt(body.user_id as string),
        max_permission_id: BigInt(body.max_permission_id as string),
        permission_update: body.permission_update?.map((p) => {
          return {
            ...p,
            permission_id: BigInt(p.permission_id as string),
          };
        }),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Get permission list */
  getListPermission(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiPermissionList> {
    const urlPath = "/mezon.api.Mezon/GetListPermission";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiPermissionList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.PermissionList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiPermissionList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** GetPermissionByRoleIdChannelId */
  getPermissionByRoleIdChannelId(
    bearerToken: string,
    roleId?: bigint,
    channelId?: bigint,
    userId?: bigint,
    options: any = {},
  ): Promise<ApiPermissionRoleChannelListEventResponse> {
    const urlPath = "/mezon.api.Mezon/GetPermissionByRoleIdChannelId";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.PermissionRoleChannelListEventRequest.encode(
      tsproto.PermissionRoleChannelListEventRequest.fromPartial({
        role_id: roleId,
        channel_id: channelId,
        user_id: userId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiPermissionRoleChannelListEventResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.PermissionRoleChannelListEventResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiPermissionRoleChannelListEventResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  deletePinMessage(
    bearerToken: string,
    id?: bigint,
    messageId?: bigint,
    channelId?: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeletePinMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeletePinMessage.encode(
      tsproto.DeletePinMessage.fromPartial({
        id: id,
        message_id: messageId,
        channel_id: channelId,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  getPinMessagesList(
    bearerToken: string,
    messageId?: bigint,
    channelId?: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<PinMessagesList> {
    const urlPath = "/mezon.api.Mezon/GetPinMessagesList";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.PinMessageRequest.encode(
      tsproto.PinMessageRequest.fromPartial({
        message_id: messageId,
        channel_id: channelId,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as PinMessagesList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.PinMessagesList.decode(
            new Uint8Array(buffer),
          ) as unknown as PinMessagesList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** create message to inbox. */
  createMessage2Inbox(
    bearerToken: string,
    body: ApiMessage2InboxRequest,
    options: any = {},
  ): Promise<ApiChannelMessageHeader> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateMessage2Inbox";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.Message2InboxRequest.encode(
      tsproto.Message2InboxRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        message_id: BigInt(body.message_id as string),
        references: body.references?.map((r) => {
          return {
            ...r,
            message_id: BigInt(r.message_id as string),
            message_ref_id: BigInt(r.message_ref_id as string),
            message_sender_id: BigInt(r.message_sender_id as string),
          };
        }),
        mentions: body.mentions?.map((m) => {
          return {
            ...m,
            id: BigInt(m.id as string),
            user_id: BigInt(m.user_id as string),
            role_id: BigInt(m.role_id as string),
          };
        }),
        reactions: body.reactions?.map((r) => {
          return {
            ...r,
            id: BigInt(r.id as string),
            emoji_id: BigInt(r.emoji_id as string),
            sender_id: BigInt(r.sender_id as string),
            channel_id: BigInt(r.channel_id as string),
            emoji_recent_id: BigInt(r.emoji_recent_id as string),
            message_id: BigInt(r.message_id as string),
            topic_id: BigInt(r.topic_id as string),
          };
        }),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelMessageHeader;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelMessageHeader.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelMessageHeader;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** set notification user channel. */
  createPinMessage(
    bearerToken: string,
    body: ApiPinMessageRequest,
    options: any = {},
  ): Promise<ApiChannelMessageHeader> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreatePinMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.PinMessageRequest.encode(
      tsproto.PinMessageRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        message_id: BigInt(body.message_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelMessageHeader;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelMessageHeader.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelMessageHeader;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** get pubkey */
  getPubKeys(
    bearerToken: string,
    userIds?: Array<bigint>,
    options: any = {},
  ): Promise<ApiGetPubKeysResponse> {
    const urlPath = "/mezon.api.Mezon/GetPubKeys";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.GetPubKeysRequest.encode(
      tsproto.GetPubKeysRequest.fromPartial({ user_ids: userIds || [] }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiGetPubKeysResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GetPubKeysResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiGetPubKeysResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** store pubkey for e2ee */
  pushPubKey(
    bearerToken: string,
    body: ApiPushPubKeyRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/PushPubKey";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.PushPubKeyRequest.encode(
      tsproto.PushPubKeyRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  addRolesChannelDesc(
    bearerToken: string,
    body: ApiAddRoleChannelDescRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddRolesChannelDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.AddRoleChannelDescRequest.encode(
      tsproto.AddRoleChannelDescRequest.fromPartial({
        ...body,
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** update the category of a channel */
  changeChannelCategory(
    bearerToken: string,
    newCategoryId: bigint,
    body: MezonChangeChannelCategoryBody,
    options: any = {},
  ): Promise<any> {
    if (newCategoryId === null || newCategoryId === undefined) {
      throw new Error(
        "'newCategoryId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ChangeChannelCategory";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChangeChannelCategoryRequest.encode(
      tsproto.ChangeChannelCategoryRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        new_category_id: newCategoryId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Update a role when Delete a role by ID. */
  deleteRoleChannelDesc(
    bearerToken: string,
    body: ApiDeleteRoleRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteRoleChannelDesc";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteRoleRequest.encode(
      tsproto.DeleteRoleRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        role_id: BigInt(body.role_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** ListRoles */
  listRoles(
    bearerToken: string,
    clanId?: bigint,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiRoleListEventResponse> {
    const urlPath = "/mezon.api.Mezon/ListRoles";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.RoleListEventRequest.encode(
      tsproto.RoleListEventRequest.fromPartial({
        clan_id: clanId,
        limit: limit,
        state: state,
        cursor: cursor,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiRoleListEventResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.RoleListEventResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiRoleListEventResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create a new role for clan. */
  createRole(
    bearerToken: string,
    body: ApiCreateRoleRequest,
    options: any = {},
  ): Promise<ApiRole> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateRole";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateRoleRequest.encode(
      tsproto.CreateRoleRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        max_permission_id: BigInt(body.max_permission_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiRole;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Role.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiRole;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update a role when Delete a role by ID. */
  updateRoleDelete(
    bearerToken: string,
    roleId: bigint,
    body: MezonUpdateRoleDeleteBody,
    options: any = {},
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteRole";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteRoleRequest.encode(
      tsproto.DeleteRoleRequest.fromPartial({
        ...body,
        role_id: roleId,
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Delete a role by ID. */
  deleteRole(
    bearerToken: string,
    roleId: bigint,
    channelId?: bigint,
    clanId?: bigint,
    roleLabel?: string,
    options: any = {},
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteRole";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteRoleRequest.encode(
      tsproto.DeleteRoleRequest.fromPartial({
        role_id: roleId,
        channel_id: channelId,
        clan_id: clanId,
        role_label: roleLabel,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Update fields in a given role. */
  updateRole(
    bearerToken: string,
    roleId: bigint,
    body: MezonUpdateRoleBody,
    options: any = {},
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateRole";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateRoleRequest.encode(
      tsproto.UpdateRoleRequest.fromPartial({
        ...body,
        role_id: roleId,
        clan_id: BigInt(body.clan_id as string),
        max_permission_id: BigInt(body.max_permission_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List role permissions */
  listRolePermissions(
    bearerToken: string,
    roleId: bigint,
    options: any = {},
  ): Promise<ApiPermissionList> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListRolePermissions";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListPermissionsRequest.encode(
      tsproto.ListPermissionsRequest.fromPartial({ role_id: roleId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiPermissionList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.PermissionList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiPermissionList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List role permissions */
  listRoleUsers(
    bearerToken: string,
    roleId: bigint,
    limit?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiRoleUserList> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListRoleUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListRoleUsersRequest.encode(
      tsproto.ListRoleUsersRequest.fromPartial({
        role_id: roleId,
        limit: limit,
        cursor: cursor,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiRoleUserList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.RoleUserList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiRoleUserList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  getRoleOfUserInTheClan(
    bearerToken: string,
    clanId: bigint,
    channelId?: bigint,
    options: any = {},
  ): Promise<ApiRoleList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GetRoleOfUserInTheClan";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListPermissionOfUsersRequest.encode(
      tsproto.ListPermissionOfUsersRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiRoleList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.RoleList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiRoleList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  searchThread(
    bearerToken: string,
    clanId?: bigint,
    channelId?: bigint,
    label?: string,
    options: any = {},
  ): Promise<ApiChannelDescList> {
    const urlPath = "/mezon.api.Mezon/SearchThread";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SearchThreadRequest.encode(
      tsproto.SearchThreadRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        label: label,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelDescList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  sessionLogout(
    bearerToken: string,
    body: ApiSessionLogoutRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/SessionLogout";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SessionLogoutRequest.encode(
      tsproto.SessionLogoutRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Add a new sticker */
  addClanSticker(
    bearerToken: string,
    body: ApiClanStickerAddRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddClanSticker";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanStickerAddRequest.encode(
      tsproto.ClanStickerAddRequest.fromPartial({
        ...body,
        id: BigInt(body.id as string),
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete a sticker by ID */
  deleteClanStickerById(
    bearerToken: string,
    id: bigint,
    clanId?: bigint,
    stickerLabel?: string,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/DeleteClanStickerById";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanStickerDeleteRequest.encode(
      tsproto.ClanStickerDeleteRequest.fromPartial({
        id: id,
        clan_id: clanId,
        sticker_label: stickerLabel,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update a sticker by ID */
  updateClanStickerById(
    bearerToken: string,
    id: bigint,
    body: MezonUpdateClanStickerByIdBody,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateClanStickerById";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ClanStickerUpdateByIdRequest.encode(
      tsproto.ClanStickerUpdateByIdRequest.fromPartial({ ...body, id: id, clan_id: BigInt(body.clan_id as string) }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** get list sticker by user id */
  getListStickersByUserId(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiStickerListedResponse> {
    const urlPath = "/mezon.api.Mezon/GetListStickersByUserId";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiStickerListedResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.StickerListedResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiStickerListedResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Register streaming in channel ( for bot - get streaming key) */
  registerStreamingChannel(
    bearerToken: string,
    body: ApiRegisterStreamingChannelRequest,
    options: any = {},
  ): Promise<ApiRegisterStreamingChannelResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/RegisterStreamingChannel";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.RegisterStreamingChannelRequest.encode(
      tsproto.RegisterStreamingChannelRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiRegisterStreamingChannelResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.RegisterStreamingChannelResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiRegisterStreamingChannelResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listStreamingChannelUsers(
    bearerToken: string,
    clanId?: bigint,
    channelId?: bigint,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiStreamingChannelUserList> {
    const urlPath = "/mezon.api.Mezon/ListStreamingChannelUsers";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListChannelUsersRequest.encode(
      tsproto.ListChannelUsersRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
        channel_type: channelType,
        limit: limit,
        state: state,
        cursor: cursor,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiStreamingChannelUserList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.StreamingChannelUserList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiStreamingChannelUserList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Get the list of system messages. */
  getSystemMessagesList(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiSystemMessagesList> {
    const urlPath = "/mezon.api.Mezon/GetSystemMessagesList";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSystemMessagesList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.SystemMessagesList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSystemMessagesList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create a system messages. */
  createSystemMessage(
    bearerToken: string,
    body: ApiSystemMessageRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateSystemMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SystemMessageRequest.encode(
      tsproto.SystemMessageRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List Sd Topic */
  listSdTopic(
    bearerToken: string,
    clanId?: bigint,
    limit?: number,
    options: any = {},
  ): Promise<ApiSdTopicList> {
    const urlPath = "/mezon.api.Mezon/ListSdTopic";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListSdTopicRequest.encode(
      tsproto.ListSdTopicRequest.fromPartial({
        clan_id: clanId,
        limit: limit,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSdTopicList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.SdTopicList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSdTopicList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create Sd Topic */
  createSdTopic(
    bearerToken: string,
    body: ApiSdTopicRequest,
    options: any = {},
  ): Promise<ApiSdTopic> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateSdTopic";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SdTopicRequest.encode(
      tsproto.SdTopicRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        message_id: BigInt(body.message_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSdTopic;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.SdTopic.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSdTopic;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Delete a specific system messages. */
  deleteSystemMessage(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteSystemMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteSystemMessage.encode(
      tsproto.DeleteSystemMessage.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Get details of a specific system messages. */
  getSystemMessageByClanId(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<ApiSystemMessage> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GetSystemMessageByClanId";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.GetSystemMessage.encode(
      tsproto.GetSystemMessage.fromPartial({ clan_id: clanId }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSystemMessage;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.SystemMessage.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSystemMessage;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update a system messages. */
  updateSystemMessage(
    bearerToken: string,
    clanId: bigint,
    body: MezonUpdateSystemMessageBody,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateSystemMessage";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.SystemMessageRequest.encode(
      tsproto.SystemMessageRequest.fromPartial({ ...body, clan_id: clanId, channel_id: BigInt(body.channel_id as string) }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List user channels */
  listThreadDescs(
    bearerToken: string,
    channelId: bigint,
    limit?: number,
    state?: number,
    clanId?: bigint,
    threadId?: bigint,
    page?: number,
    options: any = {},
  ): Promise<ApiChannelDescList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListThreadDescs";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListThreadRequest.encode(
      tsproto.ListThreadRequest.fromPartial({
        channel_id: channelId,
        limit: limit,
        state: state,
        clan_id: clanId,
        thread_id: threadId,
        page: page,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescListNoPool.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelDescList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }
  /** Update fields in a given category. */
  updateCategory(
    bearerToken: string,
    clanId: bigint,
    body: MezonUpdateCategoryBody,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateCategory";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateCategoryDescRequest.encode(
      tsproto.UpdateCategoryDescRequest.fromPartial({
        ...body,
        clan_id: clanId,
        category_id: BigInt(body.category_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update channel private. */
  updateChannelPrivate(
    bearerToken: string,
    body: ApiChangeChannelPrivateRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateChannelPrivate";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChangeChannelPrivateRequest.encode(
      tsproto.ChangeChannelPrivateRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  updateUserProfileByClan(
    bearerToken: string,
    clanId: bigint,
    body: MezonUpdateUserProfileByClanBody,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateUserProfileByClan";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateClanProfileRequest.encode(
      tsproto.UpdateClanProfileRequest.fromPartial({
        ...body,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          return {};
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Upload attachment */
  uploadOauthFile(
    bearerToken: string,
    body: ApiUploadAttachmentRequest,
    options: any = {},
  ): Promise<ApiUploadAttachment> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UploadOauthFile";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UploadAttachmentRequest.encode(
      tsproto.UploadAttachmentRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiUploadAttachment;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.UploadAttachment.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiUploadAttachment;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Upload attachment */
  uploadAttachmentFile(
    bearerToken: string,
    body: ApiUploadAttachmentRequest,
    options: any = {},
  ): Promise<ApiUploadAttachment> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UploadAttachmentFile";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UploadAttachmentRequest.encode(
      tsproto.UploadAttachmentRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiUploadAttachment;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.UploadAttachment.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiUploadAttachment;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  updateUser(
    bearerToken: string,
    body: ApiUpdateUsersRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateUser";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateUsersRequest.encode(
      tsproto.UpdateUsersRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** ListUserClansByUserId */
  listUserClansByUserId(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiAllUserClans> {
    const urlPath = "/mezon.api.Mezon/ListUserClansByUserId";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiAllUserClans;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.AllUserClans.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiAllUserClans;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** ListUserPermissionInChannel */
  listUserPermissionInChannel(
    bearerToken: string,
    clanId?: bigint,
    channelId?: bigint,
    options: any = {},
  ): Promise<ApiUserPermissionInChannelListResponse> {
    const urlPath = "/mezon.api.Mezon/ListUserPermissionInChannel";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UserPermissionInChannelListRequest.encode(
      tsproto.UserPermissionInChannelListRequest.fromPartial({
        clan_id: clanId,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiUserPermissionInChannelListResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.UserPermissionInChannelListResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiUserPermissionInChannelListResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Get user status */
  getUserStatus(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiUserStatus> {
    const urlPath = "/mezon.api.Mezon/GetUserStatus";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiUserStatus;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.UserStatus.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiUserStatus;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update user status */
  updateUserStatus(
    bearerToken: string,
    body: ApiUserStatusUpdate,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateUserStatus";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UserStatusUpdate.encode(
      tsproto.UserStatusUpdate.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** create webhook */
  generateWebhook(
    bearerToken: string,
    body: ApiWebhookCreateRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GenerateWebhook";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.WebhookCreateRequest.encode(
      tsproto.WebhookCreateRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {};
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.WebhookGenerateResponse.decode(new Uint8Array(buffer));
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** update webhook name by id */
  updateWebhookById(
    bearerToken: string,
    id: bigint,
    body: MezonUpdateWebhookByIdBody,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateWebhookById";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.WebhookUpdateRequestById.encode(
      tsproto.WebhookUpdateRequestById.fromPartial({
        ...body,
        id: id,
        channel_id: BigInt(body.channel_id as string),
        channel_id_update: BigInt(body.channel_id_update as string),
        clan_id: BigInt(body.clan_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** list webhook belong to the channel */
  listWebhookByChannelId(
    bearerToken: string,
    channelId: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<ApiWebhookListResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListWebhookByChannelId";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.WebhookListRequest.encode(
      tsproto.WebhookListRequest.fromPartial({
        channel_id: channelId,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiWebhookListResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.WebhookListResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiWebhookListResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** disabled webhook */
  deleteWebhookById(
    bearerToken: string,
    id: bigint,
    body: MezonDeleteWebhookByIdBody,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteWebhookById";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.WebhookDeleteRequestById.encode(
      tsproto.WebhookDeleteRequestById.fromPartial({
        ...body,
        id: id,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  buildFullUrl(
    basePath: string,
    fragment: string,
    queryParams: Map<string, any>,
  ) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
      if (v instanceof Array) {
        fullPath += v.reduce((prev: any, curr: any) => {
          return (
            prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&"
          );
        }, "");
      } else {
        if (v != null) {
          fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
        }
      }
    }

    return fullPath;
  }

  /** Channel canvas editor */
  editChannelCanvases(
    bearerToken: string,
    body: ApiEditChannelCanvasRequest,
    options: any = {},
  ): Promise<ApiEditChannelCanvasResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/EditChannelCanvases";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.EditChannelCanvasRequest.encode(
      tsproto.EditChannelCanvasRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        id: BigInt(body.id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiEditChannelCanvasResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.EditChannelCanvasResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiEditChannelCanvasResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  getChannelCanvasDetail(
    bearerToken: string,
    id: bigint,
    clanId?: bigint,
    channelId?: bigint,
    options: any = {},
  ): Promise<ApiChannelCanvasDetailResponse> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/GetChannelCanvasDetail";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ChannelCanvasDetailRequest.encode(
      tsproto.ChannelCanvasDetailRequest.fromPartial({
        id: id,
        clan_id: clanId,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelCanvasDetailResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelCanvasDetailResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelCanvasDetailResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  deleteChannelCanvas(
    bearerToken: string,
    canvasId: bigint,
    clanId?: bigint,
    channelId?: bigint,
    options: any = {},
  ): Promise<any> {
    if (canvasId === null || canvasId === undefined) {
      throw new Error(
        "'canvasId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/DeleteChannelCanvas";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.DeleteChannelCanvasRequest.encode(
      tsproto.DeleteChannelCanvasRequest.fromPartial({
        canvas_id: canvasId,
        clan_id: clanId,
        channel_id: channelId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** list onboarding. */
  listOnboarding(
    bearerToken: string,
    clanId?: bigint,
    guideType?: number,
    limit?: number,
    page?: number,
    options: any = {},
  ): Promise<ApiListOnboardingResponse> {
    const urlPath = "/mezon.api.Mezon/ListOnboarding";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListOnboardingRequest.encode(
      tsproto.ListOnboardingRequest.fromPartial({
        clan_id: clanId,
        guide_type: guideType,
        limit: limit,
        page: page,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListOnboardingResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListOnboardingResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListOnboardingResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** create onboarding. */
  createOnboarding(
    bearerToken: string,
    body: ApiCreateOnboardingRequest,
    options: any = {},
  ): Promise<ApiListOnboardingResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateOnboarding";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateOnboardingRequest.encode(
      tsproto.CreateOnboardingRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        contents: body.contents?.map(c => {
          return {
            ...c,
            channel_id: BigInt(c.channel_id as string)
          }
        })
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListOnboardingResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListOnboardingResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListOnboardingResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** delete onboarding. */
  deleteOnboarding(
    bearerToken: string,
    id: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/DeleteOnboarding";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.OnboardingRequest.encode(
      tsproto.OnboardingRequest.fromPartial({
        id: id,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** get detailed onboarding information. */
  getOnboardingDetail(
    bearerToken: string,
    id: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<ApiOnboardingItem> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/GetOnboardingDetail";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.OnboardingRequest.encode(
      tsproto.OnboardingRequest.fromPartial({
        id: id,
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiOnboardingItem;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.OnboardingItem.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiOnboardingItem;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** update onboarding. */
  updateOnboarding(
    bearerToken: string,
    id: bigint,
    body: MezonUpdateOnboardingBody,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateOnboarding";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateOnboardingRequest.encode(
      tsproto.UpdateOnboardingRequest.fromPartial({
        ...body,
        id: id,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Generate clan webhook. */
  generateClanWebhook(
    bearerToken: string,
    body: ApiGenerateClanWebhookRequest,
    options: any = {},
  ): Promise<ApiGenerateClanWebhookResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GenerateClanWebhook";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.GenerateClanWebhookRequest.encode(
      tsproto.GenerateClanWebhookRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiGenerateClanWebhookResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GenerateClanWebhookResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiGenerateClanWebhookResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List clan webhook. */
  listClanWebhook(
    bearerToken: string,
    clanId: bigint,
    options: any = {},
  ): Promise<ApiListClanWebhookResponse> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListClanWebhook";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.ListClanWebhookRequest.encode(
      tsproto.ListClanWebhookRequest.fromPartial({
        clan_id: clanId,
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListClanWebhookResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListClanWebhookResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListClanWebhookResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Disabled clan webhook. */
  deleteClanWebhookById(
    bearerToken: string,
    id: bigint,
    clanId?: bigint,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/mezon.api.Mezon/DeleteClanWebhookById";
    const queryParams = new Map<string, any>();

    const body = {
      id: id,
      clan_id: clanId,
    };

    const bodyWriter = tsproto.ClanWebhookRequest.encode(
      tsproto.ClanWebhookRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Update clan webhook by id. */
  updateClanWebhookById(
    bearerToken: string,
    id: bigint,
    body: MezonUpdateClanWebhookByIdBody,
    options: any = {},
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateClanWebhookById";
    const queryParams = new Map<string, any>();

    const bodyData = {
      ...body,
      id: id,
      clan_id: BigInt(body.clan_id as string)
    };

    const bodyWriter = tsproto.UpdateClanWebhookRequest.encode(
      tsproto.UpdateClanWebhookRequest.fromPartial(bodyData),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Sd Topic */
  getTopicDetail(
    bearerToken: string,
    topicId?: bigint,
    options: any = {},
  ): Promise<ApiSdTopic> {
    const urlPath = "/mezon.api.Mezon/GetTopicDetail";
    const queryParams = new Map<string, any>();

    const body = {
      topic_id: topicId,
    };

    const bodyWriter = tsproto.SdTopicDetailRequest.encode(
      tsproto.SdTopicDetailRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSdTopic;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.SdTopic.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSdTopic;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** List onboarding step. */
  listOnboardingStep(
    bearerToken: string,
    clanId?: bigint,
    limit?: number,
    page?: number,
    options: any = {},
  ): Promise<ApiListOnboardingStepResponse> {
    const urlPath = "/mezon.api.Mezon/ListOnboardingStep";
    const queryParams = new Map<string, any>();

    const body = {
      clan_id: clanId,
      limit: limit,
      page: page,
    };

    const bodyWriter = tsproto.ListOnboardingStepRequest.encode(
      tsproto.ListOnboardingStepRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListOnboardingStepResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListOnboardingStepResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListOnboardingStepResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Update onboarding step. */
  updateOnboardingStepByClanId(
    bearerToken: string,
    clanId: bigint,
    body: MezonUpdateOnboardingStepByClanIdBody,
    options: any = {},
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateOnboardingStep";
    const queryParams = new Map<string, any>();

    const bodyData = {
      ...body,
      clan_id: clanId,
    };

    const bodyWriter = tsproto.UpdateOnboardingStepRequest.encode(
      tsproto.UpdateOnboardingStepRequest.fromPartial(bodyData),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** create meeting room */
  createRoomChannelApps(
    bearerToken: string,
    body: MezonapiCreateRoomChannelApps,
    options: any = {},
  ): Promise<MezonapiCreateRoomChannelApps> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/CreateRoomChannelApps";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.CreateRoomChannelApps.encode(
      tsproto.CreateRoomChannelApps.fromPartial({
        ...body,
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as MezonapiCreateRoomChannelApps;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.CreateRoomChannelApps.decode(
            new Uint8Array(buffer),
          ) as unknown as MezonapiCreateRoomChannelApps;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Generate Meet Token */
  generateMeetToken(
    bearerToken: string,
    body: ApiGenerateMeetTokenRequest,
    options: any = {},
  ): Promise<ApiGenerateMeetTokenResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/GenerateMeetToken";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.GenerateMeetTokenRequest.encode(
      tsproto.GenerateMeetTokenRequest.fromPartial({
        ...body,
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiGenerateMeetTokenResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GenerateMeetTokenResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiGenerateMeetTokenResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Create mezon OAuth client */
  getMezonOauthClient(
    bearerToken: string,
    clientId?: string,
    clientName?: string,
    options: any = {},
  ): Promise<ApiMezonOauthClient> {
    const urlPath = "/mezon.api.Mezon/GetMezonOauthClient";
    const queryParams = new Map<string, any>();

    const body = {
      client_id: clientId,
      client_name: clientName,
    };

    const bodyWriter = tsproto.GetMezonOauthClientRequest.encode(
      tsproto.GetMezonOauthClientRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiMezonOauthClient;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.MezonOauthClient.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiMezonOauthClient;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** update mezon OAuth */
  updateMezonOauthClient(
    bearerToken: string,
    body: ApiMezonOauthClient,
    options: any = {},
  ): Promise<ApiMezonOauthClient> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateMezonOauthClient";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.MezonOauthClient.encode(
      tsproto.MezonOauthClient.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiMezonOauthClient;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.MezonOauthClient.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiMezonOauthClient;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }
  /**  */
  generateHashChannelApps(
    bearerToken: string,
    appId?: bigint,
    options: any = {},
  ): Promise<ApiCreateHashChannelAppsResponse> {
    const urlPath = "/mezon.api.Mezon/GenerateHashChannelApps";
    const queryParams = new Map<string, any>();

    const body = {
      app_id: appId,
    };

    const bodyWriter = tsproto.GenerateHashChannelAppsRequest.encode(
      tsproto.GenerateHashChannelAppsRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiCreateHashChannelAppsResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GenerateHashChannelAppsResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiCreateHashChannelAppsResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Add user event */
  addUserEvent(
    bearerToken: string,
    body: ApiUserEventRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddUserEvent";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UserEventRequest.encode(
      tsproto.UserEventRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        event_id: BigInt(body.event_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Delete user event */
  deleteUserEvent(
    bearerToken: string,
    clanId?: bigint,
    eventId?: bigint,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteUserEvent";
    const queryParams = new Map<string, any>();

    const body = {
      clan_id: clanId,
      event_id: eventId,
    };

    const bodyWriter = tsproto.UserEventRequest.encode(
      tsproto.UserEventRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  updateRoleOrder(
    bearerToken: string,
    body: ApiUpdateRoleOrderRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateRoleOrder";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateRoleOrderRequest.encode(
      tsproto.UpdateRoleOrderRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        roles: body.roles?.map(r => {
          return {
            ...r,
            role_id: BigInt(r.role_id as string)
          }
        })
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Create external Mezon meet */
  createExternalMezonMeet(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiGenerateMezonMeetResponse> {
    const urlPath = "/mezon.api.Mezon/CreateExternalMezonMeet";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiGenerateMezonMeetResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GenerateMezonMeetResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiGenerateMezonMeetResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** handler external mezon meet */
  generateMeetTokenExternal(
    bearerToken: string,
    basePath: string,
    token: string,
    displayName?: string,
    isGuest?: boolean,
    options: any = {},
  ): Promise<ApiGenerateMeetTokenExternalResponse> {
    if (token === null || token === undefined) {
      throw new Error(
        "'token' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/meet/external/{token}".replace(
      "{token}",
      encodeURIComponent(String(token)),
    );
    const queryParams = new Map<string, any>();
    queryParams.set("display_name", displayName);
    queryParams.set("is_guest", isGuest);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiGenerateMeetTokenExternalResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.GenerateMeetTokenExternalResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiGenerateMeetTokenExternalResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }
  /** mute participant in the room */
  muteParticipantMezonMeet(
    bearerToken: string,
    body: ApiMeetParticipantRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/MuteParticipantMezonMeet";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.MeetParticipantRequest.encode(
      tsproto.MeetParticipantRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Remove participant out the room */
  removeParticipantMezonMeet(
    bearerToken: string,
    body: ApiMeetParticipantRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/RemoveParticipantMezonMeet";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.MeetParticipantRequest.encode(
      tsproto.MeetParticipantRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** List channels detail */
  listChannelDetail(
    bearerToken: string,
    channelId: bigint,
    options: any = {},
  ): Promise<ApiChannelDescription> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/ListChannelDetail";
    const queryParams = new Map<string, any>();

    const body = {
      channel_id: channelId,
    };

    const bodyWriter = tsproto.ListChannelDetailRequest.encode(
      tsproto.ListChannelDetailRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiChannelDescription;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ChannelDescription.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiChannelDescription;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  updateClanOrder(
    bearerToken: string,
    body: ApiUpdateClanOrderRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateClanOrder";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateClanOrderRequest.encode(
      tsproto.UpdateClanOrderRequest.fromPartial({
        ...body,
        clans_order: body.clans_order?.map(order => {
          return {
            ...order,
            clan_id: BigInt(order.clan_id as string)
          }
        })
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Discover mezon clan. */
  clanDiscover(
    basicAuthUsername: string,
    basicAuthPassword: string,
    basePath: string,
    body: ApiClanDiscoverRequest,
    options: any = {},
  ): Promise<ApiListClanDiscover> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/v2/clan/discover";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";
    fetchOptions.headers["Content-Type"] = "application/json";

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiListClanDiscover;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ListClanDiscover.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiListClanDiscover;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }
  /**  */
  deleteQuickMenuAccess(
    bearerToken: string,
    id?: bigint,
    clanId?: bigint,
    botId?: bigint,
    menuName?: string,
    background?: string,
    actionMsg?: string,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const body = {
      id: id,
      clan_id: clanId,
      bot_id: botId,
      menu_name: menuName,
      background: background,
      action_msg: actionMsg,
    };

    const bodyWriter = tsproto.QuickMenuAccess.encode(
      tsproto.QuickMenuAccess.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  listQuickMenuAccess(
    bearerToken: string,
    botId?: bigint,
    channelId?: bigint,
    menuType?: number,
    options: any = {},
  ): Promise<ApiQuickMenuAccessList> {
    const urlPath = "/mezon.api.Mezon/ListQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const body = {
      bot_id: botId,
      channel_id: channelId,
      menu_type: menuType,
    };

    const bodyWriter = tsproto.ListQuickMenuAccessRequest.encode(
      tsproto.ListQuickMenuAccessRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiQuickMenuAccessList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.QuickMenuAccessList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiQuickMenuAccessList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  addQuickMenuAccess(
    bearerToken: string,
    body: ApiQuickMenuAccessRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/AddQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.QuickMenuAccess.encode(
      tsproto.QuickMenuAccess.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        id: BigInt(body.id as string),
        bot_id: BigInt(body.bot_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  updateQuickMenuAccess(
    bearerToken: string,
    body: ApiQuickMenuAccessRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.QuickMenuAccess.encode(
      tsproto.QuickMenuAccess.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        channel_id: BigInt(body.channel_id as string),
        id: BigInt(body.id as string),
        bot_id: BigInt(body.bot_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** For sale items */
  listForSaleItems(
    bearerToken: string,
    page?: number,
    options: any = {},
  ): Promise<ApiForSaleItemList> {
    const urlPath = "/mezon.api.Mezon/ListForSaleItems";
    const queryParams = new Map<string, any>();

    const body = {
      page: page,
    };

    const bodyWriter = tsproto.ListForSaleItemsRequest.encode(
      tsproto.ListForSaleItemsRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiForSaleItemList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.ForSaleItemList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiForSaleItemList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  isFollower(
    bearerToken: string,
    body: ApiIsFollowerRequest,
    options: any = {},
  ): Promise<ApiIsFollowerResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/IsFollower";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.IsFollowerRequest.encode(
      tsproto.IsFollowerRequest.fromPartial({
        ...body,
        follow_id: BigInt(body.follow_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiIsFollowerResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.IsFollowerResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiIsFollowerResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  transferOwnership(
    bearerToken: string,
    body: ApiTransferOwnershipRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/TransferOwnership";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.TransferOwnershipRequest.encode(
      tsproto.TransferOwnershipRequest.fromPartial({
        ...body,
        clan_id: BigInt(body.clan_id as string),
        new_owner_id: BigInt(body.new_owner_id as string)
      }),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /** Update username */
  updateUsername(
    bearerToken: string,
    body: ApiUpdateUsernameRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/UpdateUsername";
    const queryParams = new Map<string, any>();

    const bodyWriter = tsproto.UpdateUsernameRequest.encode(
      tsproto.UpdateUsernameRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiSession;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.Session.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiSession;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /** Ban a set of users from a channel. */
  isBanned(
    bearerToken: string,
    channelId: bigint,
    options: any = {},
  ): Promise<ApiIsBannedResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }
    const urlPath = "/mezon.api.Mezon/IsBanned";
    const queryParams = new Map<string, any>();

    const body = {
      channel_id: channelId,
    };

    const bodyWriter = tsproto.IsBannedRequest.encode(
      tsproto.IsBannedRequest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiIsBannedResponse;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.IsBannedResponse.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiIsBannedResponse;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }

  /**  */
  reportMessageAbuse(
    bearerToken: string,
    messageId?: bigint,
    abuseType?: string,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/ReportMessageAbuse";
    const queryParams = new Map<string, any>();

    const body = {
      message_id: messageId,
      abuse_type: abuseType,
    };

    const bodyWriter = tsproto.ReportMessageAbuseReqest.encode(
      tsproto.ReportMessageAbuseReqest.fromPartial(body),
    );
    const encodedBody = bodyWriter.finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response;
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out."),
      ),
    ]);
  }

  /**  */
  listLogedDevice(
    bearerToken: string,
    options: any = {},
  ): Promise<ApiLogedDeviceList> {
    const urlPath = "/mezon.api.Mezon/ListLogedDevice";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then(async (response) => {
        if (response.status == 204) {
          return {} as ApiLogedDeviceList;
        } else if (response.status >= 200 && response.status < 300) {
          const buffer = await response.arrayBuffer();
          return tsproto.LogedDeviceList.decode(
            new Uint8Array(buffer),
          ) as unknown as ApiLogedDeviceList;
        } else {
          throw response;
        }
      }),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("Request timed out.")),
          this.timeoutMs,
        ),
      ),
    ]);
  }
}
