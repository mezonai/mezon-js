// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { buildFetchOptions } from "./utils";
import { encode } from "js-base64";

/** A single user-role pair. */
export interface ChannelUserListChannelUser {
  //
  clan_avatar?: string;
  //
  clan_id?: string;
  //
  clan_nick?: string;
  //
  id?: string;
  //Their relationship to the role.
  role_id?: Array<string>;
  //
  thread_id?: string;
  //User.
  user_id?: string;
}

/** A single user-role pair. */
export interface ClanUserListClanUser {
  //from the `avatar_url` field in the `clan_desc_profile` table.
  clan_avatar?: string;
  //
  clan_id?: string;
  //from the `nick_name` field in the `clan_desc_profile` table.
  clan_nick?: string;
  //Their relationship to the role.
  role_id?: Array<string>;
  //User.
  user?: ApiUser;
}

/**  */
export interface CountClanBadgeResponseBadge {
  //
  clan_id?: string;
  //
  count?: number;
}

/**  */
export interface MezonChangeChannelCategoryBody {
  //
  channel_id?: string;
}

/**  */
export interface MezonDeleteWebhookByIdBody {}

/** Update app information. */
export interface MezonUpdateAppBody {
  //about the app.
  about?: string;
  //Avatar URL.
  applogo?: string;
  //Username.
  appname?: string;
  //Metadata.
  metadata?: string;
  //Token.
  token?: string;
}

/**  */
export interface MezonUpdateCategoryBody {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
}

/**  */
export interface ApiAddAppRequest {
  //The appname.
  appname?: string;
  //Creator of the app.
  creator_id?: string;
  //
  role?: ApiAppRole;
  //The password.
  token?: string;
}

/**
* - USER_ROLE_ADMIN: All access
 - USER_ROLE_DEVELOPER: Best for developers, also enables APIs and API explorer
 - USER_ROLE_MAINTAINER: Best for users who regularly update player information.
 - USER_ROLE_READONLY: Read-only role for those only need to view data
*/
export enum ApiAppRole {
  /*  */
  USER_ROLE_UNKNOWN = 0,
  /* */
  USER_ROLE_ADMIN = 1, // All access
  USER_ROLE_DEVELOPER = 2, // Best for developers, also enables APIs and API explorer
  USER_ROLE_MAINTAINER = 3, // Best for users who regularly update player information.
  USER_ROLE_READONLY = 4, // Read-only role for those only need to view data
}

/** Update fields in a given channel. */
export interface MezonUpdateChannelDescBody {
  //
  app_url?: string;
  //
  category_id?: string;
  //
  channel_label?: string;
}

/**  */
export interface MezonUpdateClanDescBody {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
}

/**  */
export interface MezonUpdateClanDescProfileBody {
  //
  avatar_url?: string;
  //
  nick_name?: string;
  //
  profile_banner?: string;
  //
  profile_theme?: string;
}

/**  */
export interface MezonUpdateClanEmojiByIdBody {
  //
  category?: string;
  //
  clan_id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/**  */
export interface MezonUpdateClanStickerByIdBody {
  //
  category?: string;
  //
  clan_id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/** update a event within clan. */
export interface MezonUpdateEventBody {
  //
  address?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
}

/** Update fields in a given role. */
export interface MezonUpdateRoleBody {
  //The permissions to add.
  active_permission_ids?: Array<string>;
  //The users to add.
  add_user_ids?: Array<string>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  max_permission_id: string;
  //The permissions to remove.
  remove_permission_ids?: Array<string>;
  //The users to remove.
  remove_user_ids?: Array<string>;
  //
  role_icon?: string;
  //
  title?: string;
}

/** Delete a role the user has access to. */
export interface MezonUpdateRoleDeleteBody {
  //
  clan_id?: string;
}

/** Request to get system message by clan and channel IDs. */
export interface MezonUpdateSystemMessageBody {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/**  */
export interface MezonUpdateUserProfileByClanBody {
  //
  avatar?: string;
  //
  nick_name?: string;
}

/**  */
export interface MezonUpdateWebhookByIdBody {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  webhook_name?: string;
}

/** A single user-role pair. */
export interface RoleUserListRoleUser {
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //The id of the user's account.
  id?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //The timezone set by the user.
  online?: boolean;
  //The username of the user's account.
  username?: string;
}

/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  //The custom id in the user's account.
  custom_id?: string;
  //The devices which belong to the user's account.
  devices?: Array<ApiAccountDevice>;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned.
  disable_time?: string;
  //The email address of the user.
  email?: string;
  //The user object.
  user?: ApiUser;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified.
  verify_time?: string;
  //The user's wallet data.
  wallet?: string;
}

/** Send a app token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountApp {
  //
  appid?: string;
  //
  appname?: string;
  //The account token when create apps to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Apple Sign In token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountApple {
  //The ID token received from Apple to validate.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a custom ID to the server. Used with authenticate/link/unlink. */
export interface ApiAccountCustom {
  //A custom identifier.
  id?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface ApiAccountDevice {
  //A device identifier. Should be obtained by a platform-specific device API.
  id?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.  Ignored with unlink operations.
  password?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Facebook token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebook {
  //The OAuth token received from Facebook to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebookInstantGame {
  //
  signed_player_info?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.

https://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign */
export interface ApiAccountGameCenter {
  //Bundle ID (generated by GameCenter).
  bundle_id?: string;
  //Player ID (generated by GameCenter).
  player_id?: string;
  //The URL for the public encryption key.
  public_key_url?: string;
  //A random "NSString" used to compute the hash and keep it randomized.
  salt?: string;
  //The verification signature data generated.
  signature?: string;
  //Time since UNIX epoch when the signature was created.
  timestamp_seconds?: number;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Google token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGoogle {
  //The OAuth token received from Google to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Steam token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountSteam {
  //The account token received from Steam to access their profile API.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiAddFavoriteChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiAddFavoriteChannelResponse {
  //
  channel_id?: string;
}

/** Add a role for channel. */
export interface ApiAddRoleChannelDescRequest {
  //
  channel_id?: string;
  //
  role_ids?: Array<string>;
}

/**  */
export interface ApiAllUsersAddChannelResponse {
  //
  channel_id?: string;
  //
  limit?: number;
  //
  user_ids?: Array<string>;
}

/**  */
export interface ApiAllUserClans {
  //
  users?: Array<ApiUser>;
}

/** App information. */
export interface ApiApp {
  //
  about?: string;
  //
  applogo?: string;
  //
  appname?: string;
  //
  creator_id?: string;
  //The UNIX time when the app was disabled.
  disable_time?: string;
  //
  id?: string;
  //
  is_shadow?: boolean;
  //
  role?: number;
  //
  token?: string;
}

/** A list of apps. */
export interface ApiAppList {
  //A list of apps.
  apps?: Array<ApiApp>;
  //Next cursor.
  next_cursor?: string;
  //Approximate total number of apps.
  total_count?: number;
}

/** Authenticate against the server with a device ID. */
export interface ApiAuthenticateRequest {
  //The App account details.
  account?: ApiAccountApp;
}

/**  */
export interface ApiCategoryDesc {
  //
  category_id?: string;
  //
  category_name?: string;
  //
  category_order?: number;
  //
  clan_id?: string;
  //
  creator_id?: string;
}

/**  */
export interface ApiCategoryDescList {
  //A list of channel.
  categorydesc?: Array<ApiCategoryDesc>;
}

/**  */
export interface ApiCategoryOrderUpdate {
  //
  category_id?: string;
  //
  order?: number;
}

export interface ApiListChannelAppsResponse {
  //
  channel_apps?: Array<ApiChannelAppResponse>;
}

/** Update fields in a given channel. */
export interface ApiChangeChannelPrivateRequest {
  //The ID of the channel to update.
  channel_id?: string;
  //
  channel_private?: number;
  //
  role_ids?: Array<string>;
  //The users to add.
  user_ids?: Array<string>;
}

/**  */
export interface ApiChannelAppResponse {
  //
  app_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  url?: string;
}

/**  */
export interface ApiChannelAttachment {
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created.
  create_time?: string;
  //
  filename?: string;
  //
  filesize?: string;
  //
  filetype?: string;
  //
  id?: string;
  //
  uploader?: string;
  //
  url?: string;
}

/**  */
export interface ApiChannelAttachmentList {
  //
  attachments?: Array<ApiChannelAttachment>;
}

/**  */
export interface ApiChannelCanvasDetailResponse {
  //
  content?: string;
  //
  creator_id?: string;
  //
  editor_id?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
}

/**  */
export interface ApiChannelCanvasItem {
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
}

/**  */
export interface ApiChannelCanvasListResponse {
  //
  channel_canvases?: Array<ApiChannelCanvasItem>;
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiEditChannelCanvasRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  content?: string;
  //
  id?: string;
  //
  is_default?: boolean;
  //
  title?: string;
}

/**  */
export interface ApiEditChannelCanvasResponse {
  //
  id?: string;
}

/** A list of channel description, usually a result of a list operation. */
export interface ApiChannelDescList {
  //Cacheable cursor to list newer channel description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //A list of channel.
  channeldesc?: Array<ApiChannelDescription>;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}

/**  */
export interface ApiChannelDescription {
  //
  active?: number;
  //
  app_url?: string;
  //
  category_id?: string;
  //
  category_name?: string;
  //
  channel_avatar?: Array<string>;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  count_mess_unread?: number;
  //
  create_time_seconds?: number;
  //creator ID.
  creator_id?: string;
  //
  creator_name?: string;
  //
  is_mute?: boolean;
  //
  last_pin_message?: string;
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  meeting_uri?: string;
  //The parrent channel this message belongs to.
  parrent_id?: string;
  //
  is_online?: Array<boolean>;
  //The channel type.
  type?: number;
  //
  update_time_seconds?: number;
  //
  user_id?: Array<string>;
  //
  usernames?: string;
  //
  status?: number;
  //
  metadata?: Array<string>;
  //
  about_me?: Array<string>;
}

/** A message sent on a channel. */
export interface ApiChannelMessage {
  // id
  id: string;
  //
  attachments?: string;
  //
  avatar?: string;
  //
  category_name?: string;
  //The channel this message belongs to.
  channel_id: string;
  //The name of the chat room, or an empty string if this message was not sent through a chat room.
  channel_label: string;
  //The clan this message belong to.
  clan_id?: string;
  //
  clan_logo?: string;
  //
  clan_nick?: string;
  //
  clan_avatar?: string;
  //The code representing a message type or category.
  code: number;
  //The content payload.
  content: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  create_time_seconds?: number;
  //
  display_name?: string;
  //
  mentions?: string;
  //The unique ID of this message.
  message_id: string;
  //
  reactions?: string;
  //
  referenced_message?: string;
  //
  references?: string;
  //Message sender, usually a user ID.
  sender_id: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  //
  update_time_seconds?: number;
  //The username of the message sender, if any.
  username?: string;
  // channel mode
  mode?: number;
  // hide editted
  hide_editted?: boolean;
}

/**  */
export interface ApiChannelMessageHeader {
  //
  attachment?: string;
  //
  content?: string;
  //
  id?: string;
  //
  mention?: string;
  //
  reaction?: string;
  //
  referece?: string;
  //
  sender_id?: string;
  //
  timestamp_seconds?: number;
}

/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  //
  last_seen_message?: ApiChannelMessageHeader;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //A list of messages.
  messages?: Array<ApiChannelMessage>;
}

/**  */
export interface ApiChannelSettingItem {
  //
  active?: number;
  //
  category_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  channel_type?: number;
  //
  creator_id?: string;
  //
  id?: string;
  //
  last_sent_message?: ApiChannelMessageHeader;
  //
  meeting_code?: string;
  //
  message_count?: string;
  //
  parent_id?: string;
  //
  user_ids?: Array<string>;
}

/**  */
export interface ApiChannelSettingListResponse {
  //
  channel_count?: number;
  //
  channel_setting_list?: Array<ApiChannelSettingItem>;
  //
  clan_id?: string;
  //
  thread_count?: number;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiChannelUserList {
  //
  channel_id?: string;
  //User-role pairs for a channel.
  channel_users?: Array<ChannelUserListChannelUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiCheckDuplicateClanNameResponse {
  //
  is_duplicate?: boolean;
}

/**  */
export interface ApiClanDesc {
  //
  banner?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
  //
  status?: number;
  //
  badge_count?: number;
}

/**  */
export interface ApiClanDescList {
  //A list of channel.
  clandesc?: Array<ApiClanDesc>;
}

/**  */
export interface ApiClanDescProfile {
  //
  avatar_url?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  nick_name?: string;
  //
  profile_banner?: string;
  //
  profile_theme?: string;
}

/**  */
export interface ApiClanEmoji {
  //
  category?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  shortname?: string;
  //
  src?: string;
}

/**  */
export interface ApiClanEmojiCreateRequest {
  //
  category?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/** Get clan profile. */
export interface ApiClanProfile {
  //
  avatar?: string;
  //
  clan_id?: string;
  //
  nick_name?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiClanSticker {
  //
  category?: string;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/**  */
export interface ApiClanStickerAddRequest {
  //
  category?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  shortname?: string;
  //
  source?: string;
}

/** A list of users belonging to a clan, along with their role. */
export interface ApiClanUserList {
  //
  clan_id?: string;
  //User-role pairs for a clan.
  clan_users?: Array<ClanUserListClanUser>;
  //Cursor for the next page of results, if any.
  cursor?: string;
}

/**  */
export interface ApiCreateCategoryDescRequest {
  //
  category_name?: string;
  //
  clan_id?: string;
}

/** Create a channel within clan. */
export interface ApiCreateChannelDescRequest {
  //
  app_url?: string;
  //
  category_id?: string;
  //The channel this message belongs to.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //The parrent channel this message belongs to.
  parrent_id?: string;
  //The channel type.
  type?: number;
  //The users to add.
  user_ids?: Array<string>;
}

/**  */
export interface ApiCreateClanDescRequest {
  //
  banner?: string;
  //
  clan_name?: string;
  //
  creator_id?: string;
  //
  logo?: string;
}

/** Create a event within clan. */
export interface ApiCreateEventRequest {
  //
  address?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
}

/** Create a event within clan. */
export interface ApiUpdateEventRequest {
  //
  address?: string;
  //
  channel_id?: string;
  //
  event_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  logo?: string;
  //
  start_time?: string;
  //
  title?: string;
  //
  clan_id?: string;
}

/** Create a role within clan. */
export interface ApiCreateRoleRequest {
  //The permissions to add.
  active_permission_ids?: Array<string>;
  //The users to add.
  add_user_ids?: Array<string>;
  //
  allow_mention?: number;
  //
  clan_id?: string;
  //
  color?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  max_permission_id: string;
  //
  role_icon?: string;
  //
  title?: string;
}

/** Delete a channel the user has access to. */
export interface ApiDeleteChannelDescRequest {
  //The id of a channel.
  channel_id?: string;
}

/**  */
export interface ApiDeleteEventRequest {
  //
  clan_id?: string;
  //The id of a event.
  event_id?: string;
}

/** Delete a role the user has access to. */
export interface ApiDeleteRoleRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //The id of a role.
  role_id?: string;
}

/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The version hash of the object.
  version?: string;
}

/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface ApiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/**  */
export interface ApiRegisterStreamingChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiRegisterStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  streaming_url?: string;
}

/**  */
export interface ApiListStreamingChannelsResponse {
  //
  streaming_channels?: Array<ApiStreamingChannelResponse>;
}

export interface ApiEmojiListedResponse {
  //
  emoji_list?: Array<ApiClanEmoji>;
}

/**  */
export interface ApiEventList {
  //A list of event.
  events?: Array<ApiEventManagement>;
}

/**  */
export interface ApiEventManagement {
  //
  active?: number;
  //
  address?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  end_time?: string;
  //
  id?: string;
  //
  logo?: string;
  //
  max_permission?: number;
  //
  start_event?: number;
  //
  start_time?: string;
  //
  title?: string;
  //
  user_ids?: Array<string>;
  //
  create_time?: string;
}

/**  */
export interface ApiListFavoriteChannelResponse {
  //
  channel_ids?: Array<string>;
}

/**  */
export interface ApiFilterParam {
  //
  field_name?: string;
  //
  field_value?: string;
}

/** A friend of a user. */
export interface ApiFriend {
  //The friend status.  one of "Friend.State".
  state?: number;
  //Time of the latest relationship update.
  update_time?: string;
  //The user object.
  user?: ApiUser;
}

/** A collection of zero or more friends of the user. */
export interface ApiFriendList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //The Friend objects.
  friends?: Array<ApiFriend>;
}

/**  */
export interface ApiGiveCoffeeEvent {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_ref_id?: string;
  //
  receiver_id?: string;
  //
  sender_id?: string;
  //
  token_count?: number;
}

/**  */
export interface ApiHashtagDm {
  //The channel id.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_private?: number;
  //
  clan_id?: string;
  //
  clan_name?: string;
  //
  meeting_code?: string;
  //
  parrent_id?: string;
  //
  type?: number;
}

/**  */
export interface ApiHashtagDmList {
  //
  hashtag_dm?: Array<ApiHashtagDm>;
}

/** Add link invite users to. */
export interface ApiInviteUserRes {
  //id channel to add link to.
  channel_id?: string;
  //
  channel_label?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  clan_name?: string;
  //
  user_joined?: boolean;
  //
  expiry_time?: string;
}

/** Add link invite users to. */
export interface ApiLinkInviteUser {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  create_time?: string;
  //The user to add.
  creator_id?: string;
  //
  expiry_time?: string;
  //
  id?: string;
  //
  invite_link?: string;
}

/** Add link invite users to. */
export interface ApiLinkInviteUserRequest {
  //id channel to add link to.
  channel_id?: string;
  //id clan to add link to .
  clan_id?: string;
  //
  expiry_time?: number;
}

/** Link Steam to the current user's account. */
export interface ApiLinkSteamRequest {
  //The Facebook account details.
  account?: ApiAccountSteam;
  //Import Steam friends for the user.
  sync?: boolean;
}

export interface ApiNotifiReactMessage {
  //
  channel_id?: string;
  //
  id?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiMessageAttachment {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  url?: string;
  //
  width?: number;
  /** The channel this message belongs to. */
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  /** The message that user react */
  message_id?: string;
  /** Message sender, usually a user ID. */
  sender_id?: string;
}

/**  */
export interface ApiMessageDeleted {
  //
  deletor?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiMarkAsReadRequest {
  //
  category_id?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiMessageMention {
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  id?: string;
  //
  user_id?: string;
  //
  username?: string;
  // role id
  role_id?: string;
  // role name
  rolename?: string;
  // start position
  s?: number;
  // end position
  e?: number;
  /** The channel this message belongs to. */
  channel_id?: string;
  // The mode
  mode?: number;
  // The channel label
  channel_label?: string;
  /** The message that user react */
  message_id?: string;
  /** Message sender, usually a user ID. */
  sender_id?: string;
}

/**  */
export interface ApiMessageReaction {
  //
  action?: boolean;
  //
  emoji_id: string;
  //
  emoji: string;
  //
  id?: string;
  //
  sender_id?: string;
  //
  sender_name?: string;
  //
  sender_avatar?: string;
  // count of emoji
  count: number;
  /** The channel this message belongs to. */
  channel_id: string;
  // The mode
  mode: number;
  // Is public
  is_public: boolean;
  // The channel label
  channel_label: string;
  /** The message that user react */
  message_id: string;
}

export interface ApiListChannelAppsResponse {
  //
  channel_apps?: Array<ApiChannelAppResponse>;
}

/**  */
export interface ApiListStreamingChannelsResponse {
  //
  streaming_channels?: Array<ApiStreamingChannelResponse>;
}

/**  */
export interface ApiMessageRef {
  //
  message_id?: string;
  //
  message_ref_id?: string;
  //
  ref_type?: number;
  //
  message_sender_id?: string;
  // original message sendre username
  message_sender_username?: string;
  // original message sender avatar
  mesages_sender_avatar?: string;
  // original sender clan nick name
  message_sender_clan_nick?: string;
  // original sender display name
  message_sender_display_name?: string;
  //
  content?: string;
  //
  has_attachment: boolean;
  /** The channel this message belongs to. */
  channel_id: string;
  // The mode
  mode: number;
  // The channel label
  channel_label: string;
}

/** A notification in the server. */
export interface ApiNotification {
  //
  avatar_url?: string;
  //
  channel_id?: string;
  //
  channel_type?: string;
  //
  clan_id?: string;
  //Category code for this notification.
  code?: number;
  //Content of the notification in JSON.
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
  create_time?: string;
  //ID of the Notification.
  id?: string;
  //True if this notification was persisted to the database.
  persistent?: boolean;
  //ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  //Subject of the notification.
  subject?: string;
}

/**  */
export interface ApiNotificationChannel {
  //
  channel_id?: string;
}

/**  */
export interface ApiNotificationChannelCategorySetting {
  //
  action?: number;
  //
  channel_category_label?: string;
  //
  channel_category_title?: string;
  //
  id?: string;
  //
  notification_setting_type?: number;
}

/**  */
export interface ApiNotificationChannelCategorySettingList {
  //
  notification_channel_category_settings_list?: Array<ApiNotificationChannelCategorySetting>;
}

/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  //Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  //Collection of notifications.
  notifications?: Array<ApiNotification>;
}

/**  */
export interface ApiNotificationSetting {
  //
  id?: string;
  //
  notification_setting_type?: number;
}

/**  */
export interface ApiNotificationUserChannel {
  //
  active?: number;
  //
  id?: string;
  //
  notification_setting_type?: number;
  //
  time_mute?: string;
}

/**  */
export interface ApiOssrsHttpCallbackRequest {
  //
  action?: string;
  //
  app?: string;
  //
  client_id?: string;
  //
  ip?: string;
  //
  page_url?: string;
  //
  param?: string;
  //
  server_id?: string;
  //
  service_id?: string;
  //
  stream?: string;
  //
  stream_id?: string;
  //
  stream_url?: string;
  //
  tc_url?: string;
  //
  vhost?: string;
}

/**  */
export interface ApiOssrsHttpCallbackResponse {
  //
  code?: number;
  //
  msg?: string;
}
/**  */
export interface ApiPermission {
  //
  active?: number;
  //
  description?: string;
  //
  id?: string;
  //
  level?: number;
  //
  scope?: number;
  //
  slug?: string;
  //
  title?: string;
}

/** A list of permission description, usually a result of a list operation. */
export interface ApiPermissionList {
  //
  max_level_permission?: number;
  //A list of permission.
  permissions?: Array<ApiPermission>;
}

/**  */
export interface ApiPermissionRoleChannel {
  //
  active?: boolean;
  //
  permission_id?: string;
}

/**  */
export interface ApiPermissionRoleChannelListEventResponse {
  //
  channel_id?: string;
  //
  permission_role_channel?: Array<ApiPermissionRoleChannel>;
  //
  role_id?: string;
  //
  user_id?: string;
}

/**  */
export interface ApiPermissionUpdate {
  //
  permission_id?: string;
  //
  slug?: string;
  //
  type?: number;
}

/**  */
export interface ApiPinMessage {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  content?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  //
  create_time_seconds?: number;
  //
  id?: string;
  //
  message_id?: string;
  //
  sender_id?: string;
  //
  username?: string;
}

/**  */
export interface ApiPinMessageRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  message_id?: string;
}

/**  */
export interface ApiPinMessagesList {
  //
  pin_messages_list?: Array<ApiPinMessage>;
}

/**  */
export interface ApiRegistFcmDeviceTokenResponse {
  //
  device_id?: string;
  //
  platform?: string;
  //
  token?: string;
}

/**  */
export interface ApiRegisterStreamingChannelRequest {
  //
  channel_id?: string;
  //
  clan_id?: string;
}

/**  */
export interface ApiRegisterStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  streaming_url?: string;
}


/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  //The collection which stores the object.
  collection?: string;
  //The key of the object within the collection.
  key?: string;
  //The user owner of the object.
  user_id?: string;
}

/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  //Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}

/**  */
export interface ApiRegistrationEmailRequest {
  //
  avatar_url?: string;
  //
  display_name?: string;
  //
  dob?: string;
  //A valid RFC-5322 email address.
  email?: string;
  //A password for the user account.
  password?: string;
  //Set the username on the account at register. Must be unique.
  username?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiRole {
  //
  active?: number;
  //
  allow_mention?: number;
  //
  channel_ids?: Array<string>;
  //
  clan_id?: string;
  //
  color?: string;
  //
  creator_id?: string;
  //
  description?: string;
  //
  display_online?: number;
  //
  id?: string;
  //
  max_level_permission?: number;
  //
  permission_list?: ApiPermissionList;
  //
  role_channel_active?: number;
  //
  role_icon?: string;
  //
  role_user_list?: ApiRoleUserList;
  //
  slug?: string;
  //
  title?: string;
}

/** A list of role description, usually a result of a list operation. */
export interface ApiRoleList {
  //Cacheable cursor to list newer role description. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  //The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  //The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  //A list of role.
  roles?: Array<ApiRole>;
}

/**  */
export interface ApiRoleListEventResponse {
  //
  clan_id?: string;
  //
  cursor?: string;
  //
  limit?: string;
  //
  roles?: ApiRoleList;
  //
  state?: string;
}

/**  */
export interface ApiRoleUserList {
  //Cursor for the next page of results, if any.
  cursor?: string;
  //role_users pairs for a clan.
  role_users?: Array<RoleUserListRoleUser>;
}

/** Execute an Lua function on the server. */
export interface ApiRpc {
  //The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  //The identifier of the function.
  id?: string;
  //The payload of the function which must be a JSON object.
  payload?: string;
}

/**  */
export interface ApiSearchMessageDocument {
  //
  attachment?: string;
  //
  avatar_url?: string;
  //The channel ID.
  channel_id?: string;
  //
  channel_label?: string;
  //
  channel_type?: number;
  //The clan ID.
  clan_id?: string;
  //
  clan_name?: string;
  //
  content?: string;
  //
  create_time?: string;
  //
  display_name?: string;
  //
  mention?: string;
  //The message ID.
  message_id?: string;
  //
  reaction?: string;
  //
  reference?: string;
  //The user ID of sender.
  sender_id?: string;
  //
  update_time?: string;
  //
  username?: string;
}

/**  */
export interface ApiSearchMessageRequest {
  //
  filters?: Array<ApiFilterParam>;
  //
  from?: number;
  //
  size?: number;
  //
  sorts?: Array<ApiSortParam>;
}

/**  */
export interface ApiSearchMessageResponse {
  //List of paged messages.
  messages?: Array<ApiSearchMessageDocument>;
  //The total number of messages.
  total?: number;
}

/** A user's session used to authenticate messages. */
export interface ApiSession {
  //True if the corresponding account was just created, false otherwise.
  created?: boolean;
  //Refresh token that can be used for session token renewal.
  refresh_token?: string;
  //Authentication credentials.
  token?: string;
}

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface ApiSessionLogoutRequest {
  //Refresh token to invalidate.
  refresh_token?: string;
  //Session token to log out.
  token?: string;
}

/** Authenticate against the server with a refresh token. */
export interface ApiSessionRefreshRequest {
  //Refresh token.
  token?: string;
  //Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/**  */
export interface ApiSetDefaultNotificationRequest {
  //
  category_id?: string;
  //
  clan_id?: string;
  //
  notification_type?: number;
}

/**  */
export interface ApiSetMuteNotificationRequest {
  //
  active?: number;
  //
  id?: string;
  //
  notification_type?: number;
}

/**  */
export interface ApiSetNotificationRequest {
  //
  channel_category_id?: string;
  //
  notification_type?: number;
  //
  time_mute?: string;
}

/**  */
export interface ApiSortParam {
  //
  field_name?: string;
  //
  order?: string;
}

/**  */
export interface ApiStickerListedResponse {
  //
  stickers?: Array<ApiClanSticker>;
}

/**  */
export interface ApiStreamingChannelResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  is_streaming?: boolean;
  //
  streaming_url?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiStreamingChannelUser {
  //
  channel_id?: string;
  //
  id?: string;
  //
  participant?: string;
  //user for a channel.
  user_id?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiStreamingChannelUserList {
  //
  streaming_channel_users?: Array<ApiStreamingChannelUser>;
}

/** System message details. */
export interface ApiSystemMessage {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  id?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/** Request to get system message by clan and channel IDs. */
export interface ApiSystemMessageRequest {
  //
  boost_message?: string;
  //
  channel_id?: string;
  //
  clan_id?: string;
  //
  setup_tips?: string;
  //
  welcome_random?: string;
  //
  welcome_sticker?: string;
}

/** List of system message. */
export interface ApiSystemMessagesList {
  //
  system_messages_list?: Array<ApiSystemMessage>;
}

/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  //
  about_me?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //The display name of the user.
  display_name?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //The timezone set by the user.
  timezone?: string;
  //The username of the user's account.
  username?: string;
}

/**  */
export interface ApiUpdateCategoryDescRequest {
  //The ID of the group to update.
  category_id?: string;
  //
  category_name?: string;
  // clan ID
  ClanId: string;
}
/**  */
export interface ApiUpdateCategoryOrderRequest {
  //
  categories?: Array<ApiCategoryOrderUpdate>;
  //
  clan_id?: string;
}

/**  */
export interface ApiUpdateRoleChannelRequest {
  //
  channel_id: string;
  //
  max_permission_id: string;
  //The permissions to add.
  permission_update?: Array<ApiPermissionUpdate>;
  //The ID of the role to update.
  role_id?: string;
  //
  user_id?: string;
}

/** Fetch a batch of zero or more users from the server. */
export interface ApiUpdateUsersRequest {
  //The avarar_url of a user.
  avatar_url?: string;
  //The account username of a user.
  display_name?: string;
}

/**  */
export interface ApiUploadAttachment {
  //
  filename?: string;
  //
  url?: string;
}

/**  */
export interface ApiUploadAttachmentRequest {
  //
  filename?: string;
  //
  filetype?: string;
  //
  height?: number;
  //
  size?: number;
  //
  width?: number;
}

/** A user in the server. */
export interface ApiUser {
  //
  about_me?: string;
  //The Apple Sign In ID in the user's account.
  apple_id?: string;
  //A URL for an avatar image.
  avatar_url?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created.
  create_time?: string;
  //The display name of the user.
  display_name?: string;
  //Number of related edges to this user.
  edge_count?: number;
  //The Facebook id in the user's account.
  facebook_id?: string;
  //The Apple Game Center in of the user's account.
  gamecenter_id?: string;
  //The Google id in the user's account.
  google_id?: string;
  //The id of the user's account.
  id?: string;
  //
  join_time?: string;
  //The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  //The location set by the user.
  location?: string;
  //Additional information stored as a JSON object.
  metadata?: string;
  //Indicates whether the user is currently online.
  online?: boolean;
  //The Steam id in the user's account.
  steam_id?: string;
  //The timezone set by the user.
  timezone?: string;
  //The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated.
  update_time?: string;
  //The username of the user's account.
  username?: string;
}

/**  */
export interface ApiUserPermissionInChannelListResponse {
  //
  channel_id?: string;
  //
  clan_id?: string;
  //A list of permission.
  permissions?: ApiPermissionList;
}

/** A collection of zero or more users. */
export interface ApiUsers {
  //The User objects.
  users?: Array<ApiUser>;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiVoiceChannelUser {
  //Cursor for the next page of results, if any.
  id?: string;
  //
  channel_id?: string;
  //
  participant?: string;
  //User for a channel.
  user_id?: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface ApiVoiceChannelUserList {
  //
  voice_channel_users?: Array<ApiVoiceChannelUser>;
}

/**  */
export interface ApiWebhook {
  //
  active?: number;
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  create_time?: string;
  //
  creator_id?: string;
  //
  id?: string;
  //
  update_time?: string;
  //
  url?: string;
  //
  webhook_name?: string;
}

/**  */
export interface ApiWebhookCreateRequest {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  webhook_name?: string;
}

/**  */
export interface ApiWebhookGenerateResponse {
  //
  avatar?: string;
  //
  channel_id?: string;
  //
  hook_name?: string;
  //
  url?: string;
}

/**  */
export interface ApiWebhookListResponse {
  //
  webhooks?: Array<ApiWebhook>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface MezonapiEvent {
  //True if the event came directly from a client call, false otherwise.
  external?: boolean;
  //An event name, type, category, or identifier.
  name?: string;
  //Arbitrary event property values.
  properties?: Record<string, string>;
  //The time when the event was triggered.
  timestamp?: string;
}

/**  */
export interface ProtobufAny {
  //
  type_url?: string;
  //
  value?: string;
}

/**  */
export interface RpcStatus {
  //
  code?: number;
  //
  details?: Array<ProtobufAny>;
  //
  message?: string;
}

export class MezonApi {
  constructor(
    readonly serverKey: string,
    readonly basePath: string,
    readonly timeoutMs: number
  ) {}

  /** A healthcheck which load balancers can use to check the service. */
  healthcheck(bearerToken: string, options: any = {}): Promise<any> {
    const urlPath = "/healthcheck";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete the current user's account. */
  deleteAccount(bearerToken: string, options: any = {}): Promise<any> {
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Fetch the current user's account. */
  getAccount(bearerToken: string, options: any = {}): Promise<ApiAccount> {
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in the current user's account. */
  updateAccount(
    bearerToken: string,
    body: ApiUpdateAccountRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with an Apple ID against the server. */
  authenticateApple(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountApple,
    create?: boolean,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/apple";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with a custom id against the server. */
  authenticateCustom(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountCustom,
    create?: boolean,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/custom";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with a device id against the server. */
  authenticateDevice(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountDevice,
    create?: boolean,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/device";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with an email+password against the server. */
  authenticateEmail(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountEmail,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/email";
    const queryParams = new Map<string, any>();
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with a Facebook OAuth token against the server. */
  authenticateFacebook(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountFacebook,
    create?: boolean,
    username?: string,
    sync?: boolean,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("sync", sync);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with a Facebook Instant Game token against the server. */
  authenticateFacebookInstantGame(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountFacebookInstantGame,
    create?: boolean,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/facebookinstantgame";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with Apple's GameCenter against the server. */
  authenticateGameCenter(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountGameCenter,
    create?: boolean,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/gamecenter";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with Google against the server. */
  authenticateGoogle(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountGoogle,
    create?: boolean,
    username?: string,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/google";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with Steam against the server. */
  authenticateSteam(
    basicAuthUsername: string,
    basicAuthPassword: string,
    account: ApiAccountSteam,
    create?: boolean,
    username?: string,
    sync?: boolean,
    options: any = {}
  ): Promise<ApiSession> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/authenticate/steam";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("sync", sync);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add an Apple ID to the social profiles on the current user's account. */
  linkApple(
    bearerToken: string,
    body: ApiAccountApple,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/apple";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a custom ID to the social profiles on the current user's account. */
  linkCustom(
    bearerToken: string,
    body: ApiAccountCustom,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/custom";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a device ID to the social profiles on the current user's account. */
  linkDevice(
    bearerToken: string,
    body: ApiAccountDevice,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/device";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add an email+password to the social profiles on the current user's account. */
  linkEmail(
    bearerToken: string,
    body: ApiAccountEmail,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/email";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add Facebook to the social profiles on the current user's account. */
  linkFacebook(
    bearerToken: string,
    account: ApiAccountFacebook,
    sync?: boolean,
    options: any = {}
  ): Promise<any> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("sync", sync);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add Facebook Instant Game to the social profiles on the current user's account. */
  linkFacebookInstantGame(
    bearerToken: string,
    body: ApiAccountFacebookInstantGame,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/facebookinstantgame";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add Apple's GameCenter to the social profiles on the current user's account. */
  linkGameCenter(
    bearerToken: string,
    body: ApiAccountGameCenter,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/gamecenter";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add Google to the social profiles on the current user's account. */
  linkGoogle(
    bearerToken: string,
    body: ApiAccountGoogle,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/google";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add Steam to the social profiles on the current user's account. */
  linkSteam(
    bearerToken: string,
    body: ApiLinkSteamRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/link/steam";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate a user with an email+password against the server. */
  registrationEmail(
    bearerToken: string,
    body: ApiRegistrationEmailRequest,
    options: any = {}
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/registry";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  sessionRefresh(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiSessionRefreshRequest,
    options: any = {}
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/session/refresh";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove the Apple ID from the social profiles on the current user's account. */
  unlinkApple(
    bearerToken: string,
    body: ApiAccountApple,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/apple";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove the custom ID from the social profiles on the current user's account. */
  unlinkCustom(
    bearerToken: string,
    body: ApiAccountCustom,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/custom";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove the device ID from the social profiles on the current user's account. */
  unlinkDevice(
    bearerToken: string,
    body: ApiAccountDevice,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/device";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove the email+password from the social profiles on the current user's account. */
  unlinkEmail(
    bearerToken: string,
    body: ApiAccountEmail,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/email";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove Facebook from the social profiles on the current user's account. */
  unlinkFacebook(
    bearerToken: string,
    body: ApiAccountFacebook,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/facebook";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove Facebook Instant Game profile from the social profiles on the current user's account. */
  unlinkFacebookInstantGame(
    bearerToken: string,
    body: ApiAccountFacebookInstantGame,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/facebookinstantgame";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove Apple's GameCenter from the social profiles on the current user's account. */
  unlinkGameCenter(
    bearerToken: string,
    body: ApiAccountGameCenter,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/gamecenter";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove Google from the social profiles on the current user's account. */
  unlinkGoogle(
    bearerToken: string,
    body: ApiAccountGoogle,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/google";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Remove Steam from the social profiles on the current user's account. */
  unlinkSteam(
    bearerToken: string,
    body: ApiAccountSteam,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/account/unlink/steam";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a new apps. */
  addApp(
    bearerToken: string,
    body: ApiAddAppRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/apps/add";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List (and optionally filter) accounts. */
  listApps(
    bearerToken: string,
    filter?: string,
    tombstones?: boolean,
    cursor?: string,
    options: any = {}
  ): Promise<ApiAppList> {
    const urlPath = "/v2/apps/app";
    const queryParams = new Map<string, any>();
    queryParams.set("filter", filter);
    queryParams.set("tombstones", tombstones);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add an app to clan. */
  addAppToClan(
    bearerToken: string,
    appId: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (appId === null || appId === undefined) {
      throw new Error(
        "'appId' is a required parameter but is null or undefined."
      );
    }
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/apps/app/{appId}/clan/{clanId}"
      .replace("{appId}", encodeURIComponent(String(appId)))
      .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete all information stored for an app. */
  deleteApp(
    bearerToken: string,
    id: string,
    recordDeletion?: boolean,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("record_deletion", recordDeletion);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get detailed app information. */
  getApp(bearerToken: string, id: string, options: any = {}): Promise<ApiApp> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update one or more fields on a app. */
  updateApp(
    bearerToken: string,
    id: string,
    body: MezonUpdateAppBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/apps/app/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Ban a app. */
  banApp(bearerToken: string, id: string, options: any = {}): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}/ban".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Unban an app. */
  unbanApp(bearerToken: string, id: string, options: any = {}): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/app/{id}/unban".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  updateCategoryOrder(bearerToken: string,
      body:ApiUpdateCategoryOrderRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/category/orders";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  listCategoryDescs(
    bearerToken: string,
    clanId: string,
    creatorId?: string,
    categoryName?: string,
    categoryId?: string,
    categoryOrder?: number,
    options: any = {}
  ): Promise<ApiCategoryDescList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/categorydesc/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("creator_id", creatorId);
    queryParams.set("category_name", categoryName);
    queryParams.set("category_id", categoryId);
    queryParams.set("category_order", categoryOrder);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List channel apps. */
  listChannelApps(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiListChannelAppsResponse> {
    const urlPath = "/v2/channel-apps";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  addChannelFavorite(bearerToken: string,
      body:ApiAddFavoriteChannelRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel/favorite";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  removeChannelFavorite(bearerToken: string,
      channelId:string,
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel/favorite/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /**  */
  getListFavoriteChannel(bearerToken: string,
      clanId:string,
      options: any = {}): Promise<ApiListFavoriteChannelResponse> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel/favorite/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List a channel's message history. */
  listChannelMessages(
    bearerToken: string,
    clanId: string,
    channelId: string,
    messageId?: string,
    direction?: number,
    limit?: number,
    options: any = {}
  ): Promise<ApiChannelMessageList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("message_id", messageId);
    queryParams.set("limit", limit);
    queryParams.set("direction", direction);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  addChannelUsers(
    bearerToken: string,
    channelId: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/add".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all attachment that are part of a channel. */
  listChannelAttachment(
    bearerToken: string,
    channelId: string,
    clanId?: string,
    fileType?: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiChannelAttachmentList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/attachment".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("file_type", fileType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Leave a channel the user is a member of. */
  leaveThread(bearerToken: string,
      channelId:string,
      options: any = {}): Promise<any> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/leave".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Kick a set of users from a channel. */
  removeChannelUsers(
    bearerToken: string,
    channelId: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/remove".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listChannelUsers(
    bearerToken: string,
    clanId: string,
    channelId: string,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiChannelUserList> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel/{channelId}/user".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_type", channelType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List user channels */
  listChannelDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    clanId?: string,
    channelType?: number,
    options: any = {}
  ): Promise<ApiChannelDescList> {
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_type", channelType);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a new channel with the current user as the owner. */
  createChannelDesc(
    bearerToken: string,
    body: ApiCreateChannelDescRequest,
    options: any = {}
  ): Promise<ApiChannelDescription> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** list user add channel by channel ids */
  listUsersAddChannelByChannelId(
    bearerToken: string,
    channelId?: string,
    limit?: number,
    options: any = {}
  ): Promise<ApiAllUsersAddChannelResponse> {
    const urlPath = "/v2/channeldesc/users/add";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);
    queryParams.set("limit", limit);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a channel by ID. */
  deleteChannelDesc(
    bearerToken: string,
    channelId: string,
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channeldesc/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given channel. */
  updateChannelDesc(
    bearerToken: string,
    channelId: string,
    body: {},
    options: any = {}
  ): Promise<any> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channeldesc/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List channel setting */
  listChannelSetting(bearerToken: string,
      clanId:string,
      parentId?:string,
      categoryId?:string,
      privateChannel?:number,
      active?:number,
      status?:number,
      type?:number,
      limit?:number,
      page?:number,
      options: any = {}): Promise<ApiChannelSettingListResponse> {
    
    if (clanId === null || clanId === undefined) {
      throw new Error("'clanId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channelsetting/{clanId}"
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();
    queryParams.set("parent_id", parentId);
    queryParams.set("category_id", categoryId);
    queryParams.set("private_channel", privateChannel);
    queryParams.set("active", active);
    queryParams.set("status", status);
    queryParams.set("type", type);
    queryParams.set("limit", limit);
    queryParams.set("page", page);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all users that are part of a channel. */
  listChannelVoiceUsers(
    bearerToken: string,
    clanId?: string,
    channelId?: string,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiVoiceChannelUserList> {
    const urlPath = "/v2/channelvoice";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);
    queryParams.set("channel_type", channelType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List clans */
  listClanDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiClanDescList> {
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a clan */
  createClanDesc(
    bearerToken: string,
    body: ApiCreateClanDescRequest,
    options: any = {}
  ): Promise<ApiClanDesc> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a clan desc by ID. */
  deleteClanDesc(
    bearerToken: string,
    clanDescId: string,
    options: any = {}
  ): Promise<any> {
    if (clanDescId === null || clanDescId === undefined) {
      throw new Error(
        "'clanDescId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanDescId}".replace(
      "{clanDescId}",
      encodeURIComponent(String(clanDescId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given clan. */
  updateClanDesc(
    bearerToken: string,
    clanId: string,
    body: {},
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Kick a set of users from a clan. */
  removeClanUsers(
    bearerToken: string,
    clanId: string,
    userIds?: Array<string>,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanId}/kick".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a clan. */
  listClanUsers(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiClanUserList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanId}/user".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** check duplicate clan name */
  checkDuplicateClanName(
    bearerToken: string,
    clanName: string,
    options: any = {}
  ): Promise<ApiCheckDuplicateClanNameResponse> {
    if (clanName === null || clanName === undefined) {
      throw new Error(
        "'clanName' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandesc/{clanName}".replace(
      "{clanName}",
      encodeURIComponent(String(clanName))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get a clan desc profile */
  getClanDescProfile(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiClanDescProfile> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandescprofile/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given clan profile. */
  updateClanDescProfile(
    bearerToken: string,
    clanId: string,
    body: {},
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/clandescprofile/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  createCategoryDesc(
    bearerToken: string,
    body: ApiCreateCategoryDescRequest,
    options: any = {}
  ): Promise<ApiCategoryDesc> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/createcategory";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteCategoryDesc(
    bearerToken: string,
    categoryId: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (categoryId === null || categoryId === undefined) {
      throw new Error(
        "'categoryId' is a required parameter but is null or undefined."
      );
    }
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath =
      "/v2/deletecategory/category_id/{categoryId}/clan_id/{clanId}"
        .replace("{categoryId}", encodeURIComponent(String(categoryId)))
        .replace("{clanId}", encodeURIComponent(String(clanId)));
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteCategoryOrder(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/deletecategoryorder/clan_id/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** regist fcm device token */
  registFCMDeviceToken(bearerToken: string,
      token?:string,
      deviceId?:string,
      platform?:string,
      options: any = {}): Promise<ApiRegistFcmDeviceTokenResponse> {
    
    const urlPath = "/v2/devicetoken";
    const queryParams = new Map<string, any>();
    queryParams.set("token", token);
    queryParams.set("device_id", deviceId);
    queryParams.set("platform", platform);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** close direct message. */
  closeDirectMess(
    bearerToken: string,
    body: ApiDeleteChannelDescRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/direct/close";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** open direct message. */
  openDirectMess(
    bearerToken: string,
    body: ApiDeleteChannelDescRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/direct/open";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Post clan Emoji  /v2/emoji/create */
  createClanEmoji(
    bearerToken: string,
    body: ApiClanEmojiCreateRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/emoji/create";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a emoji by ID. */
  deleteClanEmojiById(
    bearerToken: string,
    id: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/emoji/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    const body = { clan_id: clanId };
    let bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update ClanEmoj By id */
  updateClanEmojiById(
    bearerToken: string,
    id: string,
    body: MezonUpdateClanEmojiByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/emoji/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get list emoji by user id */
  getListEmojisByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiEmojiListedResponse> {
    const urlPath = "/v2/emojis";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Search message from elasticsearch service. */
  searchMessage(
    bearerToken: string,
    body: ApiSearchMessageRequest,
    options: any = {}
  ): Promise<ApiSearchMessageResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/es/search";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Submit an event for processing in the server's registered runtime custom events handler. */
  event(bearerToken: string, body: ApiEvent, options: any = {}): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/event";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List user events */
  listEvents(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiEventList> {
    const urlPath = "/v2/eventmanagement";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a new event for clan. */
  createEvent(
    bearerToken: string,
    body: ApiCreateEventRequest,
    options: any = {}
  ): Promise<ApiEventManagement> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/create";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given event. */
  updateEventUser(
    bearerToken: string,
    body: ApiDeleteEventRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/user";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a event by ID. */
  deleteEvent(
    bearerToken: string,
    eventId: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    if (eventId === null || eventId === undefined) {
      throw new Error(
        "'eventId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/{eventId}".replace(
      "{eventId}",
      encodeURIComponent(String(eventId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given event. */
  updateEvent(
    bearerToken: string,
    eventId: string,
    body: MezonUpdateEventBody,
    options: any = {}
  ): Promise<any> {
    if (eventId === null || eventId === undefined) {
      throw new Error(
        "'eventId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/eventmanagement/{eventId}".replace(
      "{eventId}",
      encodeURIComponent(String(eventId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete one or more users by ID or username. */
  deleteFriends(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all friends for the current user. */
  listFriends(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiFriendList> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add friends by ID or username to a user's account. */
  addFriends(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Block one or more users by ID or username. */
  blockFriends(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend/block";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Import Facebook friends and add them to a user's account. */
  importFacebookFriends(
    bearerToken: string,
    account: ApiAccountFacebook,
    reset?: boolean,
    options: any = {}
  ): Promise<any> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/friend/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("reset", reset);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Import Steam friends and add them to a user's account. */
  importSteamFriends(
    bearerToken: string,
    account: ApiAccountSteam,
    reset?: boolean,
    options: any = {}
  ): Promise<any> {
    if (account === null || account === undefined) {
      throw new Error(
        "'account' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/friend/steam";
    const queryParams = new Map<string, any>();
    queryParams.set("reset", reset);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetChannelCategoryNotiSettingsList */
  getChannelCategoryNotiSettingsList(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiNotificationChannelCategorySettingList> {
    const urlPath = "/v2/getChannelCategoryNotiSettingsList";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getUserProfileOnClan(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiClanProfile> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/getclanprofile/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationChannel */
  getNotificationCategory(
    bearerToken: string,
    categoryId?: string,
    options: any = {}
  ): Promise<ApiNotificationUserChannel> {
    const urlPath = "/v2/getnotificationcategory";
    const queryParams = new Map<string, any>();
    queryParams.set("category_id", categoryId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationChannel */
  getNotificationChannel(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiNotificationUserChannel> {
    const urlPath = "/v2/getnotificationchannel";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationClan */
  getNotificationClan(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiNotificationSetting> {
    const urlPath = "/v2/getnotificationclan";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List GetNotificationReactMessage */
  getNotificationReactMessage(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiNotifiReactMessage> {
    const urlPath = "/v2/getnotificationreactmessage";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Give a coffee */
  giveMeACoffee(
    bearerToken: string,
    body: ApiGiveCoffeeEvent,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/givecoffee";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List HashtagDMList */
  hashtagDMList(
    bearerToken: string,
    userId?: Array<string>,
    limit?: number,
    options: any = {}
  ): Promise<ApiHashtagDmList> {
    const urlPath = "/v2/hashtagdmlist";
    const queryParams = new Map<string, any>();
    queryParams.set("user_id", userId);
    queryParams.set("limit", limit);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  createLinkInviteUser(
    bearerToken: string,
    body: ApiLinkInviteUserRequest,
    options: any = {}
  ): Promise<ApiLinkInviteUser> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/invite";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  getLinkInvite(
    bearerToken: string,
    inviteId: string,
    options: any = {}
  ): Promise<ApiInviteUserRes> {
    if (inviteId === null || inviteId === undefined) {
      throw new Error(
        "'inviteId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/invite/{inviteId}".replace(
      "{inviteId}",
      encodeURIComponent(String(inviteId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add users to a channel. */
  inviteUser(
    bearerToken: string,
    inviteId: string,
    options: any = {}
  ): Promise<ApiInviteUserRes> {
    if (inviteId === null || inviteId === undefined) {
      throw new Error(
        "'inviteId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/invite/{inviteId}".replace(
      "{inviteId}",
      encodeURIComponent(String(inviteId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List HashtagDMList */
  listChannelByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiChannelDescList> {
    const urlPath = "/v2/listchannelbyuserid";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Mark as read */
  markAsRead(bearerToken: string,
      body:ApiMarkAsReadRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/markasread";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** set mute notification user channel. */
  setMuteNotificationCategory(
    bearerToken: string,
    body: ApiSetMuteNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/mutenotificationcategory/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set mute notification user channel. */
  setMuteNotificationChannel(
    bearerToken: string,
    body: ApiSetMuteNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/mutenotificationchannel/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete one or more notifications for the current user. */
  deleteNotifications(
    bearerToken: string,
    ids?: Array<string>,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Fetch list of notifications. */
  listNotifications(
    bearerToken: string,
    clanId: string,
    limit?: number,
    cacheableCursor?: string,
    options: any = {}
  ): Promise<ApiNotificationList> {
    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("clan_id", clanId);
    queryParams.set("cacheable_cursor", cacheableCursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationChannelSetting(
    bearerToken: string,
    body: ApiSetNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notificationchannel/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationClanSetting(
    bearerToken: string,
    body: ApiSetDefaultNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notificationclan/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  setNotificationCategorySetting(
    bearerToken: string,
    body: ApiSetNotificationRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notificationucategory/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteNotificationCategorySetting(
    bearerToken: string,
    categoryId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notificationusercategory/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("category_id", categoryId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteNotificationChannel(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notificationuserchannel/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteNotiReactMessage(
    bearerToken: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/notifireactmessage/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  setNotificationReactMessage(
    bearerToken: string,
    body: ApiNotificationChannel,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/notifireactmessage/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Ossrs http callback. */
  streamingServerCallback(
    bearerToken: string,
    body: ApiOssrsHttpCallbackRequest,
    options: any = {}
  ): Promise<ApiOssrsHttpCallbackResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/ossrs/callback";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set permission role channel. */
  setRoleChannelPermission(
    bearerToken: string,
    body: ApiUpdateRoleChannelRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/permissionrolechannel/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get permission list */
  getListPermission(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiPermissionList> {
    const urlPath = "/v2/permissions";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** GetPermissionByRoleIdChannelId */
  getPermissionByRoleIdChannelId(
    bearerToken: string,
    roleId?: string,
    channelId?: string,
    userId?: string,
    options: any = {}
  ): Promise<ApiPermissionRoleChannelListEventResponse> {
    const urlPath = "/v2/permissions/roles/channels/users";
    const queryParams = new Map<string, any>();
    queryParams.set("role_id", roleId);
    queryParams.set("channel_id", channelId);
    queryParams.set("user_id", userId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deletePinMessage(
    bearerToken: string,
    messageId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/pinmessage/delete";
    const queryParams = new Map<string, any>();
    queryParams.set("message_id", messageId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getPinMessagesList(bearerToken: string,
      messageId?:string,
      channelId?:string,
      clanId?:string,
      options: any = {}): Promise<ApiPinMessagesList> {
    
    const urlPath = "/v2/pinmessage/get";
    const queryParams = new Map<string, any>();
    queryParams.set("message_id", messageId);
    queryParams.set("channel_id", channelId);
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** set notification user channel. */
  createPinMessage(
    bearerToken: string,
    body: ApiPinMessageRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/pinmessage/set";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  addRolesChannelDesc(
    bearerToken: string,
    body: ApiAddRoleChannelDescRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rolechannel/addrole";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** update the category of a channel */
  changeChannelCategory(
    bearerToken: string,
    newCategoryId: string,
    body: MezonChangeChannelCategoryBody,
    options: any = {}
  ): Promise<any> {
    if (newCategoryId === null || newCategoryId === undefined) {
      throw new Error(
        "'newCategoryId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rolechannel/category/{newCategoryId}".replace(
      "{newCategoryId}",
      encodeURIComponent(String(newCategoryId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a role when Delete a role by ID. */
  deleteRoleChannelDesc(
    bearerToken: string,
    body: ApiDeleteRoleRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rolechannel/delete";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** ListRoles */
  listRoles(
    bearerToken: string,
    clanId?: string,
    limit?: string,
    state?: string,
    cursor?: string,
    options: any = {}
  ): Promise<ApiRoleListEventResponse> {
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a new role for clan. */
  createRole(
    bearerToken: string,
    body: ApiCreateRoleRequest,
    options: any = {}
  ): Promise<ApiRole> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a role when Delete a role by ID. */
  updateRoleDelete(
    bearerToken: string,
    roleId: string,
    body: MezonUpdateRoleDeleteBody,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/delete/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a role by ID. */
  deleteRole(
    bearerToken: string,
    roleId: string,
    channelId?: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);
    queryParams.set("clan_id", clanId);
    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update fields in a given role. */
  updateRole(
    bearerToken: string,
    roleId: string,
    body: MezonUpdateRoleBody,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List role permissions */
  listRolePermissions(
    bearerToken: string,
    roleId: string,
    options: any = {}
  ): Promise<ApiPermissionList> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}/permissions".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List role permissions */
  listRoleUsers(
    bearerToken: string,
    roleId: string,
    limit?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiRoleUserList> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}/users".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getRoleOfUserInTheClan(
    bearerToken: string,
    clanId: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiRoleList> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roleuserinclan/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Execute a Lua function on the server. */
  rpcFunc2(
    bearerToken: string,
    basicAuthUsername: string,
    basicAuthPassword: string,
    id: string,
    payload?: string,
    httpKey?: string,
    options: any = {}
  ): Promise<ApiRpc> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/rpc/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("payload", payload);
    queryParams.set("http_key", httpKey);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Execute a Lua function on the server. */
  rpcFunc(
    bearerToken: string,
    basicAuthUsername: string,
    basicAuthPassword: string,
    id: string,
    payload: string,
    httpKey?: string,
    options: any = {}
  ): Promise<ApiRpc> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (payload === null || payload === undefined) {
      throw new Error(
        "'payload' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/rpc/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("http_key", httpKey);

    let bodyJson: string = "";
    bodyJson = JSON.stringify(payload || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  sessionLogout(
    bearerToken: string,
    body: ApiSessionLogoutRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/session/logout";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Add a new sticker */
  addClanSticker(
    bearerToken: string,
    body: ApiClanStickerAddRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sticker";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a sticker by ID */
  deleteClanStickerById(
    bearerToken: string,
    id: string,
    clanId?: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/sticker/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a sticker by ID */
  updateClanStickerById(
    bearerToken: string,
    id: string,
    body: MezonUpdateClanStickerByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sticker/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** get list sticker by user id */
  getListStickersByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiStickerListedResponse> {
    const urlPath = "/v2/stickers";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List streaming channels. */
  listStreamingChannels(
    bearerToken: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiListStreamingChannelsResponse> {
    const urlPath = "/v2/streaming-channels";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Register streaming in channel ( for bot - get streaming key) */
  registerStreamingChannel(
    bearerToken: string,
    body: ApiRegisterStreamingChannelRequest,
    options: any = {}
  ): Promise<ApiRegisterStreamingChannelResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/streaming-channels";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List all users that are part of a channel. */
  listStreamingChannelUsers(
    bearerToken: string,
    clanId?: string,
    channelId?: string,
    channelType?: number,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<ApiStreamingChannelUserList> {
    const urlPath = "/v2/streaming-channels/users";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);
    queryParams.set("channel_type", channelType);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get the list of system messages. */
  getSystemMessagesList(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiSystemMessagesList> {
    const urlPath = "/v2/systemmessages";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Create a system messages. */
  createSystemMessage(
    bearerToken: string,
    body: ApiSystemMessageRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Delete a specific system messages. */
  deleteSystemMessage(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Get details of a specific system messages. */
  getSystemMessageByClanId(
    bearerToken: string,
    clanId: string,
    options: any = {}
  ): Promise<ApiSystemMessage> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update a system messages. */
  updateSystemMessage(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateSystemMessageBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/systemmessages/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** List user channels */
  listThreadDescs(bearerToken: string,
      channelId:string,
      limit?:number,
      state?:number,
      clanId?:string,
      threadId?:string,
      options: any = {}): Promise<ApiChannelDescList> {
    
    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/thread/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("clan_id", clanId);
    queryParams.set("thread_id", threadId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given category. */
  updateCategory(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateCategoryBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/updatecategory/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Update channel private. */
  updateChannelPrivate(
    bearerToken: string,
    body: ApiChangeChannelPrivateRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/updatechannelprivate";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  updateUserProfileByClan(
    bearerToken: string,
    clanId: string,
    body: MezonUpdateUserProfileByClanBody,
    options: any = {}
  ): Promise<any> {
    if (clanId === null || clanId === undefined) {
      throw new Error(
        "'clanId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/updateclanprofile/{clanId}".replace(
      "{clanId}",
      encodeURIComponent(String(clanId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Upload attachment */
  uploadAttachmentFile(
    bearerToken: string,
    body: ApiUploadAttachmentRequest,
    options: any = {}
  ): Promise<ApiUploadAttachment> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/uploadattachmentfile";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Fetch zero or more users by ID and/or username. */
  getUsers(
    bearerToken: string,
    ids?: Array<string>,
    usernames?: Array<string>,
    facebookIds?: Array<string>,
    options: any = {}
  ): Promise<ApiUsers> {
    const urlPath = "/v2/user";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);
    queryParams.set("facebook_ids", facebookIds);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  updateUser(
    bearerToken: string,
    body: ApiUpdateUsersRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/user/update";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** ListUserClansByUserId */
  listUserClansByUserId(
    bearerToken: string,
    options: any = {}
  ): Promise<ApiAllUserClans> {
    const urlPath = "/v2/users/clans";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** ListUserPermissionInChannel */
  listUserPermissionInChannel(bearerToken: string,
      clanId?:string,
      channelId?:string,
      options: any = {}): Promise<ApiUserPermissionInChannelListResponse> {
    
    const urlPath = "/v2/users/clans/channels";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** create webhook */
  generateWebhook(
    bearerToken: string,
    body: ApiWebhookCreateRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/generate";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** update webhook name by id */
  updateWebhookById(
    bearerToken: string,
    id: string,
    body: MezonUpdateWebhookByIdBody,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/update/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** list webhook belong to the channel */
  listWebhookByChannelId(
    bearerToken: string,
    channelId: string,
    clanId?: string,
    options: any = {}
  ): Promise<ApiWebhookListResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/webhooks/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** disabled webhook */
  deleteWebhookById(
    bearerToken: string,
    id: string,
    options: any = {}
  ): Promise<any> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }

    const urlPath = "/v2/webhooks/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PATCH", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  buildFullUrl(
    basePath: string,
    fragment: string,
    queryParams: Map<string, any>
  ) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
      if (v instanceof Array) {
        fullPath += v.reduce((prev: any, curr: any) => {
          return (
            prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&"
          );
        }, "");
      } else {
        if (v != null) {
          fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
        }
      }
    }

    return fullPath;
  }

  /** Channel canvas editor */
  editChannelCanvases(
    bearerToken: string,
    body: ApiEditChannelCanvasRequest,
    options: any = {}
  ): Promise<ApiEditChannelCanvasResponse> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/canvases/editor";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getChannelCanvasDetail(
    bearerToken: string,
    id: string,
    clanId?: string,
    channelId?: string,
    options: any = {}
  ): Promise<ApiChannelCanvasDetailResponse> {
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/canvases/{id}".replace(
      "{id}",
      encodeURIComponent(String(id))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  getChannelCanvasList(
    bearerToken: string,
    channelId: string,
    clanId?: string,
    limit?: number,
    page?: number,
    options: any = {}
  ): Promise<ApiChannelCanvasListResponse> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channel_canvases/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);
    queryParams.set("page", page);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /**  */
  deleteChannelCanvas(
    bearerToken: string,
    canvasId: string,
    clanId?: string,
    channelId?: string,
    options: any = {}
  ): Promise<any> {
    if (canvasId === null || canvasId === undefined) {
      throw new Error(
        "'canvasId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/canvases/{canvasId}".replace(
      "{canvasId}",
      encodeURIComponent(String(canvasId))
    );
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("channel_id", channelId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }
}
