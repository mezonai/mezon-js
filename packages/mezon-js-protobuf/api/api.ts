// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.2
// source: api/api.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Struct } from "../google/protobuf/struct";
import { Timestamp } from "../google/protobuf/timestamp";
import { BoolValue, Int32Value, StringValue } from "../google/protobuf/wrappers";

export const protobufPackage = "mezon.api";

/** The Mezon server RPC protocol for games and apps. */

/** Validation Provider, */
export enum StoreProvider {
  /** APPLE_APP_STORE - Apple App Store */
  APPLE_APP_STORE = 0,
  /** GOOGLE_PLAY_STORE - Google Play Store */
  GOOGLE_PLAY_STORE = 1,
  /** HUAWEI_APP_GALLERY - Huawei App Gallery */
  HUAWEI_APP_GALLERY = 2,
  /** FACEBOOK_INSTANT_STORE - Facebook Instant Store */
  FACEBOOK_INSTANT_STORE = 3,
  UNRECOGNIZED = -1,
}

export function storeProviderFromJSON(object: any): StoreProvider {
  switch (object) {
    case 0:
    case "APPLE_APP_STORE":
      return StoreProvider.APPLE_APP_STORE;
    case 1:
    case "GOOGLE_PLAY_STORE":
      return StoreProvider.GOOGLE_PLAY_STORE;
    case 2:
    case "HUAWEI_APP_GALLERY":
      return StoreProvider.HUAWEI_APP_GALLERY;
    case 3:
    case "FACEBOOK_INSTANT_STORE":
      return StoreProvider.FACEBOOK_INSTANT_STORE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StoreProvider.UNRECOGNIZED;
  }
}

export function storeProviderToJSON(object: StoreProvider): string {
  switch (object) {
    case StoreProvider.APPLE_APP_STORE:
      return "APPLE_APP_STORE";
    case StoreProvider.GOOGLE_PLAY_STORE:
      return "GOOGLE_PLAY_STORE";
    case StoreProvider.HUAWEI_APP_GALLERY:
      return "HUAWEI_APP_GALLERY";
    case StoreProvider.FACEBOOK_INSTANT_STORE:
      return "FACEBOOK_INSTANT_STORE";
    case StoreProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Environment where a purchase/subscription took place, */
export enum StoreEnvironment {
  /** UNKNOWN - Unknown environment. */
  UNKNOWN = 0,
  /** SANDBOX - Sandbox/test environment. */
  SANDBOX = 1,
  /** PRODUCTION - Production environment. */
  PRODUCTION = 2,
  UNRECOGNIZED = -1,
}

export function storeEnvironmentFromJSON(object: any): StoreEnvironment {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return StoreEnvironment.UNKNOWN;
    case 1:
    case "SANDBOX":
      return StoreEnvironment.SANDBOX;
    case 2:
    case "PRODUCTION":
      return StoreEnvironment.PRODUCTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StoreEnvironment.UNRECOGNIZED;
  }
}

export function storeEnvironmentToJSON(object: StoreEnvironment): string {
  switch (object) {
    case StoreEnvironment.UNKNOWN:
      return "UNKNOWN";
    case StoreEnvironment.SANDBOX:
      return "SANDBOX";
    case StoreEnvironment.PRODUCTION:
      return "PRODUCTION";
    case StoreEnvironment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Operator that can be used to override the one set in the leaderboard. */
export enum Operator {
  /** NO_OVERRIDE - Do not override the leaderboard operator. */
  NO_OVERRIDE = 0,
  /** BEST - Override the leaderboard operator with BEST. */
  BEST = 1,
  /** SET - Override the leaderboard operator with SET. */
  SET = 2,
  /** INCREMENT - Override the leaderboard operator with INCREMENT. */
  INCREMENT = 3,
  /** DECREMENT - Override the leaderboard operator with DECREMENT. */
  DECREMENT = 4,
  UNRECOGNIZED = -1,
}

export function operatorFromJSON(object: any): Operator {
  switch (object) {
    case 0:
    case "NO_OVERRIDE":
      return Operator.NO_OVERRIDE;
    case 1:
    case "BEST":
      return Operator.BEST;
    case 2:
    case "SET":
      return Operator.SET;
    case 3:
    case "INCREMENT":
      return Operator.INCREMENT;
    case 4:
    case "DECREMENT":
      return Operator.DECREMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operator.UNRECOGNIZED;
  }
}

export function operatorToJSON(object: Operator): string {
  switch (object) {
    case Operator.NO_OVERRIDE:
      return "NO_OVERRIDE";
    case Operator.BEST:
      return "BEST";
    case Operator.SET:
      return "SET";
    case Operator.INCREMENT:
      return "INCREMENT";
    case Operator.DECREMENT:
      return "DECREMENT";
    case Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A user with additional account details. Always the current user. */
export interface Account {
  /** The user object. */
  user:
    | User
    | undefined;
  /** The user's wallet data. */
  wallet: string;
  /** The email address of the user. */
  email: string;
  /** The devices which belong to the user's account. */
  devices: AccountDevice[];
  /** The custom id in the user's account. */
  custom_id: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified. */
  verify_time:
    | Date
    | undefined;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned. */
  disable_time:
    | Date
    | undefined;
  /** Logo url */
  logo: string;
  /** Splash screen url */
  splash_screen: string;
}

/** Obtain a new authentication token using a refresh token. */
export interface AccountRefresh {
  /** Refresh token. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountRefresh_VarsEntry {
  key: string;
  value: string;
}

/** Send a Apple Sign In token to the server. Used with authenticate/link/unlink. */
export interface AccountApple {
  /** The ID token received from Apple to validate. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountApple_VarsEntry {
  key: string;
  value: string;
}

/** Send a custom ID to the server. Used with authenticate/link/unlink. */
export interface AccountCustom {
  /** A custom identifier. */
  id: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountCustom_VarsEntry {
  key: string;
  value: string;
}

/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface AccountDevice {
  /** A device identifier. Should be obtained by a platform-specific device API. */
  id: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountDevice_VarsEntry {
  key: string;
  value: string;
}

/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface AccountEmail {
  /** A valid RFC-5322 email address. */
  email: string;
  /** A password for the user account. */
  password: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountEmail_VarsEntry {
  key: string;
  value: string;
}

/** Send a Facebook token to the server. Used with authenticate/link/unlink. */
export interface AccountFacebook {
  /** The OAuth token received from Facebook to access their profile API. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountFacebook_VarsEntry {
  key: string;
  value: string;
}

/** Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink. */
export interface AccountFacebookInstantGame {
  /** The OAuth token received from a Facebook Instant Game that may be decoded with the Application Secret (must be available with the mezon configuration) */
  signed_player_info: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountFacebookInstantGame_VarsEntry {
  key: string;
  value: string;
}

/** Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink. */
export interface AccountGameCenter {
  /** Player ID (generated by GameCenter). */
  player_id: string;
  /** Bundle ID (generated by GameCenter). */
  bundle_id: string;
  /** Time since UNIX epoch when the signature was created. */
  timestamp_seconds: number;
  /** A random "NSString" used to compute the hash and keep it randomized. */
  salt: string;
  /** The verification signature data generated. */
  signature: string;
  /** The URL for the public encryption key. */
  public_key_url: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountGameCenter_VarsEntry {
  key: string;
  value: string;
}

/** Send a Google token to the server. Used with authenticate/link/unlink. */
export interface AccountGoogle {
  /** The OAuth token received from Google to access their profile API. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountGoogle_VarsEntry {
  key: string;
  value: string;
}

/** Send a Steam token to the server. Used with authenticate/link/unlink. */
export interface AccountSteam {
  /** The account token received from Steam to access their profile API. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountSteam_VarsEntry {
  key: string;
  value: string;
}

/** Add one or more friends to the current user. */
export interface AddFriendsRequest {
  /** The account id of a user. */
  ids: string[];
  /** The account username of a user. */
  usernames: string[];
}

/** Add users to a group. */
export interface AddGroupUsersRequest {
  /** The group to add users to. */
  group_id: string;
  /** The users to add. */
  user_ids: string[];
}

/** Authenticate against the server with a refresh token. */
export interface SessionRefreshRequest {
  /** Refresh token. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface SessionRefreshRequest_VarsEntry {
  key: string;
  value: string;
}

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface SessionLogoutRequest {
  /** Session token to log out. */
  token: string;
  /** Refresh token to invalidate. */
  refresh_token: string;
  /** Device Id */
  device_id: string;
  /** FCM token from firebase */
  fcm_token: string;
}

/** Authenticate against the server with Apple Sign In. */
export interface AuthenticateAppleRequest {
  /** The Apple account details. */
  account:
    | AccountApple
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** Authenticate against the server with a custom ID. */
export interface AuthenticateCustomRequest {
  /** The custom account details. */
  account:
    | AccountCustom
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** Authenticate against the server with a device ID. */
export interface AuthenticateDeviceRequest {
  /** The device account details. */
  account:
    | AccountDevice
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** Authenticate against the server with email+password. */
export interface AuthenticateEmailRequest {
  /** The email account details. */
  account:
    | AccountEmail
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** Authenticate against the server with Facebook. */
export interface AuthenticateFacebookRequest {
  /** The Facebook account details. */
  account:
    | AccountFacebook
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
  /** Import Facebook friends for the user. */
  sync: boolean | undefined;
}

/** Authenticate against the server with Facebook Instant Game token. */
export interface AuthenticateFacebookInstantGameRequest {
  /** The Facebook Instant Game account details. */
  account:
    | AccountFacebookInstantGame
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** Authenticate against the server with Apple's Game Center. */
export interface AuthenticateGameCenterRequest {
  /** The Game Center account details. */
  account:
    | AccountGameCenter
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** AuthenticateGoogleRedirectRequest */
export interface AuthenticateGoogleRedirectRequest {
  /** The code */
  code: string;
}

/** Authenticate against the server with Google. */
export interface AuthenticateGoogleRequest {
  /** The Google account details. */
  account:
    | AccountGoogle
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
}

/** Authenticate against the server with Steam. */
export interface AuthenticateSteamRequest {
  /** The Steam account details. */
  account:
    | AccountSteam
    | undefined;
  /** Register the account if the user does not already exist. */
  create:
    | boolean
    | undefined;
  /** Set the username on the account at register. Must be unique. */
  username: string;
  /** Import Steam friends for the user. */
  sync: boolean | undefined;
}

/** Ban users from a group. */
export interface BanGroupUsersRequest {
  /** The group to ban users from. */
  group_id: string;
  /** The users to ban. */
  user_ids: string[];
}

/** Block one or more friends for the current user. */
export interface BlockFriendsRequest {
  /** The account id of a user. */
  ids: string[];
  /** The account username of a user. */
  usernames: string[];
}

/** A message sent on a channel. */
export interface ChannelMessage {
  /** The clan this message belong to. */
  clan_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The unique ID of this message. */
  message_id: string;
  /** The code representing a message type or category. */
  code:
    | number
    | undefined;
  /** Message sender, usually a user ID. */
  sender_id: string;
  /** The username of the message sender, if any. */
  username: string;
  /** The avatar of user who send message */
  avatar: string;
  /** The content payload. */
  content: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time:
    | Date
    | undefined;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated. */
  update_time:
    | Date
    | undefined;
  /** The name of the chat room, or an empty string if this message was not sent through a chat room. */
  channel_label: string;
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
  /** The clan nick name */
  display_name: string;
  /** The clan nick name */
  clan_nick: string;
  /** The clan avatar */
  clan_avatar: string;
  /** Emoji reaction */
  reactions: string;
  /** Message mention */
  mentions: string;
  /** Message attachment */
  attachments: string;
  /** Message reference */
  references: string;
  /** referenced message */
  referenced_message: string;
  /** create time in ms */
  create_time_seconds: number;
  /** update time in ms */
  update_time_seconds: number;
  /** channel mode */
  mode: number;
  /** hide editted */
  hide_editted: boolean;
  /** is public */
  is_public: boolean;
  /** topic */
  topic_id: string;
}

/** Mention to message */
export interface MessageMention {
  /** Mention id */
  id: string;
  /** mention user id */
  user_id: string;
  /** mention username */
  username: string;
  /** role id */
  role_id: string;
  /** role name */
  rolename: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time:
    | Date
    | undefined;
  /** start position from text */
  s: number;
  /** end position from text */
  e: number;
}

/** Mention to message */
export interface NotificationInfo {
  /** username */
  username: string;
  /** avatar */
  avatar: string;
  /** clan nick name */
  clan_nick: string;
  /** clan avatar */
  clan_avatar: string;
  /** display name */
  display_name: string;
  /** channel label */
  channel_label: string;
  /** channel type */
  channel_type: number;
  /** category name */
  category_name: string;
  /** clan name */
  clan_name: string;
  /** clan logo */
  clan_logo: string;
}

/** Emoji reaction by user */
export interface MessageReaction {
  /** Reaction id */
  id: string;
  /** An emoji id */
  emoji_id: string;
  /** An emoji shortname */
  emoji: string;
  /** User react to message */
  sender_id: string;
  /** Sender name */
  sender_name: string;
  /** avatar */
  sender_avatar: string;
  /** Action reaction delete or add */
  action: boolean;
  /** count of emoji */
  count: number;
  /** channel id */
  channel_id: string;
  /** message id */
  message_id: string;
  /** clan id */
  clan_id: string;
  /** mode */
  mode: number;
  /** message sender id */
  message_sender_id: string;
  /** is public */
  is_public: boolean;
}

/** Message attachment */
export interface MessageAttachment {
  /** Attachment file name */
  filename: string;
  /** Attachment file size */
  size: number;
  /** Attachment url */
  url: string;
  /** Attachment file type */
  filetype: string;
  /** Attachment width */
  width: number;
  /** Attachment width */
  height: number;
}

/** Message reference */
export interface MessageRef {
  /** A message source */
  message_id: string;
  /** A message reference to */
  message_ref_id: string;
  /** content reference */
  content: string;
  /** has attachment */
  has_attachment: boolean;
  /** Reference type. 0: reply */
  ref_type: number;
  /** original message sender */
  message_sender_id: string;
  /** original message sendre username */
  message_sender_username: string;
  /** original message sender avatar */
  mesages_sender_avatar: string;
  /** original sender clan nick name */
  message_sender_clan_nick: string;
  /** original sender display name */
  message_sender_display_name: string;
}

/** Message reference */
export interface MessageDeleted {
  /** A deleted message source */
  message_id: string;
  /** Who delete it */
  deletor: string;
}

/** A list of channel messages, usually a result of a list operation. */
export interface ChannelMessageList {
  /** A list of messages. */
  messages: ChannelMessage[];
  /** last seen message id by user */
  last_seen_message:
    | ChannelMessageHeader
    | undefined;
  /** last sent message id */
  last_sent_message: ChannelMessageHeader | undefined;
}

/** Create a group with the current user as owner. */
export interface CreateGroupRequest {
  /** A unique name for the group. */
  name: string;
  /** A description for the group. */
  description: string;
  /** The language expected to be a tag which follows the BCP-47 spec. */
  lang_tag: string;
  /** A URL for an avatar image. */
  avatar_url: string;
  /** Mark a group as open or not where only admins can accept members. */
  open: boolean;
  /** Maximum number of group members. */
  max_count: number;
}

/** Delete one or more friends for the current user. */
export interface DeleteFriendsRequest {
  /** The account id of a user. */
  ids: string[];
  /** The account username of a user. */
  usernames: string[];
}

/** Delete a group the user has access to. */
export interface DeleteGroupRequest {
  /** The id of a group. */
  group_id: string;
}

/** Delete one or more notifications for the current user. */
export interface DeleteNotificationsRequest {
  /** The id of notifications. */
  ids: string[];
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface Event {
  /** An event name, type, category, or identifier. */
  name: string;
  /** Arbitrary event property values. */
  properties: { [key: string]: string };
  /** The time when the event was triggered. */
  timestamp:
    | Date
    | undefined;
  /** True if the event came directly from a client call, false otherwise. */
  external: boolean;
}

export interface Event_PropertiesEntry {
  key: string;
  value: string;
}

/** A friend of a user. */
export interface Friend {
  /** The user object. */
  user:
    | User
    | undefined;
  /** The friend status. */
  state:
    | number
    | undefined;
  /** Time of the latest relationship update. */
  update_time: Date | undefined;
}

/** The friendship status. */
export enum Friend_State {
  /** FRIEND - The user is a friend of the current user. */
  FRIEND = 0,
  /** INVITE_SENT - The current user has sent an invite to the user. */
  INVITE_SENT = 1,
  /** INVITE_RECEIVED - The current user has received an invite from this user. */
  INVITE_RECEIVED = 2,
  /** BLOCKED - The current user has blocked this user. */
  BLOCKED = 3,
  UNRECOGNIZED = -1,
}

export function friend_StateFromJSON(object: any): Friend_State {
  switch (object) {
    case 0:
    case "FRIEND":
      return Friend_State.FRIEND;
    case 1:
    case "INVITE_SENT":
      return Friend_State.INVITE_SENT;
    case 2:
    case "INVITE_RECEIVED":
      return Friend_State.INVITE_RECEIVED;
    case 3:
    case "BLOCKED":
      return Friend_State.BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Friend_State.UNRECOGNIZED;
  }
}

export function friend_StateToJSON(object: Friend_State): string {
  switch (object) {
    case Friend_State.FRIEND:
      return "FRIEND";
    case Friend_State.INVITE_SENT:
      return "INVITE_SENT";
    case Friend_State.INVITE_RECEIVED:
      return "INVITE_RECEIVED";
    case Friend_State.BLOCKED:
      return "BLOCKED";
    case Friend_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A collection of zero or more friends of the user. */
export interface FriendList {
  /** The Friend objects. */
  friends: Friend[];
  /** Cursor for the next page of results, if any. */
  cursor: string;
}

/** Fetch a batch of zero or more users from the server. */
export interface GetUsersRequest {
  /** The account id of a user. */
  ids: string[];
  /** The account username of a user. */
  usernames: string[];
  /** The Facebook ID of a user. */
  facebook_ids: string[];
}

/** Fetch a batch of zero or more users from the server. */
export interface UpdateUsersRequest {
  /** The account username of a user. */
  display_name: string;
  /** The avarar_url of a user. */
  avatar_url: string;
}

/** A group in the server. */
export interface Group {
  /** The id of a group. */
  id: string;
  /** The id of the user who created the group. */
  creator_id: string;
  /** The unique name of the group. */
  name: string;
  /** A description for the group. */
  description: string;
  /** The language expected to be a tag which follows the BCP-47 spec. */
  lang_tag: string;
  /** Additional information stored as a JSON object. */
  metadata: string;
  /** A URL for an avatar image. */
  avatar_url: string;
  /** Anyone can join open groups, otherwise only admins can accept members. */
  open:
    | boolean
    | undefined;
  /** The current count of all members in the group. */
  edge_count: number;
  /** The maximum number of members allowed. */
  max_count: number;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created. */
  create_time:
    | Date
    | undefined;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was last updated. */
  update_time: Date | undefined;
}

/** One or more groups returned from a listing operation. */
export interface GroupList {
  /** One or more groups. */
  groups: Group[];
  /** A cursor used to get the next page. */
  cursor: string;
}

/** A list of users belonging to a group, along with their role. */
export interface GroupUserList {
  /** User-role pairs for a group. */
  group_users: GroupUserList_GroupUser[];
  /** Cursor for the next page of results, if any. */
  cursor: string;
}

/** A single user-role pair. */
export interface GroupUserList_GroupUser {
  /** User. */
  user:
    | User
    | undefined;
  /** Their relationship to the group. */
  state: number | undefined;
}

/** The group role status. */
export enum GroupUserList_GroupUser_State {
  /** SUPERADMIN - The user is a superadmin with full control of the group. */
  SUPERADMIN = 0,
  /** ADMIN - The user is an admin with additional privileges. */
  ADMIN = 1,
  /** MEMBER - The user is a regular member. */
  MEMBER = 2,
  /** JOIN_REQUEST - The user has requested to join the group */
  JOIN_REQUEST = 3,
  UNRECOGNIZED = -1,
}

export function groupUserList_GroupUser_StateFromJSON(object: any): GroupUserList_GroupUser_State {
  switch (object) {
    case 0:
    case "SUPERADMIN":
      return GroupUserList_GroupUser_State.SUPERADMIN;
    case 1:
    case "ADMIN":
      return GroupUserList_GroupUser_State.ADMIN;
    case 2:
    case "MEMBER":
      return GroupUserList_GroupUser_State.MEMBER;
    case 3:
    case "JOIN_REQUEST":
      return GroupUserList_GroupUser_State.JOIN_REQUEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GroupUserList_GroupUser_State.UNRECOGNIZED;
  }
}

export function groupUserList_GroupUser_StateToJSON(object: GroupUserList_GroupUser_State): string {
  switch (object) {
    case GroupUserList_GroupUser_State.SUPERADMIN:
      return "SUPERADMIN";
    case GroupUserList_GroupUser_State.ADMIN:
      return "ADMIN";
    case GroupUserList_GroupUser_State.MEMBER:
      return "MEMBER";
    case GroupUserList_GroupUser_State.JOIN_REQUEST:
      return "JOIN_REQUEST";
    case GroupUserList_GroupUser_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A list of users belonging to a channel, along with their role. */
export interface ChannelUserList {
  /** User-role pairs for a channel. */
  channel_users: ChannelUserList_ChannelUser[];
  /** Cursor for the next page of results, if any. */
  cursor: string;
  /** channel id */
  channel_id: string;
}

/** A single user-role pair. */
export interface ChannelUserList_ChannelUser {
  /** User. */
  user_id: string;
  /** Their relationship to the role. */
  role_id: string[];
  /** Id */
  id: string;
  /** thread id */
  thread_id: string;
  /** clan nick name */
  clan_nick: string;
  /** clan avatar */
  clan_avatar: string;
  /** clan Id */
  clan_id: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface VoiceChannelUser {
  /** voice user join id */
  id: string;
  /** User for a channel. */
  user_id: string;
  /** channel id */
  channel_id: string;
  /** participant */
  participant: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface VoiceChannelUserList {
  /** list of voice channel user */
  voice_channel_users: VoiceChannelUser[];
}

/** channel attachment */
export interface ChannelAttachment {
  /** url attachment */
  id: string;
  /** file name */
  filename: string;
  /** filetype */
  filetype: string;
  /** size */
  filesize: string;
  /** url */
  url: string;
  /** uploader */
  uploader: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created. */
  create_time:
    | Date
    | undefined;
  /** message id. */
  message_id: string;
}

/** channel attachment list */
export interface ChannelAttachmentList {
  /** list attachment */
  attachments: ChannelAttachment[];
}

/** A list of users belonging to a clan, along with their role. */
export interface ClanUserList {
  /** User-role pairs for a clan. */
  clan_users: ClanUserList_ClanUser[];
  /** Cursor for the next page of results, if any. */
  cursor: string;
  /** clan id */
  clan_id: string;
}

/** A single user-role pair. */
export interface ClanUserList_ClanUser {
  /** User. */
  user:
    | User
    | undefined;
  /** Their relationship to the role. */
  role_id: string[];
  /** from the `nick_name` field in the `clan_desc_profile` table. */
  clan_nick: string;
  /** from the `avatar_url` field in the `clan_desc_profile` table. */
  clan_avatar: string;
  /**  */
  clan_id: string;
}

/** Import Facebook friends into the current user's account. */
export interface ImportFacebookFriendsRequest {
  /** The Facebook account details. */
  account:
    | AccountFacebook
    | undefined;
  /** Reset the current user's friends list. */
  reset: boolean | undefined;
}

/** Import Facebook friends into the current user's account. */
export interface ImportSteamFriendsRequest {
  /** The Facebook account details. */
  account:
    | AccountSteam
    | undefined;
  /** Reset the current user's friends list. */
  reset: boolean | undefined;
}

export interface RegistFcmDeviceTokenRequest {
  /** The token */
  token: string;
  /**  */
  device_id: string;
  /**  */
  platform: string;
}

export interface RegistFcmDeviceTokenResponse {
  /** The token */
  token: string;
  /**  */
  device_id: string;
  /**  */
  platform: string;
}

/** Link Facebook to the current user's account. */
export interface LinkFacebookRequest {
  /** The Facebook account details. */
  account:
    | AccountFacebook
    | undefined;
  /** Import Facebook friends for the user. */
  sync: boolean | undefined;
}

/** Link Steam to the current user's account. */
export interface LinkSteamRequest {
  /** The Facebook account details. */
  account:
    | AccountSteam
    | undefined;
  /** Import Steam friends for the user. */
  sync: boolean | undefined;
}

/** List a channel's message history. */
export interface ListChannelMessagesRequest {
  /** the clan id */
  clan_id: string;
  /** The channel ID to list from. */
  channel_id: string;
  /** The current message ID. */
  message_id: string;
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** True if listing should be older messages to newer, false if reverse. */
  direction:
    | number
    | undefined;
  /**  */
  topic_id: string;
}

/** List friends for a user. */
export interface ListFriendsRequest {
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The friend state to list. */
  state:
    | number
    | undefined;
  /** An optional next page cursor. */
  cursor: string;
}

/** List groups based on given filters. */
export interface ListGroupsRequest {
  /** List groups that contain this value in their names. */
  name: string;
  /** Optional pagination cursor. */
  cursor: string;
  /** Max number of groups to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** Language tag filter */
  lang_tag: string;
  /** Number of group members */
  members:
    | number
    | undefined;
  /** Optional Open/Closed filter. */
  open: boolean | undefined;
}

/** List all users that are part of a group. */
export interface ListGroupUsersRequest {
  /** The group ID to list from. */
  group_id: string;
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The group user state to list. */
  state:
    | number
    | undefined;
  /** An optional next page cursor. */
  cursor: string;
}

/** List all users that are part of a channel. */
export interface ListChannelUsersRequest {
  /** The clan id */
  clan_id: string;
  /** The channel ID to list from. */
  channel_id: string;
  /** The channel type */
  channel_type: number;
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The group user state to list. */
  state:
    | number
    | undefined;
  /** An optional next page cursor. */
  cursor: string;
}

/** List all attachments that are part of a channel. */
export interface ListChannelAttachmentRequest {
  /** The clan id */
  clan_id: string;
  /** The channel ID to list from. */
  channel_id: string;
  /** The channel type */
  file_type: string;
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The group user state to list. */
  state:
    | number
    | undefined;
  /** An optional previous id for page. */
  before: string;
  /** An optional next id for page. */
  after: string;
  /** An optional around id for page. */
  around: string;
}

/** List all users that are part of a clan. */
export interface ListClanUsersRequest {
  /** The clan ID to list from. */
  clan_id: string;
}

/** Get a list of unexpired notifications. */
export interface ListNotificationsRequest {
  /** The number of notifications to get. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The clan id */
  clan_id: string;
  /** The current notification Id. */
  notification_id: string;
  /** The code. */
  code:
    | number
    | undefined;
  /** True if listing should be older notifications to newer, false if reverse. */
  direction: number | undefined;
}

/** List the groups a user is part of, and their relationship to each. */
export interface ListUserGroupsRequest {
  /** ID of the user. */
  user_id: string;
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The user group state to list. */
  state:
    | number
    | undefined;
  /** An optional next page cursor. */
  cursor: string;
}

/** A notification in the server. */
export interface Notification {
  /** ID of the Notification. */
  id: string;
  /** Subject of the notification. */
  subject: string;
  /** Content of the notification in JSON. */
  content: string;
  /** Category code for this notification. */
  code: number;
  /** ID of the sender, if a user. Otherwise 'null'. */
  sender_id: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created. */
  create_time:
    | Date
    | undefined;
  /** True if this notification was persisted to the database. */
  persistent: boolean;
  /** ID of clan */
  clan_id: string;
  /** ID of channel */
  channel_id: string;
  /** mode of */
  channel_type: number;
  /**  */
  avatar_url: string;
}

/** A collection of zero or more notifications. */
export interface NotificationList {
  /** Collection of notifications. */
  notifications: Notification[];
  /** Use this cursor to paginate notifications. Cache this to catch up to new notifications. */
  cacheable_cursor: string;
}

/** Promote a set of users in a group to the next role up. */
export interface PromoteGroupUsersRequest {
  /** The group ID to promote in. */
  group_id: string;
  /** The users to promote. */
  user_ids: string[];
}

/** Demote a set of users in a group to the next role down. */
export interface DemoteGroupUsersRequest {
  /** The group ID to demote in. */
  group_id: string;
  /** The users to demote. */
  user_ids: string[];
}

/** Execute an Lua function on the server. */
export interface Rpc {
  /** The identifier of the function. */
  id: string;
  /** The payload of the function which must be a JSON object. */
  payload: string;
  /** The authentication key used when executed as a non-client HTTP request. */
  http_key: string;
}

/** A user's session used to authenticate messages. */
export interface Session {
  /** True if the corresponding account was just created, false otherwise. */
  created: boolean;
  /** Authentication credentials. */
  token: string;
  /** Refresh token that can be used for session token renewal. */
  refresh_token: string;
  /** User id */
  user_id: string;
}

/** Update a user's account details. */
export interface UpdateAccountRequest {
  /** The username of the user's account. */
  username:
    | string
    | undefined;
  /** The display name of the user. */
  display_name:
    | string
    | undefined;
  /** A URL for an avatar image. */
  avatar_url:
    | string
    | undefined;
  /** The language expected to be a tag which follows the BCP-47 spec. */
  lang_tag:
    | string
    | undefined;
  /** The location set by the user. */
  location:
    | string
    | undefined;
  /** The timezone set by the user. */
  timezone:
    | string
    | undefined;
  /** update about me */
  about_me: string;
  /** date of birth */
  dob:
    | Date
    | undefined;
  /** logo url */
  logo: string;
  /** splash screen */
  splash_screen: string;
}

/** Update fields in a given group. */
export interface UpdateGroupRequest {
  /** The ID of the group to update. */
  group_id: string;
  /** Name. */
  name:
    | string
    | undefined;
  /** Description string. */
  description:
    | string
    | undefined;
  /** Lang tag. */
  lang_tag:
    | string
    | undefined;
  /** Avatar URL. */
  avatar_url:
    | string
    | undefined;
  /** Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin. */
  open: boolean | undefined;
}

export interface UpdateCategoryDescRequest {
  /** The ID of the group to update. */
  category_id: string;
  category_name: string;
  clan_id: string;
}

/** A user in the server. */
export interface User {
  /** The id of the user's account. */
  id: string;
  /** The username of the user's account. */
  username: string;
  /** The display name of the user. */
  display_name: string;
  /** A URL for an avatar image. */
  avatar_url: string;
  /** The language expected to be a tag which follows the BCP-47 spec. */
  lang_tag: string;
  /** The location set by the user. */
  location: string;
  /** The timezone set by the user. */
  timezone: string;
  /** Additional information stored as a JSON object. */
  metadata: string;
  /** The Facebook id in the user's account. */
  facebook_id: string;
  /** The Google id in the user's account. */
  google_id: string;
  /** The Apple Game Center in of the user's account. */
  gamecenter_id: string;
  /** The Steam id in the user's account. */
  steam_id: string;
  /** Indicates whether the user is currently online. */
  online: boolean;
  /** Number of related edges to this user. */
  edge_count: number;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created. */
  create_time:
    | Date
    | undefined;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated. */
  update_time:
    | Date
    | undefined;
  /** The Apple Sign In ID in the user's account. */
  apple_id: string;
  /**  */
  about_me: string;
  /**  */
  join_time:
    | Date
    | undefined;
  /** platform */
  is_mobile: boolean;
  /**  */
  dob: Date | undefined;
}

/** A list of groups belonging to a user, along with the user's role in each group. */
export interface UserGroupList {
  /** Group-role pairs for a user. */
  user_groups: UserGroupList_UserGroup[];
  /** Cursor for the next page of results, if any. */
  cursor: string;
}

/** A single group-role pair. */
export interface UserGroupList_UserGroup {
  /** Group. */
  group:
    | Group
    | undefined;
  /** The user's relationship to the group. */
  state: number | undefined;
}

/** The group role status. */
export enum UserGroupList_UserGroup_State {
  /** SUPERADMIN - The user is a superadmin with full control of the group. */
  SUPERADMIN = 0,
  /** ADMIN - The user is an admin with additional privileges. */
  ADMIN = 1,
  /** MEMBER - The user is a regular member. */
  MEMBER = 2,
  /** JOIN_REQUEST - The user has requested to join the group */
  JOIN_REQUEST = 3,
  UNRECOGNIZED = -1,
}

export function userGroupList_UserGroup_StateFromJSON(object: any): UserGroupList_UserGroup_State {
  switch (object) {
    case 0:
    case "SUPERADMIN":
      return UserGroupList_UserGroup_State.SUPERADMIN;
    case 1:
    case "ADMIN":
      return UserGroupList_UserGroup_State.ADMIN;
    case 2:
    case "MEMBER":
      return UserGroupList_UserGroup_State.MEMBER;
    case 3:
    case "JOIN_REQUEST":
      return UserGroupList_UserGroup_State.JOIN_REQUEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserGroupList_UserGroup_State.UNRECOGNIZED;
  }
}

export function userGroupList_UserGroup_StateToJSON(object: UserGroupList_UserGroup_State): string {
  switch (object) {
    case UserGroupList_UserGroup_State.SUPERADMIN:
      return "SUPERADMIN";
    case UserGroupList_UserGroup_State.ADMIN:
      return "ADMIN";
    case UserGroupList_UserGroup_State.MEMBER:
      return "MEMBER";
    case UserGroupList_UserGroup_State.JOIN_REQUEST:
      return "JOIN_REQUEST";
    case UserGroupList_UserGroup_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A collection of zero or more users. */
export interface Users {
  /** The User objects. */
  users: User[];
}

/** Clan profile information */
export interface ClanDescProfile {
  /** Clan id */
  clan_id: string;
  /** Clan creator */
  creator_id: string;
  /** Clan nick name */
  nick_name: string;
  /** Clan profile banner */
  profile_banner: string;
  /** Clan profile theme */
  profile_theme: string;
  /** Clan profile avatar */
  avatar_url: string;
}

/** Update Clan profile information */
export interface UpdateClanDescProfileRequest {
  /** Clan id */
  clan_id: string;
  /** Clan nick name */
  nick_name: string;
  /** Clan profile banner */
  profile_banner: string;
  /** Clan profile theme */
  profile_theme: string;
  /** Clan profile avatar */
  avatar_url: string;
}

/** Clan profile information */
export interface ClanDescProfileRequest {
  /** Clan id */
  clan_id: string;
}

/** Clan information */
export interface ClanDesc {
  /** Clan creator */
  creator_id: string;
  /** Clan name */
  clan_name: string;
  /** Clan logo */
  logo: string;
  /** Clan banner */
  banner: string;
  /** Clan id */
  clan_id: string;
  /** Clan status */
  status: number;
  /** Badge count */
  badge_count: number;
  /** Is onboarding. */
  is_onboarding: boolean;
}

/** Clan information */
export interface CreateClanDescRequest {
  /** Clan name */
  clan_name: string;
  /** Clan logo */
  logo: string;
  /** Clan banner */
  banner: string;
}

/** Update Clan information */
export interface UpdateClanDescRequest {
  clan_id: string;
  /** Clan name */
  clan_name: string;
  /** Clan logo */
  logo: string;
  /** Clan banner */
  banner: string;
  /** Clan status */
  status: number;
  /** Is onboarding. */
  is_onboarding: boolean | undefined;
}

/** Delete a clan the user has access to. */
export interface DeleteClanDescRequest {
  /** The id of a group. */
  clan_desc_id: string;
}

/** List (and optionally filter) channels. */
export interface ListClanDescRequest {
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The friend state to list. */
  state:
    | number
    | undefined;
  /** Cursor to start from */
  cursor: string;
}

/** A list of clan */
export interface ClanDescList {
  /** A list of channel. */
  clandesc: ClanDesc[];
}

/** Add link invite users to. */
export interface LinkInviteUserRequest {
  /** id clan to add link to . */
  clan_id: string;
  /** id channel to add link to. */
  channel_id: string;
  /** expiry time */
  expiry_time: number;
}

/** Add link invite users to. */
export interface InviteUserRequest {
  /** id clan to add link to . */
  invite_id: string;
}

/** Add link invite users to. */
export interface InviteUserRes {
  /** id clan to add link to . */
  clan_id: string;
  /** id channel to add link to. */
  channel_id: string;
  /** clan name */
  clan_name: string;
  /** channel name */
  channel_label: string;
  /** check user exist */
  user_joined: boolean;
  /** expiry_time */
  expiry_time: Date | undefined;
}

/** Add link invite users to. */
export interface JoinClanChannelRequest {
  /** id clan to add link to . */
  clan_id: string;
  /** id channel to add link to. */
  channel_id: string;
}

/** Add link invite users to. */
export interface LinkInviteUser {
  /** id clan */
  clan_id: string;
  /** The user to add. */
  creator_id: string;
  /** is clan invite */
  channel_id: string;
  /** link invite */
  invite_link: string;
  /** create time */
  create_time:
    | Date
    | undefined;
  /** expiry time */
  expiry_time: Date | undefined;
  id: string;
}

/** Get clan profile. */
export interface ClanProfile {
  /** id user to find user */
  user_id: string;
  /** name user */
  nick_name: string;
  /** id avatar */
  avatar: string;
  /** id clan */
  clan_id: string;
}

/** information user by clan requset */
export interface ClanProfileRequest {
  /** id clanc */
  clan_id: string;
}

/** update nickname user by clan requset */
export interface UpdateClanProfileRequest {
  /** id clanc */
  clan_id: string;
  /** nick_name new */
  nick_name: string;
  /** avatar */
  avatar: string;
}

/** Category to group the channel */
export interface CategoryDesc {
  /** Category creator */
  creator_id: string;
  /** the Clan that category belong to */
  clan_id: string;
  /** Category name */
  category_name: string;
  category_id: string;
  category_order: number;
}

export interface UpdateCategoryOrderRequest {
  clan_id: string;
  categories: CategoryOrderUpdate[];
}

export interface CategoryOrderUpdate {
  category_id: string;
  order: number;
}

export interface CreateCategoryDescRequest {
  category_name: string;
  clan_id: string;
}

export interface DeleteCategoryDescRequest {
  category_id: string;
  clan_id: string;
}

/** A list of clan */
export interface CategoryDescList {
  /** A list of channel. */
  categorydesc: CategoryDesc[];
}

/** List (and optionally filter) channels. */
export interface ListCategoryDescsRequest {
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The friend state to list. */
  state:
    | number
    | undefined;
  /** Cursor to start from */
  cursor: string;
}

export interface ChannelMessageHeader {
  /** the message id */
  id: string;
  /** the time stamp */
  timestamp_seconds: number;
  /** the sender id */
  sender_id: string;
  /** the content */
  content: string;
  /** the attachment */
  attachment: string;
  /** the reference */
  referece: string;
  /** the mention */
  mention: string;
  /** the reactions */
  reaction: string;
}

/** Channel description record */
export interface ChannelDescription {
  /** The clan of this channel */
  clan_id: string;
  /** The parrent channel this message belongs to. */
  parrent_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The category of channel */
  category_id: string;
  /** The category name */
  category_name: string;
  /** The channel type. */
  type:
    | number
    | undefined;
  /** creator ID. */
  creator_id: string;
  /** The channel lable */
  channel_label: string;
  /** The channel private */
  channel_private: number;
  /** The channel avatar */
  channel_avatar: string[];
  /** The user id */
  user_id: string[];
  /** last message id */
  last_sent_message:
    | ChannelMessageHeader
    | undefined;
  /** last seen message id */
  last_seen_message:
    | ChannelMessageHeader
    | undefined;
  /** status */
  is_online: boolean[];
  /** meeting code */
  meeting_code: string;
  /** count message unread */
  count_mess_unread: number;
  /** active channel */
  active: number;
  /** last pin message */
  last_pin_message: string;
  /** the usernames */
  usernames: string;
  /** creator name */
  creator_name: string;
  /** create time ms */
  create_time_seconds: number;
  /** update time ms */
  update_time_seconds: number;
  /** Additional information stored as a JSON object. */
  metadata: string[];
  /** about_me */
  about_me: string[];
  /** clan_name */
  clan_name: string;
  /** app url */
  app_url: string;
  /** channel all message */
  is_mute: boolean;
  /** age restricted */
  age_restricted: number;
  /** topic */
  topic: string;
  /** e2ee */
  e2ee: number;
}

/** A list of channel description, usually a result of a list operation. */
export interface ChannelDescList {
  /** A list of channel. */
  channeldesc: ChannelDescription[];
  /** The cursor to send when retrieving the next page, if any. */
  next_cursor: string;
  /** The cursor to send when retrieving the previous page, if any. */
  prev_cursor: string;
  /** Cacheable cursor to list newer channel description. Durable and designed to be stored, unlike next/prev cursors. */
  cacheable_cursor: string;
}

export interface ListThreadRequest {
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The channel state to list. */
  state:
    | number
    | undefined;
  /** The clan of this channel */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** thread id */
  thread_id: string;
}

/** List (and optionally filter) channels. */
export interface ListChannelDescsRequest {
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** The channel state to list. */
  state:
    | number
    | undefined;
  /** Cursor to start from */
  cursor: string;
  /** The clan of this channel */
  clan_id: string;
  /** channel type */
  channel_type: number;
}

/** Add a role for channel. */
export interface AddRoleChannelDescRequest {
  /** This is the role that needs to be added to the channel */
  role_ids: string[];
  /** This is a channel that needs more roles */
  channel_id: string;
}

/** Create a channel within clan. */
export interface CreateChannelDescRequest {
  /** The clan of this channel */
  clan_id: string;
  /** The parrent channel this message belongs to. */
  parrent_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The category of channel */
  category_id: string;
  /** The channel type. */
  type:
    | number
    | undefined;
  /** The channel lable */
  channel_label: string;
  /** The channel private */
  channel_private: number;
  /** The users to add. */
  user_ids: string[];
  /** app url for channel type app */
  app_url: string | undefined;
}

/** Delete a channel the user has access to. */
export interface DeleteChannelDescRequest {
  /** The id of a channel. */
  channel_id: string;
}

/** Update fields in a given channel. */
export interface UpdateChannelDescRequest {
  /** The ID of the channel to update. */
  channel_id: string;
  /** The channel lable */
  channel_label:
    | string
    | undefined;
  /** The category of channel */
  category_id:
    | string
    | undefined;
  /** app url for channel type app */
  app_url:
    | string
    | undefined;
  /** topic */
  topic: string;
  /**  */
  age_restricted: number;
  /**  */
  e2ee: number;
}

/** Update fields in a given channel. */
export interface ChangeChannelPrivateRequest {
  /** The ID of the channel to update. */
  channel_id: string;
  /** The channel private */
  channel_private: number;
  /** The users to add. */
  user_ids: string[];
  /** This is the role that needs to be added to the channel */
  role_ids: string[];
}

/** Add users to a channel. */
export interface AddChannelUsersRequest {
  /** The channel to add users to. */
  channel_id: string;
  /** The users to add. */
  user_ids: string[];
}

/** Kick a set of users from a channel. */
export interface RemoveChannelUsersRequest {
  /** The channel ID to kick from. */
  channel_id: string;
  /** The users to kick. */
  user_ids: string[];
}

/** Kick a set of users from a clan. */
export interface RemoveClanUsersRequest {
  /** The clan ID to kick from. */
  clan_id: string;
  /** The users to kick. */
  user_ids: string[];
}

/** Leave a channel. */
export interface LeaveThreadRequest {
  /** The channel ID to leave. */
  channel_id: string;
}

/** Role record */
export interface Role {
  /** Role id */
  id: string;
  title: string;
  color: string;
  role_icon: string;
  slug: string;
  description: string;
  creator_id: string;
  clan_id: string;
  active: number;
  display_online: number;
  allow_mention: number;
  role_user_list: RoleUserList | undefined;
  permission_list: PermissionList | undefined;
  role_channel_active: number;
  channel_ids: string[];
  max_level_permission: number;
}

/** Event clan */
export interface EventManagement {
  id: string;
  title: string;
  logo: string;
  description: string;
  active: number;
  start_event: number;
  creator_id: string;
  clan_id: string;
  channel_id: string;
  address: string;
  start_time: Date | undefined;
  end_time: Date | undefined;
  user_ids: string[];
  create_time: Date | undefined;
  max_permission: number;
}

/** Permission record */
export interface Permission {
  /** Permission id */
  id: string;
  title: string;
  slug: string;
  description: string;
  active: number;
  scope: number;
  level: number;
}

/** Notification setting record */
export interface NotificationSetting {
  /** Notification id */
  id: string;
  /** Notification title */
  notification_setting_type: number;
}

/**  */
export interface DeletePinMessage {
  /**  */
  message_id: string;
}

/**  */
export interface PinMessage {
  /**  */
  id: string;
  /**  */
  message_id: string;
  /**  */
  channel_id: string;
  /**  */
  sender_id: string;
  /**  */
  content: string;
  /**  */
  username: string;
  /**  */
  avatar: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time:
    | Date
    | undefined;
  /** create time in ms */
  create_time_seconds: number;
}

export interface PinMessagesList {
  pin_messages_list: PinMessage[];
}

/** Notification channel */
export interface NotificationUserChannel {
  /** Notification id */
  id: string;
  /**  */
  notification_setting_type: number;
  /**  */
  time_mute:
    | Date
    | undefined;
  /**  */
  active: number;
}

/** Notification channel */
export interface NotifiReactMessage {
  /** Notification id */
  id: string;
  /**  */
  user_id: string;
  /**  */
  channel_id: string;
}

/**  */
export interface DefaultNotificationClan {
  /**  */
  clan_id: string;
}

/**  */
export interface DefaultNotificationCategory {
  /**  */
  category_id: string;
}

/**  */
export interface NotificationChannel {
  /**  */
  channel_id: string;
}

/**  */
export interface NotificationClan {
  /**  */
  clan_id: string;
}

/**  */
export interface NotificationSettingList {
  /** A list of notification setting. */
  notification_setting: NotificationSetting[];
}

/** set notification */
export interface SetNotificationRequest {
  /** channelId or categoryId */
  channel_category_id: string;
  /** notification_type */
  notification_type: number;
  /** time mute channel category */
  time_mute:
    | Date
    | undefined;
  /**  */
  clan_id: string;
}

/**  */
export interface PinMessageRequest {
  message_id: string;
  channel_id: string;
  clan_id: string;
}

/** set notification */
export interface SetMuteNotificationRequest {
  /** channel_id and category_id */
  id: string;
  notification_type: number;
  active: number;
}

export interface HashtagDmListRequest {
  /** user Id */
  user_id: string[];
  /** Max number of records to return. Between 1 and 100. */
  limit: number | undefined;
}

export interface HashtagDmList {
  hashtag_dm: HashtagDm[];
}

/** hashtagDM */
export interface HashtagDm {
  /** The channel id. */
  channel_id: string;
  /** The channel lable */
  channel_label: string;
  /** The clan of this channel */
  clan_id: string;
  /** The clan name */
  clan_name: string;
  /**  */
  meeting_code: string;
  /**  */
  type: number;
  /**  */
  channel_private: number;
  /**  */
  parrent_id: string;
}

export interface NotificationChannelCategorySettingList {
  notification_channel_category_settings_list: NotificationChannelCategorySetting[];
}

export interface NotificationChannelCategorySetting {
  /** Notification id */
  id: string;
  /**  */
  channel_category_label: string;
  /** Notification title */
  notification_setting_type: number;
  /**  */
  channel_category_title: string;
  /**  */
  action: number;
}

/** set default notification */
export interface SetDefaultNotificationRequest {
  clan_id: string;
  notification_type: number;
  category_id: string;
}

/** A list of role description, usually a result of a list operation. */
export interface RoleList {
  /** A list of role. */
  roles: Role[];
  /** The cursor to send when retrieving the next page, if any. */
  next_cursor: string;
  /** The cursor to send when retrieving the previous page, if any. */
  prev_cursor: string;
  /** Cacheable cursor to list newer role description. Durable and designed to be stored, unlike next/prev cursors. */
  cacheable_cursor: string;
}

export interface EventList {
  /** A list of event. */
  events: EventManagement[];
}

/** A list of permission description, usually a result of a list operation. */
export interface PermissionList {
  /** A list of permission. */
  permissions: Permission[];
  /** level permission max */
  max_level_permission: number;
}

/** List (and optionally filter) permissions. */
export interface ListPermissionsRequest {
  role_id: string;
}

/** List (and optionally filter) role-users. */
export interface ListRoleUsersRequest {
  role_id: string;
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** An optional next page cursor. */
  cursor: string;
}

/** List Permission Of User In The Clan. */
export interface ListPermissionOfUsersRequest {
  /** clan_id. */
  clan_id: string;
  /** channel_id */
  channel_id: string;
}

export interface RoleUserList {
  /** role_users pairs for a clan. */
  role_users: RoleUserList_RoleUser[];
  /** Cursor for the next page of results, if any. */
  cursor: string;
}

/** A single user-role pair. */
export interface RoleUserList_RoleUser {
  /** The id of the user's account. */
  id: string;
  /** The username of the user's account. */
  username: string;
  /** The display name of the user. */
  display_name: string;
  /** A URL for an avatar image. */
  avatar_url: string;
  /** The language expected to be a tag which follows the BCP-47 spec. */
  lang_tag: string;
  /** The location set by the user. */
  location: string;
  /** The timezone set by the user. */
  online: boolean;
}

export interface EventUserList {
  user_event: EventUserList_EventUser[];
}

export interface EventUserList_EventUser {
  /** The id of the user's account. */
  id: string;
  /** The username of the user's account. */
  username: string;
  /** The display name of the user. */
  display_name: string;
  /** A URL for an avatar image. */
  avatar_url: string;
}

export interface ListEventsRequest {
  /** The clan of this event */
  clan_id: string;
}

/** Create a role within clan. */
export interface CreateRoleRequest {
  title: string;
  color: string;
  role_icon: string;
  description: string;
  clan_id: string;
  display_online: number;
  allow_mention: number;
  /** id of permission which has max level permission */
  max_permission_id: string;
  /** The users to add. */
  add_user_ids: string[];
  /** The permissions to add. */
  active_permission_ids: string[];
}

/** Create a event within clan. */
export interface CreateEventRequest {
  title: string;
  logo: string;
  description: string;
  clan_id: string;
  channel_id: string;
  address: string;
  start_time: Date | undefined;
  end_time: Date | undefined;
  event_id: string;
  event_status: string;
}

/** update a event within clan. */
export interface UpdateEventRequest {
  title: string;
  logo: string;
  description: string;
  event_id: string;
  channel_id: string;
  address: string;
  start_time: Date | undefined;
  end_time: Date | undefined;
  clan_id: string;
  creator_id: string;
}

/** Delete a role the user has access to. */
export interface DeleteRoleRequest {
  /** The id of a role. */
  role_id: string;
  /** The id of a channel */
  channel_id: string;
  /** clan_id */
  clan_id: string;
}

export interface DeleteEventRequest {
  /** The id of a event. */
  event_id: string;
  /** clan id */
  clan_id: string;
  /** creator id */
  creator_id: string;
}

/** Update fields in a given role. */
export interface UpdateRoleRequest {
  /** The ID of the role to update. */
  role_id: string;
  title: string | undefined;
  color: string | undefined;
  role_icon: string | undefined;
  description: string | undefined;
  display_online: number | undefined;
  allow_mention:
    | number
    | undefined;
  /** The users to add. */
  add_user_ids: string[];
  /** The permissions to add. */
  active_permission_ids: string[];
  /** The users to remove. */
  remove_user_ids: string[];
  /** The permissions to remove. */
  remove_permission_ids: string[];
  /** the clan id */
  clan_id: string;
  /** id of permission which has max level permission */
  max_permission_id: string;
}

export interface UpdateRoleChannelRequest {
  /** The ID of the role to update. */
  role_id: string;
  /** The permissions to add. */
  permission_update: PermissionUpdate[];
  /** id of permission which has max level permission */
  max_permission_id: string;
  /** The channel_id */
  channel_id: string;
  /** The ID of the role to update. */
  user_id: string;
}

export interface PermissionUpdate {
  /** permission_id */
  permission_id: string;
  /** permission slug */
  slug: string;
  /** type set permission */
  type: number;
}

export interface UploadAttachmentRequest {
  /** The name of file that need to upload */
  filename: string;
  /** The type of file that need to upload */
  filetype: string;
  /** The size of file that need to upload */
  size: number;
  /** width */
  width: number;
  /** Height */
  height: number;
}

export interface ListMessageMentionRequest {
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** True if listing should be older messages to newer, false if reverse. */
  forward:
    | boolean
    | undefined;
  /** A pagination cursor, if any. */
  cursor: string;
}

export interface UploadAttachment {
  /** The name of file that need to upload */
  filename: string;
  /** The url */
  url: string;
}

export interface SearchMessageRequest {
  filters: FilterParam[];
  /** Offset value */
  from:
    | number
    | undefined;
  /** Page size */
  size:
    | number
    | undefined;
  /** Sort information */
  sorts: SortParam[];
}

export interface SortParam {
  /** Field name to sort by */
  field_name: string;
  /** Sort order */
  order: string;
}

export interface FilterParam {
  /** Field name to filter by */
  field_name: string;
  /** Filter value */
  field_value: string;
}

export interface SearchMessageDocument {
  /** The message ID. */
  message_id: string;
  /** The channel ID. */
  channel_id: number;
  /** The clan ID. */
  clan_id: number;
  /** The user ID of sender. */
  sender_id: number;
  /** Message content */
  content: string;
  /** Mention users */
  mention: string;
  /** Reactions */
  reaction: string;
  /** Attachment */
  attachments: MessageAttachment[];
  /** Reference users */
  reference: string;
  /** Message create time */
  create_time: string;
  /** Message update time */
  update_time: string;
  /** Channel name */
  channel_label: string;
  /** Channel type */
  channel_type: number;
  /** Clan name */
  clan_name: string;
  /** Sender's username */
  username: string;
  /** Sender's display name */
  display_name: string;
  /** Sender's avatar URL */
  avatar_url: string;
}

export interface SearchMessageResponse {
  /** List of paged messages. */
  messages: SearchMessageDocument[];
  /** The total number of messages. */
  total: number;
}

export interface RegistrationEmailRequest {
  /** A valid RFC-5322 email address. */
  email: string;
  /** A password for the user account. */
  password: string;
  /** Set the username on the account at register. Must be unique. */
  username: string;
  /** Display name */
  display_name: string;
  /** Avatar url */
  avatar_url: string;
  /** DOB */
  dob: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface RegistrationEmailRequest_VarsEntry {
  key: string;
  value: string;
}

export interface ClanEmoji {
  id: string;
  /** src url */
  src: string;
  /** shortname */
  shortname: string;
  /** category */
  category: string;
  /** creator id */
  creator_id: string;
  /** clan_id */
  clan_id: string;
  /** clan logo */
  logo: string;
  /** clan name */
  clan_name: string;
}

export interface EmojiListedResponse {
  emoji_list: ClanEmoji[];
}

export interface StickerListedResponse {
  stickers: ClanSticker[];
}

export interface ClanSticker {
  id: string;
  source: string;
  shortname: string;
  category: string;
  creator_id: string;
  create_time: Date | undefined;
  clan_id: string;
  logo: string;
  clan_name: string;
}

export interface AllUsersAddChannelRequest {
  channel_id: string;
  limit: number | undefined;
}

export interface AllUsersAddChannelResponse {
  channel_id: string;
  user_ids: string[];
  limit: number | undefined;
}

export interface ClanEmojiCreateRequest {
  clan_id: string;
  source: string;
  shortname: string;
  category: string;
  id: string;
}

export interface ClanEmojiGetByClanIdRequest {
  clan_id: string;
}

export interface ClanEmojiDeleteRequest {
  id: string;
  clan_id: string;
}

export interface ClanEmojiUpdateRequest {
  id: string;
  shortname: string;
  clan_id: string;
}

export interface Webhook {
  id: string;
  webhook_name: string;
  channel_id: string;
  active: number;
  /** URL of the webhook, which is automatically generated and different from the avatar */
  url: string;
  creator_id: string;
  create_time: string;
  update_time: string;
  avatar: string;
}

export interface WebhookCreateRequest {
  webhook_name: string;
  channel_id: string;
  avatar: string;
  clan_id: string;
}

export interface WebhookListRequestById {
  id: string;
}

export interface WebhookUpdateRequestById {
  /** webhook Id */
  id: string;
  /** webhook name */
  webhook_name: string;
  /** change channel_id of webhook */
  channel_id_update: string;
  /** webhook avatar */
  avatar: string;
  /** channel id */
  channel_id: string;
  /** clan id */
  clan_id: string;
}

export interface WebhookDeleteRequestById {
  id: string;
  clan_id: string;
  channel_id: string;
}

export interface WebhookListRequest {
  channel_id: string;
  clan_id: string;
}

export interface WebhookListResponse {
  webhooks: Webhook[];
}

export interface WebhookGenerateResponse {
  url: string;
  hook_name: string;
  channel_id: string;
  avatar: string;
}

export interface WebhookHandlerRequest {
  body: { [key: string]: any } | undefined;
  channel_id: string;
  token: string;
}

export interface CheckDuplicateClanNameRequest {
  clan_name: string;
}

export interface CheckDuplicateClanNameResponse {
  is_duplicate: boolean;
}

export interface ClanStickerAddRequest {
  source: string;
  shortname: string;
  category: string;
  clan_id: number;
  /** UNIQUE include type number */
  id: string;
}

export interface ClanStickerListByClanIdRequest {
  clan_id: string;
}

export interface ClanStickerUpdateByIdRequest {
  id: string;
  source: string;
  shortname: string;
  category: string;
  clan_id: string;
}

export interface ClanStickerDeleteRequest {
  id: string;
  clan_id: string;
}

export interface ChangeChannelCategoryRequest {
  channel_id: string;
  new_category_id: string;
}

/** App information. */
export interface App {
  /** app id */
  id: string;
  /** appname */
  appname: string;
  /** creator_id */
  creator_id: string;
  /** logo */
  applogo: string;
  /** status online */
  is_shadow: boolean;
  /** The UNIX time when the app was disabled. */
  disable_time:
    | Date
    | undefined;
  /** string token */
  token: string;
  /** role */
  role: number;
  /** about */
  about: string;
}

/** Delete a app. */
export interface AppDeleteRequest {
  /** The unique identifier of the app. */
  id: string;
  /** Record the app deletion - used for GDPR compliance. */
  record_deletion: boolean | undefined;
}

/** A list of apps. */
export interface AppList {
  /** A list of apps. */
  apps: App[];
  /** Approximate total number of apps. */
  total_count: number;
  /** Next cursor. */
  next_cursor: string;
}

/** Add a new app */
export interface AddAppRequest {
  /** The appname. */
  appname: string;
  /** The password. */
  token: string;
  /** Creator of the app. */
  creator_id: string;
  /** Role of this app. */
  role: number;
  /** Is shadow. */
  is_shadow: boolean;
}

/** List (and optionally filter) users. */
export interface ListAppsRequest {
  /** User ID or username filter. */
  filter: string;
  /** Search only recorded deletes. */
  tombstones: boolean;
  /** Cursor to start from */
  cursor: string;
}

/** Update app information. */
export interface UpdateAppRequest {
  /** User ID to update. */
  id: string;
  /** Username. */
  appname:
    | string
    | undefined;
  /** Metadata. */
  metadata:
    | string
    | undefined;
  /** Avatar URL. */
  applogo:
    | string
    | undefined;
  /** Token. */
  token:
    | string
    | undefined;
  /** about the app. */
  about: string;
}

/** The identifier for an app. */
export interface AppId {
  /** The unique identifier of the app. */
  id: string;
}

/** The identifier for an app. */
export interface AppClan {
  /** The unique identifier of the app. */
  app_id: string;
  clan_id: string;
}

/** Authenticate against the server with a device ID. */
export interface AuthenticateRequest {
  /** The App account details. */
  account: AccountApp | undefined;
}

/** Send a app token to the server. Used with authenticate/link/unlink. */
export interface AccountApp {
  /** The app id */
  appid: string;
  /** the app name */
  appname: string;
  /** The account token when create apps to access their profile API. */
  token: string;
  /** Extra information that will be bundled in the session token. */
  vars: { [key: string]: string };
}

export interface AccountApp_VarsEntry {
  key: string;
  value: string;
}

/** Delete channel messages by timestamp or/and ids. */
export interface DeleteChannelMessagesRequest {
  /** Timestamp before which messages will be deleted. */
  before:
    | Date
    | undefined;
  /** IDs of the messages to delete. */
  ids: string[];
}

export interface DeleteChannelMessagesResponse {
  /** Total number of messages deleted. */
  total: number;
}

/** System message details. */
export interface SystemMessage {
  /** ID */
  id: string;
  /** Clan ID */
  clan_id: string;
  /** Channel ID */
  channel_id: string;
  /** Welcome random */
  welcome_random: string;
  /** Welcome sticker */
  welcome_sticker: string;
  /** Boost message */
  boost_message: string;
  /** Setup tips */
  setup_tips: string;
}

/** List of system message. */
export interface SystemMessagesList {
  system_messages_list: SystemMessage[];
}

/** Request to get system message by clan and channel IDs. */
export interface SystemMessageRequest {
  /** Clan ID */
  clan_id: string;
  /** Channel ID */
  channel_id: string;
  /** Welcome random */
  welcome_random: string;
  /** Welcome sticker */
  welcome_sticker: string;
  /** Boost message */
  boost_message: string;
  /** Setup tips */
  setup_tips: string;
}

/** Request to delete a system message by clan ID. */
export interface DeleteSystemMessage {
  /** Clan ID */
  clan_id: string;
}

/** Request to get system message by clan ID. */
export interface GetSystemMessage {
  /** Clan ID */
  clan_id: string;
}

export interface DeleteCategoryOrderRequest {
  clan_id: string;
}

export interface StreamHttpCallbackRequest {
  action: string;
  client_id: string;
  ip: string;
  vhost: string;
  app: string;
  stream: string;
  param: string | undefined;
  server_id: string;
  stream_url: string;
  stream_id: string;
  page_url: string | undefined;
  tcUrl: string | undefined;
  service_id: string | undefined;
}

export interface StreamHttpCallbackResponse {
  code: number | undefined;
  msg: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface StreamingChannelUser {
  /** user join id */
  id: string;
  /** user for a channel. */
  user_id: string;
  /** channel id */
  channel_id: string;
  /** participant */
  participant: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface StreamingChannelUserList {
  /** list of voice channel user */
  streaming_channel_users: StreamingChannelUser[];
}

export interface RegisterStreamingChannelRequest {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
}

export interface RegisterStreamingChannelResponse {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** streaming url */
  streaming_url: string;
}

export interface ListStreamingChannelsRequest {
  /** clan id */
  clan_id: string;
}

export interface ListStreamingChannelsResponse {
  /** list of streaming channel */
  streaming_channels: StreamingChannelResponse[];
}

export interface StreamingChannelResponse {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** stream url */
  streaming_url: string;
  /** status */
  is_streaming: boolean;
}

export interface GiveCoffeeEvent {
  /** sender id */
  sender_id: string;
  /** receiver id */
  receiver_id: string;
  /** token count */
  token_count: number;
  /** message_ref */
  message_ref_id: string;
  /** chanel id */
  channel_id: string;
  /** clan id */
  clan_id: string;
}

export interface ListChannelAppsRequest {
  /** clan id */
  clan_id: string;
}

export interface ListChannelAppsResponse {
  /** list of channel apps */
  channel_apps: ChannelAppResponse[];
}

export interface ChannelAppResponse {
  /** id */
  id: string;
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** app id */
  app_id: string;
  /** app url */
  url: string;
}

export interface AllUserClans {
  users: User[];
}

export interface RoleListEventRequest {
  /** clan id */
  clan_id: string;
  /** limit */
  limit: string;
  /** state */
  state: string;
  /** cursor */
  cursor: string;
}

export interface RoleListEventResponse {
  /** limit */
  limit: string;
  /** state */
  state: string;
  /** cursor */
  cursor: string;
  /** clan_id */
  clanId: string;
  /** list of roles */
  roles: RoleList | undefined;
}

export interface UserPermissionInChannelListRequest {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
}

export interface UserPermissionInChannelListResponse {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** A list of permission. */
  permissions: PermissionList | undefined;
}

/** Permission role channel */
export interface PermissionRoleChannel {
  /** permission id */
  permission_id: string;
  /** active */
  active: boolean;
}

export interface PermissionRoleChannelListEventRequest {
  /** role id */
  role_id: string;
  /** channel id */
  channel_id: string;
  /** user id */
  user_id: string;
}

/** List of permission role channel */
export interface PermissionRoleChannelListEventResponse {
  /** role id */
  role_id: string;
  /** channel id */
  channel_id: string;
  /** user id */
  user_id: string;
  /** list of permission role channel */
  permission_role_channel: PermissionRoleChannel[];
}

export interface ChannelSettingListRequest {
  /** clan id */
  clan_id: string;
  /** parent id of thread */
  parent_id: string;
  /** category id */
  category_id: string;
  /** is private channel */
  privateChannel:
    | number
    | undefined;
  /** is active */
  active:
    | number
    | undefined;
  /** status */
  status:
    | number
    | undefined;
  /** type */
  type:
    | number
    | undefined;
  /** limit */
  limit:
    | number
    | undefined;
  /** page */
  page:
    | number
    | undefined;
  /** channel label */
  channel_label: string;
}

export interface ChannelSettingItem {
  /** channel id */
  id: string;
  /** creator id */
  creator_id: string;
  /** parentId */
  parent_id: string;
  /** label of channel */
  channel_label: string;
  /** category id */
  category_id: string;
  /** meeting code */
  meeting_code: string;
  /** channel private */
  channel_private: number;
  /** channel type */
  channel_type: number;
  /** is active */
  active: number;
  /** list user in channel */
  user_ids: string[];
  /** message count */
  message_count: number;
  /** last sent message */
  last_sent_message: ChannelMessageHeader | undefined;
}

export interface ChannelSettingListResponse {
  /** clan id */
  clan_id: string;
  /** channel count */
  channel_count: number;
  /** thread count */
  thread_count: number;
  /** channel setting list */
  channel_setting_list: ChannelSettingItem[];
}

export interface MarkAsReadRequest {
  /** channel id */
  channel_id: string;
  /** category_id */
  category_id: string;
  /** clan id */
  clan_id: string;
}

export interface EditChannelCanvasRequest {
  /** id */
  id:
    | string
    | undefined;
  /** channel id */
  channel_id: string;
  /** clan id */
  clan_id: string;
  /** title */
  title: string;
  /** content */
  content: string;
  /** is default */
  is_default: boolean;
}

export interface EditChannelCanvasResponse {
  /** id */
  id: string;
}

export interface DeleteChannelCanvasRequest {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** canvas id */
  canvas_id: string;
}

export interface ChannelCanvasListRequest {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** limit */
  limit:
    | number
    | undefined;
  /** page */
  page: number | undefined;
}

export interface ChannelCanvasItem {
  /** id */
  id: string;
  /** title */
  title: string;
  /** is default */
  is_default: boolean;
  /** content */
  content: string;
  /** creator */
  creator_id: string;
}

export interface ChannelCanvasListResponse {
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
  /** channel doc item */
  channel_canvases: ChannelCanvasItem[];
}

export interface ChannelCanvasDetailRequest {
  /** id */
  id: string;
  /** clan id */
  clan_id: string;
  /** channel id */
  channel_id: string;
}

export interface ChannelCanvasDetailResponse {
  /** id */
  id: string;
  /** title */
  title: string;
  /** content */
  content: string;
  /** creator */
  creator_id: string;
  /** editor */
  editor_id: string;
  /** is default */
  is_default: boolean;
}

export interface AddFavoriteChannelRequest {
  channel_id: string;
  clan_id: string;
}

export interface RemoveFavoriteChannelRequest {
  channel_id: string;
}

export interface AddFavoriteChannelResponse {
  channel_id: string;
}

export interface ListFavoriteChannelRequest {
  clan_id: string;
}

export interface ListFavoriteChannelResponse {
  channel_ids: string[];
}

export interface UserActivity {
  user_id: string;
  activity_name: string;
  activity_type: number;
  activity_description: string;
  start_time: Date | undefined;
  end_time: Date | undefined;
  application_id: string;
  status: number;
}

export interface ListUserActivity {
  activities: UserActivity[];
}

export interface CreateActivityRequest {
  activity_name: string;
  activity_type: number;
  activity_description: string;
  start_time: Date | undefined;
  application_id: string;
  status: number;
}

export interface LoginIDResponse {
  /** loginId */
  login_id: string;
  /** status login */
  status: number;
  /** create time */
  create_time_second: number;
  /** platform */
  platform: string;
  /** user_id */
  user_id: number;
  /** user_name */
  user_name: string;
  /** address */
  address: string;
}

export interface LoginRequest {
  /** platform */
  platform: string;
  /** address */
  address: string;
}

export interface ConfirmLoginRequest {
  /** loginId */
  login_id: string;
}

export interface SendTokenRequest {
  /** receiver */
  receiver_id: string;
  /** amount of token */
  amount: number;
}

export interface PubKey {
  encr: Uint8Array;
  sign: Uint8Array;
}

export interface PushPubKeyRequest {
  PK: PubKey | undefined;
}

export interface GetPubKeysRequest {
  user_ids: string[];
}

export interface GetPubKeysResponse {
  pub_keys: GetPubKeysResponse_UserPubKey[];
}

export interface GetPubKeysResponse_UserPubKey {
  user_id: string;
  PK: PubKey | undefined;
}

export interface ChanEncryptionMethod {
  method: string;
  channel_id: string;
}

export interface GetKeyServerResp {
  url: string;
}

export interface AuditLog {
  id: string;
  user_id: string;
  clan_id: string;
  action_log: string;
  entity_name: string;
  entity_id: string;
  details: string;
  time_log: Date | undefined;
  channel_id: string;
  channel_label: string;
}

export interface ListAuditLog {
  total_count: number;
  date_log: string;
  logs: AuditLog[];
}

export interface ListAuditLogRequest {
  action_log: string;
  user_id: string;
  clan_id: string;
  date_log: string;
}

export interface TokenSentEvent {
  /** sender id */
  sender_id: string;
  /** sender name */
  sender_name: string;
  /** receiver */
  receiver_id: string;
  /** amount of token */
  amount: number;
  /** note */
  note: string;
}

export interface WithdrawTokenRequest {
  /** amount of token */
  amount: number;
}

export interface ListOnboardingRequest {
  /** clan id */
  clan_id: string;
  /** guide_type: 0 = greeting, 1 = rule, 2 = task, 3 = question */
  guide_type:
    | number
    | undefined;
  /** limit */
  limit:
    | number
    | undefined;
  /** page */
  page: number | undefined;
}

export interface ListOnboardingResponse {
  list_onboarding: OnboardingItem[];
}

export interface OnboardingItem {
  /** id */
  id: string;
  /** clan id */
  clan_id: string;
  /** guide_type: 0 = greeting, 1 = rule, 2 = task, 3 = question */
  guide_type: number;
  /** task type */
  task_type: number;
  /** channel id */
  channel_id: string;
  /** title */
  title: string;
  /** content */
  content: string;
  /** image */
  image_url: string;
  /** answers */
  answers: OnboardingAnswer[];
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time:
    | Date
    | undefined;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated. */
  update_time: Date | undefined;
}

export interface OnboardingAnswer {
  /** title */
  title: string;
  /** description */
  description: string;
  /** emoji */
  emoji: string;
  /** image */
  image_url: string;
}

export interface OnboardingContent {
  /** guide type */
  guide_type: number;
  /** task type */
  task_type: number;
  /** channel id */
  channel_id: string;
  /** title */
  title: string;
  /** content */
  content: string;
  /** image */
  image_url: string;
  /** answers */
  answers: OnboardingAnswer[];
}

export interface CreateOnboardingRequest {
  /** clan id */
  clan_id: string;
  /** contents */
  contents: OnboardingContent[];
}

export interface UpdateOnboardingRequest {
  /** id */
  id: string;
  /** clan id */
  clan_id: string;
  /** task type */
  task_type:
    | number
    | undefined;
  /** channel id */
  channel_id: string;
  /** title */
  title: string;
  /** content */
  content: string;
  /** image */
  image_url: string;
  /** answers */
  answers: OnboardingAnswer[];
}

export interface OnboardingRequest {
  /** id */
  id: string;
  /** clan id */
  clan_id: string;
}

export interface ClanWebhook {
  /** id. */
  id: string;
  /** webhook name. */
  webhook_name: string;
  /** clan id. */
  clan_id: string;
  /** active. */
  active: number;
  /** URL of the webhook, which is automatically generated and different from the avatar. */
  url: string;
  /** creator id. */
  creator_id: string;
  /** avatar */
  avatar: string;
  /** create time. */
  create_time: string;
  /** update time. */
  update_time: string;
}

export interface GenerateClanWebhookRequest {
  /** clan id. */
  clan_id: string;
  /** webhook name. */
  webhook_name: string;
  /** avatar. */
  avatar: string;
}

export interface GenerateClanWebhookResponse {
  /** clan id. */
  clan_id: string;
  /** url. */
  url: string;
  /** webhook name. */
  webhook_name: string;
  /** avatar. */
  avatar: string;
}

export interface ClanWebhookRequest {
  /** id. */
  id: string;
  /** clan id. */
  clan_id: string;
}

export interface UpdateClanWebhookRequest {
  /** webhook id. */
  id: string;
  /** clan id. */
  clan_id: string;
  /** webhook name. */
  webhook_name: string;
  /** avatar. */
  avatar: string;
  /** reset token. */
  reset_token: boolean;
}

export interface ListClanWebhookRequest {
  /** clan_id. */
  clan_id: string;
}

export interface ListClanWebhookResponse {
  /** list clan webhook. */
  list_clan_webhooks: ClanWebhook[];
}

export interface ClanWebhookHandlerBody {
  /** content */
  content: string;
  /** list clan webhook. */
  attachments: MessageAttachment[];
}

export interface ClanWebhookHandlerRequest {
  /** body. */
  body:
    | ClanWebhookHandlerBody
    | undefined;
  /** token. */
  token: string;
  /** username. */
  username: string;
}

export interface UserStatus {
  user_id: string;
  status: string;
}

export interface UserStatusUpdate {
  status: string;
  minutes: number;
  until_turn_on: boolean;
}

export interface OnboardingSteps {
  /** id. */
  id: string;
  /** user id. */
  user_id: string;
  /** clan id. */
  clan_id: string;
  /** onboarding step. */
  onboarding_step: number;
}

export interface ListOnboardingStepResponse {
  /** list onboarding steps. */
  list_onboarding_step: OnboardingSteps[];
}

export interface ListOnboardingStepRequest {
  /** clan id. */
  clan_id: string;
  /** limit */
  limit:
    | number
    | undefined;
  /** page */
  page: number | undefined;
}

export interface UpdateOnboardingStepRequest {
  /** clan id. */
  clan_id: string;
  /** onboarding step. */
  onboarding_step: number | undefined;
}

/** A list of users belonging to a channel, along with their role. */
export interface PTTChannelUser {
  /** user join id */
  id: string;
  /** user for a channel. */
  user_id: string;
  /** channel id */
  channel_id: string;
  /** participant */
  participant: string;
}

/** A list of users belonging to a channel, along with their role. */
export interface PTTChannelUserList {
  /** list of ptt channel user */
  ptt_channel_users: PTTChannelUser[];
}

export interface WalletLedger {
  /** change set id */
  id: string;
  /** user id */
  user_id: string;
  /** create time */
  create_time:
    | Date
    | undefined;
  /** value */
  value: number;
  /** transaction id */
  transaction_id: string;
}

export interface WalletLedgerList {
  wallet_ledger: WalletLedger[];
  prev_cursor: string;
  next_cursor: string;
}

export interface WalletLedgerListReq {
  limit: number | undefined;
  cursor: string;
  transaction_id: string;
}

export interface SdTopic {
  id: string;
  creator_id: string;
  message_id: string;
  clan_id: string;
  channel_id: string;
  status: number;
  create_time: Date | undefined;
  update_time: Date | undefined;
  message: ChannelMessage | undefined;
}

export interface SdTopicRequest {
  message_id: string;
  clan_id: string;
  channel_id: string;
}

export interface SdTopicList {
  count: number;
  topics: SdTopic[];
}

export interface ListSdTopicRequest {
  channel_id: string;
  limit: number;
}

export interface SdTopicDetailRequest {
  topic_id: string;
}

export interface DeleteSdTopicRequest {
  channel_id: string;
  id: string;
  clan_id: string;
}

function createBaseAccount(): Account {
  return {
    user: undefined,
    wallet: "",
    email: "",
    devices: [],
    custom_id: "",
    verify_time: undefined,
    disable_time: undefined,
    logo: "",
    splash_screen: "",
  };
}

export const Account = {
  encode(message: Account, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.wallet !== "") {
      writer.uint32(18).string(message.wallet);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    for (const v of message.devices) {
      AccountDevice.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.custom_id !== "") {
      writer.uint32(42).string(message.custom_id);
    }
    if (message.verify_time !== undefined) {
      Timestamp.encode(toTimestamp(message.verify_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.disable_time !== undefined) {
      Timestamp.encode(toTimestamp(message.disable_time), writer.uint32(58).fork()).ldelim();
    }
    if (message.logo !== "") {
      writer.uint32(66).string(message.logo);
    }
    if (message.splash_screen !== "") {
      writer.uint32(74).string(message.splash_screen);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wallet = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.devices.push(AccountDevice.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.custom_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.verify_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.disable_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.splash_screen = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      wallet: isSet(object.wallet) ? globalThis.String(object.wallet) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      devices: globalThis.Array.isArray(object?.devices)
        ? object.devices.map((e: any) => AccountDevice.fromJSON(e))
        : [],
      custom_id: isSet(object.custom_id) ? globalThis.String(object.custom_id) : "",
      verify_time: isSet(object.verify_time) ? fromJsonTimestamp(object.verify_time) : undefined,
      disable_time: isSet(object.disable_time) ? fromJsonTimestamp(object.disable_time) : undefined,
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      splash_screen: isSet(object.splash_screen) ? globalThis.String(object.splash_screen) : "",
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.wallet !== "") {
      obj.wallet = message.wallet;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => AccountDevice.toJSON(e));
    }
    if (message.custom_id !== "") {
      obj.custom_id = message.custom_id;
    }
    if (message.verify_time !== undefined) {
      obj.verify_time = message.verify_time.toISOString();
    }
    if (message.disable_time !== undefined) {
      obj.disable_time = message.disable_time.toISOString();
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.splash_screen !== "") {
      obj.splash_screen = message.splash_screen;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account>, I>>(base?: I): Account {
    return Account.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account>, I>>(object: I): Account {
    const message = createBaseAccount();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.wallet = object.wallet ?? "";
    message.email = object.email ?? "";
    message.devices = object.devices?.map((e) => AccountDevice.fromPartial(e)) || [];
    message.custom_id = object.custom_id ?? "";
    message.verify_time = object.verify_time ?? undefined;
    message.disable_time = object.disable_time ?? undefined;
    message.logo = object.logo ?? "";
    message.splash_screen = object.splash_screen ?? "";
    return message;
  },
};

function createBaseAccountRefresh(): AccountRefresh {
  return { token: "", vars: {} };
}

export const AccountRefresh = {
  encode(message: AccountRefresh, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountRefresh_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountRefresh {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountRefresh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountRefresh_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountRefresh {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountRefresh): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountRefresh>, I>>(base?: I): AccountRefresh {
    return AccountRefresh.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountRefresh>, I>>(object: I): AccountRefresh {
    const message = createBaseAccountRefresh();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountRefresh_VarsEntry(): AccountRefresh_VarsEntry {
  return { key: "", value: "" };
}

export const AccountRefresh_VarsEntry = {
  encode(message: AccountRefresh_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountRefresh_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountRefresh_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountRefresh_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountRefresh_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountRefresh_VarsEntry>, I>>(base?: I): AccountRefresh_VarsEntry {
    return AccountRefresh_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountRefresh_VarsEntry>, I>>(object: I): AccountRefresh_VarsEntry {
    const message = createBaseAccountRefresh_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountApple(): AccountApple {
  return { token: "", vars: {} };
}

export const AccountApple = {
  encode(message: AccountApple, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountApple_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountApple {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountApple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountApple_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountApple {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountApple): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountApple>, I>>(base?: I): AccountApple {
    return AccountApple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountApple>, I>>(object: I): AccountApple {
    const message = createBaseAccountApple();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountApple_VarsEntry(): AccountApple_VarsEntry {
  return { key: "", value: "" };
}

export const AccountApple_VarsEntry = {
  encode(message: AccountApple_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountApple_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountApple_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountApple_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountApple_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountApple_VarsEntry>, I>>(base?: I): AccountApple_VarsEntry {
    return AccountApple_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountApple_VarsEntry>, I>>(object: I): AccountApple_VarsEntry {
    const message = createBaseAccountApple_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountCustom(): AccountCustom {
  return { id: "", vars: {} };
}

export const AccountCustom = {
  encode(message: AccountCustom, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountCustom_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountCustom {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountCustom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountCustom_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountCustom {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountCustom): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountCustom>, I>>(base?: I): AccountCustom {
    return AccountCustom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountCustom>, I>>(object: I): AccountCustom {
    const message = createBaseAccountCustom();
    message.id = object.id ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountCustom_VarsEntry(): AccountCustom_VarsEntry {
  return { key: "", value: "" };
}

export const AccountCustom_VarsEntry = {
  encode(message: AccountCustom_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountCustom_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountCustom_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountCustom_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountCustom_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountCustom_VarsEntry>, I>>(base?: I): AccountCustom_VarsEntry {
    return AccountCustom_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountCustom_VarsEntry>, I>>(object: I): AccountCustom_VarsEntry {
    const message = createBaseAccountCustom_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountDevice(): AccountDevice {
  return { id: "", vars: {} };
}

export const AccountDevice = {
  encode(message: AccountDevice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountDevice_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountDevice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountDevice_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDevice {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountDevice): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountDevice>, I>>(base?: I): AccountDevice {
    return AccountDevice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountDevice>, I>>(object: I): AccountDevice {
    const message = createBaseAccountDevice();
    message.id = object.id ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountDevice_VarsEntry(): AccountDevice_VarsEntry {
  return { key: "", value: "" };
}

export const AccountDevice_VarsEntry = {
  encode(message: AccountDevice_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountDevice_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDevice_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDevice_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountDevice_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountDevice_VarsEntry>, I>>(base?: I): AccountDevice_VarsEntry {
    return AccountDevice_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountDevice_VarsEntry>, I>>(object: I): AccountDevice_VarsEntry {
    const message = createBaseAccountDevice_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountEmail(): AccountEmail {
  return { email: "", password: "", vars: {} };
}

export const AccountEmail = {
  encode(message: AccountEmail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountEmail_VarsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountEmail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = AccountEmail_VarsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.vars[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountEmail {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountEmail): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountEmail>, I>>(base?: I): AccountEmail {
    return AccountEmail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountEmail>, I>>(object: I): AccountEmail {
    const message = createBaseAccountEmail();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountEmail_VarsEntry(): AccountEmail_VarsEntry {
  return { key: "", value: "" };
}

export const AccountEmail_VarsEntry = {
  encode(message: AccountEmail_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountEmail_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountEmail_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountEmail_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountEmail_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountEmail_VarsEntry>, I>>(base?: I): AccountEmail_VarsEntry {
    return AccountEmail_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountEmail_VarsEntry>, I>>(object: I): AccountEmail_VarsEntry {
    const message = createBaseAccountEmail_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountFacebook(): AccountFacebook {
  return { token: "", vars: {} };
}

export const AccountFacebook = {
  encode(message: AccountFacebook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountFacebook_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountFacebook {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountFacebook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountFacebook_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountFacebook {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountFacebook): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountFacebook>, I>>(base?: I): AccountFacebook {
    return AccountFacebook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountFacebook>, I>>(object: I): AccountFacebook {
    const message = createBaseAccountFacebook();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountFacebook_VarsEntry(): AccountFacebook_VarsEntry {
  return { key: "", value: "" };
}

export const AccountFacebook_VarsEntry = {
  encode(message: AccountFacebook_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountFacebook_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountFacebook_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountFacebook_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountFacebook_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountFacebook_VarsEntry>, I>>(base?: I): AccountFacebook_VarsEntry {
    return AccountFacebook_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountFacebook_VarsEntry>, I>>(object: I): AccountFacebook_VarsEntry {
    const message = createBaseAccountFacebook_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountFacebookInstantGame(): AccountFacebookInstantGame {
  return { signed_player_info: "", vars: {} };
}

export const AccountFacebookInstantGame = {
  encode(message: AccountFacebookInstantGame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signed_player_info !== "") {
      writer.uint32(10).string(message.signed_player_info);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountFacebookInstantGame_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountFacebookInstantGame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountFacebookInstantGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signed_player_info = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountFacebookInstantGame_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountFacebookInstantGame {
    return {
      signed_player_info: isSet(object.signed_player_info) ? globalThis.String(object.signed_player_info) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountFacebookInstantGame): unknown {
    const obj: any = {};
    if (message.signed_player_info !== "") {
      obj.signed_player_info = message.signed_player_info;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountFacebookInstantGame>, I>>(base?: I): AccountFacebookInstantGame {
    return AccountFacebookInstantGame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountFacebookInstantGame>, I>>(object: I): AccountFacebookInstantGame {
    const message = createBaseAccountFacebookInstantGame();
    message.signed_player_info = object.signed_player_info ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountFacebookInstantGame_VarsEntry(): AccountFacebookInstantGame_VarsEntry {
  return { key: "", value: "" };
}

export const AccountFacebookInstantGame_VarsEntry = {
  encode(message: AccountFacebookInstantGame_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountFacebookInstantGame_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountFacebookInstantGame_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountFacebookInstantGame_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountFacebookInstantGame_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountFacebookInstantGame_VarsEntry>, I>>(
    base?: I,
  ): AccountFacebookInstantGame_VarsEntry {
    return AccountFacebookInstantGame_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountFacebookInstantGame_VarsEntry>, I>>(
    object: I,
  ): AccountFacebookInstantGame_VarsEntry {
    const message = createBaseAccountFacebookInstantGame_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountGameCenter(): AccountGameCenter {
  return { player_id: "", bundle_id: "", timestamp_seconds: 0, salt: "", signature: "", public_key_url: "", vars: {} };
}

export const AccountGameCenter = {
  encode(message: AccountGameCenter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.player_id !== "") {
      writer.uint32(10).string(message.player_id);
    }
    if (message.bundle_id !== "") {
      writer.uint32(18).string(message.bundle_id);
    }
    if (message.timestamp_seconds !== 0) {
      writer.uint32(24).int64(message.timestamp_seconds);
    }
    if (message.salt !== "") {
      writer.uint32(34).string(message.salt);
    }
    if (message.signature !== "") {
      writer.uint32(42).string(message.signature);
    }
    if (message.public_key_url !== "") {
      writer.uint32(50).string(message.public_key_url);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountGameCenter_VarsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountGameCenter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountGameCenter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.player_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bundle_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp_seconds = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.salt = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.public_key_url = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = AccountGameCenter_VarsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.vars[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountGameCenter {
    return {
      player_id: isSet(object.player_id) ? globalThis.String(object.player_id) : "",
      bundle_id: isSet(object.bundle_id) ? globalThis.String(object.bundle_id) : "",
      timestamp_seconds: isSet(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,
      salt: isSet(object.salt) ? globalThis.String(object.salt) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      public_key_url: isSet(object.public_key_url) ? globalThis.String(object.public_key_url) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountGameCenter): unknown {
    const obj: any = {};
    if (message.player_id !== "") {
      obj.player_id = message.player_id;
    }
    if (message.bundle_id !== "") {
      obj.bundle_id = message.bundle_id;
    }
    if (message.timestamp_seconds !== 0) {
      obj.timestamp_seconds = Math.round(message.timestamp_seconds);
    }
    if (message.salt !== "") {
      obj.salt = message.salt;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.public_key_url !== "") {
      obj.public_key_url = message.public_key_url;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountGameCenter>, I>>(base?: I): AccountGameCenter {
    return AccountGameCenter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountGameCenter>, I>>(object: I): AccountGameCenter {
    const message = createBaseAccountGameCenter();
    message.player_id = object.player_id ?? "";
    message.bundle_id = object.bundle_id ?? "";
    message.timestamp_seconds = object.timestamp_seconds ?? 0;
    message.salt = object.salt ?? "";
    message.signature = object.signature ?? "";
    message.public_key_url = object.public_key_url ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountGameCenter_VarsEntry(): AccountGameCenter_VarsEntry {
  return { key: "", value: "" };
}

export const AccountGameCenter_VarsEntry = {
  encode(message: AccountGameCenter_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountGameCenter_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountGameCenter_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountGameCenter_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountGameCenter_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountGameCenter_VarsEntry>, I>>(base?: I): AccountGameCenter_VarsEntry {
    return AccountGameCenter_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountGameCenter_VarsEntry>, I>>(object: I): AccountGameCenter_VarsEntry {
    const message = createBaseAccountGameCenter_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountGoogle(): AccountGoogle {
  return { token: "", vars: {} };
}

export const AccountGoogle = {
  encode(message: AccountGoogle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountGoogle_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountGoogle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountGoogle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountGoogle_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountGoogle {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountGoogle): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountGoogle>, I>>(base?: I): AccountGoogle {
    return AccountGoogle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountGoogle>, I>>(object: I): AccountGoogle {
    const message = createBaseAccountGoogle();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountGoogle_VarsEntry(): AccountGoogle_VarsEntry {
  return { key: "", value: "" };
}

export const AccountGoogle_VarsEntry = {
  encode(message: AccountGoogle_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountGoogle_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountGoogle_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountGoogle_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountGoogle_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountGoogle_VarsEntry>, I>>(base?: I): AccountGoogle_VarsEntry {
    return AccountGoogle_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountGoogle_VarsEntry>, I>>(object: I): AccountGoogle_VarsEntry {
    const message = createBaseAccountGoogle_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccountSteam(): AccountSteam {
  return { token: "", vars: {} };
}

export const AccountSteam = {
  encode(message: AccountSteam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountSteam_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountSteam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSteam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AccountSteam_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSteam {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountSteam): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSteam>, I>>(base?: I): AccountSteam {
    return AccountSteam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSteam>, I>>(object: I): AccountSteam {
    const message = createBaseAccountSteam();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountSteam_VarsEntry(): AccountSteam_VarsEntry {
  return { key: "", value: "" };
}

export const AccountSteam_VarsEntry = {
  encode(message: AccountSteam_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountSteam_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSteam_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSteam_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountSteam_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSteam_VarsEntry>, I>>(base?: I): AccountSteam_VarsEntry {
    return AccountSteam_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSteam_VarsEntry>, I>>(object: I): AccountSteam_VarsEntry {
    const message = createBaseAccountSteam_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAddFriendsRequest(): AddFriendsRequest {
  return { ids: [], usernames: [] };
}

export const AddFriendsRequest = {
  encode(message: AddFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFriendsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AddFriendsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFriendsRequest>, I>>(base?: I): AddFriendsRequest {
    return AddFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddFriendsRequest>, I>>(object: I): AddFriendsRequest {
    const message = createBaseAddFriendsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.usernames = object.usernames?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddGroupUsersRequest(): AddGroupUsersRequest {
  return { group_id: "", user_ids: [] };
}

export const AddGroupUsersRequest = {
  encode(message: AddGroupUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddGroupUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddGroupUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddGroupUsersRequest {
    return {
      group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AddGroupUsersRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddGroupUsersRequest>, I>>(base?: I): AddGroupUsersRequest {
    return AddGroupUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddGroupUsersRequest>, I>>(object: I): AddGroupUsersRequest {
    const message = createBaseAddGroupUsersRequest();
    message.group_id = object.group_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseSessionRefreshRequest(): SessionRefreshRequest {
  return { token: "", vars: {} };
}

export const SessionRefreshRequest = {
  encode(message: SessionRefreshRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      SessionRefreshRequest_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRefreshRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRefreshRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SessionRefreshRequest_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRefreshRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SessionRefreshRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRefreshRequest>, I>>(base?: I): SessionRefreshRequest {
    return SessionRefreshRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionRefreshRequest>, I>>(object: I): SessionRefreshRequest {
    const message = createBaseSessionRefreshRequest();
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSessionRefreshRequest_VarsEntry(): SessionRefreshRequest_VarsEntry {
  return { key: "", value: "" };
}

export const SessionRefreshRequest_VarsEntry = {
  encode(message: SessionRefreshRequest_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRefreshRequest_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRefreshRequest_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRefreshRequest_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SessionRefreshRequest_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRefreshRequest_VarsEntry>, I>>(base?: I): SessionRefreshRequest_VarsEntry {
    return SessionRefreshRequest_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionRefreshRequest_VarsEntry>, I>>(
    object: I,
  ): SessionRefreshRequest_VarsEntry {
    const message = createBaseSessionRefreshRequest_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSessionLogoutRequest(): SessionLogoutRequest {
  return { token: "", refresh_token: "", device_id: "", fcm_token: "" };
}

export const SessionLogoutRequest = {
  encode(message: SessionLogoutRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.refresh_token !== "") {
      writer.uint32(18).string(message.refresh_token);
    }
    if (message.device_id !== "") {
      writer.uint32(26).string(message.device_id);
    }
    if (message.fcm_token !== "") {
      writer.uint32(34).string(message.fcm_token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionLogoutRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refresh_token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.device_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fcm_token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionLogoutRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      refresh_token: isSet(object.refresh_token) ? globalThis.String(object.refresh_token) : "",
      device_id: isSet(object.device_id) ? globalThis.String(object.device_id) : "",
      fcm_token: isSet(object.fcm_token) ? globalThis.String(object.fcm_token) : "",
    };
  },

  toJSON(message: SessionLogoutRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.refresh_token !== "") {
      obj.refresh_token = message.refresh_token;
    }
    if (message.device_id !== "") {
      obj.device_id = message.device_id;
    }
    if (message.fcm_token !== "") {
      obj.fcm_token = message.fcm_token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionLogoutRequest>, I>>(base?: I): SessionLogoutRequest {
    return SessionLogoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionLogoutRequest>, I>>(object: I): SessionLogoutRequest {
    const message = createBaseSessionLogoutRequest();
    message.token = object.token ?? "";
    message.refresh_token = object.refresh_token ?? "";
    message.device_id = object.device_id ?? "";
    message.fcm_token = object.fcm_token ?? "";
    return message;
  },
};

function createBaseAuthenticateAppleRequest(): AuthenticateAppleRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateAppleRequest = {
  encode(message: AuthenticateAppleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountApple.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateAppleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateAppleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountApple.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateAppleRequest {
    return {
      account: isSet(object.account) ? AccountApple.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateAppleRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountApple.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateAppleRequest>, I>>(base?: I): AuthenticateAppleRequest {
    return AuthenticateAppleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateAppleRequest>, I>>(object: I): AuthenticateAppleRequest {
    const message = createBaseAuthenticateAppleRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountApple.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateCustomRequest(): AuthenticateCustomRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateCustomRequest = {
  encode(message: AuthenticateCustomRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountCustom.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateCustomRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateCustomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountCustom.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateCustomRequest {
    return {
      account: isSet(object.account) ? AccountCustom.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateCustomRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountCustom.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateCustomRequest>, I>>(base?: I): AuthenticateCustomRequest {
    return AuthenticateCustomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateCustomRequest>, I>>(object: I): AuthenticateCustomRequest {
    const message = createBaseAuthenticateCustomRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountCustom.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateDeviceRequest(): AuthenticateDeviceRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateDeviceRequest = {
  encode(message: AuthenticateDeviceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountDevice.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateDeviceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateDeviceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountDevice.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateDeviceRequest {
    return {
      account: isSet(object.account) ? AccountDevice.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateDeviceRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountDevice.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateDeviceRequest>, I>>(base?: I): AuthenticateDeviceRequest {
    return AuthenticateDeviceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateDeviceRequest>, I>>(object: I): AuthenticateDeviceRequest {
    const message = createBaseAuthenticateDeviceRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountDevice.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateEmailRequest(): AuthenticateEmailRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateEmailRequest = {
  encode(message: AuthenticateEmailRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountEmail.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateEmailRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountEmail.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateEmailRequest {
    return {
      account: isSet(object.account) ? AccountEmail.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateEmailRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountEmail.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateEmailRequest>, I>>(base?: I): AuthenticateEmailRequest {
    return AuthenticateEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateEmailRequest>, I>>(object: I): AuthenticateEmailRequest {
    const message = createBaseAuthenticateEmailRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountEmail.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateFacebookRequest(): AuthenticateFacebookRequest {
  return { account: undefined, create: undefined, username: "", sync: undefined };
}

export const AuthenticateFacebookRequest = {
  encode(message: AuthenticateFacebookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.sync !== undefined) {
      BoolValue.encode({ value: message.sync! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateFacebookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateFacebookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountFacebook.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sync = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateFacebookRequest {
    return {
      account: isSet(object.account) ? AccountFacebook.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      sync: isSet(object.sync) ? Boolean(object.sync) : undefined,
    };
  },

  toJSON(message: AuthenticateFacebookRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountFacebook.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.sync !== undefined) {
      obj.sync = message.sync;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateFacebookRequest>, I>>(base?: I): AuthenticateFacebookRequest {
    return AuthenticateFacebookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateFacebookRequest>, I>>(object: I): AuthenticateFacebookRequest {
    const message = createBaseAuthenticateFacebookRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountFacebook.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    message.sync = object.sync ?? undefined;
    return message;
  },
};

function createBaseAuthenticateFacebookInstantGameRequest(): AuthenticateFacebookInstantGameRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateFacebookInstantGameRequest = {
  encode(message: AuthenticateFacebookInstantGameRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountFacebookInstantGame.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateFacebookInstantGameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateFacebookInstantGameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountFacebookInstantGame.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateFacebookInstantGameRequest {
    return {
      account: isSet(object.account) ? AccountFacebookInstantGame.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateFacebookInstantGameRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountFacebookInstantGame.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateFacebookInstantGameRequest>, I>>(
    base?: I,
  ): AuthenticateFacebookInstantGameRequest {
    return AuthenticateFacebookInstantGameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateFacebookInstantGameRequest>, I>>(
    object: I,
  ): AuthenticateFacebookInstantGameRequest {
    const message = createBaseAuthenticateFacebookInstantGameRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountFacebookInstantGame.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateGameCenterRequest(): AuthenticateGameCenterRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateGameCenterRequest = {
  encode(message: AuthenticateGameCenterRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountGameCenter.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateGameCenterRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateGameCenterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountGameCenter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateGameCenterRequest {
    return {
      account: isSet(object.account) ? AccountGameCenter.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateGameCenterRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountGameCenter.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateGameCenterRequest>, I>>(base?: I): AuthenticateGameCenterRequest {
    return AuthenticateGameCenterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateGameCenterRequest>, I>>(
    object: I,
  ): AuthenticateGameCenterRequest {
    const message = createBaseAuthenticateGameCenterRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountGameCenter.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateGoogleRedirectRequest(): AuthenticateGoogleRedirectRequest {
  return { code: "" };
}

export const AuthenticateGoogleRedirectRequest = {
  encode(message: AuthenticateGoogleRedirectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateGoogleRedirectRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateGoogleRedirectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateGoogleRedirectRequest {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: AuthenticateGoogleRedirectRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateGoogleRedirectRequest>, I>>(
    base?: I,
  ): AuthenticateGoogleRedirectRequest {
    return AuthenticateGoogleRedirectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateGoogleRedirectRequest>, I>>(
    object: I,
  ): AuthenticateGoogleRedirectRequest {
    const message = createBaseAuthenticateGoogleRedirectRequest();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseAuthenticateGoogleRequest(): AuthenticateGoogleRequest {
  return { account: undefined, create: undefined, username: "" };
}

export const AuthenticateGoogleRequest = {
  encode(message: AuthenticateGoogleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountGoogle.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateGoogleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateGoogleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountGoogle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateGoogleRequest {
    return {
      account: isSet(object.account) ? AccountGoogle.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AuthenticateGoogleRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountGoogle.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateGoogleRequest>, I>>(base?: I): AuthenticateGoogleRequest {
    return AuthenticateGoogleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateGoogleRequest>, I>>(object: I): AuthenticateGoogleRequest {
    const message = createBaseAuthenticateGoogleRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountGoogle.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthenticateSteamRequest(): AuthenticateSteamRequest {
  return { account: undefined, create: undefined, username: "", sync: undefined };
}

export const AuthenticateSteamRequest = {
  encode(message: AuthenticateSteamRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.sync !== undefined) {
      BoolValue.encode({ value: message.sync! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateSteamRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateSteamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountSteam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.create = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sync = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateSteamRequest {
    return {
      account: isSet(object.account) ? AccountSteam.fromJSON(object.account) : undefined,
      create: isSet(object.create) ? Boolean(object.create) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      sync: isSet(object.sync) ? Boolean(object.sync) : undefined,
    };
  },

  toJSON(message: AuthenticateSteamRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountSteam.toJSON(message.account);
    }
    if (message.create !== undefined) {
      obj.create = message.create;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.sync !== undefined) {
      obj.sync = message.sync;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateSteamRequest>, I>>(base?: I): AuthenticateSteamRequest {
    return AuthenticateSteamRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateSteamRequest>, I>>(object: I): AuthenticateSteamRequest {
    const message = createBaseAuthenticateSteamRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountSteam.fromPartial(object.account)
      : undefined;
    message.create = object.create ?? undefined;
    message.username = object.username ?? "";
    message.sync = object.sync ?? undefined;
    return message;
  },
};

function createBaseBanGroupUsersRequest(): BanGroupUsersRequest {
  return { group_id: "", user_ids: [] };
}

export const BanGroupUsersRequest = {
  encode(message: BanGroupUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BanGroupUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBanGroupUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BanGroupUsersRequest {
    return {
      group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BanGroupUsersRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BanGroupUsersRequest>, I>>(base?: I): BanGroupUsersRequest {
    return BanGroupUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BanGroupUsersRequest>, I>>(object: I): BanGroupUsersRequest {
    const message = createBaseBanGroupUsersRequest();
    message.group_id = object.group_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseBlockFriendsRequest(): BlockFriendsRequest {
  return { ids: [], usernames: [] };
}

export const BlockFriendsRequest = {
  encode(message: BlockFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockFriendsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BlockFriendsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockFriendsRequest>, I>>(base?: I): BlockFriendsRequest {
    return BlockFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockFriendsRequest>, I>>(object: I): BlockFriendsRequest {
    const message = createBaseBlockFriendsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.usernames = object.usernames?.map((e) => e) || [];
    return message;
  },
};

function createBaseChannelMessage(): ChannelMessage {
  return {
    clan_id: "",
    channel_id: "",
    message_id: "",
    code: undefined,
    sender_id: "",
    username: "",
    avatar: "",
    content: "",
    create_time: undefined,
    update_time: undefined,
    channel_label: "",
    clan_logo: "",
    category_name: "",
    display_name: "",
    clan_nick: "",
    clan_avatar: "",
    reactions: "",
    mentions: "",
    attachments: "",
    references: "",
    referenced_message: "",
    create_time_seconds: 0,
    update_time_seconds: 0,
    mode: 0,
    hide_editted: false,
    is_public: false,
    topic_id: "",
  };
}

export const ChannelMessage = {
  encode(message: ChannelMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(26).string(message.message_id);
    }
    if (message.code !== undefined) {
      Int32Value.encode({ value: message.code! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.sender_id !== "") {
      writer.uint32(42).string(message.sender_id);
    }
    if (message.username !== "") {
      writer.uint32(50).string(message.username);
    }
    if (message.avatar !== "") {
      writer.uint32(58).string(message.avatar);
    }
    if (message.content !== "") {
      writer.uint32(66).string(message.content);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(74).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(82).fork()).ldelim();
    }
    if (message.channel_label !== "") {
      writer.uint32(90).string(message.channel_label);
    }
    if (message.clan_logo !== "") {
      writer.uint32(98).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(106).string(message.category_name);
    }
    if (message.display_name !== "") {
      writer.uint32(114).string(message.display_name);
    }
    if (message.clan_nick !== "") {
      writer.uint32(122).string(message.clan_nick);
    }
    if (message.clan_avatar !== "") {
      writer.uint32(130).string(message.clan_avatar);
    }
    if (message.reactions !== "") {
      writer.uint32(138).string(message.reactions);
    }
    if (message.mentions !== "") {
      writer.uint32(146).string(message.mentions);
    }
    if (message.attachments !== "") {
      writer.uint32(154).string(message.attachments);
    }
    if (message.references !== "") {
      writer.uint32(162).string(message.references);
    }
    if (message.referenced_message !== "") {
      writer.uint32(170).string(message.referenced_message);
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(176).uint32(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      writer.uint32(184).uint32(message.update_time_seconds);
    }
    if (message.mode !== 0) {
      writer.uint32(192).int32(message.mode);
    }
    if (message.hide_editted !== false) {
      writer.uint32(200).bool(message.hide_editted);
    }
    if (message.is_public !== false) {
      writer.uint32(208).bool(message.is_public);
    }
    if (message.topic_id !== "") {
      writer.uint32(218).string(message.topic_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.code = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.username = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.content = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.clan_nick = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.clan_avatar = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.reactions = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.mentions = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.attachments = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.references = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.referenced_message = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.update_time_seconds = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.hide_editted = reader.bool();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.is_public = reader.bool();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.topic_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessage {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      code: isSet(object.code) ? Number(object.code) : undefined,
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      clan_nick: isSet(object.clan_nick) ? globalThis.String(object.clan_nick) : "",
      clan_avatar: isSet(object.clan_avatar) ? globalThis.String(object.clan_avatar) : "",
      reactions: isSet(object.reactions) ? globalThis.String(object.reactions) : "",
      mentions: isSet(object.mentions) ? globalThis.String(object.mentions) : "",
      attachments: isSet(object.attachments) ? globalThis.String(object.attachments) : "",
      references: isSet(object.references) ? globalThis.String(object.references) : "",
      referenced_message: isSet(object.referenced_message) ? globalThis.String(object.referenced_message) : "",
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
      update_time_seconds: isSet(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      hide_editted: isSet(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,
      is_public: isSet(object.is_public) ? globalThis.Boolean(object.is_public) : false,
      topic_id: isSet(object.topic_id) ? globalThis.String(object.topic_id) : "",
    };
  },

  toJSON(message: ChannelMessage): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.clan_nick !== "") {
      obj.clan_nick = message.clan_nick;
    }
    if (message.clan_avatar !== "") {
      obj.clan_avatar = message.clan_avatar;
    }
    if (message.reactions !== "") {
      obj.reactions = message.reactions;
    }
    if (message.mentions !== "") {
      obj.mentions = message.mentions;
    }
    if (message.attachments !== "") {
      obj.attachments = message.attachments;
    }
    if (message.references !== "") {
      obj.references = message.references;
    }
    if (message.referenced_message !== "") {
      obj.referenced_message = message.referenced_message;
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      obj.update_time_seconds = Math.round(message.update_time_seconds);
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.hide_editted !== false) {
      obj.hide_editted = message.hide_editted;
    }
    if (message.is_public !== false) {
      obj.is_public = message.is_public;
    }
    if (message.topic_id !== "") {
      obj.topic_id = message.topic_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessage>, I>>(base?: I): ChannelMessage {
    return ChannelMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessage>, I>>(object: I): ChannelMessage {
    const message = createBaseChannelMessage();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.code = object.code ?? undefined;
    message.sender_id = object.sender_id ?? "";
    message.username = object.username ?? "";
    message.avatar = object.avatar ?? "";
    message.content = object.content ?? "";
    message.create_time = object.create_time ?? undefined;
    message.update_time = object.update_time ?? undefined;
    message.channel_label = object.channel_label ?? "";
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    message.display_name = object.display_name ?? "";
    message.clan_nick = object.clan_nick ?? "";
    message.clan_avatar = object.clan_avatar ?? "";
    message.reactions = object.reactions ?? "";
    message.mentions = object.mentions ?? "";
    message.attachments = object.attachments ?? "";
    message.references = object.references ?? "";
    message.referenced_message = object.referenced_message ?? "";
    message.create_time_seconds = object.create_time_seconds ?? 0;
    message.update_time_seconds = object.update_time_seconds ?? 0;
    message.mode = object.mode ?? 0;
    message.hide_editted = object.hide_editted ?? false;
    message.is_public = object.is_public ?? false;
    message.topic_id = object.topic_id ?? "";
    return message;
  },
};

function createBaseMessageMention(): MessageMention {
  return { id: "", user_id: "", username: "", role_id: "", rolename: "", create_time: undefined, s: 0, e: 0 };
}

export const MessageMention = {
  encode(message: MessageMention, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.role_id !== "") {
      writer.uint32(34).string(message.role_id);
    }
    if (message.rolename !== "") {
      writer.uint32(42).string(message.rolename);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.s !== 0) {
      writer.uint32(56).int32(message.s);
    }
    if (message.e !== 0) {
      writer.uint32(64).int32(message.e);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageMention {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageMention();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rolename = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.s = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.e = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageMention {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      rolename: isSet(object.rolename) ? globalThis.String(object.rolename) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      s: isSet(object.s) ? globalThis.Number(object.s) : 0,
      e: isSet(object.e) ? globalThis.Number(object.e) : 0,
    };
  },

  toJSON(message: MessageMention): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.rolename !== "") {
      obj.rolename = message.rolename;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.s !== 0) {
      obj.s = Math.round(message.s);
    }
    if (message.e !== 0) {
      obj.e = Math.round(message.e);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageMention>, I>>(base?: I): MessageMention {
    return MessageMention.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageMention>, I>>(object: I): MessageMention {
    const message = createBaseMessageMention();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.username = object.username ?? "";
    message.role_id = object.role_id ?? "";
    message.rolename = object.rolename ?? "";
    message.create_time = object.create_time ?? undefined;
    message.s = object.s ?? 0;
    message.e = object.e ?? 0;
    return message;
  },
};

function createBaseNotificationInfo(): NotificationInfo {
  return {
    username: "",
    avatar: "",
    clan_nick: "",
    clan_avatar: "",
    display_name: "",
    channel_label: "",
    channel_type: 0,
    category_name: "",
    clan_name: "",
    clan_logo: "",
  };
}

export const NotificationInfo = {
  encode(message: NotificationInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.avatar !== "") {
      writer.uint32(18).string(message.avatar);
    }
    if (message.clan_nick !== "") {
      writer.uint32(26).string(message.clan_nick);
    }
    if (message.clan_avatar !== "") {
      writer.uint32(34).string(message.clan_avatar);
    }
    if (message.display_name !== "") {
      writer.uint32(42).string(message.display_name);
    }
    if (message.channel_label !== "") {
      writer.uint32(50).string(message.channel_label);
    }
    if (message.channel_type !== 0) {
      writer.uint32(56).int32(message.channel_type);
    }
    if (message.category_name !== "") {
      writer.uint32(66).string(message.category_name);
    }
    if (message.clan_name !== "") {
      writer.uint32(74).string(message.clan_name);
    }
    if (message.clan_logo !== "") {
      writer.uint32(82).string(message.clan_logo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_nick = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_avatar = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationInfo {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      clan_nick: isSet(object.clan_nick) ? globalThis.String(object.clan_nick) : "",
      clan_avatar: isSet(object.clan_avatar) ? globalThis.String(object.clan_avatar) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
    };
  },

  toJSON(message: NotificationInfo): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.clan_nick !== "") {
      obj.clan_nick = message.clan_nick;
    }
    if (message.clan_avatar !== "") {
      obj.clan_avatar = message.clan_avatar;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationInfo>, I>>(base?: I): NotificationInfo {
    return NotificationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationInfo>, I>>(object: I): NotificationInfo {
    const message = createBaseNotificationInfo();
    message.username = object.username ?? "";
    message.avatar = object.avatar ?? "";
    message.clan_nick = object.clan_nick ?? "";
    message.clan_avatar = object.clan_avatar ?? "";
    message.display_name = object.display_name ?? "";
    message.channel_label = object.channel_label ?? "";
    message.channel_type = object.channel_type ?? 0;
    message.category_name = object.category_name ?? "";
    message.clan_name = object.clan_name ?? "";
    message.clan_logo = object.clan_logo ?? "";
    return message;
  },
};

function createBaseMessageReaction(): MessageReaction {
  return {
    id: "",
    emoji_id: "",
    emoji: "",
    sender_id: "",
    sender_name: "",
    sender_avatar: "",
    action: false,
    count: 0,
    channel_id: "",
    message_id: "",
    clan_id: "",
    mode: 0,
    message_sender_id: "",
    is_public: false,
  };
}

export const MessageReaction = {
  encode(message: MessageReaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.emoji_id !== "") {
      writer.uint32(18).string(message.emoji_id);
    }
    if (message.emoji !== "") {
      writer.uint32(26).string(message.emoji);
    }
    if (message.sender_id !== "") {
      writer.uint32(34).string(message.sender_id);
    }
    if (message.sender_name !== "") {
      writer.uint32(42).string(message.sender_name);
    }
    if (message.sender_avatar !== "") {
      writer.uint32(50).string(message.sender_avatar);
    }
    if (message.action !== false) {
      writer.uint32(56).bool(message.action);
    }
    if (message.count !== 0) {
      writer.uint32(64).int32(message.count);
    }
    if (message.channel_id !== "") {
      writer.uint32(74).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(82).string(message.message_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(90).string(message.clan_id);
    }
    if (message.mode !== 0) {
      writer.uint32(96).int32(message.mode);
    }
    if (message.message_sender_id !== "") {
      writer.uint32(106).string(message.message_sender_id);
    }
    if (message.is_public !== false) {
      writer.uint32(112).bool(message.is_public);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.emoji_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emoji = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender_name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sender_avatar = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.action = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.message_sender_id = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.is_public = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      emoji_id: isSet(object.emoji_id) ? globalThis.String(object.emoji_id) : "",
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      sender_name: isSet(object.sender_name) ? globalThis.String(object.sender_name) : "",
      sender_avatar: isSet(object.sender_avatar) ? globalThis.String(object.sender_avatar) : "",
      action: isSet(object.action) ? globalThis.Boolean(object.action) : false,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      message_sender_id: isSet(object.message_sender_id) ? globalThis.String(object.message_sender_id) : "",
      is_public: isSet(object.is_public) ? globalThis.Boolean(object.is_public) : false,
    };
  },

  toJSON(message: MessageReaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.emoji_id !== "") {
      obj.emoji_id = message.emoji_id;
    }
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.sender_name !== "") {
      obj.sender_name = message.sender_name;
    }
    if (message.sender_avatar !== "") {
      obj.sender_avatar = message.sender_avatar;
    }
    if (message.action !== false) {
      obj.action = message.action;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.message_sender_id !== "") {
      obj.message_sender_id = message.message_sender_id;
    }
    if (message.is_public !== false) {
      obj.is_public = message.is_public;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageReaction>, I>>(base?: I): MessageReaction {
    return MessageReaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageReaction>, I>>(object: I): MessageReaction {
    const message = createBaseMessageReaction();
    message.id = object.id ?? "";
    message.emoji_id = object.emoji_id ?? "";
    message.emoji = object.emoji ?? "";
    message.sender_id = object.sender_id ?? "";
    message.sender_name = object.sender_name ?? "";
    message.sender_avatar = object.sender_avatar ?? "";
    message.action = object.action ?? false;
    message.count = object.count ?? 0;
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.mode = object.mode ?? 0;
    message.message_sender_id = object.message_sender_id ?? "";
    message.is_public = object.is_public ?? false;
    return message;
  },
};

function createBaseMessageAttachment(): MessageAttachment {
  return { filename: "", size: 0, url: "", filetype: "", width: 0, height: 0 };
}

export const MessageAttachment = {
  encode(message: MessageAttachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.size !== 0) {
      writer.uint32(16).int64(message.size);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.filetype !== "") {
      writer.uint32(34).string(message.filetype);
    }
    if (message.width !== 0) {
      writer.uint32(40).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(48).int32(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.size = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filetype = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageAttachment {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      filetype: isSet(object.filetype) ? globalThis.String(object.filetype) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: MessageAttachment): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.filetype !== "") {
      obj.filetype = message.filetype;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageAttachment>, I>>(base?: I): MessageAttachment {
    return MessageAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageAttachment>, I>>(object: I): MessageAttachment {
    const message = createBaseMessageAttachment();
    message.filename = object.filename ?? "";
    message.size = object.size ?? 0;
    message.url = object.url ?? "";
    message.filetype = object.filetype ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseMessageRef(): MessageRef {
  return {
    message_id: "",
    message_ref_id: "",
    content: "",
    has_attachment: false,
    ref_type: 0,
    message_sender_id: "",
    message_sender_username: "",
    mesages_sender_avatar: "",
    message_sender_clan_nick: "",
    message_sender_display_name: "",
  };
}

export const MessageRef = {
  encode(message: MessageRef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    if (message.message_ref_id !== "") {
      writer.uint32(18).string(message.message_ref_id);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.has_attachment !== false) {
      writer.uint32(32).bool(message.has_attachment);
    }
    if (message.ref_type !== 0) {
      writer.uint32(40).int32(message.ref_type);
    }
    if (message.message_sender_id !== "") {
      writer.uint32(50).string(message.message_sender_id);
    }
    if (message.message_sender_username !== "") {
      writer.uint32(58).string(message.message_sender_username);
    }
    if (message.mesages_sender_avatar !== "") {
      writer.uint32(66).string(message.mesages_sender_avatar);
    }
    if (message.message_sender_clan_nick !== "") {
      writer.uint32(74).string(message.message_sender_clan_nick);
    }
    if (message.message_sender_display_name !== "") {
      writer.uint32(82).string(message.message_sender_display_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageRef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message_ref_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.has_attachment = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ref_type = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message_sender_id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.message_sender_username = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mesages_sender_avatar = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.message_sender_clan_nick = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.message_sender_display_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRef {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      message_ref_id: isSet(object.message_ref_id) ? globalThis.String(object.message_ref_id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      has_attachment: isSet(object.has_attachment) ? globalThis.Boolean(object.has_attachment) : false,
      ref_type: isSet(object.ref_type) ? globalThis.Number(object.ref_type) : 0,
      message_sender_id: isSet(object.message_sender_id) ? globalThis.String(object.message_sender_id) : "",
      message_sender_username: isSet(object.message_sender_username)
        ? globalThis.String(object.message_sender_username)
        : "",
      mesages_sender_avatar: isSet(object.mesages_sender_avatar) ? globalThis.String(object.mesages_sender_avatar) : "",
      message_sender_clan_nick: isSet(object.message_sender_clan_nick)
        ? globalThis.String(object.message_sender_clan_nick)
        : "",
      message_sender_display_name: isSet(object.message_sender_display_name)
        ? globalThis.String(object.message_sender_display_name)
        : "",
    };
  },

  toJSON(message: MessageRef): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.message_ref_id !== "") {
      obj.message_ref_id = message.message_ref_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.has_attachment !== false) {
      obj.has_attachment = message.has_attachment;
    }
    if (message.ref_type !== 0) {
      obj.ref_type = Math.round(message.ref_type);
    }
    if (message.message_sender_id !== "") {
      obj.message_sender_id = message.message_sender_id;
    }
    if (message.message_sender_username !== "") {
      obj.message_sender_username = message.message_sender_username;
    }
    if (message.mesages_sender_avatar !== "") {
      obj.mesages_sender_avatar = message.mesages_sender_avatar;
    }
    if (message.message_sender_clan_nick !== "") {
      obj.message_sender_clan_nick = message.message_sender_clan_nick;
    }
    if (message.message_sender_display_name !== "") {
      obj.message_sender_display_name = message.message_sender_display_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageRef>, I>>(base?: I): MessageRef {
    return MessageRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageRef>, I>>(object: I): MessageRef {
    const message = createBaseMessageRef();
    message.message_id = object.message_id ?? "";
    message.message_ref_id = object.message_ref_id ?? "";
    message.content = object.content ?? "";
    message.has_attachment = object.has_attachment ?? false;
    message.ref_type = object.ref_type ?? 0;
    message.message_sender_id = object.message_sender_id ?? "";
    message.message_sender_username = object.message_sender_username ?? "";
    message.mesages_sender_avatar = object.mesages_sender_avatar ?? "";
    message.message_sender_clan_nick = object.message_sender_clan_nick ?? "";
    message.message_sender_display_name = object.message_sender_display_name ?? "";
    return message;
  },
};

function createBaseMessageDeleted(): MessageDeleted {
  return { message_id: "", deletor: "" };
}

export const MessageDeleted = {
  encode(message: MessageDeleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    if (message.deletor !== "") {
      writer.uint32(18).string(message.deletor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageDeleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageDeleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deletor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageDeleted {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      deletor: isSet(object.deletor) ? globalThis.String(object.deletor) : "",
    };
  },

  toJSON(message: MessageDeleted): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.deletor !== "") {
      obj.deletor = message.deletor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageDeleted>, I>>(base?: I): MessageDeleted {
    return MessageDeleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageDeleted>, I>>(object: I): MessageDeleted {
    const message = createBaseMessageDeleted();
    message.message_id = object.message_id ?? "";
    message.deletor = object.deletor ?? "";
    return message;
  },
};

function createBaseChannelMessageList(): ChannelMessageList {
  return { messages: [], last_seen_message: undefined, last_sent_message: undefined };
}

export const ChannelMessageList = {
  encode(message: ChannelMessageList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      ChannelMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.last_seen_message !== undefined) {
      ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(18).fork()).ldelim();
    }
    if (message.last_sent_message !== undefined) {
      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(ChannelMessage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageList {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChannelMessage.fromJSON(e))
        : [],
      last_seen_message: isSet(object.last_seen_message)
        ? ChannelMessageHeader.fromJSON(object.last_seen_message)
        : undefined,
      last_sent_message: isSet(object.last_sent_message)
        ? ChannelMessageHeader.fromJSON(object.last_sent_message)
        : undefined,
    };
  },

  toJSON(message: ChannelMessageList): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChannelMessage.toJSON(e));
    }
    if (message.last_seen_message !== undefined) {
      obj.last_seen_message = ChannelMessageHeader.toJSON(message.last_seen_message);
    }
    if (message.last_sent_message !== undefined) {
      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageList>, I>>(base?: I): ChannelMessageList {
    return ChannelMessageList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageList>, I>>(object: I): ChannelMessageList {
    const message = createBaseChannelMessageList();
    message.messages = object.messages?.map((e) => ChannelMessage.fromPartial(e)) || [];
    message.last_seen_message = (object.last_seen_message !== undefined && object.last_seen_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_seen_message)
      : undefined;
    message.last_sent_message = (object.last_sent_message !== undefined && object.last_sent_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_sent_message)
      : undefined;
    return message;
  },
};

function createBaseCreateGroupRequest(): CreateGroupRequest {
  return { name: "", description: "", lang_tag: "", avatar_url: "", open: false, max_count: 0 };
}

export const CreateGroupRequest = {
  encode(message: CreateGroupRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.lang_tag !== "") {
      writer.uint32(26).string(message.lang_tag);
    }
    if (message.avatar_url !== "") {
      writer.uint32(34).string(message.avatar_url);
    }
    if (message.open !== false) {
      writer.uint32(40).bool(message.open);
    }
    if (message.max_count !== 0) {
      writer.uint32(48).int32(message.max_count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateGroupRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lang_tag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.open = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.max_count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      lang_tag: isSet(object.lang_tag) ? globalThis.String(object.lang_tag) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
      open: isSet(object.open) ? globalThis.Boolean(object.open) : false,
      max_count: isSet(object.max_count) ? globalThis.Number(object.max_count) : 0,
    };
  },

  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.lang_tag !== "") {
      obj.lang_tag = message.lang_tag;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    if (message.open !== false) {
      obj.open = message.open;
    }
    if (message.max_count !== 0) {
      obj.max_count = Math.round(message.max_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGroupRequest>, I>>(base?: I): CreateGroupRequest {
    return CreateGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGroupRequest>, I>>(object: I): CreateGroupRequest {
    const message = createBaseCreateGroupRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.lang_tag = object.lang_tag ?? "";
    message.avatar_url = object.avatar_url ?? "";
    message.open = object.open ?? false;
    message.max_count = object.max_count ?? 0;
    return message;
  },
};

function createBaseDeleteFriendsRequest(): DeleteFriendsRequest {
  return { ids: [], usernames: [] };
}

export const DeleteFriendsRequest = {
  encode(message: DeleteFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFriendsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteFriendsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFriendsRequest>, I>>(base?: I): DeleteFriendsRequest {
    return DeleteFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFriendsRequest>, I>>(object: I): DeleteFriendsRequest {
    const message = createBaseDeleteFriendsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.usernames = object.usernames?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteGroupRequest(): DeleteGroupRequest {
  return { group_id: "" };
}

export const DeleteGroupRequest = {
  encode(message: DeleteGroupRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteGroupRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGroupRequest {
    return { group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "" };
  },

  toJSON(message: DeleteGroupRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteGroupRequest>, I>>(base?: I): DeleteGroupRequest {
    return DeleteGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteGroupRequest>, I>>(object: I): DeleteGroupRequest {
    const message = createBaseDeleteGroupRequest();
    message.group_id = object.group_id ?? "";
    return message;
  },
};

function createBaseDeleteNotificationsRequest(): DeleteNotificationsRequest {
  return { ids: [] };
}

export const DeleteNotificationsRequest = {
  encode(message: DeleteNotificationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteNotificationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNotificationsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: DeleteNotificationsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNotificationsRequest>, I>>(base?: I): DeleteNotificationsRequest {
    return DeleteNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNotificationsRequest>, I>>(object: I): DeleteNotificationsRequest {
    const message = createBaseDeleteNotificationsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseEvent(): Event {
  return { name: "", properties: {}, timestamp: undefined, external: false };
}

export const Event = {
  encode(message: Event, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Event_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    if (message.external !== false) {
      writer.uint32(32).bool(message.external);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Event_PropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.properties[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.external = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      external: isSet(object.external) ? globalThis.Boolean(object.external) : false,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.external !== false) {
      obj.external = message.external;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.name = object.name ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timestamp = object.timestamp ?? undefined;
    message.external = object.external ?? false;
    return message;
  },
};

function createBaseEvent_PropertiesEntry(): Event_PropertiesEntry {
  return { key: "", value: "" };
}

export const Event_PropertiesEntry = {
  encode(message: Event_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Event_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Event_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event_PropertiesEntry>, I>>(base?: I): Event_PropertiesEntry {
    return Event_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event_PropertiesEntry>, I>>(object: I): Event_PropertiesEntry {
    const message = createBaseEvent_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFriend(): Friend {
  return { user: undefined, state: undefined, update_time: undefined };
}

export const Friend = {
  encode(message: Friend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Friend {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Friend {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
    };
  },

  toJSON(message: Friend): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Friend>, I>>(base?: I): Friend {
    return Friend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Friend>, I>>(object: I): Friend {
    const message = createBaseFriend();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.state = object.state ?? undefined;
    message.update_time = object.update_time ?? undefined;
    return message;
  },
};

function createBaseFriendList(): FriendList {
  return { friends: [], cursor: "" };
}

export const FriendList = {
  encode(message: FriendList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.friends) {
      Friend.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FriendList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.friends.push(Friend.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendList {
    return {
      friends: globalThis.Array.isArray(object?.friends) ? object.friends.map((e: any) => Friend.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: FriendList): unknown {
    const obj: any = {};
    if (message.friends?.length) {
      obj.friends = message.friends.map((e) => Friend.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendList>, I>>(base?: I): FriendList {
    return FriendList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendList>, I>>(object: I): FriendList {
    const message = createBaseFriendList();
    message.friends = object.friends?.map((e) => Friend.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseGetUsersRequest(): GetUsersRequest {
  return { ids: [], usernames: [], facebook_ids: [] };
}

export const GetUsersRequest = {
  encode(message: GetUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.facebook_ids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.facebook_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
      facebook_ids: globalThis.Array.isArray(object?.facebook_ids)
        ? object.facebook_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetUsersRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    if (message.facebook_ids?.length) {
      obj.facebook_ids = message.facebook_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersRequest>, I>>(base?: I): GetUsersRequest {
    return GetUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersRequest>, I>>(object: I): GetUsersRequest {
    const message = createBaseGetUsersRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.usernames = object.usernames?.map((e) => e) || [];
    message.facebook_ids = object.facebook_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateUsersRequest(): UpdateUsersRequest {
  return { display_name: "", avatar_url: "" };
}

export const UpdateUsersRequest = {
  encode(message: UpdateUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.display_name !== "") {
      writer.uint32(18).string(message.display_name);
    }
    if (message.avatar_url !== "") {
      writer.uint32(26).string(message.avatar_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUsersRequest {
    return {
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
    };
  },

  toJSON(message: UpdateUsersRequest): unknown {
    const obj: any = {};
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUsersRequest>, I>>(base?: I): UpdateUsersRequest {
    return UpdateUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUsersRequest>, I>>(object: I): UpdateUsersRequest {
    const message = createBaseUpdateUsersRequest();
    message.display_name = object.display_name ?? "";
    message.avatar_url = object.avatar_url ?? "";
    return message;
  },
};

function createBaseGroup(): Group {
  return {
    id: "",
    creator_id: "",
    name: "",
    description: "",
    lang_tag: "",
    metadata: "",
    avatar_url: "",
    open: undefined,
    edge_count: 0,
    max_count: 0,
    create_time: undefined,
    update_time: undefined,
  };
}

export const Group = {
  encode(message: Group, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creator_id !== "") {
      writer.uint32(18).string(message.creator_id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.lang_tag !== "") {
      writer.uint32(42).string(message.lang_tag);
    }
    if (message.metadata !== "") {
      writer.uint32(50).string(message.metadata);
    }
    if (message.avatar_url !== "") {
      writer.uint32(58).string(message.avatar_url);
    }
    if (message.open !== undefined) {
      BoolValue.encode({ value: message.open! }, writer.uint32(66).fork()).ldelim();
    }
    if (message.edge_count !== 0) {
      writer.uint32(72).int32(message.edge_count);
    }
    if (message.max_count !== 0) {
      writer.uint32(80).int32(message.max_count);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(90).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Group {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lang_tag = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.open = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.edge_count = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.max_count = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      lang_tag: isSet(object.lang_tag) ? globalThis.String(object.lang_tag) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
      open: isSet(object.open) ? Boolean(object.open) : undefined,
      edge_count: isSet(object.edge_count) ? globalThis.Number(object.edge_count) : 0,
      max_count: isSet(object.max_count) ? globalThis.Number(object.max_count) : 0,
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.lang_tag !== "") {
      obj.lang_tag = message.lang_tag;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    if (message.open !== undefined) {
      obj.open = message.open;
    }
    if (message.edge_count !== 0) {
      obj.edge_count = Math.round(message.edge_count);
    }
    if (message.max_count !== 0) {
      obj.max_count = Math.round(message.max_count);
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Group>, I>>(base?: I): Group {
    return Group.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Group>, I>>(object: I): Group {
    const message = createBaseGroup();
    message.id = object.id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.lang_tag = object.lang_tag ?? "";
    message.metadata = object.metadata ?? "";
    message.avatar_url = object.avatar_url ?? "";
    message.open = object.open ?? undefined;
    message.edge_count = object.edge_count ?? 0;
    message.max_count = object.max_count ?? 0;
    message.create_time = object.create_time ?? undefined;
    message.update_time = object.update_time ?? undefined;
    return message;
  },
};

function createBaseGroupList(): GroupList {
  return { groups: [], cursor: "" };
}

export const GroupList = {
  encode(message: GroupList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupList {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: GroupList): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupList>, I>>(base?: I): GroupList {
    return GroupList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupList>, I>>(object: I): GroupList {
    const message = createBaseGroupList();
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseGroupUserList(): GroupUserList {
  return { group_users: [], cursor: "" };
}

export const GroupUserList = {
  encode(message: GroupUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.group_users) {
      GroupUserList_GroupUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_users.push(GroupUserList_GroupUser.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupUserList {
    return {
      group_users: globalThis.Array.isArray(object?.group_users)
        ? object.group_users.map((e: any) => GroupUserList_GroupUser.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: GroupUserList): unknown {
    const obj: any = {};
    if (message.group_users?.length) {
      obj.group_users = message.group_users.map((e) => GroupUserList_GroupUser.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupUserList>, I>>(base?: I): GroupUserList {
    return GroupUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupUserList>, I>>(object: I): GroupUserList {
    const message = createBaseGroupUserList();
    message.group_users = object.group_users?.map((e) => GroupUserList_GroupUser.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseGroupUserList_GroupUser(): GroupUserList_GroupUser {
  return { user: undefined, state: undefined };
}

export const GroupUserList_GroupUser = {
  encode(message: GroupUserList_GroupUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupUserList_GroupUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupUserList_GroupUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupUserList_GroupUser {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
    };
  },

  toJSON(message: GroupUserList_GroupUser): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupUserList_GroupUser>, I>>(base?: I): GroupUserList_GroupUser {
    return GroupUserList_GroupUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupUserList_GroupUser>, I>>(object: I): GroupUserList_GroupUser {
    const message = createBaseGroupUserList_GroupUser();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.state = object.state ?? undefined;
    return message;
  },
};

function createBaseChannelUserList(): ChannelUserList {
  return { channel_users: [], cursor: "", channel_id: "" };
}

export const ChannelUserList = {
  encode(message: ChannelUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.channel_users) {
      ChannelUserList_ChannelUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_users.push(ChannelUserList_ChannelUser.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelUserList {
    return {
      channel_users: globalThis.Array.isArray(object?.channel_users)
        ? object.channel_users.map((e: any) => ChannelUserList_ChannelUser.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: ChannelUserList): unknown {
    const obj: any = {};
    if (message.channel_users?.length) {
      obj.channel_users = message.channel_users.map((e) => ChannelUserList_ChannelUser.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelUserList>, I>>(base?: I): ChannelUserList {
    return ChannelUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelUserList>, I>>(object: I): ChannelUserList {
    const message = createBaseChannelUserList();
    message.channel_users = object.channel_users?.map((e) => ChannelUserList_ChannelUser.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseChannelUserList_ChannelUser(): ChannelUserList_ChannelUser {
  return { user_id: "", role_id: [], id: "", thread_id: "", clan_nick: "", clan_avatar: "", clan_id: "" };
}

export const ChannelUserList_ChannelUser = {
  encode(message: ChannelUserList_ChannelUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    for (const v of message.role_id) {
      writer.uint32(18).string(v!);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.thread_id !== "") {
      writer.uint32(34).string(message.thread_id);
    }
    if (message.clan_nick !== "") {
      writer.uint32(42).string(message.clan_nick);
    }
    if (message.clan_avatar !== "") {
      writer.uint32(50).string(message.clan_avatar);
    }
    if (message.clan_id !== "") {
      writer.uint32(58).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelUserList_ChannelUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelUserList_ChannelUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role_id.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.thread_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_nick = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clan_avatar = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelUserList_ChannelUser {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      role_id: globalThis.Array.isArray(object?.role_id) ? object.role_id.map((e: any) => globalThis.String(e)) : [],
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      thread_id: isSet(object.thread_id) ? globalThis.String(object.thread_id) : "",
      clan_nick: isSet(object.clan_nick) ? globalThis.String(object.clan_nick) : "",
      clan_avatar: isSet(object.clan_avatar) ? globalThis.String(object.clan_avatar) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ChannelUserList_ChannelUser): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.role_id?.length) {
      obj.role_id = message.role_id;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.thread_id !== "") {
      obj.thread_id = message.thread_id;
    }
    if (message.clan_nick !== "") {
      obj.clan_nick = message.clan_nick;
    }
    if (message.clan_avatar !== "") {
      obj.clan_avatar = message.clan_avatar;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelUserList_ChannelUser>, I>>(base?: I): ChannelUserList_ChannelUser {
    return ChannelUserList_ChannelUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelUserList_ChannelUser>, I>>(object: I): ChannelUserList_ChannelUser {
    const message = createBaseChannelUserList_ChannelUser();
    message.user_id = object.user_id ?? "";
    message.role_id = object.role_id?.map((e) => e) || [];
    message.id = object.id ?? "";
    message.thread_id = object.thread_id ?? "";
    message.clan_nick = object.clan_nick ?? "";
    message.clan_avatar = object.clan_avatar ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseVoiceChannelUser(): VoiceChannelUser {
  return { id: "", user_id: "", channel_id: "", participant: "" };
}

export const VoiceChannelUser = {
  encode(message: VoiceChannelUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.participant !== "") {
      writer.uint32(34).string(message.participant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceChannelUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceChannelUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceChannelUser {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
    };
  },

  toJSON(message: VoiceChannelUser): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceChannelUser>, I>>(base?: I): VoiceChannelUser {
    return VoiceChannelUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceChannelUser>, I>>(object: I): VoiceChannelUser {
    const message = createBaseVoiceChannelUser();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.participant = object.participant ?? "";
    return message;
  },
};

function createBaseVoiceChannelUserList(): VoiceChannelUserList {
  return { voice_channel_users: [] };
}

export const VoiceChannelUserList = {
  encode(message: VoiceChannelUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.voice_channel_users) {
      VoiceChannelUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceChannelUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceChannelUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.voice_channel_users.push(VoiceChannelUser.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceChannelUserList {
    return {
      voice_channel_users: globalThis.Array.isArray(object?.voice_channel_users)
        ? object.voice_channel_users.map((e: any) => VoiceChannelUser.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VoiceChannelUserList): unknown {
    const obj: any = {};
    if (message.voice_channel_users?.length) {
      obj.voice_channel_users = message.voice_channel_users.map((e) => VoiceChannelUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceChannelUserList>, I>>(base?: I): VoiceChannelUserList {
    return VoiceChannelUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceChannelUserList>, I>>(object: I): VoiceChannelUserList {
    const message = createBaseVoiceChannelUserList();
    message.voice_channel_users = object.voice_channel_users?.map((e) => VoiceChannelUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannelAttachment(): ChannelAttachment {
  return {
    id: "",
    filename: "",
    filetype: "",
    filesize: "",
    url: "",
    uploader: "",
    create_time: undefined,
    message_id: "",
  };
}

export const ChannelAttachment = {
  encode(message: ChannelAttachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.filetype !== "") {
      writer.uint32(26).string(message.filetype);
    }
    if (message.filesize !== "") {
      writer.uint32(34).string(message.filesize);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.uploader !== "") {
      writer.uint32(50).string(message.uploader);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(58).fork()).ldelim();
    }
    if (message.message_id !== "") {
      writer.uint32(66).string(message.message_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filetype = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filesize = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uploader = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.message_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelAttachment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      filetype: isSet(object.filetype) ? globalThis.String(object.filetype) : "",
      filesize: isSet(object.filesize) ? globalThis.String(object.filesize) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      uploader: isSet(object.uploader) ? globalThis.String(object.uploader) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
    };
  },

  toJSON(message: ChannelAttachment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.filetype !== "") {
      obj.filetype = message.filetype;
    }
    if (message.filesize !== "") {
      obj.filesize = message.filesize;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.uploader !== "") {
      obj.uploader = message.uploader;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelAttachment>, I>>(base?: I): ChannelAttachment {
    return ChannelAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelAttachment>, I>>(object: I): ChannelAttachment {
    const message = createBaseChannelAttachment();
    message.id = object.id ?? "";
    message.filename = object.filename ?? "";
    message.filetype = object.filetype ?? "";
    message.filesize = object.filesize ?? "";
    message.url = object.url ?? "";
    message.uploader = object.uploader ?? "";
    message.create_time = object.create_time ?? undefined;
    message.message_id = object.message_id ?? "";
    return message;
  },
};

function createBaseChannelAttachmentList(): ChannelAttachmentList {
  return { attachments: [] };
}

export const ChannelAttachmentList = {
  encode(message: ChannelAttachmentList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.attachments) {
      ChannelAttachment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelAttachmentList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelAttachmentList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachments.push(ChannelAttachment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelAttachmentList {
    return {
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => ChannelAttachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChannelAttachmentList): unknown {
    const obj: any = {};
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => ChannelAttachment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelAttachmentList>, I>>(base?: I): ChannelAttachmentList {
    return ChannelAttachmentList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelAttachmentList>, I>>(object: I): ChannelAttachmentList {
    const message = createBaseChannelAttachmentList();
    message.attachments = object.attachments?.map((e) => ChannelAttachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClanUserList(): ClanUserList {
  return { clan_users: [], cursor: "", clan_id: "" };
}

export const ClanUserList = {
  encode(message: ClanUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.clan_users) {
      ClanUserList_ClanUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_users.push(ClanUserList_ClanUser.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanUserList {
    return {
      clan_users: globalThis.Array.isArray(object?.clan_users)
        ? object.clan_users.map((e: any) => ClanUserList_ClanUser.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanUserList): unknown {
    const obj: any = {};
    if (message.clan_users?.length) {
      obj.clan_users = message.clan_users.map((e) => ClanUserList_ClanUser.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanUserList>, I>>(base?: I): ClanUserList {
    return ClanUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanUserList>, I>>(object: I): ClanUserList {
    const message = createBaseClanUserList();
    message.clan_users = object.clan_users?.map((e) => ClanUserList_ClanUser.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanUserList_ClanUser(): ClanUserList_ClanUser {
  return { user: undefined, role_id: [], clan_nick: "", clan_avatar: "", clan_id: "" };
}

export const ClanUserList_ClanUser = {
  encode(message: ClanUserList_ClanUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.role_id) {
      writer.uint32(18).string(v!);
    }
    if (message.clan_nick !== "") {
      writer.uint32(26).string(message.clan_nick);
    }
    if (message.clan_avatar !== "") {
      writer.uint32(34).string(message.clan_avatar);
    }
    if (message.clan_id !== "") {
      writer.uint32(42).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanUserList_ClanUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanUserList_ClanUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role_id.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_nick = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_avatar = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanUserList_ClanUser {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      role_id: globalThis.Array.isArray(object?.role_id) ? object.role_id.map((e: any) => globalThis.String(e)) : [],
      clan_nick: isSet(object.clan_nick) ? globalThis.String(object.clan_nick) : "",
      clan_avatar: isSet(object.clan_avatar) ? globalThis.String(object.clan_avatar) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanUserList_ClanUser): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.role_id?.length) {
      obj.role_id = message.role_id;
    }
    if (message.clan_nick !== "") {
      obj.clan_nick = message.clan_nick;
    }
    if (message.clan_avatar !== "") {
      obj.clan_avatar = message.clan_avatar;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanUserList_ClanUser>, I>>(base?: I): ClanUserList_ClanUser {
    return ClanUserList_ClanUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanUserList_ClanUser>, I>>(object: I): ClanUserList_ClanUser {
    const message = createBaseClanUserList_ClanUser();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.role_id = object.role_id?.map((e) => e) || [];
    message.clan_nick = object.clan_nick ?? "";
    message.clan_avatar = object.clan_avatar ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseImportFacebookFriendsRequest(): ImportFacebookFriendsRequest {
  return { account: undefined, reset: undefined };
}

export const ImportFacebookFriendsRequest = {
  encode(message: ImportFacebookFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.reset !== undefined) {
      BoolValue.encode({ value: message.reset! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImportFacebookFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportFacebookFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountFacebook.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reset = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportFacebookFriendsRequest {
    return {
      account: isSet(object.account) ? AccountFacebook.fromJSON(object.account) : undefined,
      reset: isSet(object.reset) ? Boolean(object.reset) : undefined,
    };
  },

  toJSON(message: ImportFacebookFriendsRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountFacebook.toJSON(message.account);
    }
    if (message.reset !== undefined) {
      obj.reset = message.reset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportFacebookFriendsRequest>, I>>(base?: I): ImportFacebookFriendsRequest {
    return ImportFacebookFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportFacebookFriendsRequest>, I>>(object: I): ImportFacebookFriendsRequest {
    const message = createBaseImportFacebookFriendsRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountFacebook.fromPartial(object.account)
      : undefined;
    message.reset = object.reset ?? undefined;
    return message;
  },
};

function createBaseImportSteamFriendsRequest(): ImportSteamFriendsRequest {
  return { account: undefined, reset: undefined };
}

export const ImportSteamFriendsRequest = {
  encode(message: ImportSteamFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.reset !== undefined) {
      BoolValue.encode({ value: message.reset! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImportSteamFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportSteamFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountSteam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reset = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportSteamFriendsRequest {
    return {
      account: isSet(object.account) ? AccountSteam.fromJSON(object.account) : undefined,
      reset: isSet(object.reset) ? Boolean(object.reset) : undefined,
    };
  },

  toJSON(message: ImportSteamFriendsRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountSteam.toJSON(message.account);
    }
    if (message.reset !== undefined) {
      obj.reset = message.reset;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportSteamFriendsRequest>, I>>(base?: I): ImportSteamFriendsRequest {
    return ImportSteamFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportSteamFriendsRequest>, I>>(object: I): ImportSteamFriendsRequest {
    const message = createBaseImportSteamFriendsRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountSteam.fromPartial(object.account)
      : undefined;
    message.reset = object.reset ?? undefined;
    return message;
  },
};

function createBaseRegistFcmDeviceTokenRequest(): RegistFcmDeviceTokenRequest {
  return { token: "", device_id: "", platform: "" };
}

export const RegistFcmDeviceTokenRequest = {
  encode(message: RegistFcmDeviceTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.device_id !== "") {
      writer.uint32(18).string(message.device_id);
    }
    if (message.platform !== "") {
      writer.uint32(26).string(message.platform);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegistFcmDeviceTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistFcmDeviceTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.device_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.platform = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegistFcmDeviceTokenRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      device_id: isSet(object.device_id) ? globalThis.String(object.device_id) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
    };
  },

  toJSON(message: RegistFcmDeviceTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.device_id !== "") {
      obj.device_id = message.device_id;
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegistFcmDeviceTokenRequest>, I>>(base?: I): RegistFcmDeviceTokenRequest {
    return RegistFcmDeviceTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegistFcmDeviceTokenRequest>, I>>(object: I): RegistFcmDeviceTokenRequest {
    const message = createBaseRegistFcmDeviceTokenRequest();
    message.token = object.token ?? "";
    message.device_id = object.device_id ?? "";
    message.platform = object.platform ?? "";
    return message;
  },
};

function createBaseRegistFcmDeviceTokenResponse(): RegistFcmDeviceTokenResponse {
  return { token: "", device_id: "", platform: "" };
}

export const RegistFcmDeviceTokenResponse = {
  encode(message: RegistFcmDeviceTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.device_id !== "") {
      writer.uint32(18).string(message.device_id);
    }
    if (message.platform !== "") {
      writer.uint32(26).string(message.platform);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegistFcmDeviceTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistFcmDeviceTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.device_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.platform = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegistFcmDeviceTokenResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      device_id: isSet(object.device_id) ? globalThis.String(object.device_id) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
    };
  },

  toJSON(message: RegistFcmDeviceTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.device_id !== "") {
      obj.device_id = message.device_id;
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegistFcmDeviceTokenResponse>, I>>(base?: I): RegistFcmDeviceTokenResponse {
    return RegistFcmDeviceTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegistFcmDeviceTokenResponse>, I>>(object: I): RegistFcmDeviceTokenResponse {
    const message = createBaseRegistFcmDeviceTokenResponse();
    message.token = object.token ?? "";
    message.device_id = object.device_id ?? "";
    message.platform = object.platform ?? "";
    return message;
  },
};

function createBaseLinkFacebookRequest(): LinkFacebookRequest {
  return { account: undefined, sync: undefined };
}

export const LinkFacebookRequest = {
  encode(message: LinkFacebookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.sync !== undefined) {
      BoolValue.encode({ value: message.sync! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkFacebookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkFacebookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountFacebook.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sync = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkFacebookRequest {
    return {
      account: isSet(object.account) ? AccountFacebook.fromJSON(object.account) : undefined,
      sync: isSet(object.sync) ? Boolean(object.sync) : undefined,
    };
  },

  toJSON(message: LinkFacebookRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountFacebook.toJSON(message.account);
    }
    if (message.sync !== undefined) {
      obj.sync = message.sync;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkFacebookRequest>, I>>(base?: I): LinkFacebookRequest {
    return LinkFacebookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkFacebookRequest>, I>>(object: I): LinkFacebookRequest {
    const message = createBaseLinkFacebookRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountFacebook.fromPartial(object.account)
      : undefined;
    message.sync = object.sync ?? undefined;
    return message;
  },
};

function createBaseLinkSteamRequest(): LinkSteamRequest {
  return { account: undefined, sync: undefined };
}

export const LinkSteamRequest = {
  encode(message: LinkSteamRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.sync !== undefined) {
      BoolValue.encode({ value: message.sync! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkSteamRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkSteamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountSteam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sync = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkSteamRequest {
    return {
      account: isSet(object.account) ? AccountSteam.fromJSON(object.account) : undefined,
      sync: isSet(object.sync) ? Boolean(object.sync) : undefined,
    };
  },

  toJSON(message: LinkSteamRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountSteam.toJSON(message.account);
    }
    if (message.sync !== undefined) {
      obj.sync = message.sync;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkSteamRequest>, I>>(base?: I): LinkSteamRequest {
    return LinkSteamRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkSteamRequest>, I>>(object: I): LinkSteamRequest {
    const message = createBaseLinkSteamRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountSteam.fromPartial(object.account)
      : undefined;
    message.sync = object.sync ?? undefined;
    return message;
  },
};

function createBaseListChannelMessagesRequest(): ListChannelMessagesRequest {
  return { clan_id: "", channel_id: "", message_id: "", limit: undefined, direction: undefined, topic_id: "" };
}

export const ListChannelMessagesRequest = {
  encode(message: ListChannelMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(26).string(message.message_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.direction !== undefined) {
      Int32Value.encode({ value: message.direction! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.topic_id !== "") {
      writer.uint32(50).string(message.topic_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.direction = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.topic_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelMessagesRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      direction: isSet(object.direction) ? Number(object.direction) : undefined,
      topic_id: isSet(object.topic_id) ? globalThis.String(object.topic_id) : "",
    };
  },

  toJSON(message: ListChannelMessagesRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.direction !== undefined) {
      obj.direction = message.direction;
    }
    if (message.topic_id !== "") {
      obj.topic_id = message.topic_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelMessagesRequest>, I>>(base?: I): ListChannelMessagesRequest {
    return ListChannelMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelMessagesRequest>, I>>(object: I): ListChannelMessagesRequest {
    const message = createBaseListChannelMessagesRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.limit = object.limit ?? undefined;
    message.direction = object.direction ?? undefined;
    message.topic_id = object.topic_id ?? "";
    return message;
  },
};

function createBaseListFriendsRequest(): ListFriendsRequest {
  return { limit: undefined, state: undefined, cursor: "" };
}

export const ListFriendsRequest = {
  encode(message: ListFriendsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFriendsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFriendsRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListFriendsRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFriendsRequest>, I>>(base?: I): ListFriendsRequest {
    return ListFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFriendsRequest>, I>>(object: I): ListFriendsRequest {
    const message = createBaseListFriendsRequest();
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseListGroupsRequest(): ListGroupsRequest {
  return { name: "", cursor: "", limit: undefined, lang_tag: "", members: undefined, open: undefined };
}

export const ListGroupsRequest = {
  encode(message: ListGroupsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lang_tag !== "") {
      writer.uint32(34).string(message.lang_tag);
    }
    if (message.members !== undefined) {
      Int32Value.encode({ value: message.members! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.open !== undefined) {
      BoolValue.encode({ value: message.open! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListGroupsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lang_tag = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.members = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.open = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      lang_tag: isSet(object.lang_tag) ? globalThis.String(object.lang_tag) : "",
      members: isSet(object.members) ? Number(object.members) : undefined,
      open: isSet(object.open) ? Boolean(object.open) : undefined,
    };
  },

  toJSON(message: ListGroupsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.lang_tag !== "") {
      obj.lang_tag = message.lang_tag;
    }
    if (message.members !== undefined) {
      obj.members = message.members;
    }
    if (message.open !== undefined) {
      obj.open = message.open;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListGroupsRequest>, I>>(base?: I): ListGroupsRequest {
    return ListGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListGroupsRequest>, I>>(object: I): ListGroupsRequest {
    const message = createBaseListGroupsRequest();
    message.name = object.name ?? "";
    message.cursor = object.cursor ?? "";
    message.limit = object.limit ?? undefined;
    message.lang_tag = object.lang_tag ?? "";
    message.members = object.members ?? undefined;
    message.open = object.open ?? undefined;
    return message;
  },
};

function createBaseListGroupUsersRequest(): ListGroupUsersRequest {
  return { group_id: "", limit: undefined, state: undefined, cursor: "" };
}

export const ListGroupUsersRequest = {
  encode(message: ListGroupUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(34).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListGroupUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupUsersRequest {
    return {
      group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListGroupUsersRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListGroupUsersRequest>, I>>(base?: I): ListGroupUsersRequest {
    return ListGroupUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListGroupUsersRequest>, I>>(object: I): ListGroupUsersRequest {
    const message = createBaseListGroupUsersRequest();
    message.group_id = object.group_id ?? "";
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseListChannelUsersRequest(): ListChannelUsersRequest {
  return { clan_id: "", channel_id: "", channel_type: 0, limit: undefined, state: undefined, cursor: "" };
}

export const ListChannelUsersRequest = {
  encode(message: ListChannelUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(24).int32(message.channel_type);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(50).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelUsersRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListChannelUsersRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelUsersRequest>, I>>(base?: I): ListChannelUsersRequest {
    return ListChannelUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelUsersRequest>, I>>(object: I): ListChannelUsersRequest {
    const message = createBaseListChannelUsersRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_type = object.channel_type ?? 0;
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseListChannelAttachmentRequest(): ListChannelAttachmentRequest {
  return {
    clan_id: "",
    channel_id: "",
    file_type: "",
    limit: undefined,
    state: undefined,
    before: "",
    after: "",
    around: "",
  };
}

export const ListChannelAttachmentRequest = {
  encode(message: ListChannelAttachmentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.file_type !== "") {
      writer.uint32(26).string(message.file_type);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.before !== "") {
      writer.uint32(50).string(message.before);
    }
    if (message.after !== "") {
      writer.uint32(58).string(message.after);
    }
    if (message.around !== "") {
      writer.uint32(66).string(message.around);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelAttachmentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelAttachmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.file_type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.before = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.after = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.around = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelAttachmentRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      file_type: isSet(object.file_type) ? globalThis.String(object.file_type) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      before: isSet(object.before) ? globalThis.String(object.before) : "",
      after: isSet(object.after) ? globalThis.String(object.after) : "",
      around: isSet(object.around) ? globalThis.String(object.around) : "",
    };
  },

  toJSON(message: ListChannelAttachmentRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.file_type !== "") {
      obj.file_type = message.file_type;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.before !== "") {
      obj.before = message.before;
    }
    if (message.after !== "") {
      obj.after = message.after;
    }
    if (message.around !== "") {
      obj.around = message.around;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelAttachmentRequest>, I>>(base?: I): ListChannelAttachmentRequest {
    return ListChannelAttachmentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelAttachmentRequest>, I>>(object: I): ListChannelAttachmentRequest {
    const message = createBaseListChannelAttachmentRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.file_type = object.file_type ?? "";
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.before = object.before ?? "";
    message.after = object.after ?? "";
    message.around = object.around ?? "";
    return message;
  },
};

function createBaseListClanUsersRequest(): ListClanUsersRequest {
  return { clan_id: "" };
}

export const ListClanUsersRequest = {
  encode(message: ListClanUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListClanUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClanUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClanUsersRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ListClanUsersRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListClanUsersRequest>, I>>(base?: I): ListClanUsersRequest {
    return ListClanUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListClanUsersRequest>, I>>(object: I): ListClanUsersRequest {
    const message = createBaseListClanUsersRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseListNotificationsRequest(): ListNotificationsRequest {
  return { limit: undefined, clan_id: "", notification_id: "", code: undefined, direction: undefined };
}

export const ListNotificationsRequest = {
  encode(message: ListNotificationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.notification_id !== "") {
      writer.uint32(26).string(message.notification_id);
    }
    if (message.code !== undefined) {
      Int32Value.encode({ value: message.code! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.direction !== undefined) {
      Int32Value.encode({ value: message.direction! }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListNotificationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notification_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.code = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.direction = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationsRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      notification_id: isSet(object.notification_id) ? globalThis.String(object.notification_id) : "",
      code: isSet(object.code) ? Number(object.code) : undefined,
      direction: isSet(object.direction) ? Number(object.direction) : undefined,
    };
  },

  toJSON(message: ListNotificationsRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.notification_id !== "") {
      obj.notification_id = message.notification_id;
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.direction !== undefined) {
      obj.direction = message.direction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNotificationsRequest>, I>>(base?: I): ListNotificationsRequest {
    return ListNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNotificationsRequest>, I>>(object: I): ListNotificationsRequest {
    const message = createBaseListNotificationsRequest();
    message.limit = object.limit ?? undefined;
    message.clan_id = object.clan_id ?? "";
    message.notification_id = object.notification_id ?? "";
    message.code = object.code ?? undefined;
    message.direction = object.direction ?? undefined;
    return message;
  },
};

function createBaseListUserGroupsRequest(): ListUserGroupsRequest {
  return { user_id: "", limit: undefined, state: undefined, cursor: "" };
}

export const ListUserGroupsRequest = {
  encode(message: ListUserGroupsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(34).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserGroupsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserGroupsRequest {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListUserGroupsRequest): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserGroupsRequest>, I>>(base?: I): ListUserGroupsRequest {
    return ListUserGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserGroupsRequest>, I>>(object: I): ListUserGroupsRequest {
    const message = createBaseListUserGroupsRequest();
    message.user_id = object.user_id ?? "";
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseNotification(): Notification {
  return {
    id: "",
    subject: "",
    content: "",
    code: 0,
    sender_id: "",
    create_time: undefined,
    persistent: false,
    clan_id: "",
    channel_id: "",
    channel_type: 0,
    avatar_url: "",
  };
}

export const Notification = {
  encode(message: Notification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.code !== 0) {
      writer.uint32(32).int32(message.code);
    }
    if (message.sender_id !== "") {
      writer.uint32(42).string(message.sender_id);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.persistent !== false) {
      writer.uint32(56).bool(message.persistent);
    }
    if (message.clan_id !== "") {
      writer.uint32(66).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(74).string(message.channel_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(80).int32(message.channel_type);
    }
    if (message.avatar_url !== "") {
      writer.uint32(90).string(message.avatar_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Notification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.persistent = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      persistent: isSet(object.persistent) ? globalThis.Boolean(object.persistent) : false,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.persistent !== false) {
      obj.persistent = message.persistent;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notification>, I>>(base?: I): Notification {
    return Notification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notification>, I>>(object: I): Notification {
    const message = createBaseNotification();
    message.id = object.id ?? "";
    message.subject = object.subject ?? "";
    message.content = object.content ?? "";
    message.code = object.code ?? 0;
    message.sender_id = object.sender_id ?? "";
    message.create_time = object.create_time ?? undefined;
    message.persistent = object.persistent ?? false;
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_type = object.channel_type ?? 0;
    message.avatar_url = object.avatar_url ?? "";
    return message;
  },
};

function createBaseNotificationList(): NotificationList {
  return { notifications: [], cacheable_cursor: "" };
}

export const NotificationList = {
  encode(message: NotificationList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cacheable_cursor !== "") {
      writer.uint32(18).string(message.cacheable_cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Notification.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cacheable_cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationList {
    return {
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => Notification.fromJSON(e))
        : [],
      cacheable_cursor: isSet(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : "",
    };
  },

  toJSON(message: NotificationList): unknown {
    const obj: any = {};
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));
    }
    if (message.cacheable_cursor !== "") {
      obj.cacheable_cursor = message.cacheable_cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationList>, I>>(base?: I): NotificationList {
    return NotificationList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationList>, I>>(object: I): NotificationList {
    const message = createBaseNotificationList();
    message.notifications = object.notifications?.map((e) => Notification.fromPartial(e)) || [];
    message.cacheable_cursor = object.cacheable_cursor ?? "";
    return message;
  },
};

function createBasePromoteGroupUsersRequest(): PromoteGroupUsersRequest {
  return { group_id: "", user_ids: [] };
}

export const PromoteGroupUsersRequest = {
  encode(message: PromoteGroupUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PromoteGroupUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteGroupUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromoteGroupUsersRequest {
    return {
      group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PromoteGroupUsersRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PromoteGroupUsersRequest>, I>>(base?: I): PromoteGroupUsersRequest {
    return PromoteGroupUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PromoteGroupUsersRequest>, I>>(object: I): PromoteGroupUsersRequest {
    const message = createBasePromoteGroupUsersRequest();
    message.group_id = object.group_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseDemoteGroupUsersRequest(): DemoteGroupUsersRequest {
  return { group_id: "", user_ids: [] };
}

export const DemoteGroupUsersRequest = {
  encode(message: DemoteGroupUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DemoteGroupUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDemoteGroupUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DemoteGroupUsersRequest {
    return {
      group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DemoteGroupUsersRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DemoteGroupUsersRequest>, I>>(base?: I): DemoteGroupUsersRequest {
    return DemoteGroupUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DemoteGroupUsersRequest>, I>>(object: I): DemoteGroupUsersRequest {
    const message = createBaseDemoteGroupUsersRequest();
    message.group_id = object.group_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseRpc(): Rpc {
  return { id: "", payload: "", http_key: "" };
}

export const Rpc = {
  encode(message: Rpc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    if (message.http_key !== "") {
      writer.uint32(26).string(message.http_key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Rpc {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.http_key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rpc {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      http_key: isSet(object.http_key) ? globalThis.String(object.http_key) : "",
    };
  },

  toJSON(message: Rpc): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.http_key !== "") {
      obj.http_key = message.http_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rpc>, I>>(base?: I): Rpc {
    return Rpc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rpc>, I>>(object: I): Rpc {
    const message = createBaseRpc();
    message.id = object.id ?? "";
    message.payload = object.payload ?? "";
    message.http_key = object.http_key ?? "";
    return message;
  },
};

function createBaseSession(): Session {
  return { created: false, token: "", refresh_token: "", user_id: "" };
}

export const Session = {
  encode(message: Session, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.created !== false) {
      writer.uint32(8).bool(message.created);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.refresh_token !== "") {
      writer.uint32(26).string(message.refresh_token);
    }
    if (message.user_id !== "") {
      writer.uint32(34).string(message.user_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Session {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.created = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.refresh_token = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      created: isSet(object.created) ? globalThis.Boolean(object.created) : false,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      refresh_token: isSet(object.refresh_token) ? globalThis.String(object.refresh_token) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.created !== false) {
      obj.created = message.created;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.refresh_token !== "") {
      obj.refresh_token = message.refresh_token;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.created = object.created ?? false;
    message.token = object.token ?? "";
    message.refresh_token = object.refresh_token ?? "";
    message.user_id = object.user_id ?? "";
    return message;
  },
};

function createBaseUpdateAccountRequest(): UpdateAccountRequest {
  return {
    username: undefined,
    display_name: undefined,
    avatar_url: undefined,
    lang_tag: undefined,
    location: undefined,
    timezone: undefined,
    about_me: "",
    dob: undefined,
    logo: "",
    splash_screen: "",
  };
}

export const UpdateAccountRequest = {
  encode(message: UpdateAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== undefined) {
      StringValue.encode({ value: message.username! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.display_name !== undefined) {
      StringValue.encode({ value: message.display_name! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.avatar_url !== undefined) {
      StringValue.encode({ value: message.avatar_url! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lang_tag !== undefined) {
      StringValue.encode({ value: message.lang_tag! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.location !== undefined) {
      StringValue.encode({ value: message.location! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.timezone !== undefined) {
      StringValue.encode({ value: message.timezone! }, writer.uint32(50).fork()).ldelim();
    }
    if (message.about_me !== "") {
      writer.uint32(58).string(message.about_me);
    }
    if (message.dob !== undefined) {
      Timestamp.encode(toTimestamp(message.dob), writer.uint32(66).fork()).ldelim();
    }
    if (message.logo !== "") {
      writer.uint32(74).string(message.logo);
    }
    if (message.splash_screen !== "") {
      writer.uint32(82).string(message.splash_screen);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.display_name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar_url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lang_tag = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.location = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timezone = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.about_me = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dob = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.splash_screen = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAccountRequest {
    return {
      username: isSet(object.username) ? String(object.username) : undefined,
      display_name: isSet(object.display_name) ? String(object.display_name) : undefined,
      avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : undefined,
      lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : undefined,
      location: isSet(object.location) ? String(object.location) : undefined,
      timezone: isSet(object.timezone) ? String(object.timezone) : undefined,
      about_me: isSet(object.about_me) ? globalThis.String(object.about_me) : "",
      dob: isSet(object.dob) ? fromJsonTimestamp(object.dob) : undefined,
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      splash_screen: isSet(object.splash_screen) ? globalThis.String(object.splash_screen) : "",
    };
  },

  toJSON(message: UpdateAccountRequest): unknown {
    const obj: any = {};
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.display_name !== undefined) {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== undefined) {
      obj.avatar_url = message.avatar_url;
    }
    if (message.lang_tag !== undefined) {
      obj.lang_tag = message.lang_tag;
    }
    if (message.location !== undefined) {
      obj.location = message.location;
    }
    if (message.timezone !== undefined) {
      obj.timezone = message.timezone;
    }
    if (message.about_me !== "") {
      obj.about_me = message.about_me;
    }
    if (message.dob !== undefined) {
      obj.dob = message.dob.toISOString();
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.splash_screen !== "") {
      obj.splash_screen = message.splash_screen;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAccountRequest>, I>>(base?: I): UpdateAccountRequest {
    return UpdateAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAccountRequest>, I>>(object: I): UpdateAccountRequest {
    const message = createBaseUpdateAccountRequest();
    message.username = object.username ?? undefined;
    message.display_name = object.display_name ?? undefined;
    message.avatar_url = object.avatar_url ?? undefined;
    message.lang_tag = object.lang_tag ?? undefined;
    message.location = object.location ?? undefined;
    message.timezone = object.timezone ?? undefined;
    message.about_me = object.about_me ?? "";
    message.dob = object.dob ?? undefined;
    message.logo = object.logo ?? "";
    message.splash_screen = object.splash_screen ?? "";
    return message;
  },
};

function createBaseUpdateGroupRequest(): UpdateGroupRequest {
  return {
    group_id: "",
    name: undefined,
    description: undefined,
    lang_tag: undefined,
    avatar_url: undefined,
    open: undefined,
  };
}

export const UpdateGroupRequest = {
  encode(message: UpdateGroupRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group_id !== "") {
      writer.uint32(10).string(message.group_id);
    }
    if (message.name !== undefined) {
      StringValue.encode({ value: message.name! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lang_tag !== undefined) {
      StringValue.encode({ value: message.lang_tag! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.avatar_url !== undefined) {
      StringValue.encode({ value: message.avatar_url! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.open !== undefined) {
      BoolValue.encode({ value: message.open! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateGroupRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lang_tag = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.avatar_url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.open = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGroupRequest {
    return {
      group_id: isSet(object.group_id) ? globalThis.String(object.group_id) : "",
      name: isSet(object.name) ? String(object.name) : undefined,
      description: isSet(object.description) ? String(object.description) : undefined,
      lang_tag: isSet(object.lang_tag) ? String(object.lang_tag) : undefined,
      avatar_url: isSet(object.avatar_url) ? String(object.avatar_url) : undefined,
      open: isSet(object.open) ? Boolean(object.open) : undefined,
    };
  },

  toJSON(message: UpdateGroupRequest): unknown {
    const obj: any = {};
    if (message.group_id !== "") {
      obj.group_id = message.group_id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.lang_tag !== undefined) {
      obj.lang_tag = message.lang_tag;
    }
    if (message.avatar_url !== undefined) {
      obj.avatar_url = message.avatar_url;
    }
    if (message.open !== undefined) {
      obj.open = message.open;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateGroupRequest>, I>>(base?: I): UpdateGroupRequest {
    return UpdateGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateGroupRequest>, I>>(object: I): UpdateGroupRequest {
    const message = createBaseUpdateGroupRequest();
    message.group_id = object.group_id ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.lang_tag = object.lang_tag ?? undefined;
    message.avatar_url = object.avatar_url ?? undefined;
    message.open = object.open ?? undefined;
    return message;
  },
};

function createBaseUpdateCategoryDescRequest(): UpdateCategoryDescRequest {
  return { category_id: "", category_name: "", clan_id: "" };
}

export const UpdateCategoryDescRequest = {
  encode(message: UpdateCategoryDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category_id !== "") {
      writer.uint32(10).string(message.category_id);
    }
    if (message.category_name !== "") {
      writer.uint32(18).string(message.category_name);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCategoryDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryDescRequest {
    return {
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: UpdateCategoryDescRequest): unknown {
    const obj: any = {};
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCategoryDescRequest>, I>>(base?: I): UpdateCategoryDescRequest {
    return UpdateCategoryDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCategoryDescRequest>, I>>(object: I): UpdateCategoryDescRequest {
    const message = createBaseUpdateCategoryDescRequest();
    message.category_id = object.category_id ?? "";
    message.category_name = object.category_name ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    username: "",
    display_name: "",
    avatar_url: "",
    lang_tag: "",
    location: "",
    timezone: "",
    metadata: "",
    facebook_id: "",
    google_id: "",
    gamecenter_id: "",
    steam_id: "",
    online: false,
    edge_count: 0,
    create_time: undefined,
    update_time: undefined,
    apple_id: "",
    about_me: "",
    join_time: undefined,
    is_mobile: false,
    dob: undefined,
  };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.display_name !== "") {
      writer.uint32(26).string(message.display_name);
    }
    if (message.avatar_url !== "") {
      writer.uint32(34).string(message.avatar_url);
    }
    if (message.lang_tag !== "") {
      writer.uint32(42).string(message.lang_tag);
    }
    if (message.location !== "") {
      writer.uint32(50).string(message.location);
    }
    if (message.timezone !== "") {
      writer.uint32(58).string(message.timezone);
    }
    if (message.metadata !== "") {
      writer.uint32(66).string(message.metadata);
    }
    if (message.facebook_id !== "") {
      writer.uint32(74).string(message.facebook_id);
    }
    if (message.google_id !== "") {
      writer.uint32(82).string(message.google_id);
    }
    if (message.gamecenter_id !== "") {
      writer.uint32(90).string(message.gamecenter_id);
    }
    if (message.steam_id !== "") {
      writer.uint32(98).string(message.steam_id);
    }
    if (message.online !== false) {
      writer.uint32(104).bool(message.online);
    }
    if (message.edge_count !== 0) {
      writer.uint32(112).int32(message.edge_count);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(122).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(130).fork()).ldelim();
    }
    if (message.apple_id !== "") {
      writer.uint32(138).string(message.apple_id);
    }
    if (message.about_me !== "") {
      writer.uint32(146).string(message.about_me);
    }
    if (message.join_time !== undefined) {
      Timestamp.encode(toTimestamp(message.join_time), writer.uint32(154).fork()).ldelim();
    }
    if (message.is_mobile !== false) {
      writer.uint32(160).bool(message.is_mobile);
    }
    if (message.dob !== undefined) {
      Timestamp.encode(toTimestamp(message.dob), writer.uint32(170).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lang_tag = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.location = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timezone = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.facebook_id = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.google_id = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.gamecenter_id = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.steam_id = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.online = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.edge_count = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.apple_id = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.about_me = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.join_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.is_mobile = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.dob = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
      lang_tag: isSet(object.lang_tag) ? globalThis.String(object.lang_tag) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      facebook_id: isSet(object.facebook_id) ? globalThis.String(object.facebook_id) : "",
      google_id: isSet(object.google_id) ? globalThis.String(object.google_id) : "",
      gamecenter_id: isSet(object.gamecenter_id) ? globalThis.String(object.gamecenter_id) : "",
      steam_id: isSet(object.steam_id) ? globalThis.String(object.steam_id) : "",
      online: isSet(object.online) ? globalThis.Boolean(object.online) : false,
      edge_count: isSet(object.edge_count) ? globalThis.Number(object.edge_count) : 0,
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
      apple_id: isSet(object.apple_id) ? globalThis.String(object.apple_id) : "",
      about_me: isSet(object.about_me) ? globalThis.String(object.about_me) : "",
      join_time: isSet(object.join_time) ? fromJsonTimestamp(object.join_time) : undefined,
      is_mobile: isSet(object.is_mobile) ? globalThis.Boolean(object.is_mobile) : false,
      dob: isSet(object.dob) ? fromJsonTimestamp(object.dob) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    if (message.lang_tag !== "") {
      obj.lang_tag = message.lang_tag;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.facebook_id !== "") {
      obj.facebook_id = message.facebook_id;
    }
    if (message.google_id !== "") {
      obj.google_id = message.google_id;
    }
    if (message.gamecenter_id !== "") {
      obj.gamecenter_id = message.gamecenter_id;
    }
    if (message.steam_id !== "") {
      obj.steam_id = message.steam_id;
    }
    if (message.online !== false) {
      obj.online = message.online;
    }
    if (message.edge_count !== 0) {
      obj.edge_count = Math.round(message.edge_count);
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    if (message.apple_id !== "") {
      obj.apple_id = message.apple_id;
    }
    if (message.about_me !== "") {
      obj.about_me = message.about_me;
    }
    if (message.join_time !== undefined) {
      obj.join_time = message.join_time.toISOString();
    }
    if (message.is_mobile !== false) {
      obj.is_mobile = message.is_mobile;
    }
    if (message.dob !== undefined) {
      obj.dob = message.dob.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.display_name = object.display_name ?? "";
    message.avatar_url = object.avatar_url ?? "";
    message.lang_tag = object.lang_tag ?? "";
    message.location = object.location ?? "";
    message.timezone = object.timezone ?? "";
    message.metadata = object.metadata ?? "";
    message.facebook_id = object.facebook_id ?? "";
    message.google_id = object.google_id ?? "";
    message.gamecenter_id = object.gamecenter_id ?? "";
    message.steam_id = object.steam_id ?? "";
    message.online = object.online ?? false;
    message.edge_count = object.edge_count ?? 0;
    message.create_time = object.create_time ?? undefined;
    message.update_time = object.update_time ?? undefined;
    message.apple_id = object.apple_id ?? "";
    message.about_me = object.about_me ?? "";
    message.join_time = object.join_time ?? undefined;
    message.is_mobile = object.is_mobile ?? false;
    message.dob = object.dob ?? undefined;
    return message;
  },
};

function createBaseUserGroupList(): UserGroupList {
  return { user_groups: [], cursor: "" };
}

export const UserGroupList = {
  encode(message: UserGroupList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_groups) {
      UserGroupList_UserGroup.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserGroupList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGroupList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_groups.push(UserGroupList_UserGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGroupList {
    return {
      user_groups: globalThis.Array.isArray(object?.user_groups)
        ? object.user_groups.map((e: any) => UserGroupList_UserGroup.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: UserGroupList): unknown {
    const obj: any = {};
    if (message.user_groups?.length) {
      obj.user_groups = message.user_groups.map((e) => UserGroupList_UserGroup.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGroupList>, I>>(base?: I): UserGroupList {
    return UserGroupList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGroupList>, I>>(object: I): UserGroupList {
    const message = createBaseUserGroupList();
    message.user_groups = object.user_groups?.map((e) => UserGroupList_UserGroup.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseUserGroupList_UserGroup(): UserGroupList_UserGroup {
  return { group: undefined, state: undefined };
}

export const UserGroupList_UserGroup = {
  encode(message: UserGroupList_UserGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserGroupList_UserGroup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGroupList_UserGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGroupList_UserGroup {
    return {
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
    };
  },

  toJSON(message: UserGroupList_UserGroup): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGroupList_UserGroup>, I>>(base?: I): UserGroupList_UserGroup {
    return UserGroupList_UserGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGroupList_UserGroup>, I>>(object: I): UserGroupList_UserGroup {
    const message = createBaseUserGroupList_UserGroup();
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.state = object.state ?? undefined;
    return message;
  },
};

function createBaseUsers(): Users {
  return { users: [] };
}

export const Users = {
  encode(message: Users, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Users {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Users {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: Users): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Users>, I>>(base?: I): Users {
    return Users.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Users>, I>>(object: I): Users {
    const message = createBaseUsers();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClanDescProfile(): ClanDescProfile {
  return { clan_id: "", creator_id: "", nick_name: "", profile_banner: "", profile_theme: "", avatar_url: "" };
}

export const ClanDescProfile = {
  encode(message: ClanDescProfile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.creator_id !== "") {
      writer.uint32(18).string(message.creator_id);
    }
    if (message.nick_name !== "") {
      writer.uint32(26).string(message.nick_name);
    }
    if (message.profile_banner !== "") {
      writer.uint32(34).string(message.profile_banner);
    }
    if (message.profile_theme !== "") {
      writer.uint32(42).string(message.profile_theme);
    }
    if (message.avatar_url !== "") {
      writer.uint32(50).string(message.avatar_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanDescProfile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanDescProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nick_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.profile_banner = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.profile_theme = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanDescProfile {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      nick_name: isSet(object.nick_name) ? globalThis.String(object.nick_name) : "",
      profile_banner: isSet(object.profile_banner) ? globalThis.String(object.profile_banner) : "",
      profile_theme: isSet(object.profile_theme) ? globalThis.String(object.profile_theme) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
    };
  },

  toJSON(message: ClanDescProfile): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.nick_name !== "") {
      obj.nick_name = message.nick_name;
    }
    if (message.profile_banner !== "") {
      obj.profile_banner = message.profile_banner;
    }
    if (message.profile_theme !== "") {
      obj.profile_theme = message.profile_theme;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanDescProfile>, I>>(base?: I): ClanDescProfile {
    return ClanDescProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanDescProfile>, I>>(object: I): ClanDescProfile {
    const message = createBaseClanDescProfile();
    message.clan_id = object.clan_id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.nick_name = object.nick_name ?? "";
    message.profile_banner = object.profile_banner ?? "";
    message.profile_theme = object.profile_theme ?? "";
    message.avatar_url = object.avatar_url ?? "";
    return message;
  },
};

function createBaseUpdateClanDescProfileRequest(): UpdateClanDescProfileRequest {
  return { clan_id: "", nick_name: "", profile_banner: "", profile_theme: "", avatar_url: "" };
}

export const UpdateClanDescProfileRequest = {
  encode(message: UpdateClanDescProfileRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.nick_name !== "") {
      writer.uint32(18).string(message.nick_name);
    }
    if (message.profile_banner !== "") {
      writer.uint32(26).string(message.profile_banner);
    }
    if (message.profile_theme !== "") {
      writer.uint32(34).string(message.profile_theme);
    }
    if (message.avatar_url !== "") {
      writer.uint32(42).string(message.avatar_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateClanDescProfileRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClanDescProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nick_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.profile_banner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.profile_theme = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClanDescProfileRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      nick_name: isSet(object.nick_name) ? globalThis.String(object.nick_name) : "",
      profile_banner: isSet(object.profile_banner) ? globalThis.String(object.profile_banner) : "",
      profile_theme: isSet(object.profile_theme) ? globalThis.String(object.profile_theme) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
    };
  },

  toJSON(message: UpdateClanDescProfileRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.nick_name !== "") {
      obj.nick_name = message.nick_name;
    }
    if (message.profile_banner !== "") {
      obj.profile_banner = message.profile_banner;
    }
    if (message.profile_theme !== "") {
      obj.profile_theme = message.profile_theme;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClanDescProfileRequest>, I>>(base?: I): UpdateClanDescProfileRequest {
    return UpdateClanDescProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClanDescProfileRequest>, I>>(object: I): UpdateClanDescProfileRequest {
    const message = createBaseUpdateClanDescProfileRequest();
    message.clan_id = object.clan_id ?? "";
    message.nick_name = object.nick_name ?? "";
    message.profile_banner = object.profile_banner ?? "";
    message.profile_theme = object.profile_theme ?? "";
    message.avatar_url = object.avatar_url ?? "";
    return message;
  },
};

function createBaseClanDescProfileRequest(): ClanDescProfileRequest {
  return { clan_id: "" };
}

export const ClanDescProfileRequest = {
  encode(message: ClanDescProfileRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanDescProfileRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanDescProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanDescProfileRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ClanDescProfileRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanDescProfileRequest>, I>>(base?: I): ClanDescProfileRequest {
    return ClanDescProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanDescProfileRequest>, I>>(object: I): ClanDescProfileRequest {
    const message = createBaseClanDescProfileRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanDesc(): ClanDesc {
  return {
    creator_id: "",
    clan_name: "",
    logo: "",
    banner: "",
    clan_id: "",
    status: 0,
    badge_count: 0,
    is_onboarding: false,
  };
}

export const ClanDesc = {
  encode(message: ClanDesc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creator_id !== "") {
      writer.uint32(10).string(message.creator_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(18).string(message.clan_name);
    }
    if (message.logo !== "") {
      writer.uint32(26).string(message.logo);
    }
    if (message.banner !== "") {
      writer.uint32(34).string(message.banner);
    }
    if (message.clan_id !== "") {
      writer.uint32(42).string(message.clan_id);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.badge_count !== 0) {
      writer.uint32(56).int32(message.badge_count);
    }
    if (message.is_onboarding !== false) {
      writer.uint32(64).bool(message.is_onboarding);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanDesc {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanDesc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.banner = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.badge_count = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.is_onboarding = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanDesc {
    return {
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      banner: isSet(object.banner) ? globalThis.String(object.banner) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      badge_count: isSet(object.badge_count) ? globalThis.Number(object.badge_count) : 0,
      is_onboarding: isSet(object.is_onboarding) ? globalThis.Boolean(object.is_onboarding) : false,
    };
  },

  toJSON(message: ClanDesc): unknown {
    const obj: any = {};
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.banner !== "") {
      obj.banner = message.banner;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.badge_count !== 0) {
      obj.badge_count = Math.round(message.badge_count);
    }
    if (message.is_onboarding !== false) {
      obj.is_onboarding = message.is_onboarding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanDesc>, I>>(base?: I): ClanDesc {
    return ClanDesc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanDesc>, I>>(object: I): ClanDesc {
    const message = createBaseClanDesc();
    message.creator_id = object.creator_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.logo = object.logo ?? "";
    message.banner = object.banner ?? "";
    message.clan_id = object.clan_id ?? "";
    message.status = object.status ?? 0;
    message.badge_count = object.badge_count ?? 0;
    message.is_onboarding = object.is_onboarding ?? false;
    return message;
  },
};

function createBaseCreateClanDescRequest(): CreateClanDescRequest {
  return { clan_name: "", logo: "", banner: "" };
}

export const CreateClanDescRequest = {
  encode(message: CreateClanDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_name !== "") {
      writer.uint32(10).string(message.clan_name);
    }
    if (message.logo !== "") {
      writer.uint32(18).string(message.logo);
    }
    if (message.banner !== "") {
      writer.uint32(26).string(message.banner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateClanDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClanDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.banner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClanDescRequest {
    return {
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      banner: isSet(object.banner) ? globalThis.String(object.banner) : "",
    };
  },

  toJSON(message: CreateClanDescRequest): unknown {
    const obj: any = {};
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.banner !== "") {
      obj.banner = message.banner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateClanDescRequest>, I>>(base?: I): CreateClanDescRequest {
    return CreateClanDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateClanDescRequest>, I>>(object: I): CreateClanDescRequest {
    const message = createBaseCreateClanDescRequest();
    message.clan_name = object.clan_name ?? "";
    message.logo = object.logo ?? "";
    message.banner = object.banner ?? "";
    return message;
  },
};

function createBaseUpdateClanDescRequest(): UpdateClanDescRequest {
  return { clan_id: "", clan_name: "", logo: "", banner: "", status: 0, is_onboarding: undefined };
}

export const UpdateClanDescRequest = {
  encode(message: UpdateClanDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(18).string(message.clan_name);
    }
    if (message.logo !== "") {
      writer.uint32(26).string(message.logo);
    }
    if (message.banner !== "") {
      writer.uint32(34).string(message.banner);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.is_onboarding !== undefined) {
      BoolValue.encode({ value: message.is_onboarding! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateClanDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClanDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.banner = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.is_onboarding = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClanDescRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      banner: isSet(object.banner) ? globalThis.String(object.banner) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      is_onboarding: isSet(object.is_onboarding) ? Boolean(object.is_onboarding) : undefined,
    };
  },

  toJSON(message: UpdateClanDescRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.banner !== "") {
      obj.banner = message.banner;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.is_onboarding !== undefined) {
      obj.is_onboarding = message.is_onboarding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClanDescRequest>, I>>(base?: I): UpdateClanDescRequest {
    return UpdateClanDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClanDescRequest>, I>>(object: I): UpdateClanDescRequest {
    const message = createBaseUpdateClanDescRequest();
    message.clan_id = object.clan_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.logo = object.logo ?? "";
    message.banner = object.banner ?? "";
    message.status = object.status ?? 0;
    message.is_onboarding = object.is_onboarding ?? undefined;
    return message;
  },
};

function createBaseDeleteClanDescRequest(): DeleteClanDescRequest {
  return { clan_desc_id: "" };
}

export const DeleteClanDescRequest = {
  encode(message: DeleteClanDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_desc_id !== "") {
      writer.uint32(10).string(message.clan_desc_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteClanDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClanDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_desc_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClanDescRequest {
    return { clan_desc_id: isSet(object.clan_desc_id) ? globalThis.String(object.clan_desc_id) : "" };
  },

  toJSON(message: DeleteClanDescRequest): unknown {
    const obj: any = {};
    if (message.clan_desc_id !== "") {
      obj.clan_desc_id = message.clan_desc_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteClanDescRequest>, I>>(base?: I): DeleteClanDescRequest {
    return DeleteClanDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteClanDescRequest>, I>>(object: I): DeleteClanDescRequest {
    const message = createBaseDeleteClanDescRequest();
    message.clan_desc_id = object.clan_desc_id ?? "";
    return message;
  },
};

function createBaseListClanDescRequest(): ListClanDescRequest {
  return { limit: undefined, state: undefined, cursor: "" };
}

export const ListClanDescRequest = {
  encode(message: ListClanDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListClanDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClanDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClanDescRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListClanDescRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListClanDescRequest>, I>>(base?: I): ListClanDescRequest {
    return ListClanDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListClanDescRequest>, I>>(object: I): ListClanDescRequest {
    const message = createBaseListClanDescRequest();
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseClanDescList(): ClanDescList {
  return { clandesc: [] };
}

export const ClanDescList = {
  encode(message: ClanDescList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.clandesc) {
      ClanDesc.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanDescList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanDescList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clandesc.push(ClanDesc.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanDescList {
    return {
      clandesc: globalThis.Array.isArray(object?.clandesc) ? object.clandesc.map((e: any) => ClanDesc.fromJSON(e)) : [],
    };
  },

  toJSON(message: ClanDescList): unknown {
    const obj: any = {};
    if (message.clandesc?.length) {
      obj.clandesc = message.clandesc.map((e) => ClanDesc.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanDescList>, I>>(base?: I): ClanDescList {
    return ClanDescList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanDescList>, I>>(object: I): ClanDescList {
    const message = createBaseClanDescList();
    message.clandesc = object.clandesc?.map((e) => ClanDesc.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLinkInviteUserRequest(): LinkInviteUserRequest {
  return { clan_id: "", channel_id: "", expiry_time: 0 };
}

export const LinkInviteUserRequest = {
  encode(message: LinkInviteUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.expiry_time !== 0) {
      writer.uint32(24).int32(message.expiry_time);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkInviteUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkInviteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.expiry_time = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkInviteUserRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      expiry_time: isSet(object.expiry_time) ? globalThis.Number(object.expiry_time) : 0,
    };
  },

  toJSON(message: LinkInviteUserRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.expiry_time !== 0) {
      obj.expiry_time = Math.round(message.expiry_time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkInviteUserRequest>, I>>(base?: I): LinkInviteUserRequest {
    return LinkInviteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkInviteUserRequest>, I>>(object: I): LinkInviteUserRequest {
    const message = createBaseLinkInviteUserRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.expiry_time = object.expiry_time ?? 0;
    return message;
  },
};

function createBaseInviteUserRequest(): InviteUserRequest {
  return { invite_id: "" };
}

export const InviteUserRequest = {
  encode(message: InviteUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invite_id !== "") {
      writer.uint32(10).string(message.invite_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InviteUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invite_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InviteUserRequest {
    return { invite_id: isSet(object.invite_id) ? globalThis.String(object.invite_id) : "" };
  },

  toJSON(message: InviteUserRequest): unknown {
    const obj: any = {};
    if (message.invite_id !== "") {
      obj.invite_id = message.invite_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InviteUserRequest>, I>>(base?: I): InviteUserRequest {
    return InviteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InviteUserRequest>, I>>(object: I): InviteUserRequest {
    const message = createBaseInviteUserRequest();
    message.invite_id = object.invite_id ?? "";
    return message;
  },
};

function createBaseInviteUserRes(): InviteUserRes {
  return { clan_id: "", channel_id: "", clan_name: "", channel_label: "", user_joined: false, expiry_time: undefined };
}

export const InviteUserRes = {
  encode(message: InviteUserRes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(26).string(message.clan_name);
    }
    if (message.channel_label !== "") {
      writer.uint32(34).string(message.channel_label);
    }
    if (message.user_joined !== false) {
      writer.uint32(40).bool(message.user_joined);
    }
    if (message.expiry_time !== undefined) {
      Timestamp.encode(toTimestamp(message.expiry_time), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InviteUserRes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteUserRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.user_joined = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expiry_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InviteUserRes {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      user_joined: isSet(object.user_joined) ? globalThis.Boolean(object.user_joined) : false,
      expiry_time: isSet(object.expiry_time) ? fromJsonTimestamp(object.expiry_time) : undefined,
    };
  },

  toJSON(message: InviteUserRes): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.user_joined !== false) {
      obj.user_joined = message.user_joined;
    }
    if (message.expiry_time !== undefined) {
      obj.expiry_time = message.expiry_time.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InviteUserRes>, I>>(base?: I): InviteUserRes {
    return InviteUserRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InviteUserRes>, I>>(object: I): InviteUserRes {
    const message = createBaseInviteUserRes();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.channel_label = object.channel_label ?? "";
    message.user_joined = object.user_joined ?? false;
    message.expiry_time = object.expiry_time ?? undefined;
    return message;
  },
};

function createBaseJoinClanChannelRequest(): JoinClanChannelRequest {
  return { clan_id: "", channel_id: "" };
}

export const JoinClanChannelRequest = {
  encode(message: JoinClanChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JoinClanChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinClanChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinClanChannelRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: JoinClanChannelRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinClanChannelRequest>, I>>(base?: I): JoinClanChannelRequest {
    return JoinClanChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinClanChannelRequest>, I>>(object: I): JoinClanChannelRequest {
    const message = createBaseJoinClanChannelRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseLinkInviteUser(): LinkInviteUser {
  return {
    clan_id: "",
    creator_id: "",
    channel_id: "",
    invite_link: "",
    create_time: undefined,
    expiry_time: undefined,
    id: "",
  };
}

export const LinkInviteUser = {
  encode(message: LinkInviteUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.creator_id !== "") {
      writer.uint32(18).string(message.creator_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.invite_link !== "") {
      writer.uint32(34).string(message.invite_link);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(42).fork()).ldelim();
    }
    if (message.expiry_time !== undefined) {
      Timestamp.encode(toTimestamp(message.expiry_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkInviteUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkInviteUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.invite_link = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expiry_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkInviteUser {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      invite_link: isSet(object.invite_link) ? globalThis.String(object.invite_link) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      expiry_time: isSet(object.expiry_time) ? fromJsonTimestamp(object.expiry_time) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: LinkInviteUser): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.invite_link !== "") {
      obj.invite_link = message.invite_link;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.expiry_time !== undefined) {
      obj.expiry_time = message.expiry_time.toISOString();
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkInviteUser>, I>>(base?: I): LinkInviteUser {
    return LinkInviteUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkInviteUser>, I>>(object: I): LinkInviteUser {
    const message = createBaseLinkInviteUser();
    message.clan_id = object.clan_id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.invite_link = object.invite_link ?? "";
    message.create_time = object.create_time ?? undefined;
    message.expiry_time = object.expiry_time ?? undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseClanProfile(): ClanProfile {
  return { user_id: "", nick_name: "", avatar: "", clan_id: "" };
}

export const ClanProfile = {
  encode(message: ClanProfile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.nick_name !== "") {
      writer.uint32(18).string(message.nick_name);
    }
    if (message.avatar !== "") {
      writer.uint32(26).string(message.avatar);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanProfile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nick_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanProfile {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      nick_name: isSet(object.nick_name) ? globalThis.String(object.nick_name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanProfile): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.nick_name !== "") {
      obj.nick_name = message.nick_name;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanProfile>, I>>(base?: I): ClanProfile {
    return ClanProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanProfile>, I>>(object: I): ClanProfile {
    const message = createBaseClanProfile();
    message.user_id = object.user_id ?? "";
    message.nick_name = object.nick_name ?? "";
    message.avatar = object.avatar ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanProfileRequest(): ClanProfileRequest {
  return { clan_id: "" };
}

export const ClanProfileRequest = {
  encode(message: ClanProfileRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanProfileRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanProfileRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ClanProfileRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanProfileRequest>, I>>(base?: I): ClanProfileRequest {
    return ClanProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanProfileRequest>, I>>(object: I): ClanProfileRequest {
    const message = createBaseClanProfileRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseUpdateClanProfileRequest(): UpdateClanProfileRequest {
  return { clan_id: "", nick_name: "", avatar: "" };
}

export const UpdateClanProfileRequest = {
  encode(message: UpdateClanProfileRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.nick_name !== "") {
      writer.uint32(18).string(message.nick_name);
    }
    if (message.avatar !== "") {
      writer.uint32(26).string(message.avatar);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateClanProfileRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClanProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nick_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClanProfileRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      nick_name: isSet(object.nick_name) ? globalThis.String(object.nick_name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: UpdateClanProfileRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.nick_name !== "") {
      obj.nick_name = message.nick_name;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClanProfileRequest>, I>>(base?: I): UpdateClanProfileRequest {
    return UpdateClanProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClanProfileRequest>, I>>(object: I): UpdateClanProfileRequest {
    const message = createBaseUpdateClanProfileRequest();
    message.clan_id = object.clan_id ?? "";
    message.nick_name = object.nick_name ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseCategoryDesc(): CategoryDesc {
  return { creator_id: "", clan_id: "", category_name: "", category_id: "", category_order: 0 };
}

export const CategoryDesc = {
  encode(message: CategoryDesc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creator_id !== "") {
      writer.uint32(10).string(message.creator_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.category_name !== "") {
      writer.uint32(26).string(message.category_name);
    }
    if (message.category_id !== "") {
      writer.uint32(34).string(message.category_id);
    }
    if (message.category_order !== 0) {
      writer.uint32(40).int32(message.category_order);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CategoryDesc {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryDesc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.category_order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryDesc {
    return {
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      category_order: isSet(object.category_order) ? globalThis.Number(object.category_order) : 0,
    };
  },

  toJSON(message: CategoryDesc): unknown {
    const obj: any = {};
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.category_order !== 0) {
      obj.category_order = Math.round(message.category_order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryDesc>, I>>(base?: I): CategoryDesc {
    return CategoryDesc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryDesc>, I>>(object: I): CategoryDesc {
    const message = createBaseCategoryDesc();
    message.creator_id = object.creator_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.category_name = object.category_name ?? "";
    message.category_id = object.category_id ?? "";
    message.category_order = object.category_order ?? 0;
    return message;
  },
};

function createBaseUpdateCategoryOrderRequest(): UpdateCategoryOrderRequest {
  return { clan_id: "", categories: [] };
}

export const UpdateCategoryOrderRequest = {
  encode(message: UpdateCategoryOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    for (const v of message.categories) {
      CategoryOrderUpdate.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCategoryOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.categories.push(CategoryOrderUpdate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryOrderRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => CategoryOrderUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateCategoryOrderRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => CategoryOrderUpdate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCategoryOrderRequest>, I>>(base?: I): UpdateCategoryOrderRequest {
    return UpdateCategoryOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCategoryOrderRequest>, I>>(object: I): UpdateCategoryOrderRequest {
    const message = createBaseUpdateCategoryOrderRequest();
    message.clan_id = object.clan_id ?? "";
    message.categories = object.categories?.map((e) => CategoryOrderUpdate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCategoryOrderUpdate(): CategoryOrderUpdate {
  return { category_id: "", order: 0 };
}

export const CategoryOrderUpdate = {
  encode(message: CategoryOrderUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category_id !== "") {
      writer.uint32(10).string(message.category_id);
    }
    if (message.order !== 0) {
      writer.uint32(16).int32(message.order);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CategoryOrderUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryOrderUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryOrderUpdate {
    return {
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: CategoryOrderUpdate): unknown {
    const obj: any = {};
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryOrderUpdate>, I>>(base?: I): CategoryOrderUpdate {
    return CategoryOrderUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryOrderUpdate>, I>>(object: I): CategoryOrderUpdate {
    const message = createBaseCategoryOrderUpdate();
    message.category_id = object.category_id ?? "";
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseCreateCategoryDescRequest(): CreateCategoryDescRequest {
  return { category_name: "", clan_id: "" };
}

export const CreateCategoryDescRequest = {
  encode(message: CreateCategoryDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category_name !== "") {
      writer.uint32(10).string(message.category_name);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateCategoryDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryDescRequest {
    return {
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: CreateCategoryDescRequest): unknown {
    const obj: any = {};
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCategoryDescRequest>, I>>(base?: I): CreateCategoryDescRequest {
    return CreateCategoryDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCategoryDescRequest>, I>>(object: I): CreateCategoryDescRequest {
    const message = createBaseCreateCategoryDescRequest();
    message.category_name = object.category_name ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseDeleteCategoryDescRequest(): DeleteCategoryDescRequest {
  return { category_id: "", clan_id: "" };
}

export const DeleteCategoryDescRequest = {
  encode(message: DeleteCategoryDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category_id !== "") {
      writer.uint32(10).string(message.category_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCategoryDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryDescRequest {
    return {
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: DeleteCategoryDescRequest): unknown {
    const obj: any = {};
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCategoryDescRequest>, I>>(base?: I): DeleteCategoryDescRequest {
    return DeleteCategoryDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCategoryDescRequest>, I>>(object: I): DeleteCategoryDescRequest {
    const message = createBaseDeleteCategoryDescRequest();
    message.category_id = object.category_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseCategoryDescList(): CategoryDescList {
  return { categorydesc: [] };
}

export const CategoryDescList = {
  encode(message: CategoryDescList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.categorydesc) {
      CategoryDesc.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CategoryDescList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryDescList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categorydesc.push(CategoryDesc.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryDescList {
    return {
      categorydesc: globalThis.Array.isArray(object?.categorydesc)
        ? object.categorydesc.map((e: any) => CategoryDesc.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CategoryDescList): unknown {
    const obj: any = {};
    if (message.categorydesc?.length) {
      obj.categorydesc = message.categorydesc.map((e) => CategoryDesc.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CategoryDescList>, I>>(base?: I): CategoryDescList {
    return CategoryDescList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CategoryDescList>, I>>(object: I): CategoryDescList {
    const message = createBaseCategoryDescList();
    message.categorydesc = object.categorydesc?.map((e) => CategoryDesc.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListCategoryDescsRequest(): ListCategoryDescsRequest {
  return { limit: undefined, state: undefined, cursor: "" };
}

export const ListCategoryDescsRequest = {
  encode(message: ListCategoryDescsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListCategoryDescsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCategoryDescsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCategoryDescsRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListCategoryDescsRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCategoryDescsRequest>, I>>(base?: I): ListCategoryDescsRequest {
    return ListCategoryDescsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCategoryDescsRequest>, I>>(object: I): ListCategoryDescsRequest {
    const message = createBaseListCategoryDescsRequest();
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseChannelMessageHeader(): ChannelMessageHeader {
  return {
    id: "",
    timestamp_seconds: 0,
    sender_id: "",
    content: "",
    attachment: "",
    referece: "",
    mention: "",
    reaction: "",
  };
}

export const ChannelMessageHeader = {
  encode(message: ChannelMessageHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp_seconds !== 0) {
      writer.uint32(16).uint32(message.timestamp_seconds);
    }
    if (message.sender_id !== "") {
      writer.uint32(26).string(message.sender_id);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.attachment !== "") {
      writer.uint32(42).string(message.attachment);
    }
    if (message.referece !== "") {
      writer.uint32(50).string(message.referece);
    }
    if (message.mention !== "") {
      writer.uint32(58).string(message.mention);
    }
    if (message.reaction !== "") {
      writer.uint32(66).string(message.reaction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp_seconds = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attachment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referece = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mention = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.reaction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageHeader {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp_seconds: isSet(object.timestamp_seconds) ? globalThis.Number(object.timestamp_seconds) : 0,
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      attachment: isSet(object.attachment) ? globalThis.String(object.attachment) : "",
      referece: isSet(object.referece) ? globalThis.String(object.referece) : "",
      mention: isSet(object.mention) ? globalThis.String(object.mention) : "",
      reaction: isSet(object.reaction) ? globalThis.String(object.reaction) : "",
    };
  },

  toJSON(message: ChannelMessageHeader): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp_seconds !== 0) {
      obj.timestamp_seconds = Math.round(message.timestamp_seconds);
    }
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.attachment !== "") {
      obj.attachment = message.attachment;
    }
    if (message.referece !== "") {
      obj.referece = message.referece;
    }
    if (message.mention !== "") {
      obj.mention = message.mention;
    }
    if (message.reaction !== "") {
      obj.reaction = message.reaction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageHeader>, I>>(base?: I): ChannelMessageHeader {
    return ChannelMessageHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageHeader>, I>>(object: I): ChannelMessageHeader {
    const message = createBaseChannelMessageHeader();
    message.id = object.id ?? "";
    message.timestamp_seconds = object.timestamp_seconds ?? 0;
    message.sender_id = object.sender_id ?? "";
    message.content = object.content ?? "";
    message.attachment = object.attachment ?? "";
    message.referece = object.referece ?? "";
    message.mention = object.mention ?? "";
    message.reaction = object.reaction ?? "";
    return message;
  },
};

function createBaseChannelDescription(): ChannelDescription {
  return {
    clan_id: "",
    parrent_id: "",
    channel_id: "",
    category_id: "",
    category_name: "",
    type: undefined,
    creator_id: "",
    channel_label: "",
    channel_private: 0,
    channel_avatar: [],
    user_id: [],
    last_sent_message: undefined,
    last_seen_message: undefined,
    is_online: [],
    meeting_code: "",
    count_mess_unread: 0,
    active: 0,
    last_pin_message: "",
    usernames: "",
    creator_name: "",
    create_time_seconds: 0,
    update_time_seconds: 0,
    metadata: [],
    about_me: [],
    clan_name: "",
    app_url: "",
    is_mute: false,
    age_restricted: 0,
    topic: "",
    e2ee: 0,
  };
}

export const ChannelDescription = {
  encode(message: ChannelDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.parrent_id !== "") {
      writer.uint32(18).string(message.parrent_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.category_id !== "") {
      writer.uint32(34).string(message.category_id);
    }
    if (message.category_name !== "") {
      writer.uint32(42).string(message.category_name);
    }
    if (message.type !== undefined) {
      Int32Value.encode({ value: message.type! }, writer.uint32(50).fork()).ldelim();
    }
    if (message.creator_id !== "") {
      writer.uint32(58).string(message.creator_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(66).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(72).int32(message.channel_private);
    }
    for (const v of message.channel_avatar) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.user_id) {
      writer.uint32(90).string(v!);
    }
    if (message.last_sent_message !== undefined) {
      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();
    }
    if (message.last_seen_message !== undefined) {
      ChannelMessageHeader.encode(message.last_seen_message, writer.uint32(106).fork()).ldelim();
    }
    writer.uint32(114).fork();
    for (const v of message.is_online) {
      writer.bool(v);
    }
    writer.ldelim();
    if (message.meeting_code !== "") {
      writer.uint32(122).string(message.meeting_code);
    }
    if (message.count_mess_unread !== 0) {
      writer.uint32(128).int32(message.count_mess_unread);
    }
    if (message.active !== 0) {
      writer.uint32(136).int32(message.active);
    }
    if (message.last_pin_message !== "") {
      writer.uint32(146).string(message.last_pin_message);
    }
    if (message.usernames !== "") {
      writer.uint32(154).string(message.usernames);
    }
    if (message.creator_name !== "") {
      writer.uint32(162).string(message.creator_name);
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(168).uint32(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      writer.uint32(176).uint32(message.update_time_seconds);
    }
    for (const v of message.metadata) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.about_me) {
      writer.uint32(194).string(v!);
    }
    if (message.clan_name !== "") {
      writer.uint32(202).string(message.clan_name);
    }
    if (message.app_url !== "") {
      writer.uint32(210).string(message.app_url);
    }
    if (message.is_mute !== false) {
      writer.uint32(216).bool(message.is_mute);
    }
    if (message.age_restricted !== 0) {
      writer.uint32(224).int32(message.age_restricted);
    }
    if (message.topic !== "") {
      writer.uint32(234).string(message.topic);
    }
    if (message.e2ee !== 0) {
      writer.uint32(240).int32(message.e2ee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.channel_avatar.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.user_id.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.last_seen_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag === 112) {
            message.is_online.push(reader.bool());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.is_online.push(reader.bool());
            }

            continue;
          }

          break;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.count_mess_unread = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.last_pin_message = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.usernames = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.creator_name = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.update_time_seconds = reader.uint32();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.metadata.push(reader.string());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.about_me.push(reader.string());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.app_url = reader.string();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.is_mute = reader.bool();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.age_restricted = reader.int32();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.e2ee = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDescription {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      type: isSet(object.type) ? Number(object.type) : undefined,
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      channel_avatar: globalThis.Array.isArray(object?.channel_avatar)
        ? object.channel_avatar.map((e: any) => globalThis.String(e))
        : [],
      user_id: globalThis.Array.isArray(object?.user_id) ? object.user_id.map((e: any) => globalThis.String(e)) : [],
      last_sent_message: isSet(object.last_sent_message)
        ? ChannelMessageHeader.fromJSON(object.last_sent_message)
        : undefined,
      last_seen_message: isSet(object.last_seen_message)
        ? ChannelMessageHeader.fromJSON(object.last_seen_message)
        : undefined,
      is_online: globalThis.Array.isArray(object?.is_online)
        ? object.is_online.map((e: any) => globalThis.Boolean(e))
        : [],
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      count_mess_unread: isSet(object.count_mess_unread) ? globalThis.Number(object.count_mess_unread) : 0,
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      last_pin_message: isSet(object.last_pin_message) ? globalThis.String(object.last_pin_message) : "",
      usernames: isSet(object.usernames) ? globalThis.String(object.usernames) : "",
      creator_name: isSet(object.creator_name) ? globalThis.String(object.creator_name) : "",
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
      update_time_seconds: isSet(object.update_time_seconds) ? globalThis.Number(object.update_time_seconds) : 0,
      metadata: globalThis.Array.isArray(object?.metadata) ? object.metadata.map((e: any) => globalThis.String(e)) : [],
      about_me: globalThis.Array.isArray(object?.about_me) ? object.about_me.map((e: any) => globalThis.String(e)) : [],
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      app_url: isSet(object.app_url) ? globalThis.String(object.app_url) : "",
      is_mute: isSet(object.is_mute) ? globalThis.Boolean(object.is_mute) : false,
      age_restricted: isSet(object.age_restricted) ? globalThis.Number(object.age_restricted) : 0,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      e2ee: isSet(object.e2ee) ? globalThis.Number(object.e2ee) : 0,
    };
  },

  toJSON(message: ChannelDescription): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.channel_avatar?.length) {
      obj.channel_avatar = message.channel_avatar;
    }
    if (message.user_id?.length) {
      obj.user_id = message.user_id;
    }
    if (message.last_sent_message !== undefined) {
      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);
    }
    if (message.last_seen_message !== undefined) {
      obj.last_seen_message = ChannelMessageHeader.toJSON(message.last_seen_message);
    }
    if (message.is_online?.length) {
      obj.is_online = message.is_online;
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.count_mess_unread !== 0) {
      obj.count_mess_unread = Math.round(message.count_mess_unread);
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.last_pin_message !== "") {
      obj.last_pin_message = message.last_pin_message;
    }
    if (message.usernames !== "") {
      obj.usernames = message.usernames;
    }
    if (message.creator_name !== "") {
      obj.creator_name = message.creator_name;
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    if (message.update_time_seconds !== 0) {
      obj.update_time_seconds = Math.round(message.update_time_seconds);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata;
    }
    if (message.about_me?.length) {
      obj.about_me = message.about_me;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.app_url !== "") {
      obj.app_url = message.app_url;
    }
    if (message.is_mute !== false) {
      obj.is_mute = message.is_mute;
    }
    if (message.age_restricted !== 0) {
      obj.age_restricted = Math.round(message.age_restricted);
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.e2ee !== 0) {
      obj.e2ee = Math.round(message.e2ee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDescription>, I>>(base?: I): ChannelDescription {
    return ChannelDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDescription>, I>>(object: I): ChannelDescription {
    const message = createBaseChannelDescription();
    message.clan_id = object.clan_id ?? "";
    message.parrent_id = object.parrent_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.category_id = object.category_id ?? "";
    message.category_name = object.category_name ?? "";
    message.type = object.type ?? undefined;
    message.creator_id = object.creator_id ?? "";
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.channel_avatar = object.channel_avatar?.map((e) => e) || [];
    message.user_id = object.user_id?.map((e) => e) || [];
    message.last_sent_message = (object.last_sent_message !== undefined && object.last_sent_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_sent_message)
      : undefined;
    message.last_seen_message = (object.last_seen_message !== undefined && object.last_seen_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_seen_message)
      : undefined;
    message.is_online = object.is_online?.map((e) => e) || [];
    message.meeting_code = object.meeting_code ?? "";
    message.count_mess_unread = object.count_mess_unread ?? 0;
    message.active = object.active ?? 0;
    message.last_pin_message = object.last_pin_message ?? "";
    message.usernames = object.usernames ?? "";
    message.creator_name = object.creator_name ?? "";
    message.create_time_seconds = object.create_time_seconds ?? 0;
    message.update_time_seconds = object.update_time_seconds ?? 0;
    message.metadata = object.metadata?.map((e) => e) || [];
    message.about_me = object.about_me?.map((e) => e) || [];
    message.clan_name = object.clan_name ?? "";
    message.app_url = object.app_url ?? "";
    message.is_mute = object.is_mute ?? false;
    message.age_restricted = object.age_restricted ?? 0;
    message.topic = object.topic ?? "";
    message.e2ee = object.e2ee ?? 0;
    return message;
  },
};

function createBaseChannelDescList(): ChannelDescList {
  return { channeldesc: [], next_cursor: "", prev_cursor: "", cacheable_cursor: "" };
}

export const ChannelDescList = {
  encode(message: ChannelDescList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.channeldesc) {
      ChannelDescription.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.next_cursor !== "") {
      writer.uint32(18).string(message.next_cursor);
    }
    if (message.prev_cursor !== "") {
      writer.uint32(26).string(message.prev_cursor);
    }
    if (message.cacheable_cursor !== "") {
      writer.uint32(34).string(message.cacheable_cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDescList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDescList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.next_cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prev_cursor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cacheable_cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDescList {
    return {
      channeldesc: globalThis.Array.isArray(object?.channeldesc)
        ? object.channeldesc.map((e: any) => ChannelDescription.fromJSON(e))
        : [],
      next_cursor: isSet(object.next_cursor) ? globalThis.String(object.next_cursor) : "",
      prev_cursor: isSet(object.prev_cursor) ? globalThis.String(object.prev_cursor) : "",
      cacheable_cursor: isSet(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : "",
    };
  },

  toJSON(message: ChannelDescList): unknown {
    const obj: any = {};
    if (message.channeldesc?.length) {
      obj.channeldesc = message.channeldesc.map((e) => ChannelDescription.toJSON(e));
    }
    if (message.next_cursor !== "") {
      obj.next_cursor = message.next_cursor;
    }
    if (message.prev_cursor !== "") {
      obj.prev_cursor = message.prev_cursor;
    }
    if (message.cacheable_cursor !== "") {
      obj.cacheable_cursor = message.cacheable_cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDescList>, I>>(base?: I): ChannelDescList {
    return ChannelDescList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDescList>, I>>(object: I): ChannelDescList {
    const message = createBaseChannelDescList();
    message.channeldesc = object.channeldesc?.map((e) => ChannelDescription.fromPartial(e)) || [];
    message.next_cursor = object.next_cursor ?? "";
    message.prev_cursor = object.prev_cursor ?? "";
    message.cacheable_cursor = object.cacheable_cursor ?? "";
    return message;
  },
};

function createBaseListThreadRequest(): ListThreadRequest {
  return { limit: undefined, state: undefined, clan_id: "", channel_id: "", thread_id: "" };
}

export const ListThreadRequest = {
  encode(message: ListThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(34).string(message.channel_id);
    }
    if (message.thread_id !== "") {
      writer.uint32(42).string(message.thread_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.thread_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListThreadRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      thread_id: isSet(object.thread_id) ? globalThis.String(object.thread_id) : "",
    };
  },

  toJSON(message: ListThreadRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.thread_id !== "") {
      obj.thread_id = message.thread_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListThreadRequest>, I>>(base?: I): ListThreadRequest {
    return ListThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListThreadRequest>, I>>(object: I): ListThreadRequest {
    const message = createBaseListThreadRequest();
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.thread_id = object.thread_id ?? "";
    return message;
  },
};

function createBaseListChannelDescsRequest(): ListChannelDescsRequest {
  return { limit: undefined, state: undefined, cursor: "", clan_id: "", channel_type: 0 };
}

export const ListChannelDescsRequest = {
  encode(message: ListChannelDescsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(40).int32(message.channel_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelDescsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelDescsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelDescsRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      state: isSet(object.state) ? Number(object.state) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
    };
  },

  toJSON(message: ListChannelDescsRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelDescsRequest>, I>>(base?: I): ListChannelDescsRequest {
    return ListChannelDescsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelDescsRequest>, I>>(object: I): ListChannelDescsRequest {
    const message = createBaseListChannelDescsRequest();
    message.limit = object.limit ?? undefined;
    message.state = object.state ?? undefined;
    message.cursor = object.cursor ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_type = object.channel_type ?? 0;
    return message;
  },
};

function createBaseAddRoleChannelDescRequest(): AddRoleChannelDescRequest {
  return { role_ids: [], channel_id: "" };
}

export const AddRoleChannelDescRequest = {
  encode(message: AddRoleChannelDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.role_ids) {
      writer.uint32(10).string(v!);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddRoleChannelDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRoleChannelDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddRoleChannelDescRequest {
    return {
      role_ids: globalThis.Array.isArray(object?.role_ids) ? object.role_ids.map((e: any) => globalThis.String(e)) : [],
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: AddRoleChannelDescRequest): unknown {
    const obj: any = {};
    if (message.role_ids?.length) {
      obj.role_ids = message.role_ids;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddRoleChannelDescRequest>, I>>(base?: I): AddRoleChannelDescRequest {
    return AddRoleChannelDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddRoleChannelDescRequest>, I>>(object: I): AddRoleChannelDescRequest {
    const message = createBaseAddRoleChannelDescRequest();
    message.role_ids = object.role_ids?.map((e) => e) || [];
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseCreateChannelDescRequest(): CreateChannelDescRequest {
  return {
    clan_id: "",
    parrent_id: "",
    channel_id: "",
    category_id: "",
    type: undefined,
    channel_label: "",
    channel_private: 0,
    user_ids: [],
    app_url: undefined,
  };
}

export const CreateChannelDescRequest = {
  encode(message: CreateChannelDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.parrent_id !== "") {
      writer.uint32(18).string(message.parrent_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.category_id !== "") {
      writer.uint32(34).string(message.category_id);
    }
    if (message.type !== undefined) {
      Int32Value.encode({ value: message.type! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.channel_label !== "") {
      writer.uint32(50).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(56).int32(message.channel_private);
    }
    for (const v of message.user_ids) {
      writer.uint32(66).string(v!);
    }
    if (message.app_url !== undefined) {
      StringValue.encode({ value: message.app_url! }, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateChannelDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.app_url = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChannelDescRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      type: isSet(object.type) ? Number(object.type) : undefined,
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      app_url: isSet(object.app_url) ? String(object.app_url) : undefined,
    };
  },

  toJSON(message: CreateChannelDescRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.app_url !== undefined) {
      obj.app_url = message.app_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateChannelDescRequest>, I>>(base?: I): CreateChannelDescRequest {
    return CreateChannelDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateChannelDescRequest>, I>>(object: I): CreateChannelDescRequest {
    const message = createBaseCreateChannelDescRequest();
    message.clan_id = object.clan_id ?? "";
    message.parrent_id = object.parrent_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.category_id = object.category_id ?? "";
    message.type = object.type ?? undefined;
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.app_url = object.app_url ?? undefined;
    return message;
  },
};

function createBaseDeleteChannelDescRequest(): DeleteChannelDescRequest {
  return { channel_id: "" };
}

export const DeleteChannelDescRequest = {
  encode(message: DeleteChannelDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteChannelDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChannelDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChannelDescRequest {
    return { channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "" };
  },

  toJSON(message: DeleteChannelDescRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChannelDescRequest>, I>>(base?: I): DeleteChannelDescRequest {
    return DeleteChannelDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChannelDescRequest>, I>>(object: I): DeleteChannelDescRequest {
    const message = createBaseDeleteChannelDescRequest();
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseUpdateChannelDescRequest(): UpdateChannelDescRequest {
  return {
    channel_id: "",
    channel_label: undefined,
    category_id: undefined,
    app_url: undefined,
    topic: "",
    age_restricted: 0,
    e2ee: 0,
  };
}

export const UpdateChannelDescRequest = {
  encode(message: UpdateChannelDescRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.channel_label !== undefined) {
      StringValue.encode({ value: message.channel_label! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.category_id !== undefined) {
      StringValue.encode({ value: message.category_id! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.app_url !== undefined) {
      StringValue.encode({ value: message.app_url! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.topic !== "") {
      writer.uint32(42).string(message.topic);
    }
    if (message.age_restricted !== 0) {
      writer.uint32(48).int32(message.age_restricted);
    }
    if (message.e2ee !== 0) {
      writer.uint32(56).int32(message.e2ee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateChannelDescRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChannelDescRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_label = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.category_id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.app_url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.age_restricted = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.e2ee = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChannelDescRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_label: isSet(object.channel_label) ? String(object.channel_label) : undefined,
      category_id: isSet(object.category_id) ? String(object.category_id) : undefined,
      app_url: isSet(object.app_url) ? String(object.app_url) : undefined,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      age_restricted: isSet(object.age_restricted) ? globalThis.Number(object.age_restricted) : 0,
      e2ee: isSet(object.e2ee) ? globalThis.Number(object.e2ee) : 0,
    };
  },

  toJSON(message: UpdateChannelDescRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_label !== undefined) {
      obj.channel_label = message.channel_label;
    }
    if (message.category_id !== undefined) {
      obj.category_id = message.category_id;
    }
    if (message.app_url !== undefined) {
      obj.app_url = message.app_url;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.age_restricted !== 0) {
      obj.age_restricted = Math.round(message.age_restricted);
    }
    if (message.e2ee !== 0) {
      obj.e2ee = Math.round(message.e2ee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateChannelDescRequest>, I>>(base?: I): UpdateChannelDescRequest {
    return UpdateChannelDescRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateChannelDescRequest>, I>>(object: I): UpdateChannelDescRequest {
    const message = createBaseUpdateChannelDescRequest();
    message.channel_id = object.channel_id ?? "";
    message.channel_label = object.channel_label ?? undefined;
    message.category_id = object.category_id ?? undefined;
    message.app_url = object.app_url ?? undefined;
    message.topic = object.topic ?? "";
    message.age_restricted = object.age_restricted ?? 0;
    message.e2ee = object.e2ee ?? 0;
    return message;
  },
};

function createBaseChangeChannelPrivateRequest(): ChangeChannelPrivateRequest {
  return { channel_id: "", channel_private: 0, user_ids: [], role_ids: [] };
}

export const ChangeChannelPrivateRequest = {
  encode(message: ChangeChannelPrivateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.channel_private !== 0) {
      writer.uint32(16).int32(message.channel_private);
    }
    for (const v of message.user_ids) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.role_ids) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChangeChannelPrivateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeChannelPrivateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.role_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeChannelPrivateRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      role_ids: globalThis.Array.isArray(object?.role_ids) ? object.role_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ChangeChannelPrivateRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.role_ids?.length) {
      obj.role_ids = message.role_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeChannelPrivateRequest>, I>>(base?: I): ChangeChannelPrivateRequest {
    return ChangeChannelPrivateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeChannelPrivateRequest>, I>>(object: I): ChangeChannelPrivateRequest {
    const message = createBaseChangeChannelPrivateRequest();
    message.channel_id = object.channel_id ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.role_ids = object.role_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddChannelUsersRequest(): AddChannelUsersRequest {
  return { channel_id: "", user_ids: [] };
}

export const AddChannelUsersRequest = {
  encode(message: AddChannelUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddChannelUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddChannelUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddChannelUsersRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AddChannelUsersRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddChannelUsersRequest>, I>>(base?: I): AddChannelUsersRequest {
    return AddChannelUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddChannelUsersRequest>, I>>(object: I): AddChannelUsersRequest {
    const message = createBaseAddChannelUsersRequest();
    message.channel_id = object.channel_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveChannelUsersRequest(): RemoveChannelUsersRequest {
  return { channel_id: "", user_ids: [] };
}

export const RemoveChannelUsersRequest = {
  encode(message: RemoveChannelUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveChannelUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveChannelUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveChannelUsersRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RemoveChannelUsersRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveChannelUsersRequest>, I>>(base?: I): RemoveChannelUsersRequest {
    return RemoveChannelUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveChannelUsersRequest>, I>>(object: I): RemoveChannelUsersRequest {
    const message = createBaseRemoveChannelUsersRequest();
    message.channel_id = object.channel_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveClanUsersRequest(): RemoveClanUsersRequest {
  return { clan_id: "", user_ids: [] };
}

export const RemoveClanUsersRequest = {
  encode(message: RemoveClanUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveClanUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveClanUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveClanUsersRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RemoveClanUsersRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveClanUsersRequest>, I>>(base?: I): RemoveClanUsersRequest {
    return RemoveClanUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveClanUsersRequest>, I>>(object: I): RemoveClanUsersRequest {
    const message = createBaseRemoveClanUsersRequest();
    message.clan_id = object.clan_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseLeaveThreadRequest(): LeaveThreadRequest {
  return { channel_id: "" };
}

export const LeaveThreadRequest = {
  encode(message: LeaveThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveThreadRequest {
    return { channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "" };
  },

  toJSON(message: LeaveThreadRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveThreadRequest>, I>>(base?: I): LeaveThreadRequest {
    return LeaveThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveThreadRequest>, I>>(object: I): LeaveThreadRequest {
    const message = createBaseLeaveThreadRequest();
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseRole(): Role {
  return {
    id: "",
    title: "",
    color: "",
    role_icon: "",
    slug: "",
    description: "",
    creator_id: "",
    clan_id: "",
    active: 0,
    display_online: 0,
    allow_mention: 0,
    role_user_list: undefined,
    permission_list: undefined,
    role_channel_active: 0,
    channel_ids: [],
    max_level_permission: 0,
  };
}

export const Role = {
  encode(message: Role, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.color !== "") {
      writer.uint32(26).string(message.color);
    }
    if (message.role_icon !== "") {
      writer.uint32(34).string(message.role_icon);
    }
    if (message.slug !== "") {
      writer.uint32(42).string(message.slug);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.creator_id !== "") {
      writer.uint32(58).string(message.creator_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(66).string(message.clan_id);
    }
    if (message.active !== 0) {
      writer.uint32(72).int32(message.active);
    }
    if (message.display_online !== 0) {
      writer.uint32(80).int32(message.display_online);
    }
    if (message.allow_mention !== 0) {
      writer.uint32(88).int32(message.allow_mention);
    }
    if (message.role_user_list !== undefined) {
      RoleUserList.encode(message.role_user_list, writer.uint32(98).fork()).ldelim();
    }
    if (message.permission_list !== undefined) {
      PermissionList.encode(message.permission_list, writer.uint32(106).fork()).ldelim();
    }
    if (message.role_channel_active !== 0) {
      writer.uint32(112).int32(message.role_channel_active);
    }
    for (const v of message.channel_ids) {
      writer.uint32(122).string(v!);
    }
    if (message.max_level_permission !== 0) {
      writer.uint32(128).int32(message.max_level_permission);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Role {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.color = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.role_icon = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.display_online = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.allow_mention = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.role_user_list = RoleUserList.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.permission_list = PermissionList.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.role_channel_active = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.channel_ids.push(reader.string());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.max_level_permission = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Role {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      role_icon: isSet(object.role_icon) ? globalThis.String(object.role_icon) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      display_online: isSet(object.display_online) ? globalThis.Number(object.display_online) : 0,
      allow_mention: isSet(object.allow_mention) ? globalThis.Number(object.allow_mention) : 0,
      role_user_list: isSet(object.role_user_list) ? RoleUserList.fromJSON(object.role_user_list) : undefined,
      permission_list: isSet(object.permission_list) ? PermissionList.fromJSON(object.permission_list) : undefined,
      role_channel_active: isSet(object.role_channel_active) ? globalThis.Number(object.role_channel_active) : 0,
      channel_ids: globalThis.Array.isArray(object?.channel_ids)
        ? object.channel_ids.map((e: any) => globalThis.String(e))
        : [],
      max_level_permission: isSet(object.max_level_permission) ? globalThis.Number(object.max_level_permission) : 0,
    };
  },

  toJSON(message: Role): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.role_icon !== "") {
      obj.role_icon = message.role_icon;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.display_online !== 0) {
      obj.display_online = Math.round(message.display_online);
    }
    if (message.allow_mention !== 0) {
      obj.allow_mention = Math.round(message.allow_mention);
    }
    if (message.role_user_list !== undefined) {
      obj.role_user_list = RoleUserList.toJSON(message.role_user_list);
    }
    if (message.permission_list !== undefined) {
      obj.permission_list = PermissionList.toJSON(message.permission_list);
    }
    if (message.role_channel_active !== 0) {
      obj.role_channel_active = Math.round(message.role_channel_active);
    }
    if (message.channel_ids?.length) {
      obj.channel_ids = message.channel_ids;
    }
    if (message.max_level_permission !== 0) {
      obj.max_level_permission = Math.round(message.max_level_permission);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Role>, I>>(base?: I): Role {
    return Role.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Role>, I>>(object: I): Role {
    const message = createBaseRole();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.color = object.color ?? "";
    message.role_icon = object.role_icon ?? "";
    message.slug = object.slug ?? "";
    message.description = object.description ?? "";
    message.creator_id = object.creator_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.active = object.active ?? 0;
    message.display_online = object.display_online ?? 0;
    message.allow_mention = object.allow_mention ?? 0;
    message.role_user_list = (object.role_user_list !== undefined && object.role_user_list !== null)
      ? RoleUserList.fromPartial(object.role_user_list)
      : undefined;
    message.permission_list = (object.permission_list !== undefined && object.permission_list !== null)
      ? PermissionList.fromPartial(object.permission_list)
      : undefined;
    message.role_channel_active = object.role_channel_active ?? 0;
    message.channel_ids = object.channel_ids?.map((e) => e) || [];
    message.max_level_permission = object.max_level_permission ?? 0;
    return message;
  },
};

function createBaseEventManagement(): EventManagement {
  return {
    id: "",
    title: "",
    logo: "",
    description: "",
    active: 0,
    start_event: 0,
    creator_id: "",
    clan_id: "",
    channel_id: "",
    address: "",
    start_time: undefined,
    end_time: undefined,
    user_ids: [],
    create_time: undefined,
    max_permission: 0,
  };
}

export const EventManagement = {
  encode(message: EventManagement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.logo !== "") {
      writer.uint32(26).string(message.logo);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.active !== 0) {
      writer.uint32(40).int32(message.active);
    }
    if (message.start_event !== 0) {
      writer.uint32(48).int32(message.start_event);
    }
    if (message.creator_id !== "") {
      writer.uint32(58).string(message.creator_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(66).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(74).string(message.channel_id);
    }
    if (message.address !== "") {
      writer.uint32(82).string(message.address);
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(90).fork()).ldelim();
    }
    if (message.end_time !== undefined) {
      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.user_ids) {
      writer.uint32(106).string(v!);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(114).fork()).ldelim();
    }
    if (message.max_permission !== 0) {
      writer.uint32(120).int32(message.max_permission);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventManagement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventManagement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.start_event = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.address = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.max_permission = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventManagement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      start_event: isSet(object.start_event) ? globalThis.Number(object.start_event) : 0,
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      max_permission: isSet(object.max_permission) ? globalThis.Number(object.max_permission) : 0,
    };
  },

  toJSON(message: EventManagement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.start_event !== 0) {
      obj.start_event = Math.round(message.start_event);
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.end_time !== undefined) {
      obj.end_time = message.end_time.toISOString();
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.max_permission !== 0) {
      obj.max_permission = Math.round(message.max_permission);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventManagement>, I>>(base?: I): EventManagement {
    return EventManagement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventManagement>, I>>(object: I): EventManagement {
    const message = createBaseEventManagement();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.logo = object.logo ?? "";
    message.description = object.description ?? "";
    message.active = object.active ?? 0;
    message.start_event = object.start_event ?? 0;
    message.creator_id = object.creator_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.address = object.address ?? "";
    message.start_time = object.start_time ?? undefined;
    message.end_time = object.end_time ?? undefined;
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.create_time = object.create_time ?? undefined;
    message.max_permission = object.max_permission ?? 0;
    return message;
  },
};

function createBasePermission(): Permission {
  return { id: "", title: "", slug: "", description: "", active: 0, scope: 0, level: 0 };
}

export const Permission = {
  encode(message: Permission, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.active !== 0) {
      writer.uint32(40).int32(message.active);
    }
    if (message.scope !== 0) {
      writer.uint32(48).int32(message.scope);
    }
    if (message.level !== 0) {
      writer.uint32(56).int32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Permission {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.scope = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.level = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Permission {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      scope: isSet(object.scope) ? globalThis.Number(object.scope) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
    };
  },

  toJSON(message: Permission): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.scope !== 0) {
      obj.scope = Math.round(message.scope);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permission>, I>>(base?: I): Permission {
    return Permission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permission>, I>>(object: I): Permission {
    const message = createBasePermission();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.slug = object.slug ?? "";
    message.description = object.description ?? "";
    message.active = object.active ?? 0;
    message.scope = object.scope ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseNotificationSetting(): NotificationSetting {
  return { id: "", notification_setting_type: 0 };
}

export const NotificationSetting = {
  encode(message: NotificationSetting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.notification_setting_type !== 0) {
      writer.uint32(16).int32(message.notification_setting_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationSetting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_setting_type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationSetting {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      notification_setting_type: isSet(object.notification_setting_type)
        ? globalThis.Number(object.notification_setting_type)
        : 0,
    };
  },

  toJSON(message: NotificationSetting): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.notification_setting_type !== 0) {
      obj.notification_setting_type = Math.round(message.notification_setting_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationSetting>, I>>(base?: I): NotificationSetting {
    return NotificationSetting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationSetting>, I>>(object: I): NotificationSetting {
    const message = createBaseNotificationSetting();
    message.id = object.id ?? "";
    message.notification_setting_type = object.notification_setting_type ?? 0;
    return message;
  },
};

function createBaseDeletePinMessage(): DeletePinMessage {
  return { message_id: "" };
}

export const DeletePinMessage = {
  encode(message: DeletePinMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeletePinMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePinMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePinMessage {
    return { message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "" };
  },

  toJSON(message: DeletePinMessage): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePinMessage>, I>>(base?: I): DeletePinMessage {
    return DeletePinMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePinMessage>, I>>(object: I): DeletePinMessage {
    const message = createBaseDeletePinMessage();
    message.message_id = object.message_id ?? "";
    return message;
  },
};

function createBasePinMessage(): PinMessage {
  return {
    id: "",
    message_id: "",
    channel_id: "",
    sender_id: "",
    content: "",
    username: "",
    avatar: "",
    create_time: undefined,
    create_time_seconds: 0,
  };
}

export const PinMessage = {
  encode(message: PinMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message_id !== "") {
      writer.uint32(18).string(message.message_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.sender_id !== "") {
      writer.uint32(34).string(message.sender_id);
    }
    if (message.content !== "") {
      writer.uint32(42).string(message.content);
    }
    if (message.username !== "") {
      writer.uint32(50).string(message.username);
    }
    if (message.avatar !== "") {
      writer.uint32(58).string(message.avatar);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.create_time_seconds !== 0) {
      writer.uint32(72).uint32(message.create_time_seconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PinMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.username = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.create_time_seconds = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      create_time_seconds: isSet(object.create_time_seconds) ? globalThis.Number(object.create_time_seconds) : 0,
    };
  },

  toJSON(message: PinMessage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.create_time_seconds !== 0) {
      obj.create_time_seconds = Math.round(message.create_time_seconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PinMessage>, I>>(base?: I): PinMessage {
    return PinMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PinMessage>, I>>(object: I): PinMessage {
    const message = createBasePinMessage();
    message.id = object.id ?? "";
    message.message_id = object.message_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.sender_id = object.sender_id ?? "";
    message.content = object.content ?? "";
    message.username = object.username ?? "";
    message.avatar = object.avatar ?? "";
    message.create_time = object.create_time ?? undefined;
    message.create_time_seconds = object.create_time_seconds ?? 0;
    return message;
  },
};

function createBasePinMessagesList(): PinMessagesList {
  return { pin_messages_list: [] };
}

export const PinMessagesList = {
  encode(message: PinMessagesList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.pin_messages_list) {
      PinMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PinMessagesList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinMessagesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pin_messages_list.push(PinMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinMessagesList {
    return {
      pin_messages_list: globalThis.Array.isArray(object?.pin_messages_list)
        ? object.pin_messages_list.map((e: any) => PinMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PinMessagesList): unknown {
    const obj: any = {};
    if (message.pin_messages_list?.length) {
      obj.pin_messages_list = message.pin_messages_list.map((e) => PinMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PinMessagesList>, I>>(base?: I): PinMessagesList {
    return PinMessagesList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PinMessagesList>, I>>(object: I): PinMessagesList {
    const message = createBasePinMessagesList();
    message.pin_messages_list = object.pin_messages_list?.map((e) => PinMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNotificationUserChannel(): NotificationUserChannel {
  return { id: "", notification_setting_type: 0, time_mute: undefined, active: 0 };
}

export const NotificationUserChannel = {
  encode(message: NotificationUserChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.notification_setting_type !== 0) {
      writer.uint32(16).int32(message.notification_setting_type);
    }
    if (message.time_mute !== undefined) {
      Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();
    }
    if (message.active !== 0) {
      writer.uint32(32).int32(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationUserChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationUserChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_setting_type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.time_mute = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.active = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationUserChannel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      notification_setting_type: isSet(object.notification_setting_type)
        ? globalThis.Number(object.notification_setting_type)
        : 0,
      time_mute: isSet(object.time_mute) ? fromJsonTimestamp(object.time_mute) : undefined,
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
    };
  },

  toJSON(message: NotificationUserChannel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.notification_setting_type !== 0) {
      obj.notification_setting_type = Math.round(message.notification_setting_type);
    }
    if (message.time_mute !== undefined) {
      obj.time_mute = message.time_mute.toISOString();
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationUserChannel>, I>>(base?: I): NotificationUserChannel {
    return NotificationUserChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationUserChannel>, I>>(object: I): NotificationUserChannel {
    const message = createBaseNotificationUserChannel();
    message.id = object.id ?? "";
    message.notification_setting_type = object.notification_setting_type ?? 0;
    message.time_mute = object.time_mute ?? undefined;
    message.active = object.active ?? 0;
    return message;
  },
};

function createBaseNotifiReactMessage(): NotifiReactMessage {
  return { id: "", user_id: "", channel_id: "" };
}

export const NotifiReactMessage = {
  encode(message: NotifiReactMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotifiReactMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifiReactMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifiReactMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: NotifiReactMessage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifiReactMessage>, I>>(base?: I): NotifiReactMessage {
    return NotifiReactMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifiReactMessage>, I>>(object: I): NotifiReactMessage {
    const message = createBaseNotifiReactMessage();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseDefaultNotificationClan(): DefaultNotificationClan {
  return { clan_id: "" };
}

export const DefaultNotificationClan = {
  encode(message: DefaultNotificationClan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DefaultNotificationClan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultNotificationClan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultNotificationClan {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: DefaultNotificationClan): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultNotificationClan>, I>>(base?: I): DefaultNotificationClan {
    return DefaultNotificationClan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultNotificationClan>, I>>(object: I): DefaultNotificationClan {
    const message = createBaseDefaultNotificationClan();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseDefaultNotificationCategory(): DefaultNotificationCategory {
  return { category_id: "" };
}

export const DefaultNotificationCategory = {
  encode(message: DefaultNotificationCategory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category_id !== "") {
      writer.uint32(10).string(message.category_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DefaultNotificationCategory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultNotificationCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.category_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultNotificationCategory {
    return { category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "" };
  },

  toJSON(message: DefaultNotificationCategory): unknown {
    const obj: any = {};
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DefaultNotificationCategory>, I>>(base?: I): DefaultNotificationCategory {
    return DefaultNotificationCategory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultNotificationCategory>, I>>(object: I): DefaultNotificationCategory {
    const message = createBaseDefaultNotificationCategory();
    message.category_id = object.category_id ?? "";
    return message;
  },
};

function createBaseNotificationChannel(): NotificationChannel {
  return { channel_id: "" };
}

export const NotificationChannel = {
  encode(message: NotificationChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannel {
    return { channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "" };
  },

  toJSON(message: NotificationChannel): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationChannel>, I>>(base?: I): NotificationChannel {
    return NotificationChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationChannel>, I>>(object: I): NotificationChannel {
    const message = createBaseNotificationChannel();
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseNotificationClan(): NotificationClan {
  return { clan_id: "" };
}

export const NotificationClan = {
  encode(message: NotificationClan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationClan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationClan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationClan {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: NotificationClan): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationClan>, I>>(base?: I): NotificationClan {
    return NotificationClan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationClan>, I>>(object: I): NotificationClan {
    const message = createBaseNotificationClan();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseNotificationSettingList(): NotificationSettingList {
  return { notification_setting: [] };
}

export const NotificationSettingList = {
  encode(message: NotificationSettingList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.notification_setting) {
      NotificationSetting.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationSettingList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationSettingList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notification_setting.push(NotificationSetting.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationSettingList {
    return {
      notification_setting: globalThis.Array.isArray(object?.notification_setting)
        ? object.notification_setting.map((e: any) => NotificationSetting.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NotificationSettingList): unknown {
    const obj: any = {};
    if (message.notification_setting?.length) {
      obj.notification_setting = message.notification_setting.map((e) => NotificationSetting.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationSettingList>, I>>(base?: I): NotificationSettingList {
    return NotificationSettingList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationSettingList>, I>>(object: I): NotificationSettingList {
    const message = createBaseNotificationSettingList();
    message.notification_setting = object.notification_setting?.map((e) => NotificationSetting.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSetNotificationRequest(): SetNotificationRequest {
  return { channel_category_id: "", notification_type: 0, time_mute: undefined, clan_id: "" };
}

export const SetNotificationRequest = {
  encode(message: SetNotificationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_category_id !== "") {
      writer.uint32(10).string(message.channel_category_id);
    }
    if (message.notification_type !== 0) {
      writer.uint32(16).int32(message.notification_type);
    }
    if (message.time_mute !== undefined) {
      Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetNotificationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_category_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.time_mute = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNotificationRequest {
    return {
      channel_category_id: isSet(object.channel_category_id) ? globalThis.String(object.channel_category_id) : "",
      notification_type: isSet(object.notification_type) ? globalThis.Number(object.notification_type) : 0,
      time_mute: isSet(object.time_mute) ? fromJsonTimestamp(object.time_mute) : undefined,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: SetNotificationRequest): unknown {
    const obj: any = {};
    if (message.channel_category_id !== "") {
      obj.channel_category_id = message.channel_category_id;
    }
    if (message.notification_type !== 0) {
      obj.notification_type = Math.round(message.notification_type);
    }
    if (message.time_mute !== undefined) {
      obj.time_mute = message.time_mute.toISOString();
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetNotificationRequest>, I>>(base?: I): SetNotificationRequest {
    return SetNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetNotificationRequest>, I>>(object: I): SetNotificationRequest {
    const message = createBaseSetNotificationRequest();
    message.channel_category_id = object.channel_category_id ?? "";
    message.notification_type = object.notification_type ?? 0;
    message.time_mute = object.time_mute ?? undefined;
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBasePinMessageRequest(): PinMessageRequest {
  return { message_id: "", channel_id: "", clan_id: "" };
}

export const PinMessageRequest = {
  encode(message: PinMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PinMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinMessageRequest {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: PinMessageRequest): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PinMessageRequest>, I>>(base?: I): PinMessageRequest {
    return PinMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PinMessageRequest>, I>>(object: I): PinMessageRequest {
    const message = createBasePinMessageRequest();
    message.message_id = object.message_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseSetMuteNotificationRequest(): SetMuteNotificationRequest {
  return { id: "", notification_type: 0, active: 0 };
}

export const SetMuteNotificationRequest = {
  encode(message: SetMuteNotificationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.notification_type !== 0) {
      writer.uint32(16).int32(message.notification_type);
    }
    if (message.active !== 0) {
      writer.uint32(24).int32(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetMuteNotificationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMuteNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_type = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.active = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMuteNotificationRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      notification_type: isSet(object.notification_type) ? globalThis.Number(object.notification_type) : 0,
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
    };
  },

  toJSON(message: SetMuteNotificationRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.notification_type !== 0) {
      obj.notification_type = Math.round(message.notification_type);
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetMuteNotificationRequest>, I>>(base?: I): SetMuteNotificationRequest {
    return SetMuteNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetMuteNotificationRequest>, I>>(object: I): SetMuteNotificationRequest {
    const message = createBaseSetMuteNotificationRequest();
    message.id = object.id ?? "";
    message.notification_type = object.notification_type ?? 0;
    message.active = object.active ?? 0;
    return message;
  },
};

function createBaseHashtagDmListRequest(): HashtagDmListRequest {
  return { user_id: [], limit: undefined };
}

export const HashtagDmListRequest = {
  encode(message: HashtagDmListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_id) {
      writer.uint32(10).string(v!);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashtagDmListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtagDmListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashtagDmListRequest {
    return {
      user_id: globalThis.Array.isArray(object?.user_id) ? object.user_id.map((e: any) => globalThis.String(e)) : [],
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
    };
  },

  toJSON(message: HashtagDmListRequest): unknown {
    const obj: any = {};
    if (message.user_id?.length) {
      obj.user_id = message.user_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashtagDmListRequest>, I>>(base?: I): HashtagDmListRequest {
    return HashtagDmListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashtagDmListRequest>, I>>(object: I): HashtagDmListRequest {
    const message = createBaseHashtagDmListRequest();
    message.user_id = object.user_id?.map((e) => e) || [];
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseHashtagDmList(): HashtagDmList {
  return { hashtag_dm: [] };
}

export const HashtagDmList = {
  encode(message: HashtagDmList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.hashtag_dm) {
      HashtagDm.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashtagDmList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtagDmList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hashtag_dm.push(HashtagDm.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashtagDmList {
    return {
      hashtag_dm: globalThis.Array.isArray(object?.hashtag_dm)
        ? object.hashtag_dm.map((e: any) => HashtagDm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HashtagDmList): unknown {
    const obj: any = {};
    if (message.hashtag_dm?.length) {
      obj.hashtag_dm = message.hashtag_dm.map((e) => HashtagDm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashtagDmList>, I>>(base?: I): HashtagDmList {
    return HashtagDmList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashtagDmList>, I>>(object: I): HashtagDmList {
    const message = createBaseHashtagDmList();
    message.hashtag_dm = object.hashtag_dm?.map((e) => HashtagDm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHashtagDm(): HashtagDm {
  return {
    channel_id: "",
    channel_label: "",
    clan_id: "",
    clan_name: "",
    meeting_code: "",
    type: 0,
    channel_private: 0,
    parrent_id: "",
  };
}

export const HashtagDm = {
  encode(message: HashtagDm, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(18).string(message.channel_label);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(34).string(message.clan_name);
    }
    if (message.meeting_code !== "") {
      writer.uint32(42).string(message.meeting_code);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.channel_private !== 0) {
      writer.uint32(56).int32(message.channel_private);
    }
    if (message.parrent_id !== "") {
      writer.uint32(66).string(message.parrent_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashtagDm {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtagDm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashtagDm {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
    };
  },

  toJSON(message: HashtagDm): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashtagDm>, I>>(base?: I): HashtagDm {
    return HashtagDm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashtagDm>, I>>(object: I): HashtagDm {
    const message = createBaseHashtagDm();
    message.channel_id = object.channel_id ?? "";
    message.channel_label = object.channel_label ?? "";
    message.clan_id = object.clan_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.meeting_code = object.meeting_code ?? "";
    message.type = object.type ?? 0;
    message.channel_private = object.channel_private ?? 0;
    message.parrent_id = object.parrent_id ?? "";
    return message;
  },
};

function createBaseNotificationChannelCategorySettingList(): NotificationChannelCategorySettingList {
  return { notification_channel_category_settings_list: [] };
}

export const NotificationChannelCategorySettingList = {
  encode(message: NotificationChannelCategorySettingList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.notification_channel_category_settings_list) {
      NotificationChannelCategorySetting.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationChannelCategorySettingList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannelCategorySettingList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notification_channel_category_settings_list.push(
            NotificationChannelCategorySetting.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannelCategorySettingList {
    return {
      notification_channel_category_settings_list:
        globalThis.Array.isArray(object?.notification_channel_category_settings_list)
          ? object.notification_channel_category_settings_list.map((e: any) =>
            NotificationChannelCategorySetting.fromJSON(e)
          )
          : [],
    };
  },

  toJSON(message: NotificationChannelCategorySettingList): unknown {
    const obj: any = {};
    if (message.notification_channel_category_settings_list?.length) {
      obj.notification_channel_category_settings_list = message.notification_channel_category_settings_list.map((e) =>
        NotificationChannelCategorySetting.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationChannelCategorySettingList>, I>>(
    base?: I,
  ): NotificationChannelCategorySettingList {
    return NotificationChannelCategorySettingList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationChannelCategorySettingList>, I>>(
    object: I,
  ): NotificationChannelCategorySettingList {
    const message = createBaseNotificationChannelCategorySettingList();
    message.notification_channel_category_settings_list =
      object.notification_channel_category_settings_list?.map((e) =>
        NotificationChannelCategorySetting.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseNotificationChannelCategorySetting(): NotificationChannelCategorySetting {
  return { id: "", channel_category_label: "", notification_setting_type: 0, channel_category_title: "", action: 0 };
}

export const NotificationChannelCategorySetting = {
  encode(message: NotificationChannelCategorySetting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.channel_category_label !== "") {
      writer.uint32(18).string(message.channel_category_label);
    }
    if (message.notification_setting_type !== 0) {
      writer.uint32(24).int32(message.notification_setting_type);
    }
    if (message.channel_category_title !== "") {
      writer.uint32(34).string(message.channel_category_title);
    }
    if (message.action !== 0) {
      writer.uint32(40).int32(message.action);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationChannelCategorySetting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannelCategorySetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_category_label = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.notification_setting_type = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_category_title = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.action = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannelCategorySetting {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      channel_category_label: isSet(object.channel_category_label)
        ? globalThis.String(object.channel_category_label)
        : "",
      notification_setting_type: isSet(object.notification_setting_type)
        ? globalThis.Number(object.notification_setting_type)
        : 0,
      channel_category_title: isSet(object.channel_category_title)
        ? globalThis.String(object.channel_category_title)
        : "",
      action: isSet(object.action) ? globalThis.Number(object.action) : 0,
    };
  },

  toJSON(message: NotificationChannelCategorySetting): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.channel_category_label !== "") {
      obj.channel_category_label = message.channel_category_label;
    }
    if (message.notification_setting_type !== 0) {
      obj.notification_setting_type = Math.round(message.notification_setting_type);
    }
    if (message.channel_category_title !== "") {
      obj.channel_category_title = message.channel_category_title;
    }
    if (message.action !== 0) {
      obj.action = Math.round(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationChannelCategorySetting>, I>>(
    base?: I,
  ): NotificationChannelCategorySetting {
    return NotificationChannelCategorySetting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationChannelCategorySetting>, I>>(
    object: I,
  ): NotificationChannelCategorySetting {
    const message = createBaseNotificationChannelCategorySetting();
    message.id = object.id ?? "";
    message.channel_category_label = object.channel_category_label ?? "";
    message.notification_setting_type = object.notification_setting_type ?? 0;
    message.channel_category_title = object.channel_category_title ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseSetDefaultNotificationRequest(): SetDefaultNotificationRequest {
  return { clan_id: "", notification_type: 0, category_id: "" };
}

export const SetDefaultNotificationRequest = {
  encode(message: SetDefaultNotificationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.notification_type !== 0) {
      writer.uint32(16).int32(message.notification_type);
    }
    if (message.category_id !== "") {
      writer.uint32(26).string(message.category_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetDefaultNotificationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetDefaultNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.category_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetDefaultNotificationRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      notification_type: isSet(object.notification_type) ? globalThis.Number(object.notification_type) : 0,
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
    };
  },

  toJSON(message: SetDefaultNotificationRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.notification_type !== 0) {
      obj.notification_type = Math.round(message.notification_type);
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetDefaultNotificationRequest>, I>>(base?: I): SetDefaultNotificationRequest {
    return SetDefaultNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetDefaultNotificationRequest>, I>>(
    object: I,
  ): SetDefaultNotificationRequest {
    const message = createBaseSetDefaultNotificationRequest();
    message.clan_id = object.clan_id ?? "";
    message.notification_type = object.notification_type ?? 0;
    message.category_id = object.category_id ?? "";
    return message;
  },
};

function createBaseRoleList(): RoleList {
  return { roles: [], next_cursor: "", prev_cursor: "", cacheable_cursor: "" };
}

export const RoleList = {
  encode(message: RoleList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.next_cursor !== "") {
      writer.uint32(18).string(message.next_cursor);
    }
    if (message.prev_cursor !== "") {
      writer.uint32(26).string(message.prev_cursor);
    }
    if (message.cacheable_cursor !== "") {
      writer.uint32(34).string(message.cacheable_cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.next_cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prev_cursor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cacheable_cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleList {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => Role.fromJSON(e)) : [],
      next_cursor: isSet(object.next_cursor) ? globalThis.String(object.next_cursor) : "",
      prev_cursor: isSet(object.prev_cursor) ? globalThis.String(object.prev_cursor) : "",
      cacheable_cursor: isSet(object.cacheable_cursor) ? globalThis.String(object.cacheable_cursor) : "",
    };
  },

  toJSON(message: RoleList): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => Role.toJSON(e));
    }
    if (message.next_cursor !== "") {
      obj.next_cursor = message.next_cursor;
    }
    if (message.prev_cursor !== "") {
      obj.prev_cursor = message.prev_cursor;
    }
    if (message.cacheable_cursor !== "") {
      obj.cacheable_cursor = message.cacheable_cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoleList>, I>>(base?: I): RoleList {
    return RoleList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoleList>, I>>(object: I): RoleList {
    const message = createBaseRoleList();
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.next_cursor = object.next_cursor ?? "";
    message.prev_cursor = object.prev_cursor ?? "";
    message.cacheable_cursor = object.cacheable_cursor ?? "";
    return message;
  },
};

function createBaseEventList(): EventList {
  return { events: [] };
}

export const EventList = {
  encode(message: EventList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      EventManagement.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(EventManagement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventList {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => EventManagement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventList): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => EventManagement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventList>, I>>(base?: I): EventList {
    return EventList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventList>, I>>(object: I): EventList {
    const message = createBaseEventList();
    message.events = object.events?.map((e) => EventManagement.fromPartial(e)) || [];
    return message;
  },
};

function createBasePermissionList(): PermissionList {
  return { permissions: [], max_level_permission: 0 };
}

export const PermissionList = {
  encode(message: PermissionList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.permissions) {
      Permission.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.max_level_permission !== 0) {
      writer.uint32(16).int32(message.max_level_permission);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permissions.push(Permission.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.max_level_permission = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionList {
    return {
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => Permission.fromJSON(e))
        : [],
      max_level_permission: isSet(object.max_level_permission) ? globalThis.Number(object.max_level_permission) : 0,
    };
  },

  toJSON(message: PermissionList): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => Permission.toJSON(e));
    }
    if (message.max_level_permission !== 0) {
      obj.max_level_permission = Math.round(message.max_level_permission);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionList>, I>>(base?: I): PermissionList {
    return PermissionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionList>, I>>(object: I): PermissionList {
    const message = createBasePermissionList();
    message.permissions = object.permissions?.map((e) => Permission.fromPartial(e)) || [];
    message.max_level_permission = object.max_level_permission ?? 0;
    return message;
  },
};

function createBaseListPermissionsRequest(): ListPermissionsRequest {
  return { role_id: "" };
}

export const ListPermissionsRequest = {
  encode(message: ListPermissionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListPermissionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPermissionsRequest {
    return { role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "" };
  },

  toJSON(message: ListPermissionsRequest): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPermissionsRequest>, I>>(base?: I): ListPermissionsRequest {
    return ListPermissionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPermissionsRequest>, I>>(object: I): ListPermissionsRequest {
    const message = createBaseListPermissionsRequest();
    message.role_id = object.role_id ?? "";
    return message;
  },
};

function createBaseListRoleUsersRequest(): ListRoleUsersRequest {
  return { role_id: "", limit: undefined, cursor: "" };
}

export const ListRoleUsersRequest = {
  encode(message: ListRoleUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRoleUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoleUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoleUsersRequest {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListRoleUsersRequest): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRoleUsersRequest>, I>>(base?: I): ListRoleUsersRequest {
    return ListRoleUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRoleUsersRequest>, I>>(object: I): ListRoleUsersRequest {
    const message = createBaseListRoleUsersRequest();
    message.role_id = object.role_id ?? "";
    message.limit = object.limit ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseListPermissionOfUsersRequest(): ListPermissionOfUsersRequest {
  return { clan_id: "", channel_id: "" };
}

export const ListPermissionOfUsersRequest = {
  encode(message: ListPermissionOfUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListPermissionOfUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPermissionOfUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPermissionOfUsersRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: ListPermissionOfUsersRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPermissionOfUsersRequest>, I>>(base?: I): ListPermissionOfUsersRequest {
    return ListPermissionOfUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPermissionOfUsersRequest>, I>>(object: I): ListPermissionOfUsersRequest {
    const message = createBaseListPermissionOfUsersRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseRoleUserList(): RoleUserList {
  return { role_users: [], cursor: "" };
}

export const RoleUserList = {
  encode(message: RoleUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.role_users) {
      RoleUserList_RoleUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_users.push(RoleUserList_RoleUser.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleUserList {
    return {
      role_users: globalThis.Array.isArray(object?.role_users)
        ? object.role_users.map((e: any) => RoleUserList_RoleUser.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: RoleUserList): unknown {
    const obj: any = {};
    if (message.role_users?.length) {
      obj.role_users = message.role_users.map((e) => RoleUserList_RoleUser.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoleUserList>, I>>(base?: I): RoleUserList {
    return RoleUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoleUserList>, I>>(object: I): RoleUserList {
    const message = createBaseRoleUserList();
    message.role_users = object.role_users?.map((e) => RoleUserList_RoleUser.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseRoleUserList_RoleUser(): RoleUserList_RoleUser {
  return { id: "", username: "", display_name: "", avatar_url: "", lang_tag: "", location: "", online: false };
}

export const RoleUserList_RoleUser = {
  encode(message: RoleUserList_RoleUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.display_name !== "") {
      writer.uint32(26).string(message.display_name);
    }
    if (message.avatar_url !== "") {
      writer.uint32(34).string(message.avatar_url);
    }
    if (message.lang_tag !== "") {
      writer.uint32(42).string(message.lang_tag);
    }
    if (message.location !== "") {
      writer.uint32(50).string(message.location);
    }
    if (message.online !== false) {
      writer.uint32(56).bool(message.online);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleUserList_RoleUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleUserList_RoleUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lang_tag = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.location = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.online = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleUserList_RoleUser {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
      lang_tag: isSet(object.lang_tag) ? globalThis.String(object.lang_tag) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      online: isSet(object.online) ? globalThis.Boolean(object.online) : false,
    };
  },

  toJSON(message: RoleUserList_RoleUser): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    if (message.lang_tag !== "") {
      obj.lang_tag = message.lang_tag;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.online !== false) {
      obj.online = message.online;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoleUserList_RoleUser>, I>>(base?: I): RoleUserList_RoleUser {
    return RoleUserList_RoleUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoleUserList_RoleUser>, I>>(object: I): RoleUserList_RoleUser {
    const message = createBaseRoleUserList_RoleUser();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.display_name = object.display_name ?? "";
    message.avatar_url = object.avatar_url ?? "";
    message.lang_tag = object.lang_tag ?? "";
    message.location = object.location ?? "";
    message.online = object.online ?? false;
    return message;
  },
};

function createBaseEventUserList(): EventUserList {
  return { user_event: [] };
}

export const EventUserList = {
  encode(message: EventUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_event) {
      EventUserList_EventUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_event.push(EventUserList_EventUser.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUserList {
    return {
      user_event: globalThis.Array.isArray(object?.user_event)
        ? object.user_event.map((e: any) => EventUserList_EventUser.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventUserList): unknown {
    const obj: any = {};
    if (message.user_event?.length) {
      obj.user_event = message.user_event.map((e) => EventUserList_EventUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventUserList>, I>>(base?: I): EventUserList {
    return EventUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventUserList>, I>>(object: I): EventUserList {
    const message = createBaseEventUserList();
    message.user_event = object.user_event?.map((e) => EventUserList_EventUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventUserList_EventUser(): EventUserList_EventUser {
  return { id: "", username: "", display_name: "", avatar_url: "" };
}

export const EventUserList_EventUser = {
  encode(message: EventUserList_EventUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.display_name !== "") {
      writer.uint32(26).string(message.display_name);
    }
    if (message.avatar_url !== "") {
      writer.uint32(34).string(message.avatar_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventUserList_EventUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUserList_EventUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUserList_EventUser {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
    };
  },

  toJSON(message: EventUserList_EventUser): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventUserList_EventUser>, I>>(base?: I): EventUserList_EventUser {
    return EventUserList_EventUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventUserList_EventUser>, I>>(object: I): EventUserList_EventUser {
    const message = createBaseEventUserList_EventUser();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.display_name = object.display_name ?? "";
    message.avatar_url = object.avatar_url ?? "";
    return message;
  },
};

function createBaseListEventsRequest(): ListEventsRequest {
  return { clan_id: "" };
}

export const ListEventsRequest = {
  encode(message: ListEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ListEventsRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListEventsRequest>, I>>(base?: I): ListEventsRequest {
    return ListEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListEventsRequest>, I>>(object: I): ListEventsRequest {
    const message = createBaseListEventsRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseCreateRoleRequest(): CreateRoleRequest {
  return {
    title: "",
    color: "",
    role_icon: "",
    description: "",
    clan_id: "",
    display_online: 0,
    allow_mention: 0,
    max_permission_id: "",
    add_user_ids: [],
    active_permission_ids: [],
  };
}

export const CreateRoleRequest = {
  encode(message: CreateRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.color !== "") {
      writer.uint32(18).string(message.color);
    }
    if (message.role_icon !== "") {
      writer.uint32(26).string(message.role_icon);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.clan_id !== "") {
      writer.uint32(42).string(message.clan_id);
    }
    if (message.display_online !== 0) {
      writer.uint32(48).int32(message.display_online);
    }
    if (message.allow_mention !== 0) {
      writer.uint32(56).int32(message.allow_mention);
    }
    if (message.max_permission_id !== "") {
      writer.uint32(66).string(message.max_permission_id);
    }
    for (const v of message.add_user_ids) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.active_permission_ids) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.color = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.role_icon = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.display_online = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.allow_mention = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.max_permission_id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.add_user_ids.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.active_permission_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoleRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      role_icon: isSet(object.role_icon) ? globalThis.String(object.role_icon) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      display_online: isSet(object.display_online) ? globalThis.Number(object.display_online) : 0,
      allow_mention: isSet(object.allow_mention) ? globalThis.Number(object.allow_mention) : 0,
      max_permission_id: isSet(object.max_permission_id) ? globalThis.String(object.max_permission_id) : "",
      add_user_ids: globalThis.Array.isArray(object?.add_user_ids)
        ? object.add_user_ids.map((e: any) => globalThis.String(e))
        : [],
      active_permission_ids: globalThis.Array.isArray(object?.active_permission_ids)
        ? object.active_permission_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateRoleRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.role_icon !== "") {
      obj.role_icon = message.role_icon;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.display_online !== 0) {
      obj.display_online = Math.round(message.display_online);
    }
    if (message.allow_mention !== 0) {
      obj.allow_mention = Math.round(message.allow_mention);
    }
    if (message.max_permission_id !== "") {
      obj.max_permission_id = message.max_permission_id;
    }
    if (message.add_user_ids?.length) {
      obj.add_user_ids = message.add_user_ids;
    }
    if (message.active_permission_ids?.length) {
      obj.active_permission_ids = message.active_permission_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRoleRequest>, I>>(base?: I): CreateRoleRequest {
    return CreateRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRoleRequest>, I>>(object: I): CreateRoleRequest {
    const message = createBaseCreateRoleRequest();
    message.title = object.title ?? "";
    message.color = object.color ?? "";
    message.role_icon = object.role_icon ?? "";
    message.description = object.description ?? "";
    message.clan_id = object.clan_id ?? "";
    message.display_online = object.display_online ?? 0;
    message.allow_mention = object.allow_mention ?? 0;
    message.max_permission_id = object.max_permission_id ?? "";
    message.add_user_ids = object.add_user_ids?.map((e) => e) || [];
    message.active_permission_ids = object.active_permission_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateEventRequest(): CreateEventRequest {
  return {
    title: "",
    logo: "",
    description: "",
    clan_id: "",
    channel_id: "",
    address: "",
    start_time: undefined,
    end_time: undefined,
    event_id: "",
    event_status: "",
  };
}

export const CreateEventRequest = {
  encode(message: CreateEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.logo !== "") {
      writer.uint32(18).string(message.logo);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.address !== "") {
      writer.uint32(50).string(message.address);
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(58).fork()).ldelim();
    }
    if (message.end_time !== undefined) {
      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.event_id !== "") {
      writer.uint32(74).string(message.event_id);
    }
    if (message.event_status !== "") {
      writer.uint32(82).string(message.event_status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.address = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.event_id = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.event_status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEventRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,
      event_id: isSet(object.event_id) ? globalThis.String(object.event_id) : "",
      event_status: isSet(object.event_status) ? globalThis.String(object.event_status) : "",
    };
  },

  toJSON(message: CreateEventRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.end_time !== undefined) {
      obj.end_time = message.end_time.toISOString();
    }
    if (message.event_id !== "") {
      obj.event_id = message.event_id;
    }
    if (message.event_status !== "") {
      obj.event_status = message.event_status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateEventRequest>, I>>(base?: I): CreateEventRequest {
    return CreateEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateEventRequest>, I>>(object: I): CreateEventRequest {
    const message = createBaseCreateEventRequest();
    message.title = object.title ?? "";
    message.logo = object.logo ?? "";
    message.description = object.description ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.address = object.address ?? "";
    message.start_time = object.start_time ?? undefined;
    message.end_time = object.end_time ?? undefined;
    message.event_id = object.event_id ?? "";
    message.event_status = object.event_status ?? "";
    return message;
  },
};

function createBaseUpdateEventRequest(): UpdateEventRequest {
  return {
    title: "",
    logo: "",
    description: "",
    event_id: "",
    channel_id: "",
    address: "",
    start_time: undefined,
    end_time: undefined,
    clan_id: "",
    creator_id: "",
  };
}

export const UpdateEventRequest = {
  encode(message: UpdateEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.logo !== "") {
      writer.uint32(18).string(message.logo);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.event_id !== "") {
      writer.uint32(34).string(message.event_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.address !== "") {
      writer.uint32(50).string(message.address);
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(58).fork()).ldelim();
    }
    if (message.end_time !== undefined) {
      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.clan_id !== "") {
      writer.uint32(74).string(message.clan_id);
    }
    if (message.creator_id !== "") {
      writer.uint32(82).string(message.creator_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.event_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.address = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.creator_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEventRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      event_id: isSet(object.event_id) ? globalThis.String(object.event_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
    };
  },

  toJSON(message: UpdateEventRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.event_id !== "") {
      obj.event_id = message.event_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.end_time !== undefined) {
      obj.end_time = message.end_time.toISOString();
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateEventRequest>, I>>(base?: I): UpdateEventRequest {
    return UpdateEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateEventRequest>, I>>(object: I): UpdateEventRequest {
    const message = createBaseUpdateEventRequest();
    message.title = object.title ?? "";
    message.logo = object.logo ?? "";
    message.description = object.description ?? "";
    message.event_id = object.event_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.address = object.address ?? "";
    message.start_time = object.start_time ?? undefined;
    message.end_time = object.end_time ?? undefined;
    message.clan_id = object.clan_id ?? "";
    message.creator_id = object.creator_id ?? "";
    return message;
  },
};

function createBaseDeleteRoleRequest(): DeleteRoleRequest {
  return { role_id: "", channel_id: "", clan_id: "" };
}

export const DeleteRoleRequest = {
  encode(message: DeleteRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoleRequest {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: DeleteRoleRequest): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoleRequest>, I>>(base?: I): DeleteRoleRequest {
    return DeleteRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoleRequest>, I>>(object: I): DeleteRoleRequest {
    const message = createBaseDeleteRoleRequest();
    message.role_id = object.role_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseDeleteEventRequest(): DeleteEventRequest {
  return { event_id: "", clan_id: "", creator_id: "" };
}

export const DeleteEventRequest = {
  encode(message: DeleteEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event_id !== "") {
      writer.uint32(10).string(message.event_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.creator_id !== "") {
      writer.uint32(26).string(message.creator_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.event_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEventRequest {
    return {
      event_id: isSet(object.event_id) ? globalThis.String(object.event_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
    };
  },

  toJSON(message: DeleteEventRequest): unknown {
    const obj: any = {};
    if (message.event_id !== "") {
      obj.event_id = message.event_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteEventRequest>, I>>(base?: I): DeleteEventRequest {
    return DeleteEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteEventRequest>, I>>(object: I): DeleteEventRequest {
    const message = createBaseDeleteEventRequest();
    message.event_id = object.event_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.creator_id = object.creator_id ?? "";
    return message;
  },
};

function createBaseUpdateRoleRequest(): UpdateRoleRequest {
  return {
    role_id: "",
    title: undefined,
    color: undefined,
    role_icon: undefined,
    description: undefined,
    display_online: undefined,
    allow_mention: undefined,
    add_user_ids: [],
    active_permission_ids: [],
    remove_user_ids: [],
    remove_permission_ids: [],
    clan_id: "",
    max_permission_id: "",
  };
}

export const UpdateRoleRequest = {
  encode(message: UpdateRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    if (message.title !== undefined) {
      StringValue.encode({ value: message.title! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.color !== undefined) {
      StringValue.encode({ value: message.color! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.role_icon !== undefined) {
      StringValue.encode({ value: message.role_icon! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.display_online !== undefined) {
      Int32Value.encode({ value: message.display_online! }, writer.uint32(50).fork()).ldelim();
    }
    if (message.allow_mention !== undefined) {
      Int32Value.encode({ value: message.allow_mention! }, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.add_user_ids) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.active_permission_ids) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.remove_user_ids) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.remove_permission_ids) {
      writer.uint32(90).string(v!);
    }
    if (message.clan_id !== "") {
      writer.uint32(98).string(message.clan_id);
    }
    if (message.max_permission_id !== "") {
      writer.uint32(106).string(message.max_permission_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.color = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.role_icon = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.display_online = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.allow_mention = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.add_user_ids.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.active_permission_ids.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.remove_user_ids.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.remove_permission_ids.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.max_permission_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoleRequest {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      title: isSet(object.title) ? String(object.title) : undefined,
      color: isSet(object.color) ? String(object.color) : undefined,
      role_icon: isSet(object.role_icon) ? String(object.role_icon) : undefined,
      description: isSet(object.description) ? String(object.description) : undefined,
      display_online: isSet(object.display_online) ? Number(object.display_online) : undefined,
      allow_mention: isSet(object.allow_mention) ? Number(object.allow_mention) : undefined,
      add_user_ids: globalThis.Array.isArray(object?.add_user_ids)
        ? object.add_user_ids.map((e: any) => globalThis.String(e))
        : [],
      active_permission_ids: globalThis.Array.isArray(object?.active_permission_ids)
        ? object.active_permission_ids.map((e: any) => globalThis.String(e))
        : [],
      remove_user_ids: globalThis.Array.isArray(object?.remove_user_ids)
        ? object.remove_user_ids.map((e: any) => globalThis.String(e))
        : [],
      remove_permission_ids: globalThis.Array.isArray(object?.remove_permission_ids)
        ? object.remove_permission_ids.map((e: any) => globalThis.String(e))
        : [],
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      max_permission_id: isSet(object.max_permission_id) ? globalThis.String(object.max_permission_id) : "",
    };
  },

  toJSON(message: UpdateRoleRequest): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.color !== undefined) {
      obj.color = message.color;
    }
    if (message.role_icon !== undefined) {
      obj.role_icon = message.role_icon;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.display_online !== undefined) {
      obj.display_online = message.display_online;
    }
    if (message.allow_mention !== undefined) {
      obj.allow_mention = message.allow_mention;
    }
    if (message.add_user_ids?.length) {
      obj.add_user_ids = message.add_user_ids;
    }
    if (message.active_permission_ids?.length) {
      obj.active_permission_ids = message.active_permission_ids;
    }
    if (message.remove_user_ids?.length) {
      obj.remove_user_ids = message.remove_user_ids;
    }
    if (message.remove_permission_ids?.length) {
      obj.remove_permission_ids = message.remove_permission_ids;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.max_permission_id !== "") {
      obj.max_permission_id = message.max_permission_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRoleRequest>, I>>(base?: I): UpdateRoleRequest {
    return UpdateRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRoleRequest>, I>>(object: I): UpdateRoleRequest {
    const message = createBaseUpdateRoleRequest();
    message.role_id = object.role_id ?? "";
    message.title = object.title ?? undefined;
    message.color = object.color ?? undefined;
    message.role_icon = object.role_icon ?? undefined;
    message.description = object.description ?? undefined;
    message.display_online = object.display_online ?? undefined;
    message.allow_mention = object.allow_mention ?? undefined;
    message.add_user_ids = object.add_user_ids?.map((e) => e) || [];
    message.active_permission_ids = object.active_permission_ids?.map((e) => e) || [];
    message.remove_user_ids = object.remove_user_ids?.map((e) => e) || [];
    message.remove_permission_ids = object.remove_permission_ids?.map((e) => e) || [];
    message.clan_id = object.clan_id ?? "";
    message.max_permission_id = object.max_permission_id ?? "";
    return message;
  },
};

function createBaseUpdateRoleChannelRequest(): UpdateRoleChannelRequest {
  return { role_id: "", permission_update: [], max_permission_id: "", channel_id: "", user_id: "" };
}

export const UpdateRoleChannelRequest = {
  encode(message: UpdateRoleChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    for (const v of message.permission_update) {
      PermissionUpdate.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.max_permission_id !== "") {
      writer.uint32(26).string(message.max_permission_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(34).string(message.channel_id);
    }
    if (message.user_id !== "") {
      writer.uint32(42).string(message.user_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRoleChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoleChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permission_update.push(PermissionUpdate.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.max_permission_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.user_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoleChannelRequest {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      permission_update: globalThis.Array.isArray(object?.permission_update)
        ? object.permission_update.map((e: any) => PermissionUpdate.fromJSON(e))
        : [],
      max_permission_id: isSet(object.max_permission_id) ? globalThis.String(object.max_permission_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
    };
  },

  toJSON(message: UpdateRoleChannelRequest): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.permission_update?.length) {
      obj.permission_update = message.permission_update.map((e) => PermissionUpdate.toJSON(e));
    }
    if (message.max_permission_id !== "") {
      obj.max_permission_id = message.max_permission_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRoleChannelRequest>, I>>(base?: I): UpdateRoleChannelRequest {
    return UpdateRoleChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRoleChannelRequest>, I>>(object: I): UpdateRoleChannelRequest {
    const message = createBaseUpdateRoleChannelRequest();
    message.role_id = object.role_id ?? "";
    message.permission_update = object.permission_update?.map((e) => PermissionUpdate.fromPartial(e)) || [];
    message.max_permission_id = object.max_permission_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.user_id = object.user_id ?? "";
    return message;
  },
};

function createBasePermissionUpdate(): PermissionUpdate {
  return { permission_id: "", slug: "", type: 0 };
}

export const PermissionUpdate = {
  encode(message: PermissionUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permission_id !== "") {
      writer.uint32(10).string(message.permission_id);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permission_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionUpdate {
    return {
      permission_id: isSet(object.permission_id) ? globalThis.String(object.permission_id) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: PermissionUpdate): unknown {
    const obj: any = {};
    if (message.permission_id !== "") {
      obj.permission_id = message.permission_id;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionUpdate>, I>>(base?: I): PermissionUpdate {
    return PermissionUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionUpdate>, I>>(object: I): PermissionUpdate {
    const message = createBasePermissionUpdate();
    message.permission_id = object.permission_id ?? "";
    message.slug = object.slug ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseUploadAttachmentRequest(): UploadAttachmentRequest {
  return { filename: "", filetype: "", size: 0, width: 0, height: 0 };
}

export const UploadAttachmentRequest = {
  encode(message: UploadAttachmentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.filetype !== "") {
      writer.uint32(18).string(message.filetype);
    }
    if (message.size !== 0) {
      writer.uint32(24).int32(message.size);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UploadAttachmentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAttachmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filetype = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.size = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadAttachmentRequest {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      filetype: isSet(object.filetype) ? globalThis.String(object.filetype) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: UploadAttachmentRequest): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.filetype !== "") {
      obj.filetype = message.filetype;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadAttachmentRequest>, I>>(base?: I): UploadAttachmentRequest {
    return UploadAttachmentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadAttachmentRequest>, I>>(object: I): UploadAttachmentRequest {
    const message = createBaseUploadAttachmentRequest();
    message.filename = object.filename ?? "";
    message.filetype = object.filetype ?? "";
    message.size = object.size ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseListMessageMentionRequest(): ListMessageMentionRequest {
  return { limit: undefined, forward: undefined, cursor: "" };
}

export const ListMessageMentionRequest = {
  encode(message: ListMessageMentionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.forward !== undefined) {
      BoolValue.encode({ value: message.forward! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMessageMentionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMessageMentionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.forward = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMessageMentionRequest {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      forward: isSet(object.forward) ? Boolean(object.forward) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListMessageMentionRequest): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.forward !== undefined) {
      obj.forward = message.forward;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListMessageMentionRequest>, I>>(base?: I): ListMessageMentionRequest {
    return ListMessageMentionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListMessageMentionRequest>, I>>(object: I): ListMessageMentionRequest {
    const message = createBaseListMessageMentionRequest();
    message.limit = object.limit ?? undefined;
    message.forward = object.forward ?? undefined;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseUploadAttachment(): UploadAttachment {
  return { filename: "", url: "" };
}

export const UploadAttachment = {
  encode(message: UploadAttachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UploadAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadAttachment {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: UploadAttachment): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadAttachment>, I>>(base?: I): UploadAttachment {
    return UploadAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadAttachment>, I>>(object: I): UploadAttachment {
    const message = createBaseUploadAttachment();
    message.filename = object.filename ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseSearchMessageRequest(): SearchMessageRequest {
  return { filters: [], from: undefined, size: undefined, sorts: [] };
}

export const SearchMessageRequest = {
  encode(message: SearchMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.filters) {
      FilterParam.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.from !== undefined) {
      Int32Value.encode({ value: message.from! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.size !== undefined) {
      Int32Value.encode({ value: message.size! }, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.sorts) {
      SortParam.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filters.push(FilterParam.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.size = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sorts.push(SortParam.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchMessageRequest {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => FilterParam.fromJSON(e)) : [],
      from: isSet(object.from) ? Number(object.from) : undefined,
      size: isSet(object.size) ? Number(object.size) : undefined,
      sorts: globalThis.Array.isArray(object?.sorts) ? object.sorts.map((e: any) => SortParam.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchMessageRequest): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterParam.toJSON(e));
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.size !== undefined) {
      obj.size = message.size;
    }
    if (message.sorts?.length) {
      obj.sorts = message.sorts.map((e) => SortParam.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchMessageRequest>, I>>(base?: I): SearchMessageRequest {
    return SearchMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchMessageRequest>, I>>(object: I): SearchMessageRequest {
    const message = createBaseSearchMessageRequest();
    message.filters = object.filters?.map((e) => FilterParam.fromPartial(e)) || [];
    message.from = object.from ?? undefined;
    message.size = object.size ?? undefined;
    message.sorts = object.sorts?.map((e) => SortParam.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSortParam(): SortParam {
  return { field_name: "", order: "" };
}

export const SortParam = {
  encode(message: SortParam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field_name !== "") {
      writer.uint32(10).string(message.field_name);
    }
    if (message.order !== "") {
      writer.uint32(18).string(message.order);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SortParam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.order = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SortParam {
    return {
      field_name: isSet(object.field_name) ? globalThis.String(object.field_name) : "",
      order: isSet(object.order) ? globalThis.String(object.order) : "",
    };
  },

  toJSON(message: SortParam): unknown {
    const obj: any = {};
    if (message.field_name !== "") {
      obj.field_name = message.field_name;
    }
    if (message.order !== "") {
      obj.order = message.order;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SortParam>, I>>(base?: I): SortParam {
    return SortParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SortParam>, I>>(object: I): SortParam {
    const message = createBaseSortParam();
    message.field_name = object.field_name ?? "";
    message.order = object.order ?? "";
    return message;
  },
};

function createBaseFilterParam(): FilterParam {
  return { field_name: "", field_value: "" };
}

export const FilterParam = {
  encode(message: FilterParam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field_name !== "") {
      writer.uint32(10).string(message.field_name);
    }
    if (message.field_value !== "") {
      writer.uint32(18).string(message.field_value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilterParam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.field_value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterParam {
    return {
      field_name: isSet(object.field_name) ? globalThis.String(object.field_name) : "",
      field_value: isSet(object.field_value) ? globalThis.String(object.field_value) : "",
    };
  },

  toJSON(message: FilterParam): unknown {
    const obj: any = {};
    if (message.field_name !== "") {
      obj.field_name = message.field_name;
    }
    if (message.field_value !== "") {
      obj.field_value = message.field_value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterParam>, I>>(base?: I): FilterParam {
    return FilterParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterParam>, I>>(object: I): FilterParam {
    const message = createBaseFilterParam();
    message.field_name = object.field_name ?? "";
    message.field_value = object.field_value ?? "";
    return message;
  },
};

function createBaseSearchMessageDocument(): SearchMessageDocument {
  return {
    message_id: "",
    channel_id: 0,
    clan_id: 0,
    sender_id: 0,
    content: "",
    mention: "",
    reaction: "",
    attachments: [],
    reference: "",
    create_time: "",
    update_time: "",
    channel_label: "",
    channel_type: 0,
    clan_name: "",
    username: "",
    display_name: "",
    avatar_url: "",
  };
}

export const SearchMessageDocument = {
  encode(message: SearchMessageDocument, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    if (message.channel_id !== 0) {
      writer.uint32(16).int64(message.channel_id);
    }
    if (message.clan_id !== 0) {
      writer.uint32(24).int64(message.clan_id);
    }
    if (message.sender_id !== 0) {
      writer.uint32(32).int64(message.sender_id);
    }
    if (message.content !== "") {
      writer.uint32(42).string(message.content);
    }
    if (message.mention !== "") {
      writer.uint32(50).string(message.mention);
    }
    if (message.reaction !== "") {
      writer.uint32(58).string(message.reaction);
    }
    for (const v of message.attachments) {
      MessageAttachment.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.reference !== "") {
      writer.uint32(74).string(message.reference);
    }
    if (message.create_time !== "") {
      writer.uint32(82).string(message.create_time);
    }
    if (message.update_time !== "") {
      writer.uint32(90).string(message.update_time);
    }
    if (message.channel_label !== "") {
      writer.uint32(98).string(message.channel_label);
    }
    if (message.channel_type !== 0) {
      writer.uint32(104).int32(message.channel_type);
    }
    if (message.clan_name !== "") {
      writer.uint32(114).string(message.clan_name);
    }
    if (message.username !== "") {
      writer.uint32(122).string(message.username);
    }
    if (message.display_name !== "") {
      writer.uint32(130).string(message.display_name);
    }
    if (message.avatar_url !== "") {
      writer.uint32(138).string(message.avatar_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchMessageDocument {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchMessageDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_id = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clan_id = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sender_id = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mention = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.reaction = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.reference = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.create_time = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.update_time = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.username = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchMessageDocument {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.Number(object.channel_id) : 0,
      clan_id: isSet(object.clan_id) ? globalThis.Number(object.clan_id) : 0,
      sender_id: isSet(object.sender_id) ? globalThis.Number(object.sender_id) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      mention: isSet(object.mention) ? globalThis.String(object.mention) : "",
      reaction: isSet(object.reaction) ? globalThis.String(object.reaction) : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => MessageAttachment.fromJSON(e))
        : [],
      reference: isSet(object.reference) ? globalThis.String(object.reference) : "",
      create_time: isSet(object.create_time) ? globalThis.String(object.create_time) : "",
      update_time: isSet(object.update_time) ? globalThis.String(object.update_time) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
    };
  },

  toJSON(message: SearchMessageDocument): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.channel_id !== 0) {
      obj.channel_id = Math.round(message.channel_id);
    }
    if (message.clan_id !== 0) {
      obj.clan_id = Math.round(message.clan_id);
    }
    if (message.sender_id !== 0) {
      obj.sender_id = Math.round(message.sender_id);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.mention !== "") {
      obj.mention = message.mention;
    }
    if (message.reaction !== "") {
      obj.reaction = message.reaction;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));
    }
    if (message.reference !== "") {
      obj.reference = message.reference;
    }
    if (message.create_time !== "") {
      obj.create_time = message.create_time;
    }
    if (message.update_time !== "") {
      obj.update_time = message.update_time;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchMessageDocument>, I>>(base?: I): SearchMessageDocument {
    return SearchMessageDocument.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchMessageDocument>, I>>(object: I): SearchMessageDocument {
    const message = createBaseSearchMessageDocument();
    message.message_id = object.message_id ?? "";
    message.channel_id = object.channel_id ?? 0;
    message.clan_id = object.clan_id ?? 0;
    message.sender_id = object.sender_id ?? 0;
    message.content = object.content ?? "";
    message.mention = object.mention ?? "";
    message.reaction = object.reaction ?? "";
    message.attachments = object.attachments?.map((e) => MessageAttachment.fromPartial(e)) || [];
    message.reference = object.reference ?? "";
    message.create_time = object.create_time ?? "";
    message.update_time = object.update_time ?? "";
    message.channel_label = object.channel_label ?? "";
    message.channel_type = object.channel_type ?? 0;
    message.clan_name = object.clan_name ?? "";
    message.username = object.username ?? "";
    message.display_name = object.display_name ?? "";
    message.avatar_url = object.avatar_url ?? "";
    return message;
  },
};

function createBaseSearchMessageResponse(): SearchMessageResponse {
  return { messages: [], total: 0 };
}

export const SearchMessageResponse = {
  encode(message: SearchMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      SearchMessageDocument.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(SearchMessageDocument.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchMessageResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => SearchMessageDocument.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: SearchMessageResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => SearchMessageDocument.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchMessageResponse>, I>>(base?: I): SearchMessageResponse {
    return SearchMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchMessageResponse>, I>>(object: I): SearchMessageResponse {
    const message = createBaseSearchMessageResponse();
    message.messages = object.messages?.map((e) => SearchMessageDocument.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseRegistrationEmailRequest(): RegistrationEmailRequest {
  return { email: "", password: "", username: "", display_name: "", avatar_url: "", dob: "", vars: {} };
}

export const RegistrationEmailRequest = {
  encode(message: RegistrationEmailRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.display_name !== "") {
      writer.uint32(34).string(message.display_name);
    }
    if (message.avatar_url !== "") {
      writer.uint32(42).string(message.avatar_url);
    }
    if (message.dob !== "") {
      writer.uint32(50).string(message.dob);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      RegistrationEmailRequest_VarsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegistrationEmailRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistrationEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.avatar_url = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dob = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = RegistrationEmailRequest_VarsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.vars[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegistrationEmailRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar_url: isSet(object.avatar_url) ? globalThis.String(object.avatar_url) : "",
      dob: isSet(object.dob) ? globalThis.String(object.dob) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RegistrationEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar_url !== "") {
      obj.avatar_url = message.avatar_url;
    }
    if (message.dob !== "") {
      obj.dob = message.dob;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegistrationEmailRequest>, I>>(base?: I): RegistrationEmailRequest {
    return RegistrationEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegistrationEmailRequest>, I>>(object: I): RegistrationEmailRequest {
    const message = createBaseRegistrationEmailRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.username = object.username ?? "";
    message.display_name = object.display_name ?? "";
    message.avatar_url = object.avatar_url ?? "";
    message.dob = object.dob ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRegistrationEmailRequest_VarsEntry(): RegistrationEmailRequest_VarsEntry {
  return { key: "", value: "" };
}

export const RegistrationEmailRequest_VarsEntry = {
  encode(message: RegistrationEmailRequest_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegistrationEmailRequest_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistrationEmailRequest_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegistrationEmailRequest_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RegistrationEmailRequest_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegistrationEmailRequest_VarsEntry>, I>>(
    base?: I,
  ): RegistrationEmailRequest_VarsEntry {
    return RegistrationEmailRequest_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegistrationEmailRequest_VarsEntry>, I>>(
    object: I,
  ): RegistrationEmailRequest_VarsEntry {
    const message = createBaseRegistrationEmailRequest_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseClanEmoji(): ClanEmoji {
  return { id: "", src: "", shortname: "", category: "", creator_id: "", clan_id: "", logo: "", clan_name: "" };
}

export const ClanEmoji = {
  encode(message: ClanEmoji, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.shortname !== "") {
      writer.uint32(26).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.creator_id !== "") {
      writer.uint32(42).string(message.creator_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(50).string(message.clan_id);
    }
    if (message.logo !== "") {
      writer.uint32(58).string(message.logo);
    }
    if (message.clan_name !== "") {
      writer.uint32(66).string(message.clan_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanEmoji {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanEmoji();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clan_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanEmoji {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
    };
  },

  toJSON(message: ClanEmoji): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanEmoji>, I>>(base?: I): ClanEmoji {
    return ClanEmoji.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanEmoji>, I>>(object: I): ClanEmoji {
    const message = createBaseClanEmoji();
    message.id = object.id ?? "";
    message.src = object.src ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.creator_id = object.creator_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.logo = object.logo ?? "";
    message.clan_name = object.clan_name ?? "";
    return message;
  },
};

function createBaseEmojiListedResponse(): EmojiListedResponse {
  return { emoji_list: [] };
}

export const EmojiListedResponse = {
  encode(message: EmojiListedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.emoji_list) {
      ClanEmoji.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmojiListedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmojiListedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emoji_list.push(ClanEmoji.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmojiListedResponse {
    return {
      emoji_list: globalThis.Array.isArray(object?.emoji_list)
        ? object.emoji_list.map((e: any) => ClanEmoji.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EmojiListedResponse): unknown {
    const obj: any = {};
    if (message.emoji_list?.length) {
      obj.emoji_list = message.emoji_list.map((e) => ClanEmoji.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmojiListedResponse>, I>>(base?: I): EmojiListedResponse {
    return EmojiListedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmojiListedResponse>, I>>(object: I): EmojiListedResponse {
    const message = createBaseEmojiListedResponse();
    message.emoji_list = object.emoji_list?.map((e) => ClanEmoji.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStickerListedResponse(): StickerListedResponse {
  return { stickers: [] };
}

export const StickerListedResponse = {
  encode(message: StickerListedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stickers) {
      ClanSticker.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StickerListedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStickerListedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stickers.push(ClanSticker.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StickerListedResponse {
    return {
      stickers: globalThis.Array.isArray(object?.stickers)
        ? object.stickers.map((e: any) => ClanSticker.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StickerListedResponse): unknown {
    const obj: any = {};
    if (message.stickers?.length) {
      obj.stickers = message.stickers.map((e) => ClanSticker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StickerListedResponse>, I>>(base?: I): StickerListedResponse {
    return StickerListedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StickerListedResponse>, I>>(object: I): StickerListedResponse {
    const message = createBaseStickerListedResponse();
    message.stickers = object.stickers?.map((e) => ClanSticker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClanSticker(): ClanSticker {
  return {
    id: "",
    source: "",
    shortname: "",
    category: "",
    creator_id: "",
    create_time: undefined,
    clan_id: "",
    logo: "",
    clan_name: "",
  };
}

export const ClanSticker = {
  encode(message: ClanSticker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.shortname !== "") {
      writer.uint32(26).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.creator_id !== "") {
      writer.uint32(42).string(message.creator_id);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.clan_id !== "") {
      writer.uint32(58).string(message.clan_id);
    }
    if (message.logo !== "") {
      writer.uint32(66).string(message.logo);
    }
    if (message.clan_name !== "") {
      writer.uint32(74).string(message.clan_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanSticker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanSticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.logo = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clan_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanSticker {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
    };
  },

  toJSON(message: ClanSticker): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanSticker>, I>>(base?: I): ClanSticker {
    return ClanSticker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanSticker>, I>>(object: I): ClanSticker {
    const message = createBaseClanSticker();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.creator_id = object.creator_id ?? "";
    message.create_time = object.create_time ?? undefined;
    message.clan_id = object.clan_id ?? "";
    message.logo = object.logo ?? "";
    message.clan_name = object.clan_name ?? "";
    return message;
  },
};

function createBaseAllUsersAddChannelRequest(): AllUsersAddChannelRequest {
  return { channel_id: "", limit: undefined };
}

export const AllUsersAddChannelRequest = {
  encode(message: AllUsersAddChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllUsersAddChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUsersAddChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUsersAddChannelRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
    };
  },

  toJSON(message: AllUsersAddChannelRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUsersAddChannelRequest>, I>>(base?: I): AllUsersAddChannelRequest {
    return AllUsersAddChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUsersAddChannelRequest>, I>>(object: I): AllUsersAddChannelRequest {
    const message = createBaseAllUsersAddChannelRequest();
    message.channel_id = object.channel_id ?? "";
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseAllUsersAddChannelResponse(): AllUsersAddChannelResponse {
  return { channel_id: "", user_ids: [], limit: undefined };
}

export const AllUsersAddChannelResponse = {
  encode(message: AllUsersAddChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllUsersAddChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUsersAddChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUsersAddChannelResponse {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
    };
  },

  toJSON(message: AllUsersAddChannelResponse): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUsersAddChannelResponse>, I>>(base?: I): AllUsersAddChannelResponse {
    return AllUsersAddChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUsersAddChannelResponse>, I>>(object: I): AllUsersAddChannelResponse {
    const message = createBaseAllUsersAddChannelResponse();
    message.channel_id = object.channel_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseClanEmojiCreateRequest(): ClanEmojiCreateRequest {
  return { clan_id: "", source: "", shortname: "", category: "", id: "" };
}

export const ClanEmojiCreateRequest = {
  encode(message: ClanEmojiCreateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.shortname !== "") {
      writer.uint32(26).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanEmojiCreateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanEmojiCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanEmojiCreateRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ClanEmojiCreateRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanEmojiCreateRequest>, I>>(base?: I): ClanEmojiCreateRequest {
    return ClanEmojiCreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanEmojiCreateRequest>, I>>(object: I): ClanEmojiCreateRequest {
    const message = createBaseClanEmojiCreateRequest();
    message.clan_id = object.clan_id ?? "";
    message.source = object.source ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseClanEmojiGetByClanIdRequest(): ClanEmojiGetByClanIdRequest {
  return { clan_id: "" };
}

export const ClanEmojiGetByClanIdRequest = {
  encode(message: ClanEmojiGetByClanIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanEmojiGetByClanIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanEmojiGetByClanIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanEmojiGetByClanIdRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ClanEmojiGetByClanIdRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanEmojiGetByClanIdRequest>, I>>(base?: I): ClanEmojiGetByClanIdRequest {
    return ClanEmojiGetByClanIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanEmojiGetByClanIdRequest>, I>>(object: I): ClanEmojiGetByClanIdRequest {
    const message = createBaseClanEmojiGetByClanIdRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanEmojiDeleteRequest(): ClanEmojiDeleteRequest {
  return { id: "", clan_id: "" };
}

export const ClanEmojiDeleteRequest = {
  encode(message: ClanEmojiDeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanEmojiDeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanEmojiDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanEmojiDeleteRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanEmojiDeleteRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanEmojiDeleteRequest>, I>>(base?: I): ClanEmojiDeleteRequest {
    return ClanEmojiDeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanEmojiDeleteRequest>, I>>(object: I): ClanEmojiDeleteRequest {
    const message = createBaseClanEmojiDeleteRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanEmojiUpdateRequest(): ClanEmojiUpdateRequest {
  return { id: "", shortname: "", clan_id: "" };
}

export const ClanEmojiUpdateRequest = {
  encode(message: ClanEmojiUpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.shortname !== "") {
      writer.uint32(18).string(message.shortname);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanEmojiUpdateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanEmojiUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanEmojiUpdateRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanEmojiUpdateRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanEmojiUpdateRequest>, I>>(base?: I): ClanEmojiUpdateRequest {
    return ClanEmojiUpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanEmojiUpdateRequest>, I>>(object: I): ClanEmojiUpdateRequest {
    const message = createBaseClanEmojiUpdateRequest();
    message.id = object.id ?? "";
    message.shortname = object.shortname ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseWebhook(): Webhook {
  return {
    id: "",
    webhook_name: "",
    channel_id: "",
    active: 0,
    url: "",
    creator_id: "",
    create_time: "",
    update_time: "",
    avatar: "",
  };
}

export const Webhook = {
  encode(message: Webhook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.webhook_name !== "") {
      writer.uint32(18).string(message.webhook_name);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.active !== 0) {
      writer.uint32(32).int32(message.active);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.creator_id !== "") {
      writer.uint32(50).string(message.creator_id);
    }
    if (message.create_time !== "") {
      writer.uint32(58).string(message.create_time);
    }
    if (message.update_time !== "") {
      writer.uint32(66).string(message.update_time);
    }
    if (message.avatar !== "") {
      writer.uint32(74).string(message.avatar);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Webhook {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.create_time = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.update_time = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Webhook {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      create_time: isSet(object.create_time) ? globalThis.String(object.create_time) : "",
      update_time: isSet(object.update_time) ? globalThis.String(object.update_time) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: Webhook): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.create_time !== "") {
      obj.create_time = message.create_time;
    }
    if (message.update_time !== "") {
      obj.update_time = message.update_time;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Webhook>, I>>(base?: I): Webhook {
    return Webhook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Webhook>, I>>(object: I): Webhook {
    const message = createBaseWebhook();
    message.id = object.id ?? "";
    message.webhook_name = object.webhook_name ?? "";
    message.channel_id = object.channel_id ?? "";
    message.active = object.active ?? 0;
    message.url = object.url ?? "";
    message.creator_id = object.creator_id ?? "";
    message.create_time = object.create_time ?? "";
    message.update_time = object.update_time ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseWebhookCreateRequest(): WebhookCreateRequest {
  return { webhook_name: "", channel_id: "", avatar: "", clan_id: "" };
}

export const WebhookCreateRequest = {
  encode(message: WebhookCreateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.webhook_name !== "") {
      writer.uint32(10).string(message.webhook_name);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.avatar !== "") {
      writer.uint32(26).string(message.avatar);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookCreateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookCreateRequest {
    return {
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: WebhookCreateRequest): unknown {
    const obj: any = {};
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookCreateRequest>, I>>(base?: I): WebhookCreateRequest {
    return WebhookCreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookCreateRequest>, I>>(object: I): WebhookCreateRequest {
    const message = createBaseWebhookCreateRequest();
    message.webhook_name = object.webhook_name ?? "";
    message.channel_id = object.channel_id ?? "";
    message.avatar = object.avatar ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseWebhookListRequestById(): WebhookListRequestById {
  return { id: "" };
}

export const WebhookListRequestById = {
  encode(message: WebhookListRequestById, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookListRequestById {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookListRequestById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookListRequestById {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: WebhookListRequestById): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookListRequestById>, I>>(base?: I): WebhookListRequestById {
    return WebhookListRequestById.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookListRequestById>, I>>(object: I): WebhookListRequestById {
    const message = createBaseWebhookListRequestById();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseWebhookUpdateRequestById(): WebhookUpdateRequestById {
  return { id: "", webhook_name: "", channel_id_update: "", avatar: "", channel_id: "", clan_id: "" };
}

export const WebhookUpdateRequestById = {
  encode(message: WebhookUpdateRequestById, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.webhook_name !== "") {
      writer.uint32(18).string(message.webhook_name);
    }
    if (message.channel_id_update !== "") {
      writer.uint32(26).string(message.channel_id_update);
    }
    if (message.avatar !== "") {
      writer.uint32(34).string(message.avatar);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(50).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookUpdateRequestById {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookUpdateRequestById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id_update = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookUpdateRequestById {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      channel_id_update: isSet(object.channel_id_update) ? globalThis.String(object.channel_id_update) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: WebhookUpdateRequestById): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.channel_id_update !== "") {
      obj.channel_id_update = message.channel_id_update;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookUpdateRequestById>, I>>(base?: I): WebhookUpdateRequestById {
    return WebhookUpdateRequestById.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookUpdateRequestById>, I>>(object: I): WebhookUpdateRequestById {
    const message = createBaseWebhookUpdateRequestById();
    message.id = object.id ?? "";
    message.webhook_name = object.webhook_name ?? "";
    message.channel_id_update = object.channel_id_update ?? "";
    message.avatar = object.avatar ?? "";
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseWebhookDeleteRequestById(): WebhookDeleteRequestById {
  return { id: "", clan_id: "", channel_id: "" };
}

export const WebhookDeleteRequestById = {
  encode(message: WebhookDeleteRequestById, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookDeleteRequestById {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookDeleteRequestById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookDeleteRequestById {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: WebhookDeleteRequestById): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookDeleteRequestById>, I>>(base?: I): WebhookDeleteRequestById {
    return WebhookDeleteRequestById.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookDeleteRequestById>, I>>(object: I): WebhookDeleteRequestById {
    const message = createBaseWebhookDeleteRequestById();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseWebhookListRequest(): WebhookListRequest {
  return { channel_id: "", clan_id: "" };
}

export const WebhookListRequest = {
  encode(message: WebhookListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookListRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: WebhookListRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookListRequest>, I>>(base?: I): WebhookListRequest {
    return WebhookListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookListRequest>, I>>(object: I): WebhookListRequest {
    const message = createBaseWebhookListRequest();
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseWebhookListResponse(): WebhookListResponse {
  return { webhooks: [] };
}

export const WebhookListResponse = {
  encode(message: WebhookListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.webhooks) {
      Webhook.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webhooks.push(Webhook.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookListResponse {
    return {
      webhooks: globalThis.Array.isArray(object?.webhooks) ? object.webhooks.map((e: any) => Webhook.fromJSON(e)) : [],
    };
  },

  toJSON(message: WebhookListResponse): unknown {
    const obj: any = {};
    if (message.webhooks?.length) {
      obj.webhooks = message.webhooks.map((e) => Webhook.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookListResponse>, I>>(base?: I): WebhookListResponse {
    return WebhookListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookListResponse>, I>>(object: I): WebhookListResponse {
    const message = createBaseWebhookListResponse();
    message.webhooks = object.webhooks?.map((e) => Webhook.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebhookGenerateResponse(): WebhookGenerateResponse {
  return { url: "", hook_name: "", channel_id: "", avatar: "" };
}

export const WebhookGenerateResponse = {
  encode(message: WebhookGenerateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.hook_name !== "") {
      writer.uint32(18).string(message.hook_name);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.avatar !== "") {
      writer.uint32(34).string(message.avatar);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookGenerateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookGenerateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hook_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookGenerateResponse {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      hook_name: isSet(object.hook_name) ? globalThis.String(object.hook_name) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: WebhookGenerateResponse): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.hook_name !== "") {
      obj.hook_name = message.hook_name;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookGenerateResponse>, I>>(base?: I): WebhookGenerateResponse {
    return WebhookGenerateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookGenerateResponse>, I>>(object: I): WebhookGenerateResponse {
    const message = createBaseWebhookGenerateResponse();
    message.url = object.url ?? "";
    message.hook_name = object.hook_name ?? "";
    message.channel_id = object.channel_id ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseWebhookHandlerRequest(): WebhookHandlerRequest {
  return { body: undefined, channel_id: "", token: "" };
}

export const WebhookHandlerRequest = {
  encode(message: WebhookHandlerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.body !== undefined) {
      Struct.encode(Struct.wrap(message.body), writer.uint32(10).fork()).ldelim();
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebhookHandlerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookHandlerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookHandlerRequest {
    return {
      body: isObject(object.body) ? object.body : undefined,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: WebhookHandlerRequest): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = message.body;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookHandlerRequest>, I>>(base?: I): WebhookHandlerRequest {
    return WebhookHandlerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookHandlerRequest>, I>>(object: I): WebhookHandlerRequest {
    const message = createBaseWebhookHandlerRequest();
    message.body = object.body ?? undefined;
    message.channel_id = object.channel_id ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseCheckDuplicateClanNameRequest(): CheckDuplicateClanNameRequest {
  return { clan_name: "" };
}

export const CheckDuplicateClanNameRequest = {
  encode(message: CheckDuplicateClanNameRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_name !== "") {
      writer.uint32(10).string(message.clan_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckDuplicateClanNameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckDuplicateClanNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckDuplicateClanNameRequest {
    return { clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "" };
  },

  toJSON(message: CheckDuplicateClanNameRequest): unknown {
    const obj: any = {};
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckDuplicateClanNameRequest>, I>>(base?: I): CheckDuplicateClanNameRequest {
    return CheckDuplicateClanNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckDuplicateClanNameRequest>, I>>(
    object: I,
  ): CheckDuplicateClanNameRequest {
    const message = createBaseCheckDuplicateClanNameRequest();
    message.clan_name = object.clan_name ?? "";
    return message;
  },
};

function createBaseCheckDuplicateClanNameResponse(): CheckDuplicateClanNameResponse {
  return { is_duplicate: false };
}

export const CheckDuplicateClanNameResponse = {
  encode(message: CheckDuplicateClanNameResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.is_duplicate !== false) {
      writer.uint32(8).bool(message.is_duplicate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckDuplicateClanNameResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckDuplicateClanNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.is_duplicate = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckDuplicateClanNameResponse {
    return { is_duplicate: isSet(object.is_duplicate) ? globalThis.Boolean(object.is_duplicate) : false };
  },

  toJSON(message: CheckDuplicateClanNameResponse): unknown {
    const obj: any = {};
    if (message.is_duplicate !== false) {
      obj.is_duplicate = message.is_duplicate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckDuplicateClanNameResponse>, I>>(base?: I): CheckDuplicateClanNameResponse {
    return CheckDuplicateClanNameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckDuplicateClanNameResponse>, I>>(
    object: I,
  ): CheckDuplicateClanNameResponse {
    const message = createBaseCheckDuplicateClanNameResponse();
    message.is_duplicate = object.is_duplicate ?? false;
    return message;
  },
};

function createBaseClanStickerAddRequest(): ClanStickerAddRequest {
  return { source: "", shortname: "", category: "", clan_id: 0, id: "" };
}

export const ClanStickerAddRequest = {
  encode(message: ClanStickerAddRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.shortname !== "") {
      writer.uint32(18).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.clan_id !== 0) {
      writer.uint32(32).int64(message.clan_id);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanStickerAddRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanStickerAddRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.clan_id = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanStickerAddRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      clan_id: isSet(object.clan_id) ? globalThis.Number(object.clan_id) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ClanStickerAddRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.clan_id !== 0) {
      obj.clan_id = Math.round(message.clan_id);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanStickerAddRequest>, I>>(base?: I): ClanStickerAddRequest {
    return ClanStickerAddRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanStickerAddRequest>, I>>(object: I): ClanStickerAddRequest {
    const message = createBaseClanStickerAddRequest();
    message.source = object.source ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.clan_id = object.clan_id ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseClanStickerListByClanIdRequest(): ClanStickerListByClanIdRequest {
  return { clan_id: "" };
}

export const ClanStickerListByClanIdRequest = {
  encode(message: ClanStickerListByClanIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanStickerListByClanIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanStickerListByClanIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanStickerListByClanIdRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ClanStickerListByClanIdRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanStickerListByClanIdRequest>, I>>(base?: I): ClanStickerListByClanIdRequest {
    return ClanStickerListByClanIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanStickerListByClanIdRequest>, I>>(
    object: I,
  ): ClanStickerListByClanIdRequest {
    const message = createBaseClanStickerListByClanIdRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanStickerUpdateByIdRequest(): ClanStickerUpdateByIdRequest {
  return { id: "", source: "", shortname: "", category: "", clan_id: "" };
}

export const ClanStickerUpdateByIdRequest = {
  encode(message: ClanStickerUpdateByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.shortname !== "") {
      writer.uint32(26).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.clan_id !== "") {
      writer.uint32(42).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanStickerUpdateByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanStickerUpdateByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanStickerUpdateByIdRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanStickerUpdateByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanStickerUpdateByIdRequest>, I>>(base?: I): ClanStickerUpdateByIdRequest {
    return ClanStickerUpdateByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanStickerUpdateByIdRequest>, I>>(object: I): ClanStickerUpdateByIdRequest {
    const message = createBaseClanStickerUpdateByIdRequest();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanStickerDeleteRequest(): ClanStickerDeleteRequest {
  return { id: "", clan_id: "" };
}

export const ClanStickerDeleteRequest = {
  encode(message: ClanStickerDeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanStickerDeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanStickerDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanStickerDeleteRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanStickerDeleteRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanStickerDeleteRequest>, I>>(base?: I): ClanStickerDeleteRequest {
    return ClanStickerDeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanStickerDeleteRequest>, I>>(object: I): ClanStickerDeleteRequest {
    const message = createBaseClanStickerDeleteRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseChangeChannelCategoryRequest(): ChangeChannelCategoryRequest {
  return { channel_id: "", new_category_id: "" };
}

export const ChangeChannelCategoryRequest = {
  encode(message: ChangeChannelCategoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.new_category_id !== "") {
      writer.uint32(18).string(message.new_category_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChangeChannelCategoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeChannelCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.new_category_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeChannelCategoryRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      new_category_id: isSet(object.new_category_id) ? globalThis.String(object.new_category_id) : "",
    };
  },

  toJSON(message: ChangeChannelCategoryRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.new_category_id !== "") {
      obj.new_category_id = message.new_category_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeChannelCategoryRequest>, I>>(base?: I): ChangeChannelCategoryRequest {
    return ChangeChannelCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeChannelCategoryRequest>, I>>(object: I): ChangeChannelCategoryRequest {
    const message = createBaseChangeChannelCategoryRequest();
    message.channel_id = object.channel_id ?? "";
    message.new_category_id = object.new_category_id ?? "";
    return message;
  },
};

function createBaseApp(): App {
  return {
    id: "",
    appname: "",
    creator_id: "",
    applogo: "",
    is_shadow: false,
    disable_time: undefined,
    token: "",
    role: 0,
    about: "",
  };
}

export const App = {
  encode(message: App, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appname !== "") {
      writer.uint32(18).string(message.appname);
    }
    if (message.creator_id !== "") {
      writer.uint32(26).string(message.creator_id);
    }
    if (message.applogo !== "") {
      writer.uint32(34).string(message.applogo);
    }
    if (message.is_shadow !== false) {
      writer.uint32(40).bool(message.is_shadow);
    }
    if (message.disable_time !== undefined) {
      Timestamp.encode(toTimestamp(message.disable_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.token !== "") {
      writer.uint32(58).string(message.token);
    }
    if (message.role !== 0) {
      writer.uint32(64).int32(message.role);
    }
    if (message.about !== "") {
      writer.uint32(74).string(message.about);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): App {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.applogo = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_shadow = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.disable_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.token = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.role = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.about = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): App {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      appname: isSet(object.appname) ? globalThis.String(object.appname) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      applogo: isSet(object.applogo) ? globalThis.String(object.applogo) : "",
      is_shadow: isSet(object.is_shadow) ? globalThis.Boolean(object.is_shadow) : false,
      disable_time: isSet(object.disable_time) ? fromJsonTimestamp(object.disable_time) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      about: isSet(object.about) ? globalThis.String(object.about) : "",
    };
  },

  toJSON(message: App): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appname !== "") {
      obj.appname = message.appname;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.applogo !== "") {
      obj.applogo = message.applogo;
    }
    if (message.is_shadow !== false) {
      obj.is_shadow = message.is_shadow;
    }
    if (message.disable_time !== undefined) {
      obj.disable_time = message.disable_time.toISOString();
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.about !== "") {
      obj.about = message.about;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<App>, I>>(base?: I): App {
    return App.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<App>, I>>(object: I): App {
    const message = createBaseApp();
    message.id = object.id ?? "";
    message.appname = object.appname ?? "";
    message.creator_id = object.creator_id ?? "";
    message.applogo = object.applogo ?? "";
    message.is_shadow = object.is_shadow ?? false;
    message.disable_time = object.disable_time ?? undefined;
    message.token = object.token ?? "";
    message.role = object.role ?? 0;
    message.about = object.about ?? "";
    return message;
  },
};

function createBaseAppDeleteRequest(): AppDeleteRequest {
  return { id: "", record_deletion: undefined };
}

export const AppDeleteRequest = {
  encode(message: AppDeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.record_deletion !== undefined) {
      BoolValue.encode({ value: message.record_deletion! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppDeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.record_deletion = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDeleteRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      record_deletion: isSet(object.record_deletion) ? Boolean(object.record_deletion) : undefined,
    };
  },

  toJSON(message: AppDeleteRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.record_deletion !== undefined) {
      obj.record_deletion = message.record_deletion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDeleteRequest>, I>>(base?: I): AppDeleteRequest {
    return AppDeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDeleteRequest>, I>>(object: I): AppDeleteRequest {
    const message = createBaseAppDeleteRequest();
    message.id = object.id ?? "";
    message.record_deletion = object.record_deletion ?? undefined;
    return message;
  },
};

function createBaseAppList(): AppList {
  return { apps: [], total_count: 0, next_cursor: "" };
}

export const AppList = {
  encode(message: AppList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.apps) {
      App.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total_count !== 0) {
      writer.uint32(16).int32(message.total_count);
    }
    if (message.next_cursor !== "") {
      writer.uint32(26).string(message.next_cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apps.push(App.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total_count = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next_cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppList {
    return {
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e: any) => App.fromJSON(e)) : [],
      total_count: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
      next_cursor: isSet(object.next_cursor) ? globalThis.String(object.next_cursor) : "",
    };
  },

  toJSON(message: AppList): unknown {
    const obj: any = {};
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => App.toJSON(e));
    }
    if (message.total_count !== 0) {
      obj.total_count = Math.round(message.total_count);
    }
    if (message.next_cursor !== "") {
      obj.next_cursor = message.next_cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppList>, I>>(base?: I): AppList {
    return AppList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppList>, I>>(object: I): AppList {
    const message = createBaseAppList();
    message.apps = object.apps?.map((e) => App.fromPartial(e)) || [];
    message.total_count = object.total_count ?? 0;
    message.next_cursor = object.next_cursor ?? "";
    return message;
  },
};

function createBaseAddAppRequest(): AddAppRequest {
  return { appname: "", token: "", creator_id: "", role: 0, is_shadow: false };
}

export const AddAppRequest = {
  encode(message: AddAppRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appname !== "") {
      writer.uint32(10).string(message.appname);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.creator_id !== "") {
      writer.uint32(26).string(message.creator_id);
    }
    if (message.role !== 0) {
      writer.uint32(32).int32(message.role);
    }
    if (message.is_shadow !== false) {
      writer.uint32(40).bool(message.is_shadow);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddAppRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appname = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.role = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_shadow = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddAppRequest {
    return {
      appname: isSet(object.appname) ? globalThis.String(object.appname) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      is_shadow: isSet(object.is_shadow) ? globalThis.Boolean(object.is_shadow) : false,
    };
  },

  toJSON(message: AddAppRequest): unknown {
    const obj: any = {};
    if (message.appname !== "") {
      obj.appname = message.appname;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.is_shadow !== false) {
      obj.is_shadow = message.is_shadow;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddAppRequest>, I>>(base?: I): AddAppRequest {
    return AddAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddAppRequest>, I>>(object: I): AddAppRequest {
    const message = createBaseAddAppRequest();
    message.appname = object.appname ?? "";
    message.token = object.token ?? "";
    message.creator_id = object.creator_id ?? "";
    message.role = object.role ?? 0;
    message.is_shadow = object.is_shadow ?? false;
    return message;
  },
};

function createBaseListAppsRequest(): ListAppsRequest {
  return { filter: "", tombstones: false, cursor: "" };
}

export const ListAppsRequest = {
  encode(message: ListAppsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    if (message.tombstones !== false) {
      writer.uint32(16).bool(message.tombstones);
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAppsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tombstones = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAppsRequest {
    return {
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      tombstones: isSet(object.tombstones) ? globalThis.Boolean(object.tombstones) : false,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: ListAppsRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.tombstones !== false) {
      obj.tombstones = message.tombstones;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAppsRequest>, I>>(base?: I): ListAppsRequest {
    return ListAppsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAppsRequest>, I>>(object: I): ListAppsRequest {
    const message = createBaseListAppsRequest();
    message.filter = object.filter ?? "";
    message.tombstones = object.tombstones ?? false;
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseUpdateAppRequest(): UpdateAppRequest {
  return { id: "", appname: undefined, metadata: undefined, applogo: undefined, token: undefined, about: "" };
}

export const UpdateAppRequest = {
  encode(message: UpdateAppRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.appname !== undefined) {
      StringValue.encode({ value: message.appname! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      StringValue.encode({ value: message.metadata! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.applogo !== undefined) {
      StringValue.encode({ value: message.applogo! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.token !== undefined) {
      StringValue.encode({ value: message.token! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.about !== "") {
      writer.uint32(50).string(message.about);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateAppRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAppRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appname = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.applogo = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.token = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.about = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAppRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      appname: isSet(object.appname) ? String(object.appname) : undefined,
      metadata: isSet(object.metadata) ? String(object.metadata) : undefined,
      applogo: isSet(object.applogo) ? String(object.applogo) : undefined,
      token: isSet(object.token) ? String(object.token) : undefined,
      about: isSet(object.about) ? globalThis.String(object.about) : "",
    };
  },

  toJSON(message: UpdateAppRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.appname !== undefined) {
      obj.appname = message.appname;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.applogo !== undefined) {
      obj.applogo = message.applogo;
    }
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    if (message.about !== "") {
      obj.about = message.about;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAppRequest>, I>>(base?: I): UpdateAppRequest {
    return UpdateAppRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAppRequest>, I>>(object: I): UpdateAppRequest {
    const message = createBaseUpdateAppRequest();
    message.id = object.id ?? "";
    message.appname = object.appname ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.applogo = object.applogo ?? undefined;
    message.token = object.token ?? undefined;
    message.about = object.about ?? "";
    return message;
  },
};

function createBaseAppId(): AppId {
  return { id: "" };
}

export const AppId = {
  encode(message: AppId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppId {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: AppId): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppId>, I>>(base?: I): AppId {
    return AppId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppId>, I>>(object: I): AppId {
    const message = createBaseAppId();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAppClan(): AppClan {
  return { app_id: "", clan_id: "" };
}

export const AppClan = {
  encode(message: AppClan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.app_id !== "") {
      writer.uint32(10).string(message.app_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppClan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppClan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.app_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppClan {
    return {
      app_id: isSet(object.app_id) ? globalThis.String(object.app_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: AppClan): unknown {
    const obj: any = {};
    if (message.app_id !== "") {
      obj.app_id = message.app_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppClan>, I>>(base?: I): AppClan {
    return AppClan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppClan>, I>>(object: I): AppClan {
    const message = createBaseAppClan();
    message.app_id = object.app_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseAuthenticateRequest(): AuthenticateRequest {
  return { account: undefined };
}

export const AuthenticateRequest = {
  encode(message: AuthenticateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountApp.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountApp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateRequest {
    return { account: isSet(object.account) ? AccountApp.fromJSON(object.account) : undefined };
  },

  toJSON(message: AuthenticateRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountApp.toJSON(message.account);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateRequest>, I>>(base?: I): AuthenticateRequest {
    return AuthenticateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateRequest>, I>>(object: I): AuthenticateRequest {
    const message = createBaseAuthenticateRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountApp.fromPartial(object.account)
      : undefined;
    return message;
  },
};

function createBaseAccountApp(): AccountApp {
  return { appid: "", appname: "", token: "", vars: {} };
}

export const AccountApp = {
  encode(message: AccountApp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== "") {
      writer.uint32(10).string(message.appid);
    }
    if (message.appname !== "") {
      writer.uint32(18).string(message.appname);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountApp_VarsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountApp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountApp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AccountApp_VarsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.vars[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountApp {
    return {
      appid: isSet(object.appid) ? globalThis.String(object.appid) : "",
      appname: isSet(object.appname) ? globalThis.String(object.appname) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      vars: isObject(object.vars)
        ? Object.entries(object.vars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AccountApp): unknown {
    const obj: any = {};
    if (message.appid !== "") {
      obj.appid = message.appid;
    }
    if (message.appname !== "") {
      obj.appname = message.appname;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.vars) {
      const entries = Object.entries(message.vars);
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountApp>, I>>(base?: I): AccountApp {
    return AccountApp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountApp>, I>>(object: I): AccountApp {
    const message = createBaseAccountApp();
    message.appid = object.appid ?? "";
    message.appname = object.appname ?? "";
    message.token = object.token ?? "";
    message.vars = Object.entries(object.vars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAccountApp_VarsEntry(): AccountApp_VarsEntry {
  return { key: "", value: "" };
}

export const AccountApp_VarsEntry = {
  encode(message: AccountApp_VarsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountApp_VarsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountApp_VarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountApp_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AccountApp_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountApp_VarsEntry>, I>>(base?: I): AccountApp_VarsEntry {
    return AccountApp_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountApp_VarsEntry>, I>>(object: I): AccountApp_VarsEntry {
    const message = createBaseAccountApp_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeleteChannelMessagesRequest(): DeleteChannelMessagesRequest {
  return { before: undefined, ids: [] };
}

export const DeleteChannelMessagesRequest = {
  encode(message: DeleteChannelMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.before !== undefined) {
      Timestamp.encode(toTimestamp(message.before), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteChannelMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChannelMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.before = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChannelMessagesRequest {
    return {
      before: isSet(object.before) ? fromJsonTimestamp(object.before) : undefined,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteChannelMessagesRequest): unknown {
    const obj: any = {};
    if (message.before !== undefined) {
      obj.before = message.before.toISOString();
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChannelMessagesRequest>, I>>(base?: I): DeleteChannelMessagesRequest {
    return DeleteChannelMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChannelMessagesRequest>, I>>(object: I): DeleteChannelMessagesRequest {
    const message = createBaseDeleteChannelMessagesRequest();
    message.before = object.before ?? undefined;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteChannelMessagesResponse(): DeleteChannelMessagesResponse {
  return { total: 0 };
}

export const DeleteChannelMessagesResponse = {
  encode(message: DeleteChannelMessagesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total !== 0) {
      writer.uint32(8).int64(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteChannelMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChannelMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.total = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChannelMessagesResponse {
    return { total: isSet(object.total) ? globalThis.Number(object.total) : 0 };
  },

  toJSON(message: DeleteChannelMessagesResponse): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChannelMessagesResponse>, I>>(base?: I): DeleteChannelMessagesResponse {
    return DeleteChannelMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChannelMessagesResponse>, I>>(
    object: I,
  ): DeleteChannelMessagesResponse {
    const message = createBaseDeleteChannelMessagesResponse();
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return {
    id: "",
    clan_id: "",
    channel_id: "",
    welcome_random: "",
    welcome_sticker: "",
    boost_message: "",
    setup_tips: "",
  };
}

export const SystemMessage = {
  encode(message: SystemMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.welcome_random !== "") {
      writer.uint32(34).string(message.welcome_random);
    }
    if (message.welcome_sticker !== "") {
      writer.uint32(42).string(message.welcome_sticker);
    }
    if (message.boost_message !== "") {
      writer.uint32(50).string(message.boost_message);
    }
    if (message.setup_tips !== "") {
      writer.uint32(58).string(message.setup_tips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.welcome_random = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.welcome_sticker = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.boost_message = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.setup_tips = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      welcome_random: isSet(object.welcome_random) ? globalThis.String(object.welcome_random) : "",
      welcome_sticker: isSet(object.welcome_sticker) ? globalThis.String(object.welcome_sticker) : "",
      boost_message: isSet(object.boost_message) ? globalThis.String(object.boost_message) : "",
      setup_tips: isSet(object.setup_tips) ? globalThis.String(object.setup_tips) : "",
    };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.welcome_random !== "") {
      obj.welcome_random = message.welcome_random;
    }
    if (message.welcome_sticker !== "") {
      obj.welcome_sticker = message.welcome_sticker;
    }
    if (message.boost_message !== "") {
      obj.boost_message = message.boost_message;
    }
    if (message.setup_tips !== "") {
      obj.setup_tips = message.setup_tips;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessage>, I>>(base?: I): SystemMessage {
    return SystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessage>, I>>(object: I): SystemMessage {
    const message = createBaseSystemMessage();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.welcome_random = object.welcome_random ?? "";
    message.welcome_sticker = object.welcome_sticker ?? "";
    message.boost_message = object.boost_message ?? "";
    message.setup_tips = object.setup_tips ?? "";
    return message;
  },
};

function createBaseSystemMessagesList(): SystemMessagesList {
  return { system_messages_list: [] };
}

export const SystemMessagesList = {
  encode(message: SystemMessagesList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.system_messages_list) {
      SystemMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMessagesList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessagesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.system_messages_list.push(SystemMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessagesList {
    return {
      system_messages_list: globalThis.Array.isArray(object?.system_messages_list)
        ? object.system_messages_list.map((e: any) => SystemMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SystemMessagesList): unknown {
    const obj: any = {};
    if (message.system_messages_list?.length) {
      obj.system_messages_list = message.system_messages_list.map((e) => SystemMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessagesList>, I>>(base?: I): SystemMessagesList {
    return SystemMessagesList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessagesList>, I>>(object: I): SystemMessagesList {
    const message = createBaseSystemMessagesList();
    message.system_messages_list = object.system_messages_list?.map((e) => SystemMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSystemMessageRequest(): SystemMessageRequest {
  return { clan_id: "", channel_id: "", welcome_random: "", welcome_sticker: "", boost_message: "", setup_tips: "" };
}

export const SystemMessageRequest = {
  encode(message: SystemMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.welcome_random !== "") {
      writer.uint32(26).string(message.welcome_random);
    }
    if (message.welcome_sticker !== "") {
      writer.uint32(34).string(message.welcome_sticker);
    }
    if (message.boost_message !== "") {
      writer.uint32(42).string(message.boost_message);
    }
    if (message.setup_tips !== "") {
      writer.uint32(50).string(message.setup_tips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.welcome_random = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.welcome_sticker = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.boost_message = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.setup_tips = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessageRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      welcome_random: isSet(object.welcome_random) ? globalThis.String(object.welcome_random) : "",
      welcome_sticker: isSet(object.welcome_sticker) ? globalThis.String(object.welcome_sticker) : "",
      boost_message: isSet(object.boost_message) ? globalThis.String(object.boost_message) : "",
      setup_tips: isSet(object.setup_tips) ? globalThis.String(object.setup_tips) : "",
    };
  },

  toJSON(message: SystemMessageRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.welcome_random !== "") {
      obj.welcome_random = message.welcome_random;
    }
    if (message.welcome_sticker !== "") {
      obj.welcome_sticker = message.welcome_sticker;
    }
    if (message.boost_message !== "") {
      obj.boost_message = message.boost_message;
    }
    if (message.setup_tips !== "") {
      obj.setup_tips = message.setup_tips;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessageRequest>, I>>(base?: I): SystemMessageRequest {
    return SystemMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessageRequest>, I>>(object: I): SystemMessageRequest {
    const message = createBaseSystemMessageRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.welcome_random = object.welcome_random ?? "";
    message.welcome_sticker = object.welcome_sticker ?? "";
    message.boost_message = object.boost_message ?? "";
    message.setup_tips = object.setup_tips ?? "";
    return message;
  },
};

function createBaseDeleteSystemMessage(): DeleteSystemMessage {
  return { clan_id: "" };
}

export const DeleteSystemMessage = {
  encode(message: DeleteSystemMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSystemMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSystemMessage {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: DeleteSystemMessage): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSystemMessage>, I>>(base?: I): DeleteSystemMessage {
    return DeleteSystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSystemMessage>, I>>(object: I): DeleteSystemMessage {
    const message = createBaseDeleteSystemMessage();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseGetSystemMessage(): GetSystemMessage {
  return { clan_id: "" };
}

export const GetSystemMessage = {
  encode(message: GetSystemMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSystemMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSystemMessage {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: GetSystemMessage): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSystemMessage>, I>>(base?: I): GetSystemMessage {
    return GetSystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSystemMessage>, I>>(object: I): GetSystemMessage {
    const message = createBaseGetSystemMessage();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseDeleteCategoryOrderRequest(): DeleteCategoryOrderRequest {
  return { clan_id: "" };
}

export const DeleteCategoryOrderRequest = {
  encode(message: DeleteCategoryOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCategoryOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryOrderRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: DeleteCategoryOrderRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCategoryOrderRequest>, I>>(base?: I): DeleteCategoryOrderRequest {
    return DeleteCategoryOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCategoryOrderRequest>, I>>(object: I): DeleteCategoryOrderRequest {
    const message = createBaseDeleteCategoryOrderRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseStreamHttpCallbackRequest(): StreamHttpCallbackRequest {
  return {
    action: "",
    client_id: "",
    ip: "",
    vhost: "",
    app: "",
    stream: "",
    param: undefined,
    server_id: "",
    stream_url: "",
    stream_id: "",
    page_url: undefined,
    tcUrl: undefined,
    service_id: undefined,
  };
}

export const StreamHttpCallbackRequest = {
  encode(message: StreamHttpCallbackRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.client_id !== "") {
      writer.uint32(18).string(message.client_id);
    }
    if (message.ip !== "") {
      writer.uint32(26).string(message.ip);
    }
    if (message.vhost !== "") {
      writer.uint32(34).string(message.vhost);
    }
    if (message.app !== "") {
      writer.uint32(42).string(message.app);
    }
    if (message.stream !== "") {
      writer.uint32(50).string(message.stream);
    }
    if (message.param !== undefined) {
      StringValue.encode({ value: message.param! }, writer.uint32(58).fork()).ldelim();
    }
    if (message.server_id !== "") {
      writer.uint32(66).string(message.server_id);
    }
    if (message.stream_url !== "") {
      writer.uint32(74).string(message.stream_url);
    }
    if (message.stream_id !== "") {
      writer.uint32(82).string(message.stream_id);
    }
    if (message.page_url !== undefined) {
      StringValue.encode({ value: message.page_url! }, writer.uint32(90).fork()).ldelim();
    }
    if (message.tcUrl !== undefined) {
      StringValue.encode({ value: message.tcUrl! }, writer.uint32(98).fork()).ldelim();
    }
    if (message.service_id !== undefined) {
      StringValue.encode({ value: message.service_id! }, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamHttpCallbackRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamHttpCallbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.client_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vhost = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.app = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.param = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.server_id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stream_url = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.stream_id = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.page_url = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.tcUrl = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.service_id = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamHttpCallbackRequest {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      client_id: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      vhost: isSet(object.vhost) ? globalThis.String(object.vhost) : "",
      app: isSet(object.app) ? globalThis.String(object.app) : "",
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      param: isSet(object.param) ? String(object.param) : undefined,
      server_id: isSet(object.server_id) ? globalThis.String(object.server_id) : "",
      stream_url: isSet(object.stream_url) ? globalThis.String(object.stream_url) : "",
      stream_id: isSet(object.stream_id) ? globalThis.String(object.stream_id) : "",
      page_url: isSet(object.page_url) ? String(object.page_url) : undefined,
      tcUrl: isSet(object.tcUrl) ? String(object.tcUrl) : undefined,
      service_id: isSet(object.service_id) ? String(object.service_id) : undefined,
    };
  },

  toJSON(message: StreamHttpCallbackRequest): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.client_id !== "") {
      obj.client_id = message.client_id;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.vhost !== "") {
      obj.vhost = message.vhost;
    }
    if (message.app !== "") {
      obj.app = message.app;
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.param !== undefined) {
      obj.param = message.param;
    }
    if (message.server_id !== "") {
      obj.server_id = message.server_id;
    }
    if (message.stream_url !== "") {
      obj.stream_url = message.stream_url;
    }
    if (message.stream_id !== "") {
      obj.stream_id = message.stream_id;
    }
    if (message.page_url !== undefined) {
      obj.page_url = message.page_url;
    }
    if (message.tcUrl !== undefined) {
      obj.tcUrl = message.tcUrl;
    }
    if (message.service_id !== undefined) {
      obj.service_id = message.service_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamHttpCallbackRequest>, I>>(base?: I): StreamHttpCallbackRequest {
    return StreamHttpCallbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamHttpCallbackRequest>, I>>(object: I): StreamHttpCallbackRequest {
    const message = createBaseStreamHttpCallbackRequest();
    message.action = object.action ?? "";
    message.client_id = object.client_id ?? "";
    message.ip = object.ip ?? "";
    message.vhost = object.vhost ?? "";
    message.app = object.app ?? "";
    message.stream = object.stream ?? "";
    message.param = object.param ?? undefined;
    message.server_id = object.server_id ?? "";
    message.stream_url = object.stream_url ?? "";
    message.stream_id = object.stream_id ?? "";
    message.page_url = object.page_url ?? undefined;
    message.tcUrl = object.tcUrl ?? undefined;
    message.service_id = object.service_id ?? undefined;
    return message;
  },
};

function createBaseStreamHttpCallbackResponse(): StreamHttpCallbackResponse {
  return { code: undefined, msg: "" };
}

export const StreamHttpCallbackResponse = {
  encode(message: StreamHttpCallbackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== undefined) {
      Int32Value.encode({ value: message.code! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamHttpCallbackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamHttpCallbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamHttpCallbackResponse {
    return {
      code: isSet(object.code) ? Number(object.code) : undefined,
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: StreamHttpCallbackResponse): unknown {
    const obj: any = {};
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamHttpCallbackResponse>, I>>(base?: I): StreamHttpCallbackResponse {
    return StreamHttpCallbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamHttpCallbackResponse>, I>>(object: I): StreamHttpCallbackResponse {
    const message = createBaseStreamHttpCallbackResponse();
    message.code = object.code ?? undefined;
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseStreamingChannelUser(): StreamingChannelUser {
  return { id: "", user_id: "", channel_id: "", participant: "" };
}

export const StreamingChannelUser = {
  encode(message: StreamingChannelUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.participant !== "") {
      writer.uint32(34).string(message.participant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamingChannelUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingChannelUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingChannelUser {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
    };
  },

  toJSON(message: StreamingChannelUser): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingChannelUser>, I>>(base?: I): StreamingChannelUser {
    return StreamingChannelUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingChannelUser>, I>>(object: I): StreamingChannelUser {
    const message = createBaseStreamingChannelUser();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.participant = object.participant ?? "";
    return message;
  },
};

function createBaseStreamingChannelUserList(): StreamingChannelUserList {
  return { streaming_channel_users: [] };
}

export const StreamingChannelUserList = {
  encode(message: StreamingChannelUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.streaming_channel_users) {
      StreamingChannelUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamingChannelUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingChannelUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streaming_channel_users.push(StreamingChannelUser.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingChannelUserList {
    return {
      streaming_channel_users: globalThis.Array.isArray(object?.streaming_channel_users)
        ? object.streaming_channel_users.map((e: any) => StreamingChannelUser.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamingChannelUserList): unknown {
    const obj: any = {};
    if (message.streaming_channel_users?.length) {
      obj.streaming_channel_users = message.streaming_channel_users.map((e) => StreamingChannelUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingChannelUserList>, I>>(base?: I): StreamingChannelUserList {
    return StreamingChannelUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingChannelUserList>, I>>(object: I): StreamingChannelUserList {
    const message = createBaseStreamingChannelUserList();
    message.streaming_channel_users = object.streaming_channel_users?.map((e) => StreamingChannelUser.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseRegisterStreamingChannelRequest(): RegisterStreamingChannelRequest {
  return { clan_id: "", channel_id: "" };
}

export const RegisterStreamingChannelRequest = {
  encode(message: RegisterStreamingChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterStreamingChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterStreamingChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterStreamingChannelRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: RegisterStreamingChannelRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterStreamingChannelRequest>, I>>(base?: I): RegisterStreamingChannelRequest {
    return RegisterStreamingChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterStreamingChannelRequest>, I>>(
    object: I,
  ): RegisterStreamingChannelRequest {
    const message = createBaseRegisterStreamingChannelRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseRegisterStreamingChannelResponse(): RegisterStreamingChannelResponse {
  return { clan_id: "", channel_id: "", streaming_url: "" };
}

export const RegisterStreamingChannelResponse = {
  encode(message: RegisterStreamingChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.streaming_url !== "") {
      writer.uint32(26).string(message.streaming_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterStreamingChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterStreamingChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.streaming_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterStreamingChannelResponse {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      streaming_url: isSet(object.streaming_url) ? globalThis.String(object.streaming_url) : "",
    };
  },

  toJSON(message: RegisterStreamingChannelResponse): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.streaming_url !== "") {
      obj.streaming_url = message.streaming_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterStreamingChannelResponse>, I>>(
    base?: I,
  ): RegisterStreamingChannelResponse {
    return RegisterStreamingChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterStreamingChannelResponse>, I>>(
    object: I,
  ): RegisterStreamingChannelResponse {
    const message = createBaseRegisterStreamingChannelResponse();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.streaming_url = object.streaming_url ?? "";
    return message;
  },
};

function createBaseListStreamingChannelsRequest(): ListStreamingChannelsRequest {
  return { clan_id: "" };
}

export const ListStreamingChannelsRequest = {
  encode(message: ListStreamingChannelsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStreamingChannelsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStreamingChannelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStreamingChannelsRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ListStreamingChannelsRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStreamingChannelsRequest>, I>>(base?: I): ListStreamingChannelsRequest {
    return ListStreamingChannelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStreamingChannelsRequest>, I>>(object: I): ListStreamingChannelsRequest {
    const message = createBaseListStreamingChannelsRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseListStreamingChannelsResponse(): ListStreamingChannelsResponse {
  return { streaming_channels: [] };
}

export const ListStreamingChannelsResponse = {
  encode(message: ListStreamingChannelsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.streaming_channels) {
      StreamingChannelResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStreamingChannelsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStreamingChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streaming_channels.push(StreamingChannelResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStreamingChannelsResponse {
    return {
      streaming_channels: globalThis.Array.isArray(object?.streaming_channels)
        ? object.streaming_channels.map((e: any) => StreamingChannelResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListStreamingChannelsResponse): unknown {
    const obj: any = {};
    if (message.streaming_channels?.length) {
      obj.streaming_channels = message.streaming_channels.map((e) => StreamingChannelResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStreamingChannelsResponse>, I>>(base?: I): ListStreamingChannelsResponse {
    return ListStreamingChannelsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStreamingChannelsResponse>, I>>(
    object: I,
  ): ListStreamingChannelsResponse {
    const message = createBaseListStreamingChannelsResponse();
    message.streaming_channels = object.streaming_channels?.map((e) => StreamingChannelResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamingChannelResponse(): StreamingChannelResponse {
  return { clan_id: "", channel_id: "", streaming_url: "", is_streaming: false };
}

export const StreamingChannelResponse = {
  encode(message: StreamingChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.streaming_url !== "") {
      writer.uint32(26).string(message.streaming_url);
    }
    if (message.is_streaming !== false) {
      writer.uint32(32).bool(message.is_streaming);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamingChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.streaming_url = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.is_streaming = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingChannelResponse {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      streaming_url: isSet(object.streaming_url) ? globalThis.String(object.streaming_url) : "",
      is_streaming: isSet(object.is_streaming) ? globalThis.Boolean(object.is_streaming) : false,
    };
  },

  toJSON(message: StreamingChannelResponse): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.streaming_url !== "") {
      obj.streaming_url = message.streaming_url;
    }
    if (message.is_streaming !== false) {
      obj.is_streaming = message.is_streaming;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamingChannelResponse>, I>>(base?: I): StreamingChannelResponse {
    return StreamingChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamingChannelResponse>, I>>(object: I): StreamingChannelResponse {
    const message = createBaseStreamingChannelResponse();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.streaming_url = object.streaming_url ?? "";
    message.is_streaming = object.is_streaming ?? false;
    return message;
  },
};

function createBaseGiveCoffeeEvent(): GiveCoffeeEvent {
  return { sender_id: "", receiver_id: "", token_count: 0, message_ref_id: "", channel_id: "", clan_id: "" };
}

export const GiveCoffeeEvent = {
  encode(message: GiveCoffeeEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender_id !== "") {
      writer.uint32(10).string(message.sender_id);
    }
    if (message.receiver_id !== "") {
      writer.uint32(18).string(message.receiver_id);
    }
    if (message.token_count !== 0) {
      writer.uint32(24).int32(message.token_count);
    }
    if (message.message_ref_id !== "") {
      writer.uint32(34).string(message.message_ref_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(50).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GiveCoffeeEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGiveCoffeeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.receiver_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.token_count = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message_ref_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GiveCoffeeEvent {
    return {
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      receiver_id: isSet(object.receiver_id) ? globalThis.String(object.receiver_id) : "",
      token_count: isSet(object.token_count) ? globalThis.Number(object.token_count) : 0,
      message_ref_id: isSet(object.message_ref_id) ? globalThis.String(object.message_ref_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: GiveCoffeeEvent): unknown {
    const obj: any = {};
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.receiver_id !== "") {
      obj.receiver_id = message.receiver_id;
    }
    if (message.token_count !== 0) {
      obj.token_count = Math.round(message.token_count);
    }
    if (message.message_ref_id !== "") {
      obj.message_ref_id = message.message_ref_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GiveCoffeeEvent>, I>>(base?: I): GiveCoffeeEvent {
    return GiveCoffeeEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GiveCoffeeEvent>, I>>(object: I): GiveCoffeeEvent {
    const message = createBaseGiveCoffeeEvent();
    message.sender_id = object.sender_id ?? "";
    message.receiver_id = object.receiver_id ?? "";
    message.token_count = object.token_count ?? 0;
    message.message_ref_id = object.message_ref_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseListChannelAppsRequest(): ListChannelAppsRequest {
  return { clan_id: "" };
}

export const ListChannelAppsRequest = {
  encode(message: ListChannelAppsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelAppsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelAppsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelAppsRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ListChannelAppsRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelAppsRequest>, I>>(base?: I): ListChannelAppsRequest {
    return ListChannelAppsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelAppsRequest>, I>>(object: I): ListChannelAppsRequest {
    const message = createBaseListChannelAppsRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseListChannelAppsResponse(): ListChannelAppsResponse {
  return { channel_apps: [] };
}

export const ListChannelAppsResponse = {
  encode(message: ListChannelAppsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.channel_apps) {
      ChannelAppResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListChannelAppsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelAppsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_apps.push(ChannelAppResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelAppsResponse {
    return {
      channel_apps: globalThis.Array.isArray(object?.channel_apps)
        ? object.channel_apps.map((e: any) => ChannelAppResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListChannelAppsResponse): unknown {
    const obj: any = {};
    if (message.channel_apps?.length) {
      obj.channel_apps = message.channel_apps.map((e) => ChannelAppResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListChannelAppsResponse>, I>>(base?: I): ListChannelAppsResponse {
    return ListChannelAppsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChannelAppsResponse>, I>>(object: I): ListChannelAppsResponse {
    const message = createBaseListChannelAppsResponse();
    message.channel_apps = object.channel_apps?.map((e) => ChannelAppResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannelAppResponse(): ChannelAppResponse {
  return { id: "", clan_id: "", channel_id: "", app_id: "", url: "" };
}

export const ChannelAppResponse = {
  encode(message: ChannelAppResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.app_id !== "") {
      writer.uint32(34).string(message.app_id);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelAppResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelAppResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.app_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelAppResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      app_id: isSet(object.app_id) ? globalThis.String(object.app_id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: ChannelAppResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.app_id !== "") {
      obj.app_id = message.app_id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelAppResponse>, I>>(base?: I): ChannelAppResponse {
    return ChannelAppResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelAppResponse>, I>>(object: I): ChannelAppResponse {
    const message = createBaseChannelAppResponse();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.app_id = object.app_id ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseAllUserClans(): AllUserClans {
  return { users: [] };
}

export const AllUserClans = {
  encode(message: AllUserClans, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllUserClans {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUserClans();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUserClans {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: AllUserClans): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUserClans>, I>>(base?: I): AllUserClans {
    return AllUserClans.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUserClans>, I>>(object: I): AllUserClans {
    const message = createBaseAllUserClans();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoleListEventRequest(): RoleListEventRequest {
  return { clan_id: "", limit: "", state: "", cursor: "" };
}

export const RoleListEventRequest = {
  encode(message: RoleListEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.limit !== "") {
      writer.uint32(18).string(message.limit);
    }
    if (message.state !== "") {
      writer.uint32(26).string(message.state);
    }
    if (message.cursor !== "") {
      writer.uint32(34).string(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleListEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleListEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.state = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleListEventRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
    };
  },

  toJSON(message: RoleListEventRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.limit !== "") {
      obj.limit = message.limit;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoleListEventRequest>, I>>(base?: I): RoleListEventRequest {
    return RoleListEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoleListEventRequest>, I>>(object: I): RoleListEventRequest {
    const message = createBaseRoleListEventRequest();
    message.clan_id = object.clan_id ?? "";
    message.limit = object.limit ?? "";
    message.state = object.state ?? "";
    message.cursor = object.cursor ?? "";
    return message;
  },
};

function createBaseRoleListEventResponse(): RoleListEventResponse {
  return { limit: "", state: "", cursor: "", clanId: "", roles: undefined };
}

export const RoleListEventResponse = {
  encode(message: RoleListEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== "") {
      writer.uint32(10).string(message.limit);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    if (message.cursor !== "") {
      writer.uint32(26).string(message.cursor);
    }
    if (message.clanId !== "") {
      writer.uint32(34).string(message.clanId);
    }
    if (message.roles !== undefined) {
      RoleList.encode(message.roles, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleListEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleListEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clanId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.roles = RoleList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleListEventResponse {
    return {
      limit: isSet(object.limit) ? globalThis.String(object.limit) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      clanId: isSet(object.clanId) ? globalThis.String(object.clanId) : "",
      roles: isSet(object.roles) ? RoleList.fromJSON(object.roles) : undefined,
    };
  },

  toJSON(message: RoleListEventResponse): unknown {
    const obj: any = {};
    if (message.limit !== "") {
      obj.limit = message.limit;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.clanId !== "") {
      obj.clanId = message.clanId;
    }
    if (message.roles !== undefined) {
      obj.roles = RoleList.toJSON(message.roles);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoleListEventResponse>, I>>(base?: I): RoleListEventResponse {
    return RoleListEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoleListEventResponse>, I>>(object: I): RoleListEventResponse {
    const message = createBaseRoleListEventResponse();
    message.limit = object.limit ?? "";
    message.state = object.state ?? "";
    message.cursor = object.cursor ?? "";
    message.clanId = object.clanId ?? "";
    message.roles = (object.roles !== undefined && object.roles !== null)
      ? RoleList.fromPartial(object.roles)
      : undefined;
    return message;
  },
};

function createBaseUserPermissionInChannelListRequest(): UserPermissionInChannelListRequest {
  return { clan_id: "", channel_id: "" };
}

export const UserPermissionInChannelListRequest = {
  encode(message: UserPermissionInChannelListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserPermissionInChannelListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPermissionInChannelListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPermissionInChannelListRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: UserPermissionInChannelListRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPermissionInChannelListRequest>, I>>(
    base?: I,
  ): UserPermissionInChannelListRequest {
    return UserPermissionInChannelListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPermissionInChannelListRequest>, I>>(
    object: I,
  ): UserPermissionInChannelListRequest {
    const message = createBaseUserPermissionInChannelListRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseUserPermissionInChannelListResponse(): UserPermissionInChannelListResponse {
  return { clan_id: "", channel_id: "", permissions: undefined };
}

export const UserPermissionInChannelListResponse = {
  encode(message: UserPermissionInChannelListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.permissions !== undefined) {
      PermissionList.encode(message.permissions, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserPermissionInChannelListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPermissionInChannelListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.permissions = PermissionList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPermissionInChannelListResponse {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      permissions: isSet(object.permissions) ? PermissionList.fromJSON(object.permissions) : undefined,
    };
  },

  toJSON(message: UserPermissionInChannelListResponse): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.permissions !== undefined) {
      obj.permissions = PermissionList.toJSON(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPermissionInChannelListResponse>, I>>(
    base?: I,
  ): UserPermissionInChannelListResponse {
    return UserPermissionInChannelListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPermissionInChannelListResponse>, I>>(
    object: I,
  ): UserPermissionInChannelListResponse {
    const message = createBaseUserPermissionInChannelListResponse();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.permissions = (object.permissions !== undefined && object.permissions !== null)
      ? PermissionList.fromPartial(object.permissions)
      : undefined;
    return message;
  },
};

function createBasePermissionRoleChannel(): PermissionRoleChannel {
  return { permission_id: "", active: false };
}

export const PermissionRoleChannel = {
  encode(message: PermissionRoleChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permission_id !== "") {
      writer.uint32(10).string(message.permission_id);
    }
    if (message.active !== false) {
      writer.uint32(16).bool(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionRoleChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionRoleChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permission_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.active = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionRoleChannel {
    return {
      permission_id: isSet(object.permission_id) ? globalThis.String(object.permission_id) : "",
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
    };
  },

  toJSON(message: PermissionRoleChannel): unknown {
    const obj: any = {};
    if (message.permission_id !== "") {
      obj.permission_id = message.permission_id;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionRoleChannel>, I>>(base?: I): PermissionRoleChannel {
    return PermissionRoleChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionRoleChannel>, I>>(object: I): PermissionRoleChannel {
    const message = createBasePermissionRoleChannel();
    message.permission_id = object.permission_id ?? "";
    message.active = object.active ?? false;
    return message;
  },
};

function createBasePermissionRoleChannelListEventRequest(): PermissionRoleChannelListEventRequest {
  return { role_id: "", channel_id: "", user_id: "" };
}

export const PermissionRoleChannelListEventRequest = {
  encode(message: PermissionRoleChannelListEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.user_id !== "") {
      writer.uint32(34).string(message.user_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionRoleChannelListEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionRoleChannelListEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionRoleChannelListEventRequest {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
    };
  },

  toJSON(message: PermissionRoleChannelListEventRequest): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionRoleChannelListEventRequest>, I>>(
    base?: I,
  ): PermissionRoleChannelListEventRequest {
    return PermissionRoleChannelListEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionRoleChannelListEventRequest>, I>>(
    object: I,
  ): PermissionRoleChannelListEventRequest {
    const message = createBasePermissionRoleChannelListEventRequest();
    message.role_id = object.role_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.user_id = object.user_id ?? "";
    return message;
  },
};

function createBasePermissionRoleChannelListEventResponse(): PermissionRoleChannelListEventResponse {
  return { role_id: "", channel_id: "", user_id: "", permission_role_channel: [] };
}

export const PermissionRoleChannelListEventResponse = {
  encode(message: PermissionRoleChannelListEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.user_id !== "") {
      writer.uint32(26).string(message.user_id);
    }
    for (const v of message.permission_role_channel) {
      PermissionRoleChannel.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionRoleChannelListEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionRoleChannelListEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.permission_role_channel.push(PermissionRoleChannel.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionRoleChannelListEventResponse {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      permission_role_channel: globalThis.Array.isArray(object?.permission_role_channel)
        ? object.permission_role_channel.map((e: any) => PermissionRoleChannel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PermissionRoleChannelListEventResponse): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.permission_role_channel?.length) {
      obj.permission_role_channel = message.permission_role_channel.map((e) => PermissionRoleChannel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionRoleChannelListEventResponse>, I>>(
    base?: I,
  ): PermissionRoleChannelListEventResponse {
    return PermissionRoleChannelListEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionRoleChannelListEventResponse>, I>>(
    object: I,
  ): PermissionRoleChannelListEventResponse {
    const message = createBasePermissionRoleChannelListEventResponse();
    message.role_id = object.role_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.user_id = object.user_id ?? "";
    message.permission_role_channel =
      object.permission_role_channel?.map((e) => PermissionRoleChannel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannelSettingListRequest(): ChannelSettingListRequest {
  return {
    clan_id: "",
    parent_id: "",
    category_id: "",
    privateChannel: undefined,
    active: undefined,
    status: undefined,
    type: undefined,
    limit: undefined,
    page: undefined,
    channel_label: "",
  };
}

export const ChannelSettingListRequest = {
  encode(message: ChannelSettingListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.parent_id !== "") {
      writer.uint32(18).string(message.parent_id);
    }
    if (message.category_id !== "") {
      writer.uint32(26).string(message.category_id);
    }
    if (message.privateChannel !== undefined) {
      Int32Value.encode({ value: message.privateChannel! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.active !== undefined) {
      Int32Value.encode({ value: message.active! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.status !== undefined) {
      Int32Value.encode({ value: message.status! }, writer.uint32(50).fork()).ldelim();
    }
    if (message.type !== undefined) {
      Int32Value.encode({ value: message.type! }, writer.uint32(58).fork()).ldelim();
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(66).fork()).ldelim();
    }
    if (message.page !== undefined) {
      Int32Value.encode({ value: message.page! }, writer.uint32(74).fork()).ldelim();
    }
    if (message.channel_label !== "") {
      writer.uint32(82).string(message.channel_label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelSettingListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelSettingListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.privateChannel = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.active = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.status = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.page = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.channel_label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelSettingListRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      parent_id: isSet(object.parent_id) ? globalThis.String(object.parent_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      privateChannel: isSet(object.privateChannel) ? Number(object.privateChannel) : undefined,
      active: isSet(object.active) ? Number(object.active) : undefined,
      status: isSet(object.status) ? Number(object.status) : undefined,
      type: isSet(object.type) ? Number(object.type) : undefined,
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      page: isSet(object.page) ? Number(object.page) : undefined,
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
    };
  },

  toJSON(message: ChannelSettingListRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.parent_id !== "") {
      obj.parent_id = message.parent_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.privateChannel !== undefined) {
      obj.privateChannel = message.privateChannel;
    }
    if (message.active !== undefined) {
      obj.active = message.active;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.page !== undefined) {
      obj.page = message.page;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelSettingListRequest>, I>>(base?: I): ChannelSettingListRequest {
    return ChannelSettingListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelSettingListRequest>, I>>(object: I): ChannelSettingListRequest {
    const message = createBaseChannelSettingListRequest();
    message.clan_id = object.clan_id ?? "";
    message.parent_id = object.parent_id ?? "";
    message.category_id = object.category_id ?? "";
    message.privateChannel = object.privateChannel ?? undefined;
    message.active = object.active ?? undefined;
    message.status = object.status ?? undefined;
    message.type = object.type ?? undefined;
    message.limit = object.limit ?? undefined;
    message.page = object.page ?? undefined;
    message.channel_label = object.channel_label ?? "";
    return message;
  },
};

function createBaseChannelSettingItem(): ChannelSettingItem {
  return {
    id: "",
    creator_id: "",
    parent_id: "",
    channel_label: "",
    category_id: "",
    meeting_code: "",
    channel_private: 0,
    channel_type: 0,
    active: 0,
    user_ids: [],
    message_count: 0,
    last_sent_message: undefined,
  };
}

export const ChannelSettingItem = {
  encode(message: ChannelSettingItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creator_id !== "") {
      writer.uint32(18).string(message.creator_id);
    }
    if (message.parent_id !== "") {
      writer.uint32(26).string(message.parent_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(34).string(message.channel_label);
    }
    if (message.category_id !== "") {
      writer.uint32(42).string(message.category_id);
    }
    if (message.meeting_code !== "") {
      writer.uint32(50).string(message.meeting_code);
    }
    if (message.channel_private !== 0) {
      writer.uint32(56).int32(message.channel_private);
    }
    if (message.channel_type !== 0) {
      writer.uint32(64).int32(message.channel_type);
    }
    if (message.active !== 0) {
      writer.uint32(72).int32(message.active);
    }
    for (const v of message.user_ids) {
      writer.uint32(82).string(v!);
    }
    if (message.message_count !== 0) {
      writer.uint32(88).int64(message.message_count);
    }
    if (message.last_sent_message !== undefined) {
      ChannelMessageHeader.encode(message.last_sent_message, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelSettingItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelSettingItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.message_count = longToNumber(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.last_sent_message = ChannelMessageHeader.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelSettingItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      parent_id: isSet(object.parent_id) ? globalThis.String(object.parent_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      message_count: isSet(object.message_count) ? globalThis.Number(object.message_count) : 0,
      last_sent_message: isSet(object.last_sent_message)
        ? ChannelMessageHeader.fromJSON(object.last_sent_message)
        : undefined,
    };
  },

  toJSON(message: ChannelSettingItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.parent_id !== "") {
      obj.parent_id = message.parent_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.message_count !== 0) {
      obj.message_count = Math.round(message.message_count);
    }
    if (message.last_sent_message !== undefined) {
      obj.last_sent_message = ChannelMessageHeader.toJSON(message.last_sent_message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelSettingItem>, I>>(base?: I): ChannelSettingItem {
    return ChannelSettingItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelSettingItem>, I>>(object: I): ChannelSettingItem {
    const message = createBaseChannelSettingItem();
    message.id = object.id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.parent_id = object.parent_id ?? "";
    message.channel_label = object.channel_label ?? "";
    message.category_id = object.category_id ?? "";
    message.meeting_code = object.meeting_code ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.channel_type = object.channel_type ?? 0;
    message.active = object.active ?? 0;
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.message_count = object.message_count ?? 0;
    message.last_sent_message = (object.last_sent_message !== undefined && object.last_sent_message !== null)
      ? ChannelMessageHeader.fromPartial(object.last_sent_message)
      : undefined;
    return message;
  },
};

function createBaseChannelSettingListResponse(): ChannelSettingListResponse {
  return { clan_id: "", channel_count: 0, thread_count: 0, channel_setting_list: [] };
}

export const ChannelSettingListResponse = {
  encode(message: ChannelSettingListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_count !== 0) {
      writer.uint32(16).int32(message.channel_count);
    }
    if (message.thread_count !== 0) {
      writer.uint32(24).int32(message.thread_count);
    }
    for (const v of message.channel_setting_list) {
      ChannelSettingItem.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelSettingListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelSettingListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel_count = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.thread_count = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_setting_list.push(ChannelSettingItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelSettingListResponse {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_count: isSet(object.channel_count) ? globalThis.Number(object.channel_count) : 0,
      thread_count: isSet(object.thread_count) ? globalThis.Number(object.thread_count) : 0,
      channel_setting_list: globalThis.Array.isArray(object?.channel_setting_list)
        ? object.channel_setting_list.map((e: any) => ChannelSettingItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChannelSettingListResponse): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_count !== 0) {
      obj.channel_count = Math.round(message.channel_count);
    }
    if (message.thread_count !== 0) {
      obj.thread_count = Math.round(message.thread_count);
    }
    if (message.channel_setting_list?.length) {
      obj.channel_setting_list = message.channel_setting_list.map((e) => ChannelSettingItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelSettingListResponse>, I>>(base?: I): ChannelSettingListResponse {
    return ChannelSettingListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelSettingListResponse>, I>>(object: I): ChannelSettingListResponse {
    const message = createBaseChannelSettingListResponse();
    message.clan_id = object.clan_id ?? "";
    message.channel_count = object.channel_count ?? 0;
    message.thread_count = object.thread_count ?? 0;
    message.channel_setting_list = object.channel_setting_list?.map((e) => ChannelSettingItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarkAsReadRequest(): MarkAsReadRequest {
  return { channel_id: "", category_id: "", clan_id: "" };
}

export const MarkAsReadRequest = {
  encode(message: MarkAsReadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.category_id !== "") {
      writer.uint32(18).string(message.category_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarkAsReadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkAsReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkAsReadRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: MarkAsReadRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkAsReadRequest>, I>>(base?: I): MarkAsReadRequest {
    return MarkAsReadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkAsReadRequest>, I>>(object: I): MarkAsReadRequest {
    const message = createBaseMarkAsReadRequest();
    message.channel_id = object.channel_id ?? "";
    message.category_id = object.category_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseEditChannelCanvasRequest(): EditChannelCanvasRequest {
  return { id: undefined, channel_id: "", clan_id: "", title: "", content: "", is_default: false };
}

export const EditChannelCanvasRequest = {
  encode(message: EditChannelCanvasRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      StringValue.encode({ value: message.id! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(42).string(message.content);
    }
    if (message.is_default !== false) {
      writer.uint32(48).bool(message.is_default);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EditChannelCanvasRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditChannelCanvasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.is_default = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditChannelCanvasRequest {
    return {
      id: isSet(object.id) ? String(object.id) : undefined,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      is_default: isSet(object.is_default) ? globalThis.Boolean(object.is_default) : false,
    };
  },

  toJSON(message: EditChannelCanvasRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.is_default !== false) {
      obj.is_default = message.is_default;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditChannelCanvasRequest>, I>>(base?: I): EditChannelCanvasRequest {
    return EditChannelCanvasRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditChannelCanvasRequest>, I>>(object: I): EditChannelCanvasRequest {
    const message = createBaseEditChannelCanvasRequest();
    message.id = object.id ?? undefined;
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.is_default = object.is_default ?? false;
    return message;
  },
};

function createBaseEditChannelCanvasResponse(): EditChannelCanvasResponse {
  return { id: "" };
}

export const EditChannelCanvasResponse = {
  encode(message: EditChannelCanvasResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EditChannelCanvasResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditChannelCanvasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditChannelCanvasResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: EditChannelCanvasResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EditChannelCanvasResponse>, I>>(base?: I): EditChannelCanvasResponse {
    return EditChannelCanvasResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EditChannelCanvasResponse>, I>>(object: I): EditChannelCanvasResponse {
    const message = createBaseEditChannelCanvasResponse();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteChannelCanvasRequest(): DeleteChannelCanvasRequest {
  return { clan_id: "", channel_id: "", canvas_id: "" };
}

export const DeleteChannelCanvasRequest = {
  encode(message: DeleteChannelCanvasRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.canvas_id !== "") {
      writer.uint32(26).string(message.canvas_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteChannelCanvasRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChannelCanvasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.canvas_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChannelCanvasRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      canvas_id: isSet(object.canvas_id) ? globalThis.String(object.canvas_id) : "",
    };
  },

  toJSON(message: DeleteChannelCanvasRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.canvas_id !== "") {
      obj.canvas_id = message.canvas_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChannelCanvasRequest>, I>>(base?: I): DeleteChannelCanvasRequest {
    return DeleteChannelCanvasRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChannelCanvasRequest>, I>>(object: I): DeleteChannelCanvasRequest {
    const message = createBaseDeleteChannelCanvasRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.canvas_id = object.canvas_id ?? "";
    return message;
  },
};

function createBaseChannelCanvasListRequest(): ChannelCanvasListRequest {
  return { clan_id: "", channel_id: "", limit: undefined, page: undefined };
}

export const ChannelCanvasListRequest = {
  encode(message: ChannelCanvasListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.page !== undefined) {
      Int32Value.encode({ value: message.page! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelCanvasListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelCanvasListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.page = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelCanvasListRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      page: isSet(object.page) ? Number(object.page) : undefined,
    };
  },

  toJSON(message: ChannelCanvasListRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.page !== undefined) {
      obj.page = message.page;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelCanvasListRequest>, I>>(base?: I): ChannelCanvasListRequest {
    return ChannelCanvasListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelCanvasListRequest>, I>>(object: I): ChannelCanvasListRequest {
    const message = createBaseChannelCanvasListRequest();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.limit = object.limit ?? undefined;
    message.page = object.page ?? undefined;
    return message;
  },
};

function createBaseChannelCanvasItem(): ChannelCanvasItem {
  return { id: "", title: "", is_default: false, content: "", creator_id: "" };
}

export const ChannelCanvasItem = {
  encode(message: ChannelCanvasItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.is_default !== false) {
      writer.uint32(24).bool(message.is_default);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.creator_id !== "") {
      writer.uint32(42).string(message.creator_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelCanvasItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelCanvasItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.is_default = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelCanvasItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      is_default: isSet(object.is_default) ? globalThis.Boolean(object.is_default) : false,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
    };
  },

  toJSON(message: ChannelCanvasItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.is_default !== false) {
      obj.is_default = message.is_default;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelCanvasItem>, I>>(base?: I): ChannelCanvasItem {
    return ChannelCanvasItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelCanvasItem>, I>>(object: I): ChannelCanvasItem {
    const message = createBaseChannelCanvasItem();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.is_default = object.is_default ?? false;
    message.content = object.content ?? "";
    message.creator_id = object.creator_id ?? "";
    return message;
  },
};

function createBaseChannelCanvasListResponse(): ChannelCanvasListResponse {
  return { clan_id: "", channel_id: "", channel_canvases: [] };
}

export const ChannelCanvasListResponse = {
  encode(message: ChannelCanvasListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    for (const v of message.channel_canvases) {
      ChannelCanvasItem.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelCanvasListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelCanvasListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_canvases.push(ChannelCanvasItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelCanvasListResponse {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_canvases: globalThis.Array.isArray(object?.channel_canvases)
        ? object.channel_canvases.map((e: any) => ChannelCanvasItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChannelCanvasListResponse): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_canvases?.length) {
      obj.channel_canvases = message.channel_canvases.map((e) => ChannelCanvasItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelCanvasListResponse>, I>>(base?: I): ChannelCanvasListResponse {
    return ChannelCanvasListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelCanvasListResponse>, I>>(object: I): ChannelCanvasListResponse {
    const message = createBaseChannelCanvasListResponse();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_canvases = object.channel_canvases?.map((e) => ChannelCanvasItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannelCanvasDetailRequest(): ChannelCanvasDetailRequest {
  return { id: "", clan_id: "", channel_id: "" };
}

export const ChannelCanvasDetailRequest = {
  encode(message: ChannelCanvasDetailRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelCanvasDetailRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelCanvasDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelCanvasDetailRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: ChannelCanvasDetailRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelCanvasDetailRequest>, I>>(base?: I): ChannelCanvasDetailRequest {
    return ChannelCanvasDetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelCanvasDetailRequest>, I>>(object: I): ChannelCanvasDetailRequest {
    const message = createBaseChannelCanvasDetailRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseChannelCanvasDetailResponse(): ChannelCanvasDetailResponse {
  return { id: "", title: "", content: "", creator_id: "", editor_id: "", is_default: false };
}

export const ChannelCanvasDetailResponse = {
  encode(message: ChannelCanvasDetailResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.creator_id !== "") {
      writer.uint32(34).string(message.creator_id);
    }
    if (message.editor_id !== "") {
      writer.uint32(42).string(message.editor_id);
    }
    if (message.is_default !== false) {
      writer.uint32(48).bool(message.is_default);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelCanvasDetailResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelCanvasDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.editor_id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.is_default = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelCanvasDetailResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      editor_id: isSet(object.editor_id) ? globalThis.String(object.editor_id) : "",
      is_default: isSet(object.is_default) ? globalThis.Boolean(object.is_default) : false,
    };
  },

  toJSON(message: ChannelCanvasDetailResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.editor_id !== "") {
      obj.editor_id = message.editor_id;
    }
    if (message.is_default !== false) {
      obj.is_default = message.is_default;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelCanvasDetailResponse>, I>>(base?: I): ChannelCanvasDetailResponse {
    return ChannelCanvasDetailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelCanvasDetailResponse>, I>>(object: I): ChannelCanvasDetailResponse {
    const message = createBaseChannelCanvasDetailResponse();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.creator_id = object.creator_id ?? "";
    message.editor_id = object.editor_id ?? "";
    message.is_default = object.is_default ?? false;
    return message;
  },
};

function createBaseAddFavoriteChannelRequest(): AddFavoriteChannelRequest {
  return { channel_id: "", clan_id: "" };
}

export const AddFavoriteChannelRequest = {
  encode(message: AddFavoriteChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddFavoriteChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFavoriteChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFavoriteChannelRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: AddFavoriteChannelRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFavoriteChannelRequest>, I>>(base?: I): AddFavoriteChannelRequest {
    return AddFavoriteChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddFavoriteChannelRequest>, I>>(object: I): AddFavoriteChannelRequest {
    const message = createBaseAddFavoriteChannelRequest();
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseRemoveFavoriteChannelRequest(): RemoveFavoriteChannelRequest {
  return { channel_id: "" };
}

export const RemoveFavoriteChannelRequest = {
  encode(message: RemoveFavoriteChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveFavoriteChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFavoriteChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFavoriteChannelRequest {
    return { channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "" };
  },

  toJSON(message: RemoveFavoriteChannelRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFavoriteChannelRequest>, I>>(base?: I): RemoveFavoriteChannelRequest {
    return RemoveFavoriteChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFavoriteChannelRequest>, I>>(object: I): RemoveFavoriteChannelRequest {
    const message = createBaseRemoveFavoriteChannelRequest();
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseAddFavoriteChannelResponse(): AddFavoriteChannelResponse {
  return { channel_id: "" };
}

export const AddFavoriteChannelResponse = {
  encode(message: AddFavoriteChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddFavoriteChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFavoriteChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFavoriteChannelResponse {
    return { channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "" };
  },

  toJSON(message: AddFavoriteChannelResponse): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFavoriteChannelResponse>, I>>(base?: I): AddFavoriteChannelResponse {
    return AddFavoriteChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddFavoriteChannelResponse>, I>>(object: I): AddFavoriteChannelResponse {
    const message = createBaseAddFavoriteChannelResponse();
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseListFavoriteChannelRequest(): ListFavoriteChannelRequest {
  return { clan_id: "" };
}

export const ListFavoriteChannelRequest = {
  encode(message: ListFavoriteChannelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFavoriteChannelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFavoriteChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFavoriteChannelRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ListFavoriteChannelRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFavoriteChannelRequest>, I>>(base?: I): ListFavoriteChannelRequest {
    return ListFavoriteChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFavoriteChannelRequest>, I>>(object: I): ListFavoriteChannelRequest {
    const message = createBaseListFavoriteChannelRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseListFavoriteChannelResponse(): ListFavoriteChannelResponse {
  return { channel_ids: [] };
}

export const ListFavoriteChannelResponse = {
  encode(message: ListFavoriteChannelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.channel_ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFavoriteChannelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFavoriteChannelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFavoriteChannelResponse {
    return {
      channel_ids: globalThis.Array.isArray(object?.channel_ids)
        ? object.channel_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListFavoriteChannelResponse): unknown {
    const obj: any = {};
    if (message.channel_ids?.length) {
      obj.channel_ids = message.channel_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFavoriteChannelResponse>, I>>(base?: I): ListFavoriteChannelResponse {
    return ListFavoriteChannelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFavoriteChannelResponse>, I>>(object: I): ListFavoriteChannelResponse {
    const message = createBaseListFavoriteChannelResponse();
    message.channel_ids = object.channel_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserActivity(): UserActivity {
  return {
    user_id: "",
    activity_name: "",
    activity_type: 0,
    activity_description: "",
    start_time: undefined,
    end_time: undefined,
    application_id: "",
    status: 0,
  };
}

export const UserActivity = {
  encode(message: UserActivity, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.activity_name !== "") {
      writer.uint32(18).string(message.activity_name);
    }
    if (message.activity_type !== 0) {
      writer.uint32(24).int32(message.activity_type);
    }
    if (message.activity_description !== "") {
      writer.uint32(34).string(message.activity_description);
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(42).fork()).ldelim();
    }
    if (message.end_time !== undefined) {
      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.application_id !== "") {
      writer.uint32(58).string(message.application_id);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserActivity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.activity_name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.activity_type = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.activity_description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.application_id = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserActivity {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      activity_name: isSet(object.activity_name) ? globalThis.String(object.activity_name) : "",
      activity_type: isSet(object.activity_type) ? globalThis.Number(object.activity_type) : 0,
      activity_description: isSet(object.activity_description) ? globalThis.String(object.activity_description) : "",
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      end_time: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,
      application_id: isSet(object.application_id) ? globalThis.String(object.application_id) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: UserActivity): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.activity_name !== "") {
      obj.activity_name = message.activity_name;
    }
    if (message.activity_type !== 0) {
      obj.activity_type = Math.round(message.activity_type);
    }
    if (message.activity_description !== "") {
      obj.activity_description = message.activity_description;
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.end_time !== undefined) {
      obj.end_time = message.end_time.toISOString();
    }
    if (message.application_id !== "") {
      obj.application_id = message.application_id;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserActivity>, I>>(base?: I): UserActivity {
    return UserActivity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserActivity>, I>>(object: I): UserActivity {
    const message = createBaseUserActivity();
    message.user_id = object.user_id ?? "";
    message.activity_name = object.activity_name ?? "";
    message.activity_type = object.activity_type ?? 0;
    message.activity_description = object.activity_description ?? "";
    message.start_time = object.start_time ?? undefined;
    message.end_time = object.end_time ?? undefined;
    message.application_id = object.application_id ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseListUserActivity(): ListUserActivity {
  return { activities: [] };
}

export const ListUserActivity = {
  encode(message: ListUserActivity, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.activities) {
      UserActivity.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserActivity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.activities.push(UserActivity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserActivity {
    return {
      activities: globalThis.Array.isArray(object?.activities)
        ? object.activities.map((e: any) => UserActivity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListUserActivity): unknown {
    const obj: any = {};
    if (message.activities?.length) {
      obj.activities = message.activities.map((e) => UserActivity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserActivity>, I>>(base?: I): ListUserActivity {
    return ListUserActivity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserActivity>, I>>(object: I): ListUserActivity {
    const message = createBaseListUserActivity();
    message.activities = object.activities?.map((e) => UserActivity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateActivityRequest(): CreateActivityRequest {
  return {
    activity_name: "",
    activity_type: 0,
    activity_description: "",
    start_time: undefined,
    application_id: "",
    status: 0,
  };
}

export const CreateActivityRequest = {
  encode(message: CreateActivityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.activity_name !== "") {
      writer.uint32(10).string(message.activity_name);
    }
    if (message.activity_type !== 0) {
      writer.uint32(16).int32(message.activity_type);
    }
    if (message.activity_description !== "") {
      writer.uint32(26).string(message.activity_description);
    }
    if (message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(34).fork()).ldelim();
    }
    if (message.application_id !== "") {
      writer.uint32(42).string(message.application_id);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateActivityRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateActivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.activity_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.activity_type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.activity_description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.application_id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateActivityRequest {
    return {
      activity_name: isSet(object.activity_name) ? globalThis.String(object.activity_name) : "",
      activity_type: isSet(object.activity_type) ? globalThis.Number(object.activity_type) : 0,
      activity_description: isSet(object.activity_description) ? globalThis.String(object.activity_description) : "",
      start_time: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      application_id: isSet(object.application_id) ? globalThis.String(object.application_id) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: CreateActivityRequest): unknown {
    const obj: any = {};
    if (message.activity_name !== "") {
      obj.activity_name = message.activity_name;
    }
    if (message.activity_type !== 0) {
      obj.activity_type = Math.round(message.activity_type);
    }
    if (message.activity_description !== "") {
      obj.activity_description = message.activity_description;
    }
    if (message.start_time !== undefined) {
      obj.start_time = message.start_time.toISOString();
    }
    if (message.application_id !== "") {
      obj.application_id = message.application_id;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateActivityRequest>, I>>(base?: I): CreateActivityRequest {
    return CreateActivityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateActivityRequest>, I>>(object: I): CreateActivityRequest {
    const message = createBaseCreateActivityRequest();
    message.activity_name = object.activity_name ?? "";
    message.activity_type = object.activity_type ?? 0;
    message.activity_description = object.activity_description ?? "";
    message.start_time = object.start_time ?? undefined;
    message.application_id = object.application_id ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseLoginIDResponse(): LoginIDResponse {
  return { login_id: "", status: 0, create_time_second: 0, platform: "", user_id: 0, user_name: "", address: "" };
}

export const LoginIDResponse = {
  encode(message: LoginIDResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.login_id !== "") {
      writer.uint32(10).string(message.login_id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.create_time_second !== 0) {
      writer.uint32(24).int64(message.create_time_second);
    }
    if (message.platform !== "") {
      writer.uint32(34).string(message.platform);
    }
    if (message.user_id !== 0) {
      writer.uint32(40).int64(message.user_id);
    }
    if (message.user_name !== "") {
      writer.uint32(50).string(message.user_name);
    }
    if (message.address !== "") {
      writer.uint32(58).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.login_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.create_time_second = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.user_id = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.user_name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginIDResponse {
    return {
      login_id: isSet(object.login_id) ? globalThis.String(object.login_id) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      create_time_second: isSet(object.create_time_second) ? globalThis.Number(object.create_time_second) : 0,
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      user_id: isSet(object.user_id) ? globalThis.Number(object.user_id) : 0,
      user_name: isSet(object.user_name) ? globalThis.String(object.user_name) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: LoginIDResponse): unknown {
    const obj: any = {};
    if (message.login_id !== "") {
      obj.login_id = message.login_id;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.create_time_second !== 0) {
      obj.create_time_second = Math.round(message.create_time_second);
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.user_id !== 0) {
      obj.user_id = Math.round(message.user_id);
    }
    if (message.user_name !== "") {
      obj.user_name = message.user_name;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginIDResponse>, I>>(base?: I): LoginIDResponse {
    return LoginIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginIDResponse>, I>>(object: I): LoginIDResponse {
    const message = createBaseLoginIDResponse();
    message.login_id = object.login_id ?? "";
    message.status = object.status ?? 0;
    message.create_time_second = object.create_time_second ?? 0;
    message.platform = object.platform ?? "";
    message.user_id = object.user_id ?? 0;
    message.user_name = object.user_name ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { platform: "", address: "" };
}

export const LoginRequest = {
  encode(message: LoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.platform !== "") {
      writer.uint32(10).string(message.platform);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.platform = object.platform ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseConfirmLoginRequest(): ConfirmLoginRequest {
  return { login_id: "" };
}

export const ConfirmLoginRequest = {
  encode(message: ConfirmLoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.login_id !== "") {
      writer.uint32(10).string(message.login_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmLoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.login_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmLoginRequest {
    return { login_id: isSet(object.login_id) ? globalThis.String(object.login_id) : "" };
  },

  toJSON(message: ConfirmLoginRequest): unknown {
    const obj: any = {};
    if (message.login_id !== "") {
      obj.login_id = message.login_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmLoginRequest>, I>>(base?: I): ConfirmLoginRequest {
    return ConfirmLoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmLoginRequest>, I>>(object: I): ConfirmLoginRequest {
    const message = createBaseConfirmLoginRequest();
    message.login_id = object.login_id ?? "";
    return message;
  },
};

function createBaseSendTokenRequest(): SendTokenRequest {
  return { receiver_id: "", amount: 0 };
}

export const SendTokenRequest = {
  encode(message: SendTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.receiver_id !== "") {
      writer.uint32(10).string(message.receiver_id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int32(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receiver_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendTokenRequest {
    return {
      receiver_id: isSet(object.receiver_id) ? globalThis.String(object.receiver_id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: SendTokenRequest): unknown {
    const obj: any = {};
    if (message.receiver_id !== "") {
      obj.receiver_id = message.receiver_id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendTokenRequest>, I>>(base?: I): SendTokenRequest {
    return SendTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendTokenRequest>, I>>(object: I): SendTokenRequest {
    const message = createBaseSendTokenRequest();
    message.receiver_id = object.receiver_id ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBasePubKey(): PubKey {
  return { encr: new Uint8Array(0), sign: new Uint8Array(0) };
}

export const PubKey = {
  encode(message: PubKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encr.length !== 0) {
      writer.uint32(10).bytes(message.encr);
    }
    if (message.sign.length !== 0) {
      writer.uint32(18).bytes(message.sign);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encr = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sign = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubKey {
    return {
      encr: isSet(object.encr) ? bytesFromBase64(object.encr) : new Uint8Array(0),
      sign: isSet(object.sign) ? bytesFromBase64(object.sign) : new Uint8Array(0),
    };
  },

  toJSON(message: PubKey): unknown {
    const obj: any = {};
    if (message.encr.length !== 0) {
      obj.encr = base64FromBytes(message.encr);
    }
    if (message.sign.length !== 0) {
      obj.sign = base64FromBytes(message.sign);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubKey>, I>>(base?: I): PubKey {
    return PubKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubKey>, I>>(object: I): PubKey {
    const message = createBasePubKey();
    message.encr = object.encr ?? new Uint8Array(0);
    message.sign = object.sign ?? new Uint8Array(0);
    return message;
  },
};

function createBasePushPubKeyRequest(): PushPubKeyRequest {
  return { PK: undefined };
}

export const PushPubKeyRequest = {
  encode(message: PushPubKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.PK !== undefined) {
      PubKey.encode(message.PK, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PushPubKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushPubKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.PK = PubKey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushPubKeyRequest {
    return { PK: isSet(object.PK) ? PubKey.fromJSON(object.PK) : undefined };
  },

  toJSON(message: PushPubKeyRequest): unknown {
    const obj: any = {};
    if (message.PK !== undefined) {
      obj.PK = PubKey.toJSON(message.PK);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PushPubKeyRequest>, I>>(base?: I): PushPubKeyRequest {
    return PushPubKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PushPubKeyRequest>, I>>(object: I): PushPubKeyRequest {
    const message = createBasePushPubKeyRequest();
    message.PK = (object.PK !== undefined && object.PK !== null) ? PubKey.fromPartial(object.PK) : undefined;
    return message;
  },
};

function createBaseGetPubKeysRequest(): GetPubKeysRequest {
  return { user_ids: [] };
}

export const GetPubKeysRequest = {
  encode(message: GetPubKeysRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPubKeysRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPubKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPubKeysRequest {
    return {
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetPubKeysRequest): unknown {
    const obj: any = {};
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPubKeysRequest>, I>>(base?: I): GetPubKeysRequest {
    return GetPubKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPubKeysRequest>, I>>(object: I): GetPubKeysRequest {
    const message = createBaseGetPubKeysRequest();
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPubKeysResponse(): GetPubKeysResponse {
  return { pub_keys: [] };
}

export const GetPubKeysResponse = {
  encode(message: GetPubKeysResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.pub_keys) {
      GetPubKeysResponse_UserPubKey.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPubKeysResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPubKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pub_keys.push(GetPubKeysResponse_UserPubKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPubKeysResponse {
    return {
      pub_keys: globalThis.Array.isArray(object?.pub_keys)
        ? object.pub_keys.map((e: any) => GetPubKeysResponse_UserPubKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPubKeysResponse): unknown {
    const obj: any = {};
    if (message.pub_keys?.length) {
      obj.pub_keys = message.pub_keys.map((e) => GetPubKeysResponse_UserPubKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPubKeysResponse>, I>>(base?: I): GetPubKeysResponse {
    return GetPubKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPubKeysResponse>, I>>(object: I): GetPubKeysResponse {
    const message = createBaseGetPubKeysResponse();
    message.pub_keys = object.pub_keys?.map((e) => GetPubKeysResponse_UserPubKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPubKeysResponse_UserPubKey(): GetPubKeysResponse_UserPubKey {
  return { user_id: "", PK: undefined };
}

export const GetPubKeysResponse_UserPubKey = {
  encode(message: GetPubKeysResponse_UserPubKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.PK !== undefined) {
      PubKey.encode(message.PK, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPubKeysResponse_UserPubKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPubKeysResponse_UserPubKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.PK = PubKey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPubKeysResponse_UserPubKey {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      PK: isSet(object.PK) ? PubKey.fromJSON(object.PK) : undefined,
    };
  },

  toJSON(message: GetPubKeysResponse_UserPubKey): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.PK !== undefined) {
      obj.PK = PubKey.toJSON(message.PK);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPubKeysResponse_UserPubKey>, I>>(base?: I): GetPubKeysResponse_UserPubKey {
    return GetPubKeysResponse_UserPubKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPubKeysResponse_UserPubKey>, I>>(
    object: I,
  ): GetPubKeysResponse_UserPubKey {
    const message = createBaseGetPubKeysResponse_UserPubKey();
    message.user_id = object.user_id ?? "";
    message.PK = (object.PK !== undefined && object.PK !== null) ? PubKey.fromPartial(object.PK) : undefined;
    return message;
  },
};

function createBaseChanEncryptionMethod(): ChanEncryptionMethod {
  return { method: "", channel_id: "" };
}

export const ChanEncryptionMethod = {
  encode(message: ChanEncryptionMethod, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChanEncryptionMethod {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChanEncryptionMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChanEncryptionMethod {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: ChanEncryptionMethod): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChanEncryptionMethod>, I>>(base?: I): ChanEncryptionMethod {
    return ChanEncryptionMethod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChanEncryptionMethod>, I>>(object: I): ChanEncryptionMethod {
    const message = createBaseChanEncryptionMethod();
    message.method = object.method ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseGetKeyServerResp(): GetKeyServerResp {
  return { url: "" };
}

export const GetKeyServerResp = {
  encode(message: GetKeyServerResp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetKeyServerResp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyServerResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyServerResp {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: GetKeyServerResp): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyServerResp>, I>>(base?: I): GetKeyServerResp {
    return GetKeyServerResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyServerResp>, I>>(object: I): GetKeyServerResp {
    const message = createBaseGetKeyServerResp();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseAuditLog(): AuditLog {
  return {
    id: "",
    user_id: "",
    clan_id: "",
    action_log: "",
    entity_name: "",
    entity_id: "",
    details: "",
    time_log: undefined,
    channel_id: "",
    channel_label: "",
  };
}

export const AuditLog = {
  encode(message: AuditLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.action_log !== "") {
      writer.uint32(34).string(message.action_log);
    }
    if (message.entity_name !== "") {
      writer.uint32(42).string(message.entity_name);
    }
    if (message.entity_id !== "") {
      writer.uint32(50).string(message.entity_id);
    }
    if (message.details !== "") {
      writer.uint32(58).string(message.details);
    }
    if (message.time_log !== undefined) {
      Timestamp.encode(toTimestamp(message.time_log), writer.uint32(66).fork()).ldelim();
    }
    if (message.channel_id !== "") {
      writer.uint32(74).string(message.channel_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(82).string(message.channel_label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action_log = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.entity_name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entity_id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.details = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.time_log = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.channel_label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      action_log: isSet(object.action_log) ? globalThis.String(object.action_log) : "",
      entity_name: isSet(object.entity_name) ? globalThis.String(object.entity_name) : "",
      entity_id: isSet(object.entity_id) ? globalThis.String(object.entity_id) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      time_log: isSet(object.time_log) ? fromJsonTimestamp(object.time_log) : undefined,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
    };
  },

  toJSON(message: AuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.action_log !== "") {
      obj.action_log = message.action_log;
    }
    if (message.entity_name !== "") {
      obj.entity_name = message.entity_name;
    }
    if (message.entity_id !== "") {
      obj.entity_id = message.entity_id;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.time_log !== undefined) {
      obj.time_log = message.time_log.toISOString();
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLog>, I>>(base?: I): AuditLog {
    return AuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLog>, I>>(object: I): AuditLog {
    const message = createBaseAuditLog();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.action_log = object.action_log ?? "";
    message.entity_name = object.entity_name ?? "";
    message.entity_id = object.entity_id ?? "";
    message.details = object.details ?? "";
    message.time_log = object.time_log ?? undefined;
    message.channel_id = object.channel_id ?? "";
    message.channel_label = object.channel_label ?? "";
    return message;
  },
};

function createBaseListAuditLog(): ListAuditLog {
  return { total_count: 0, date_log: "", logs: [] };
}

export const ListAuditLog = {
  encode(message: ListAuditLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total_count !== 0) {
      writer.uint32(8).int32(message.total_count);
    }
    if (message.date_log !== "") {
      writer.uint32(18).string(message.date_log);
    }
    for (const v of message.logs) {
      AuditLog.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAuditLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.total_count = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.date_log = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logs.push(AuditLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditLog {
    return {
      total_count: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
      date_log: isSet(object.date_log) ? globalThis.String(object.date_log) : "",
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => AuditLog.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListAuditLog): unknown {
    const obj: any = {};
    if (message.total_count !== 0) {
      obj.total_count = Math.round(message.total_count);
    }
    if (message.date_log !== "") {
      obj.date_log = message.date_log;
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => AuditLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditLog>, I>>(base?: I): ListAuditLog {
    return ListAuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditLog>, I>>(object: I): ListAuditLog {
    const message = createBaseListAuditLog();
    message.total_count = object.total_count ?? 0;
    message.date_log = object.date_log ?? "";
    message.logs = object.logs?.map((e) => AuditLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListAuditLogRequest(): ListAuditLogRequest {
  return { action_log: "", user_id: "", clan_id: "", date_log: "" };
}

export const ListAuditLogRequest = {
  encode(message: ListAuditLogRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action_log !== "") {
      writer.uint32(10).string(message.action_log);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.date_log !== "") {
      writer.uint32(34).string(message.date_log);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAuditLogRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action_log = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.date_log = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditLogRequest {
    return {
      action_log: isSet(object.action_log) ? globalThis.String(object.action_log) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      date_log: isSet(object.date_log) ? globalThis.String(object.date_log) : "",
    };
  },

  toJSON(message: ListAuditLogRequest): unknown {
    const obj: any = {};
    if (message.action_log !== "") {
      obj.action_log = message.action_log;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.date_log !== "") {
      obj.date_log = message.date_log;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditLogRequest>, I>>(base?: I): ListAuditLogRequest {
    return ListAuditLogRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditLogRequest>, I>>(object: I): ListAuditLogRequest {
    const message = createBaseListAuditLogRequest();
    message.action_log = object.action_log ?? "";
    message.user_id = object.user_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.date_log = object.date_log ?? "";
    return message;
  },
};

function createBaseTokenSentEvent(): TokenSentEvent {
  return { sender_id: "", sender_name: "", receiver_id: "", amount: 0, note: "" };
}

export const TokenSentEvent = {
  encode(message: TokenSentEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender_id !== "") {
      writer.uint32(10).string(message.sender_id);
    }
    if (message.sender_name !== "") {
      writer.uint32(18).string(message.sender_name);
    }
    if (message.receiver_id !== "") {
      writer.uint32(26).string(message.receiver_id);
    }
    if (message.amount !== 0) {
      writer.uint32(32).int32(message.amount);
    }
    if (message.note !== "") {
      writer.uint32(42).string(message.note);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenSentEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenSentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sender_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receiver_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.note = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenSentEvent {
    return {
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      sender_name: isSet(object.sender_name) ? globalThis.String(object.sender_name) : "",
      receiver_id: isSet(object.receiver_id) ? globalThis.String(object.receiver_id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      note: isSet(object.note) ? globalThis.String(object.note) : "",
    };
  },

  toJSON(message: TokenSentEvent): unknown {
    const obj: any = {};
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.sender_name !== "") {
      obj.sender_name = message.sender_name;
    }
    if (message.receiver_id !== "") {
      obj.receiver_id = message.receiver_id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenSentEvent>, I>>(base?: I): TokenSentEvent {
    return TokenSentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenSentEvent>, I>>(object: I): TokenSentEvent {
    const message = createBaseTokenSentEvent();
    message.sender_id = object.sender_id ?? "";
    message.sender_name = object.sender_name ?? "";
    message.receiver_id = object.receiver_id ?? "";
    message.amount = object.amount ?? 0;
    message.note = object.note ?? "";
    return message;
  },
};

function createBaseWithdrawTokenRequest(): WithdrawTokenRequest {
  return { amount: 0 };
}

export const WithdrawTokenRequest = {
  encode(message: WithdrawTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== 0) {
      writer.uint32(8).int32(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WithdrawTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.amount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawTokenRequest {
    return { amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0 };
  },

  toJSON(message: WithdrawTokenRequest): unknown {
    const obj: any = {};
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawTokenRequest>, I>>(base?: I): WithdrawTokenRequest {
    return WithdrawTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawTokenRequest>, I>>(object: I): WithdrawTokenRequest {
    const message = createBaseWithdrawTokenRequest();
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseListOnboardingRequest(): ListOnboardingRequest {
  return { clan_id: "", guide_type: undefined, limit: undefined, page: undefined };
}

export const ListOnboardingRequest = {
  encode(message: ListOnboardingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.guide_type !== undefined) {
      Int32Value.encode({ value: message.guide_type! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.page !== undefined) {
      Int32Value.encode({ value: message.page! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOnboardingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOnboardingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guide_type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.page = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOnboardingRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      guide_type: isSet(object.guide_type) ? Number(object.guide_type) : undefined,
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      page: isSet(object.page) ? Number(object.page) : undefined,
    };
  },

  toJSON(message: ListOnboardingRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.guide_type !== undefined) {
      obj.guide_type = message.guide_type;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.page !== undefined) {
      obj.page = message.page;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOnboardingRequest>, I>>(base?: I): ListOnboardingRequest {
    return ListOnboardingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOnboardingRequest>, I>>(object: I): ListOnboardingRequest {
    const message = createBaseListOnboardingRequest();
    message.clan_id = object.clan_id ?? "";
    message.guide_type = object.guide_type ?? undefined;
    message.limit = object.limit ?? undefined;
    message.page = object.page ?? undefined;
    return message;
  },
};

function createBaseListOnboardingResponse(): ListOnboardingResponse {
  return { list_onboarding: [] };
}

export const ListOnboardingResponse = {
  encode(message: ListOnboardingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.list_onboarding) {
      OnboardingItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOnboardingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOnboardingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.list_onboarding.push(OnboardingItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOnboardingResponse {
    return {
      list_onboarding: globalThis.Array.isArray(object?.list_onboarding)
        ? object.list_onboarding.map((e: any) => OnboardingItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListOnboardingResponse): unknown {
    const obj: any = {};
    if (message.list_onboarding?.length) {
      obj.list_onboarding = message.list_onboarding.map((e) => OnboardingItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOnboardingResponse>, I>>(base?: I): ListOnboardingResponse {
    return ListOnboardingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOnboardingResponse>, I>>(object: I): ListOnboardingResponse {
    const message = createBaseListOnboardingResponse();
    message.list_onboarding = object.list_onboarding?.map((e) => OnboardingItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOnboardingItem(): OnboardingItem {
  return {
    id: "",
    clan_id: "",
    guide_type: 0,
    task_type: 0,
    channel_id: "",
    title: "",
    content: "",
    image_url: "",
    answers: [],
    create_time: undefined,
    update_time: undefined,
  };
}

export const OnboardingItem = {
  encode(message: OnboardingItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.guide_type !== 0) {
      writer.uint32(24).int32(message.guide_type);
    }
    if (message.task_type !== 0) {
      writer.uint32(32).int32(message.task_type);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(58).string(message.content);
    }
    if (message.image_url !== "") {
      writer.uint32(66).string(message.image_url);
    }
    for (const v of message.answers) {
      OnboardingAnswer.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(82).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnboardingItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardingItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.guide_type = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.task_type = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.content = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.image_url = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.answers.push(OnboardingAnswer.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardingItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      guide_type: isSet(object.guide_type) ? globalThis.Number(object.guide_type) : 0,
      task_type: isSet(object.task_type) ? globalThis.Number(object.task_type) : 0,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      image_url: isSet(object.image_url) ? globalThis.String(object.image_url) : "",
      answers: globalThis.Array.isArray(object?.answers)
        ? object.answers.map((e: any) => OnboardingAnswer.fromJSON(e))
        : [],
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
    };
  },

  toJSON(message: OnboardingItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.guide_type !== 0) {
      obj.guide_type = Math.round(message.guide_type);
    }
    if (message.task_type !== 0) {
      obj.task_type = Math.round(message.task_type);
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.image_url !== "") {
      obj.image_url = message.image_url;
    }
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => OnboardingAnswer.toJSON(e));
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardingItem>, I>>(base?: I): OnboardingItem {
    return OnboardingItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardingItem>, I>>(object: I): OnboardingItem {
    const message = createBaseOnboardingItem();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.guide_type = object.guide_type ?? 0;
    message.task_type = object.task_type ?? 0;
    message.channel_id = object.channel_id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.image_url = object.image_url ?? "";
    message.answers = object.answers?.map((e) => OnboardingAnswer.fromPartial(e)) || [];
    message.create_time = object.create_time ?? undefined;
    message.update_time = object.update_time ?? undefined;
    return message;
  },
};

function createBaseOnboardingAnswer(): OnboardingAnswer {
  return { title: "", description: "", emoji: "", image_url: "" };
}

export const OnboardingAnswer = {
  encode(message: OnboardingAnswer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.emoji !== "") {
      writer.uint32(26).string(message.emoji);
    }
    if (message.image_url !== "") {
      writer.uint32(34).string(message.image_url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnboardingAnswer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardingAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emoji = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image_url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardingAnswer {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      image_url: isSet(object.image_url) ? globalThis.String(object.image_url) : "",
    };
  },

  toJSON(message: OnboardingAnswer): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.image_url !== "") {
      obj.image_url = message.image_url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardingAnswer>, I>>(base?: I): OnboardingAnswer {
    return OnboardingAnswer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardingAnswer>, I>>(object: I): OnboardingAnswer {
    const message = createBaseOnboardingAnswer();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.emoji = object.emoji ?? "";
    message.image_url = object.image_url ?? "";
    return message;
  },
};

function createBaseOnboardingContent(): OnboardingContent {
  return { guide_type: 0, task_type: 0, channel_id: "", title: "", content: "", image_url: "", answers: [] };
}

export const OnboardingContent = {
  encode(message: OnboardingContent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.guide_type !== 0) {
      writer.uint32(8).int32(message.guide_type);
    }
    if (message.task_type !== 0) {
      writer.uint32(16).int32(message.task_type);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(42).string(message.content);
    }
    if (message.image_url !== "") {
      writer.uint32(50).string(message.image_url);
    }
    for (const v of message.answers) {
      OnboardingAnswer.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnboardingContent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardingContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.guide_type = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.task_type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.image_url = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.answers.push(OnboardingAnswer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardingContent {
    return {
      guide_type: isSet(object.guide_type) ? globalThis.Number(object.guide_type) : 0,
      task_type: isSet(object.task_type) ? globalThis.Number(object.task_type) : 0,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      image_url: isSet(object.image_url) ? globalThis.String(object.image_url) : "",
      answers: globalThis.Array.isArray(object?.answers)
        ? object.answers.map((e: any) => OnboardingAnswer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OnboardingContent): unknown {
    const obj: any = {};
    if (message.guide_type !== 0) {
      obj.guide_type = Math.round(message.guide_type);
    }
    if (message.task_type !== 0) {
      obj.task_type = Math.round(message.task_type);
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.image_url !== "") {
      obj.image_url = message.image_url;
    }
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => OnboardingAnswer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardingContent>, I>>(base?: I): OnboardingContent {
    return OnboardingContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardingContent>, I>>(object: I): OnboardingContent {
    const message = createBaseOnboardingContent();
    message.guide_type = object.guide_type ?? 0;
    message.task_type = object.task_type ?? 0;
    message.channel_id = object.channel_id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.image_url = object.image_url ?? "";
    message.answers = object.answers?.map((e) => OnboardingAnswer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateOnboardingRequest(): CreateOnboardingRequest {
  return { clan_id: "", contents: [] };
}

export const CreateOnboardingRequest = {
  encode(message: CreateOnboardingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    for (const v of message.contents) {
      OnboardingContent.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOnboardingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOnboardingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contents.push(OnboardingContent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOnboardingRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      contents: globalThis.Array.isArray(object?.contents)
        ? object.contents.map((e: any) => OnboardingContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateOnboardingRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.contents?.length) {
      obj.contents = message.contents.map((e) => OnboardingContent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOnboardingRequest>, I>>(base?: I): CreateOnboardingRequest {
    return CreateOnboardingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOnboardingRequest>, I>>(object: I): CreateOnboardingRequest {
    const message = createBaseCreateOnboardingRequest();
    message.clan_id = object.clan_id ?? "";
    message.contents = object.contents?.map((e) => OnboardingContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateOnboardingRequest(): UpdateOnboardingRequest {
  return {
    id: "",
    clan_id: "",
    task_type: undefined,
    channel_id: "",
    title: "",
    content: "",
    image_url: "",
    answers: [],
  };
}

export const UpdateOnboardingRequest = {
  encode(message: UpdateOnboardingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.task_type !== undefined) {
      Int32Value.encode({ value: message.task_type! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.channel_id !== "") {
      writer.uint32(34).string(message.channel_id);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(50).string(message.content);
    }
    if (message.image_url !== "") {
      writer.uint32(58).string(message.image_url);
    }
    for (const v of message.answers) {
      OnboardingAnswer.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOnboardingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOnboardingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.task_type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.content = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.image_url = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.answers.push(OnboardingAnswer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOnboardingRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      task_type: isSet(object.task_type) ? Number(object.task_type) : undefined,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      image_url: isSet(object.image_url) ? globalThis.String(object.image_url) : "",
      answers: globalThis.Array.isArray(object?.answers)
        ? object.answers.map((e: any) => OnboardingAnswer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateOnboardingRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.task_type !== undefined) {
      obj.task_type = message.task_type;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.image_url !== "") {
      obj.image_url = message.image_url;
    }
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => OnboardingAnswer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOnboardingRequest>, I>>(base?: I): UpdateOnboardingRequest {
    return UpdateOnboardingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOnboardingRequest>, I>>(object: I): UpdateOnboardingRequest {
    const message = createBaseUpdateOnboardingRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.task_type = object.task_type ?? undefined;
    message.channel_id = object.channel_id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.image_url = object.image_url ?? "";
    message.answers = object.answers?.map((e) => OnboardingAnswer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOnboardingRequest(): OnboardingRequest {
  return { id: "", clan_id: "" };
}

export const OnboardingRequest = {
  encode(message: OnboardingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnboardingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardingRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: OnboardingRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardingRequest>, I>>(base?: I): OnboardingRequest {
    return OnboardingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardingRequest>, I>>(object: I): OnboardingRequest {
    const message = createBaseOnboardingRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanWebhook(): ClanWebhook {
  return {
    id: "",
    webhook_name: "",
    clan_id: "",
    active: 0,
    url: "",
    creator_id: "",
    avatar: "",
    create_time: "",
    update_time: "",
  };
}

export const ClanWebhook = {
  encode(message: ClanWebhook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.webhook_name !== "") {
      writer.uint32(18).string(message.webhook_name);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.active !== 0) {
      writer.uint32(32).int32(message.active);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.creator_id !== "") {
      writer.uint32(50).string(message.creator_id);
    }
    if (message.avatar !== "") {
      writer.uint32(58).string(message.avatar);
    }
    if (message.create_time !== "") {
      writer.uint32(66).string(message.create_time);
    }
    if (message.update_time !== "") {
      writer.uint32(74).string(message.update_time);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanWebhook {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanWebhook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.active = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.create_time = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.update_time = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanWebhook {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      create_time: isSet(object.create_time) ? globalThis.String(object.create_time) : "",
      update_time: isSet(object.update_time) ? globalThis.String(object.update_time) : "",
    };
  },

  toJSON(message: ClanWebhook): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.create_time !== "") {
      obj.create_time = message.create_time;
    }
    if (message.update_time !== "") {
      obj.update_time = message.update_time;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanWebhook>, I>>(base?: I): ClanWebhook {
    return ClanWebhook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanWebhook>, I>>(object: I): ClanWebhook {
    const message = createBaseClanWebhook();
    message.id = object.id ?? "";
    message.webhook_name = object.webhook_name ?? "";
    message.clan_id = object.clan_id ?? "";
    message.active = object.active ?? 0;
    message.url = object.url ?? "";
    message.creator_id = object.creator_id ?? "";
    message.avatar = object.avatar ?? "";
    message.create_time = object.create_time ?? "";
    message.update_time = object.update_time ?? "";
    return message;
  },
};

function createBaseGenerateClanWebhookRequest(): GenerateClanWebhookRequest {
  return { clan_id: "", webhook_name: "", avatar: "" };
}

export const GenerateClanWebhookRequest = {
  encode(message: GenerateClanWebhookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.webhook_name !== "") {
      writer.uint32(18).string(message.webhook_name);
    }
    if (message.avatar !== "") {
      writer.uint32(26).string(message.avatar);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerateClanWebhookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateClanWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateClanWebhookRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: GenerateClanWebhookRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateClanWebhookRequest>, I>>(base?: I): GenerateClanWebhookRequest {
    return GenerateClanWebhookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateClanWebhookRequest>, I>>(object: I): GenerateClanWebhookRequest {
    const message = createBaseGenerateClanWebhookRequest();
    message.clan_id = object.clan_id ?? "";
    message.webhook_name = object.webhook_name ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseGenerateClanWebhookResponse(): GenerateClanWebhookResponse {
  return { clan_id: "", url: "", webhook_name: "", avatar: "" };
}

export const GenerateClanWebhookResponse = {
  encode(message: GenerateClanWebhookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.webhook_name !== "") {
      writer.uint32(26).string(message.webhook_name);
    }
    if (message.avatar !== "") {
      writer.uint32(34).string(message.avatar);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerateClanWebhookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateClanWebhookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateClanWebhookResponse {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: GenerateClanWebhookResponse): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateClanWebhookResponse>, I>>(base?: I): GenerateClanWebhookResponse {
    return GenerateClanWebhookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateClanWebhookResponse>, I>>(object: I): GenerateClanWebhookResponse {
    const message = createBaseGenerateClanWebhookResponse();
    message.clan_id = object.clan_id ?? "";
    message.url = object.url ?? "";
    message.webhook_name = object.webhook_name ?? "";
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseClanWebhookRequest(): ClanWebhookRequest {
  return { id: "", clan_id: "" };
}

export const ClanWebhookRequest = {
  encode(message: ClanWebhookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanWebhookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanWebhookRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanWebhookRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanWebhookRequest>, I>>(base?: I): ClanWebhookRequest {
    return ClanWebhookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanWebhookRequest>, I>>(object: I): ClanWebhookRequest {
    const message = createBaseClanWebhookRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseUpdateClanWebhookRequest(): UpdateClanWebhookRequest {
  return { id: "", clan_id: "", webhook_name: "", avatar: "", reset_token: false };
}

export const UpdateClanWebhookRequest = {
  encode(message: UpdateClanWebhookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.webhook_name !== "") {
      writer.uint32(26).string(message.webhook_name);
    }
    if (message.avatar !== "") {
      writer.uint32(34).string(message.avatar);
    }
    if (message.reset_token !== false) {
      writer.uint32(40).bool(message.reset_token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateClanWebhookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClanWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.webhook_name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.reset_token = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClanWebhookRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      webhook_name: isSet(object.webhook_name) ? globalThis.String(object.webhook_name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      reset_token: isSet(object.reset_token) ? globalThis.Boolean(object.reset_token) : false,
    };
  },

  toJSON(message: UpdateClanWebhookRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.webhook_name !== "") {
      obj.webhook_name = message.webhook_name;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.reset_token !== false) {
      obj.reset_token = message.reset_token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClanWebhookRequest>, I>>(base?: I): UpdateClanWebhookRequest {
    return UpdateClanWebhookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClanWebhookRequest>, I>>(object: I): UpdateClanWebhookRequest {
    const message = createBaseUpdateClanWebhookRequest();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.webhook_name = object.webhook_name ?? "";
    message.avatar = object.avatar ?? "";
    message.reset_token = object.reset_token ?? false;
    return message;
  },
};

function createBaseListClanWebhookRequest(): ListClanWebhookRequest {
  return { clan_id: "" };
}

export const ListClanWebhookRequest = {
  encode(message: ListClanWebhookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListClanWebhookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClanWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClanWebhookRequest {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ListClanWebhookRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListClanWebhookRequest>, I>>(base?: I): ListClanWebhookRequest {
    return ListClanWebhookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListClanWebhookRequest>, I>>(object: I): ListClanWebhookRequest {
    const message = createBaseListClanWebhookRequest();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseListClanWebhookResponse(): ListClanWebhookResponse {
  return { list_clan_webhooks: [] };
}

export const ListClanWebhookResponse = {
  encode(message: ListClanWebhookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.list_clan_webhooks) {
      ClanWebhook.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListClanWebhookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClanWebhookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.list_clan_webhooks.push(ClanWebhook.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClanWebhookResponse {
    return {
      list_clan_webhooks: globalThis.Array.isArray(object?.list_clan_webhooks)
        ? object.list_clan_webhooks.map((e: any) => ClanWebhook.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListClanWebhookResponse): unknown {
    const obj: any = {};
    if (message.list_clan_webhooks?.length) {
      obj.list_clan_webhooks = message.list_clan_webhooks.map((e) => ClanWebhook.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListClanWebhookResponse>, I>>(base?: I): ListClanWebhookResponse {
    return ListClanWebhookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListClanWebhookResponse>, I>>(object: I): ListClanWebhookResponse {
    const message = createBaseListClanWebhookResponse();
    message.list_clan_webhooks = object.list_clan_webhooks?.map((e) => ClanWebhook.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClanWebhookHandlerBody(): ClanWebhookHandlerBody {
  return { content: "", attachments: [] };
}

export const ClanWebhookHandlerBody = {
  encode(message: ClanWebhookHandlerBody, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    for (const v of message.attachments) {
      MessageAttachment.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanWebhookHandlerBody {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanWebhookHandlerBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanWebhookHandlerBody {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => MessageAttachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClanWebhookHandlerBody): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanWebhookHandlerBody>, I>>(base?: I): ClanWebhookHandlerBody {
    return ClanWebhookHandlerBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanWebhookHandlerBody>, I>>(object: I): ClanWebhookHandlerBody {
    const message = createBaseClanWebhookHandlerBody();
    message.content = object.content ?? "";
    message.attachments = object.attachments?.map((e) => MessageAttachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClanWebhookHandlerRequest(): ClanWebhookHandlerRequest {
  return { body: undefined, token: "", username: "" };
}

export const ClanWebhookHandlerRequest = {
  encode(message: ClanWebhookHandlerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.body !== undefined) {
      ClanWebhookHandlerBody.encode(message.body, writer.uint32(10).fork()).ldelim();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanWebhookHandlerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanWebhookHandlerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = ClanWebhookHandlerBody.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanWebhookHandlerRequest {
    return {
      body: isSet(object.body) ? ClanWebhookHandlerBody.fromJSON(object.body) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: ClanWebhookHandlerRequest): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = ClanWebhookHandlerBody.toJSON(message.body);
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanWebhookHandlerRequest>, I>>(base?: I): ClanWebhookHandlerRequest {
    return ClanWebhookHandlerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanWebhookHandlerRequest>, I>>(object: I): ClanWebhookHandlerRequest {
    const message = createBaseClanWebhookHandlerRequest();
    message.body = (object.body !== undefined && object.body !== null)
      ? ClanWebhookHandlerBody.fromPartial(object.body)
      : undefined;
    message.token = object.token ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseUserStatus(): UserStatus {
  return { user_id: "", status: "" };
}

export const UserStatus = {
  encode(message: UserStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatus {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: UserStatus): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatus>, I>>(base?: I): UserStatus {
    return UserStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatus>, I>>(object: I): UserStatus {
    const message = createBaseUserStatus();
    message.user_id = object.user_id ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseUserStatusUpdate(): UserStatusUpdate {
  return { status: "", minutes: 0, until_turn_on: false };
}

export const UserStatusUpdate = {
  encode(message: UserStatusUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.minutes !== 0) {
      writer.uint32(16).int32(message.minutes);
    }
    if (message.until_turn_on !== false) {
      writer.uint32(24).bool(message.until_turn_on);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserStatusUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minutes = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.until_turn_on = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatusUpdate {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      minutes: isSet(object.minutes) ? globalThis.Number(object.minutes) : 0,
      until_turn_on: isSet(object.until_turn_on) ? globalThis.Boolean(object.until_turn_on) : false,
    };
  },

  toJSON(message: UserStatusUpdate): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.minutes !== 0) {
      obj.minutes = Math.round(message.minutes);
    }
    if (message.until_turn_on !== false) {
      obj.until_turn_on = message.until_turn_on;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatusUpdate>, I>>(base?: I): UserStatusUpdate {
    return UserStatusUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatusUpdate>, I>>(object: I): UserStatusUpdate {
    const message = createBaseUserStatusUpdate();
    message.status = object.status ?? "";
    message.minutes = object.minutes ?? 0;
    message.until_turn_on = object.until_turn_on ?? false;
    return message;
  },
};

function createBaseOnboardingSteps(): OnboardingSteps {
  return { id: "", user_id: "", clan_id: "", onboarding_step: 0 };
}

export const OnboardingSteps = {
  encode(message: OnboardingSteps, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.onboarding_step !== 0) {
      writer.uint32(32).int32(message.onboarding_step);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OnboardingSteps {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardingSteps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.onboarding_step = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardingSteps {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      onboarding_step: isSet(object.onboarding_step) ? globalThis.Number(object.onboarding_step) : 0,
    };
  },

  toJSON(message: OnboardingSteps): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.onboarding_step !== 0) {
      obj.onboarding_step = Math.round(message.onboarding_step);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardingSteps>, I>>(base?: I): OnboardingSteps {
    return OnboardingSteps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardingSteps>, I>>(object: I): OnboardingSteps {
    const message = createBaseOnboardingSteps();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.onboarding_step = object.onboarding_step ?? 0;
    return message;
  },
};

function createBaseListOnboardingStepResponse(): ListOnboardingStepResponse {
  return { list_onboarding_step: [] };
}

export const ListOnboardingStepResponse = {
  encode(message: ListOnboardingStepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.list_onboarding_step) {
      OnboardingSteps.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOnboardingStepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOnboardingStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.list_onboarding_step.push(OnboardingSteps.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOnboardingStepResponse {
    return {
      list_onboarding_step: globalThis.Array.isArray(object?.list_onboarding_step)
        ? object.list_onboarding_step.map((e: any) => OnboardingSteps.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListOnboardingStepResponse): unknown {
    const obj: any = {};
    if (message.list_onboarding_step?.length) {
      obj.list_onboarding_step = message.list_onboarding_step.map((e) => OnboardingSteps.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOnboardingStepResponse>, I>>(base?: I): ListOnboardingStepResponse {
    return ListOnboardingStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOnboardingStepResponse>, I>>(object: I): ListOnboardingStepResponse {
    const message = createBaseListOnboardingStepResponse();
    message.list_onboarding_step = object.list_onboarding_step?.map((e) => OnboardingSteps.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListOnboardingStepRequest(): ListOnboardingStepRequest {
  return { clan_id: "", limit: undefined, page: undefined };
}

export const ListOnboardingStepRequest = {
  encode(message: ListOnboardingStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.page !== undefined) {
      Int32Value.encode({ value: message.page! }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOnboardingStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOnboardingStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.page = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOnboardingStepRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      page: isSet(object.page) ? Number(object.page) : undefined,
    };
  },

  toJSON(message: ListOnboardingStepRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.page !== undefined) {
      obj.page = message.page;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOnboardingStepRequest>, I>>(base?: I): ListOnboardingStepRequest {
    return ListOnboardingStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOnboardingStepRequest>, I>>(object: I): ListOnboardingStepRequest {
    const message = createBaseListOnboardingStepRequest();
    message.clan_id = object.clan_id ?? "";
    message.limit = object.limit ?? undefined;
    message.page = object.page ?? undefined;
    return message;
  },
};

function createBaseUpdateOnboardingStepRequest(): UpdateOnboardingStepRequest {
  return { clan_id: "", onboarding_step: undefined };
}

export const UpdateOnboardingStepRequest = {
  encode(message: UpdateOnboardingStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.onboarding_step !== undefined) {
      Int32Value.encode({ value: message.onboarding_step! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOnboardingStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOnboardingStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.onboarding_step = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOnboardingStepRequest {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      onboarding_step: isSet(object.onboarding_step) ? Number(object.onboarding_step) : undefined,
    };
  },

  toJSON(message: UpdateOnboardingStepRequest): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.onboarding_step !== undefined) {
      obj.onboarding_step = message.onboarding_step;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOnboardingStepRequest>, I>>(base?: I): UpdateOnboardingStepRequest {
    return UpdateOnboardingStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOnboardingStepRequest>, I>>(object: I): UpdateOnboardingStepRequest {
    const message = createBaseUpdateOnboardingStepRequest();
    message.clan_id = object.clan_id ?? "";
    message.onboarding_step = object.onboarding_step ?? undefined;
    return message;
  },
};

function createBasePTTChannelUser(): PTTChannelUser {
  return { id: "", user_id: "", channel_id: "", participant: "" };
}

export const PTTChannelUser = {
  encode(message: PTTChannelUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    if (message.participant !== "") {
      writer.uint32(34).string(message.participant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PTTChannelUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTTChannelUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTTChannelUser {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
    };
  },

  toJSON(message: PTTChannelUser): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTTChannelUser>, I>>(base?: I): PTTChannelUser {
    return PTTChannelUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTTChannelUser>, I>>(object: I): PTTChannelUser {
    const message = createBasePTTChannelUser();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.participant = object.participant ?? "";
    return message;
  },
};

function createBasePTTChannelUserList(): PTTChannelUserList {
  return { ptt_channel_users: [] };
}

export const PTTChannelUserList = {
  encode(message: PTTChannelUserList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ptt_channel_users) {
      PTTChannelUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PTTChannelUserList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePTTChannelUserList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ptt_channel_users.push(PTTChannelUser.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PTTChannelUserList {
    return {
      ptt_channel_users: globalThis.Array.isArray(object?.ptt_channel_users)
        ? object.ptt_channel_users.map((e: any) => PTTChannelUser.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PTTChannelUserList): unknown {
    const obj: any = {};
    if (message.ptt_channel_users?.length) {
      obj.ptt_channel_users = message.ptt_channel_users.map((e) => PTTChannelUser.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PTTChannelUserList>, I>>(base?: I): PTTChannelUserList {
    return PTTChannelUserList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PTTChannelUserList>, I>>(object: I): PTTChannelUserList {
    const message = createBasePTTChannelUserList();
    message.ptt_channel_users = object.ptt_channel_users?.map((e) => PTTChannelUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWalletLedger(): WalletLedger {
  return { id: "", user_id: "", create_time: undefined, value: 0, transaction_id: "" };
}

export const WalletLedger = {
  encode(message: WalletLedger, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(26).fork()).ldelim();
    }
    if (message.value !== 0) {
      writer.uint32(32).int32(message.value);
    }
    if (message.transaction_id !== "") {
      writer.uint32(42).string(message.transaction_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WalletLedger {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletLedger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.value = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transaction_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletLedger {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      transaction_id: isSet(object.transaction_id) ? globalThis.String(object.transaction_id) : "",
    };
  },

  toJSON(message: WalletLedger): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.transaction_id !== "") {
      obj.transaction_id = message.transaction_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletLedger>, I>>(base?: I): WalletLedger {
    return WalletLedger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletLedger>, I>>(object: I): WalletLedger {
    const message = createBaseWalletLedger();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.create_time = object.create_time ?? undefined;
    message.value = object.value ?? 0;
    message.transaction_id = object.transaction_id ?? "";
    return message;
  },
};

function createBaseWalletLedgerList(): WalletLedgerList {
  return { wallet_ledger: [], prev_cursor: "", next_cursor: "" };
}

export const WalletLedgerList = {
  encode(message: WalletLedgerList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.wallet_ledger) {
      WalletLedger.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.prev_cursor !== "") {
      writer.uint32(18).string(message.prev_cursor);
    }
    if (message.next_cursor !== "") {
      writer.uint32(26).string(message.next_cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WalletLedgerList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletLedgerList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wallet_ledger.push(WalletLedger.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prev_cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next_cursor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletLedgerList {
    return {
      wallet_ledger: globalThis.Array.isArray(object?.wallet_ledger)
        ? object.wallet_ledger.map((e: any) => WalletLedger.fromJSON(e))
        : [],
      prev_cursor: isSet(object.prev_cursor) ? globalThis.String(object.prev_cursor) : "",
      next_cursor: isSet(object.next_cursor) ? globalThis.String(object.next_cursor) : "",
    };
  },

  toJSON(message: WalletLedgerList): unknown {
    const obj: any = {};
    if (message.wallet_ledger?.length) {
      obj.wallet_ledger = message.wallet_ledger.map((e) => WalletLedger.toJSON(e));
    }
    if (message.prev_cursor !== "") {
      obj.prev_cursor = message.prev_cursor;
    }
    if (message.next_cursor !== "") {
      obj.next_cursor = message.next_cursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletLedgerList>, I>>(base?: I): WalletLedgerList {
    return WalletLedgerList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletLedgerList>, I>>(object: I): WalletLedgerList {
    const message = createBaseWalletLedgerList();
    message.wallet_ledger = object.wallet_ledger?.map((e) => WalletLedger.fromPartial(e)) || [];
    message.prev_cursor = object.prev_cursor ?? "";
    message.next_cursor = object.next_cursor ?? "";
    return message;
  },
};

function createBaseWalletLedgerListReq(): WalletLedgerListReq {
  return { limit: undefined, cursor: "", transaction_id: "" };
}

export const WalletLedgerListReq = {
  encode(message: WalletLedgerListReq, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.transaction_id !== "") {
      writer.uint32(26).string(message.transaction_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WalletLedgerListReq {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletLedgerListReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transaction_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletLedgerListReq {
    return {
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      transaction_id: isSet(object.transaction_id) ? globalThis.String(object.transaction_id) : "",
    };
  },

  toJSON(message: WalletLedgerListReq): unknown {
    const obj: any = {};
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.transaction_id !== "") {
      obj.transaction_id = message.transaction_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletLedgerListReq>, I>>(base?: I): WalletLedgerListReq {
    return WalletLedgerListReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletLedgerListReq>, I>>(object: I): WalletLedgerListReq {
    const message = createBaseWalletLedgerListReq();
    message.limit = object.limit ?? undefined;
    message.cursor = object.cursor ?? "";
    message.transaction_id = object.transaction_id ?? "";
    return message;
  },
};

function createBaseSdTopic(): SdTopic {
  return {
    id: "",
    creator_id: "",
    message_id: "",
    clan_id: "",
    channel_id: "",
    status: 0,
    create_time: undefined,
    update_time: undefined,
    message: undefined,
  };
}

export const SdTopic = {
  encode(message: SdTopic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creator_id !== "") {
      writer.uint32(18).string(message.creator_id);
    }
    if (message.message_id !== "") {
      writer.uint32(26).string(message.message_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(58).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.message !== undefined) {
      ChannelMessage.encode(message.message, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SdTopic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSdTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.message = ChannelMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SdTopic {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
      message: isSet(object.message) ? ChannelMessage.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: SdTopic): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    if (message.message !== undefined) {
      obj.message = ChannelMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SdTopic>, I>>(base?: I): SdTopic {
    return SdTopic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SdTopic>, I>>(object: I): SdTopic {
    const message = createBaseSdTopic();
    message.id = object.id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.message_id = object.message_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.status = object.status ?? 0;
    message.create_time = object.create_time ?? undefined;
    message.update_time = object.update_time ?? undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? ChannelMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseSdTopicRequest(): SdTopicRequest {
  return { message_id: "", clan_id: "", channel_id: "" };
}

export const SdTopicRequest = {
  encode(message: SdTopicRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message_id !== "") {
      writer.uint32(10).string(message.message_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SdTopicRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSdTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SdTopicRequest {
    return {
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: SdTopicRequest): unknown {
    const obj: any = {};
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SdTopicRequest>, I>>(base?: I): SdTopicRequest {
    return SdTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SdTopicRequest>, I>>(object: I): SdTopicRequest {
    const message = createBaseSdTopicRequest();
    message.message_id = object.message_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

function createBaseSdTopicList(): SdTopicList {
  return { count: 0, topics: [] };
}

export const SdTopicList = {
  encode(message: SdTopicList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    for (const v of message.topics) {
      SdTopic.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SdTopicList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSdTopicList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topics.push(SdTopic.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SdTopicList {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => SdTopic.fromJSON(e)) : [],
    };
  },

  toJSON(message: SdTopicList): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => SdTopic.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SdTopicList>, I>>(base?: I): SdTopicList {
    return SdTopicList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SdTopicList>, I>>(object: I): SdTopicList {
    const message = createBaseSdTopicList();
    message.count = object.count ?? 0;
    message.topics = object.topics?.map((e) => SdTopic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSdTopicRequest(): ListSdTopicRequest {
  return { channel_id: "", limit: 0 };
}

export const ListSdTopicRequest = {
  encode(message: ListSdTopicRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSdTopicRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSdTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSdTopicRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListSdTopicRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSdTopicRequest>, I>>(base?: I): ListSdTopicRequest {
    return ListSdTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSdTopicRequest>, I>>(object: I): ListSdTopicRequest {
    const message = createBaseListSdTopicRequest();
    message.channel_id = object.channel_id ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSdTopicDetailRequest(): SdTopicDetailRequest {
  return { topic_id: "" };
}

export const SdTopicDetailRequest = {
  encode(message: SdTopicDetailRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.topic_id !== "") {
      writer.uint32(10).string(message.topic_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SdTopicDetailRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSdTopicDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SdTopicDetailRequest {
    return { topic_id: isSet(object.topic_id) ? globalThis.String(object.topic_id) : "" };
  },

  toJSON(message: SdTopicDetailRequest): unknown {
    const obj: any = {};
    if (message.topic_id !== "") {
      obj.topic_id = message.topic_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SdTopicDetailRequest>, I>>(base?: I): SdTopicDetailRequest {
    return SdTopicDetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SdTopicDetailRequest>, I>>(object: I): SdTopicDetailRequest {
    const message = createBaseSdTopicDetailRequest();
    message.topic_id = object.topic_id ?? "";
    return message;
  },
};

function createBaseDeleteSdTopicRequest(): DeleteSdTopicRequest {
  return { channel_id: "", id: "", clan_id: "" };
}

export const DeleteSdTopicRequest = {
  encode(message: DeleteSdTopicRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSdTopicRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSdTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSdTopicRequest {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: DeleteSdTopicRequest): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSdTopicRequest>, I>>(base?: I): DeleteSdTopicRequest {
    return DeleteSdTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSdTopicRequest>, I>>(object: I): DeleteSdTopicRequest {
    const message = createBaseDeleteSdTopicRequest();
    message.channel_id = object.channel_id ?? "";
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
