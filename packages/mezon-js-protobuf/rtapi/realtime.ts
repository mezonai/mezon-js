// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.2
// source: rtapi/realtime.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import {
  ChannelMessage,
  MessageAttachment,
  MessageMention,
  MessageReaction,
  MessageRef,
  Notification,
  Rpc,
} from "../api/api";
import { Timestamp } from "../google/protobuf/timestamp";
import { BoolValue, Int32Value, StringValue } from "../google/protobuf/wrappers";

export const protobufPackage = "mezon.realtime";

/** The realtime protocol for Mezon server. */

/** An envelope for a realtime message. */
export interface Envelope {
  cid: string;
  /** A response from a channel join operation. */
  channel?:
    | Channel
    | undefined;
  /** Join a realtime chat clan */
  clan_join?:
    | ClanJoin
    | undefined;
  /** Join a realtime chat channel. */
  channel_join?:
    | ChannelJoin
    | undefined;
  /** Leave a realtime chat channel. */
  channel_leave?:
    | ChannelLeave
    | undefined;
  /** An incoming message on a realtime chat channel. */
  channel_message?:
    | ChannelMessage
    | undefined;
  /** An acknowledgement received in response to sending a message on a chat channel. */
  channel_message_ack?:
    | ChannelMessageAck
    | undefined;
  /** Send a message to a realtime chat channel. */
  channel_message_send?:
    | ChannelMessageSend
    | undefined;
  /** Update a message previously sent to a realtime chat channel. */
  channel_message_update?:
    | ChannelMessageUpdate
    | undefined;
  /** Remove a message previously sent to a realtime chat channel. */
  channel_message_remove?:
    | ChannelMessageRemove
    | undefined;
  /** Presence update for a particular realtime chat channel. */
  channel_presence_event?:
    | ChannelPresenceEvent
    | undefined;
  /** Describes an error which occurred on the server. */
  error?:
    | Error
    | undefined;
  /** Notifications send by the server. */
  notifications?:
    | Notifications
    | undefined;
  /** RPC call or response. */
  rpc?:
    | Rpc
    | undefined;
  /** An incoming status snapshot for some set of users. */
  status?:
    | Status
    | undefined;
  /** Start following some set of users to receive their status updates. */
  status_follow?:
    | StatusFollow
    | undefined;
  /** An incoming status update. */
  status_presence_event?:
    | StatusPresenceEvent
    | undefined;
  /** Stop following some set of users to no longer receive their status updates. */
  status_unfollow?:
    | StatusUnfollow
    | undefined;
  /** Set the user's own status. */
  status_update?:
    | StatusUpdate
    | undefined;
  /** A data message delivered over a stream. */
  stream_data?:
    | StreamData
    | undefined;
  /** Presence update for a particular stream. */
  stream_presence_event?:
    | StreamPresenceEvent
    | undefined;
  /** Application-level heartbeat and connection check. */
  ping?:
    | Ping
    | undefined;
  /** Application-level heartbeat and connection check response. */
  pong?:
    | Pong
    | undefined;
  /** User typing event */
  message_typing_event?:
    | MessageTypingEvent
    | undefined;
  /** Last seen message event */
  last_seen_message_event?:
    | LastSeenMessageEvent
    | undefined;
  /** User send reactoin event */
  message_reaction_event?:
    | MessageReaction
    | undefined;
  /** user join voice channel */
  voice_joined_event?:
    | VoiceJoinedEvent
    | undefined;
  /** user leave voice channel */
  voice_leaved_event?:
    | VoiceLeavedEvent
    | undefined;
  /** voice channel start */
  voice_started_event?:
    | VoiceStartedEvent
    | undefined;
  /** voice channel end */
  voice_ended_event?:
    | VoiceEndedEvent
    | undefined;
  /** channel created event */
  channel_created_event?:
    | ChannelCreatedEvent
    | undefined;
  /** channel deleted event */
  channel_deleted_event?:
    | ChannelDeletedEvent
    | undefined;
  /** channel deleted event */
  channel_updated_event?:
    | ChannelUpdatedEvent
    | undefined;
  /** Last pin message event */
  last_pin_message_event?:
    | LastPinMessageEvent
    | undefined;
  /** Update custom status */
  custom_status_event?:
    | CustomStatusEvent
    | undefined;
  /** User is added to channel event */
  user_channel_added_event?:
    | UserChannelAdded
    | undefined;
  /** User is removed to channel event */
  user_channel_removed_event?:
    | UserChannelRemoved
    | undefined;
  /** User is removed to clan event */
  user_clan_removed_event?:
    | UserClanRemoved
    | undefined;
  /** Clan updated event */
  clan_updated_event?:
    | ClanUpdatedEvent
    | undefined;
  /** Clan profile updated event */
  clan_profile_updated_event?:
    | ClanProfileUpdatedEvent
    | undefined;
  /** Check duplicate clan name event */
  clan_name_existed_event?:
    | ClanNameExistedEvent
    | undefined;
  /** User profile update event */
  user_profile_updated_event?:
    | UserProfileUpdatedEvent
    | undefined;
  /** Request to retrieve all emojis associated with a specific clan. */
  emojis_listed_event?:
    | EmojiListedEvent
    | undefined;
  /** ClanEmojiList contains a list of emojis that are associated with a specific clan. */
  sticker_listed_event?:
    | StrickerListedEvent
    | undefined;
  /** channelDescList */
  channel_desc_list_event?:
    | ChannelDescListEvent
    | undefined;
  /** list channel hastag */
  hashtag_dm_list_event?:
    | HashtagDmListEvent
    | undefined;
  /** set notification user channel. */
  notification_channel_setting_event?:
    | NotificationChannelSettingEvent
    | undefined;
  /** notification selected */
  notification_category_setting_event?:
    | NotificationCategorySettingEvent
    | undefined;
  /** notification selected */
  notification_clan_setting_event?:
    | NotificationClanSettingEvent
    | undefined;
  /** notifiReactMessage Event */
  notifi_react_message_event?:
    | NotifiReactMessageEvent
    | undefined;
  /**  */
  permission_role_channel_list_event?: PermissionRoleChannelListEvent | undefined;
}

/** A list of permission role channel. */
export interface PermissionRoleChannelListEvent {
  /**  */
  role_id: string;
  /**  */
  channel_id: string;
  /** A list of permission. */
  permission_role_channel: PermissionRoleChannel[];
}

/** Permission role channel */
export interface PermissionRoleChannel {
  /** Permission id */
  permission_id: string;
  /** active */
  active: boolean;
}

/** A list of Channel */
export interface HashtagDmListEvent {
  /** user Id */
  user_id: string[];
  /** Max number of records to return. Between 1 and 100. */
  limit:
    | number
    | undefined;
  /** A list of channel. */
  hashtag_dm: HashtagDm[];
}

/** hashtagDM */
export interface HashtagDm {
  /** The channel id. */
  channel_id: string;
  /** The channel lable */
  channel_label: string;
  /** The clan of this channel */
  clan_id: string;
  /** The clan name */
  clan_name: string;
  /**  */
  meeting_code: string;
  /**  */
  type: number;
  /**  */
  channel_private: number;
  /**  */
  parrent_id: string;
}

export interface ChannelDescListEvent {
  /** A list of channel. */
  channeldesc: ChannelDescription[];
}

/** Channel description record */
export interface ChannelDescription {
  /** The clan of this channel */
  clan_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** The channel type. */
  type:
    | number
    | undefined;
  /** The channel lable */
  channel_label: string;
  /** The channel private */
  channel_private: number;
  /** meeting code */
  meeting_code: string;
  /**  */
  clan_name: string;
  /**  */
  parrent_id: string;
}

export interface StrickerListedEvent {
  clan_id: string;
  stickers: ClanSticker[];
}

export interface ClanSticker {
  id: string;
  source: string;
  shortname: string;
  category: string;
  creator_id: string;
  create_time: Date | undefined;
  clan_id: string;
}

export interface ClanEmoji {
  id: string;
  /** src url */
  src: string;
  /** shortname */
  shortname: string;
  /** category */
  category: string;
  /** creator id */
  creator_id: string;
}

export interface EmojiListedEvent {
  clan_id: string;
  emoji_list: ClanEmoji[];
}

/** A realtime chat channel. */
export interface Channel {
  /** The ID of the channel. */
  id: string;
  /** The users currently in the channel. */
  presences: UserPresence[];
  /** A reference to the current user's presence in the channel. */
  self:
    | UserPresence
    | undefined;
  /** The name of the chat room, or an empty string if this message was not sent through a chat room. */
  chanel_label: string;
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
}

/** Join operation for a realtime chat channel. */
export interface ClanJoin {
  /** The id of channel or group */
  clan_id: string;
}

/** Join operation for a realtime chat channel. */
export interface ChannelJoin {
  /** The clan id */
  clan_id: string;
  /** The id of channel or group */
  channel_id: string;
  /** channel type */
  channel_type: number;
}

/** Leave a realtime channel. */
export interface ChannelLeave {
  /** The clan id */
  clan_id: string;
  /** The ID of the channel to leave. */
  channel_id: string;
  /** channel type */
  channel_type: number;
}

/** A receipt reply from a channel message send operation. */
export interface ChannelMessageAck {
  /** The channel the message was sent to. */
  channel_id: string;
  /** The unique ID assigned to the message. */
  message_id: string;
  /** The code representing a message type or category. */
  code:
    | number
    | undefined;
  /** Username of the message sender. */
  username: string;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created. */
  create_time:
    | Date
    | undefined;
  /** The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated. */
  update_time:
    | Date
    | undefined;
  /** True if the message was persisted to the channel's history, false otherwise. */
  persistent:
    | boolean
    | undefined;
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
}

/** Send a message to a realtime channel. */
export interface ChannelMessageSend {
  /** The clan that channel belong to. */
  clan_id: string;
  /** The channel to sent to. */
  channel_id: string;
  /** Message content. */
  content: string;
  /** Message mention */
  mentions: MessageMention[];
  /** Message attachment */
  attachments: MessageAttachment[];
  /** Message reference */
  references: MessageRef[];
  /** Mode */
  mode: number;
  /** anonymous message */
  anonymous_message: boolean;
  /** mention everyone */
  mention_everyone: boolean;
  /** clan avatar */
  avatar: string;
}

/** Update a message previously sent to a realtime channel. */
export interface ChannelMessageUpdate {
  /** The clan that channel belong to. */
  clan_id: string;
  /** The channel the message was sent to. */
  channel_id: string;
  /** The ID assigned to the message to update. */
  message_id: string;
  /** New message content. */
  content: string;
  /** The mentions */
  mentions: MessageMention[];
  /** Message attachment */
  attachments: MessageAttachment[];
  /** The mode */
  mode: number;
  /** hide editted */
  hide_editted: boolean;
}

/** Remove a message previously sent to a realtime channel. */
export interface ChannelMessageRemove {
  /** The clan that channel belong to. */
  clan_id: string;
  /** The channel the message was sent to. */
  channel_id: string;
  /** The ID assigned to the message to update. */
  message_id: string;
  /** The mode */
  mode: number;
}

/** A set of joins and leaves on a particular channel. */
export interface ChannelPresenceEvent {
  /** The channel identifier this event is for. */
  channel_id: string;
  /** Presences joining the channel as part of this event, if any. */
  joins: UserPresence[];
  /** Presences leaving the channel as part of this event, if any. */
  leaves: UserPresence[];
  /** The clan logo */
  clan_logo: string;
  /** The category name */
  category_name: string;
  /** The mode */
  mode: number;
}

/** A logical error which may occur on the server. */
export interface Error {
  /** The error code which should be one of "Error.Code" enums. */
  code: number;
  /** A message in English to help developers debug the response. */
  message: string;
  /** Additional error details which may be different for each response. */
  context: { [key: string]: string };
}

/** The selection of possible error codes. */
export enum Error_Code {
  /** RUNTIME_EXCEPTION - An unexpected result from the server. */
  RUNTIME_EXCEPTION = 0,
  /** UNRECOGNIZED_PAYLOAD - The server received a message which is not recognised. */
  UNRECOGNIZED_PAYLOAD = 1,
  /** MISSING_PAYLOAD - A message was expected but contains no content. */
  MISSING_PAYLOAD = 2,
  /** BAD_INPUT - Fields in the message have an invalid format. */
  BAD_INPUT = 3,
  /** MATCH_NOT_FOUND - The match id was not found. */
  MATCH_NOT_FOUND = 4,
  /** MATCH_JOIN_REJECTED - The match join was rejected. */
  MATCH_JOIN_REJECTED = 5,
  /** RUNTIME_FUNCTION_NOT_FOUND - The runtime function does not exist on the server. */
  RUNTIME_FUNCTION_NOT_FOUND = 6,
  /** RUNTIME_FUNCTION_EXCEPTION - The runtime function executed with an error. */
  RUNTIME_FUNCTION_EXCEPTION = 7,
  UNRECOGNIZED = -1,
}

export function error_CodeFromJSON(object: any): Error_Code {
  switch (object) {
    case 0:
    case "RUNTIME_EXCEPTION":
      return Error_Code.RUNTIME_EXCEPTION;
    case 1:
    case "UNRECOGNIZED_PAYLOAD":
      return Error_Code.UNRECOGNIZED_PAYLOAD;
    case 2:
    case "MISSING_PAYLOAD":
      return Error_Code.MISSING_PAYLOAD;
    case 3:
    case "BAD_INPUT":
      return Error_Code.BAD_INPUT;
    case 4:
    case "MATCH_NOT_FOUND":
      return Error_Code.MATCH_NOT_FOUND;
    case 5:
    case "MATCH_JOIN_REJECTED":
      return Error_Code.MATCH_JOIN_REJECTED;
    case 6:
    case "RUNTIME_FUNCTION_NOT_FOUND":
      return Error_Code.RUNTIME_FUNCTION_NOT_FOUND;
    case 7:
    case "RUNTIME_FUNCTION_EXCEPTION":
      return Error_Code.RUNTIME_FUNCTION_EXCEPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Error_Code.UNRECOGNIZED;
  }
}

export function error_CodeToJSON(object: Error_Code): string {
  switch (object) {
    case Error_Code.RUNTIME_EXCEPTION:
      return "RUNTIME_EXCEPTION";
    case Error_Code.UNRECOGNIZED_PAYLOAD:
      return "UNRECOGNIZED_PAYLOAD";
    case Error_Code.MISSING_PAYLOAD:
      return "MISSING_PAYLOAD";
    case Error_Code.BAD_INPUT:
      return "BAD_INPUT";
    case Error_Code.MATCH_NOT_FOUND:
      return "MATCH_NOT_FOUND";
    case Error_Code.MATCH_JOIN_REJECTED:
      return "MATCH_JOIN_REJECTED";
    case Error_Code.RUNTIME_FUNCTION_NOT_FOUND:
      return "RUNTIME_FUNCTION_NOT_FOUND";
    case Error_Code.RUNTIME_FUNCTION_EXCEPTION:
      return "RUNTIME_FUNCTION_EXCEPTION";
    case Error_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Error_ContextEntry {
  key: string;
  value: string;
}

/** A collection of zero or more notifications. */
export interface Notifications {
  /** Collection of notifications. */
  notifications: Notification[];
}

/** Application-level heartbeat and connection check. */
export interface Ping {
}

/** Application-level heartbeat and connection check response. */
export interface Pong {
}

/** A snapshot of statuses for some set of users. */
export interface Status {
  /** User statuses. */
  presences: UserPresence[];
}

/** Start receiving status updates for some set of users. */
export interface StatusFollow {
  /** User IDs to follow. */
  user_ids: string[];
  /** Usernames to follow. */
  usernames: string[];
}

/** A batch of status updates for a given user. */
export interface StatusPresenceEvent {
  /** New statuses for the user. */
  joins: UserPresence[];
  /** Previous statuses for the user. */
  leaves: UserPresence[];
}

/** Last pin message by user */
export interface LastPinMessageEvent {
  /** The clan id */
  clan_id: string;
  /** The unique ID of this channel. */
  channel_id: string;
  /** The unique ID of this message. */
  message_id: string;
  /** The stream mode */
  mode: number;
  /** The UserID */
  user_id: string;
  /** The timestamp */
  timestamp: string;
  /** operation */
  operation: number;
}

/** Last seen message by user */
export interface LastSeenMessageEvent {
  /** The unique ID of this channel. */
  channel_id: string;
  /** The unique ID of this message. */
  message_id: string;
  /** The stream mode */
  mode: number;
  /** The timestamp */
  timestamp: string;
}

/** Message typing event data */
export interface MessageTypingEvent {
  /** The clan id */
  clan_id: string;
  /** The channel this message belongs to. */
  channel_id: string;
  /** Message sender, usually a user ID. */
  sender_id: string;
  /** mode */
  mode: number;
}

/** Voice Joined event */
export interface VoiceLeavedEvent {
  /** id voice */
  id: string;
  /** The unique identifier of the chat clan. */
  clan_id: string;
  /** voice channel name */
  voice_channel_id: string;
  /** voice user_id */
  voice_user_id: string;
}

/** Voice Joined event */
export interface VoiceJoinedEvent {
  /** The unique identifier of the chat clan. */
  clan_id: string;
  /** The channel name */
  clan_name: string;
  /** id voice */
  id: string;
  /** voice participant */
  participant: string;
  /** user id */
  user_id: string;
  /** voice channel label */
  voice_channel_label: string;
  /** voice channel id */
  voice_channel_id: string;
  /** last screenshot */
  last_screenshot: string;
}

/** Voice start event */
export interface VoiceStartedEvent {
  /** id voice */
  id: string;
  /** The unique identifier of the chat clan. */
  clan_id: string;
  /** voice channel name */
  voice_channel_id: string;
}

/** Voice start event */
export interface VoiceEndedEvent {
  /** id voice */
  id: string;
  /** The unique identifier of the chat clan. */
  clan_id: string;
  /** voice channel name */
  voice_channel_id: string;
}

export interface ChannelCreatedEvent {
  /** clan id */
  clan_id: string;
  /** category */
  category_id: string;
  /** creator */
  creator_id: string;
  /** parrent id */
  parrent_id: string;
  /** channel id */
  channel_id: string;
  /** channel label */
  channel_label: string;
  /** channel private */
  channel_private: number;
  /** channel type */
  channel_type:
    | number
    | undefined;
  /** status */
  status: number;
}

export interface ChannelDeletedEvent {
  /** clan id */
  clan_id: string;
  /** category */
  category_id: string;
  /** parrent id */
  parrent_id: string;
  /** channel id */
  channel_id: string;
  /** deletor */
  deletor: string;
}

export interface ChannelUpdatedEvent {
  /** clan id */
  clan_id: string;
  /** category */
  category_id: string;
  /** creator */
  creator_id: string;
  /** parrent id */
  parrent_id: string;
  /** channel id */
  channel_id: string;
  /** channel label */
  channel_label: string;
  /** channel type */
  channel_type:
    | number
    | undefined;
  /** status */
  status: number;
}

/** Stop receiving status updates for some set of users. */
export interface StatusUnfollow {
  /** Users to unfollow. */
  user_ids: string[];
}

/** Set the user's own status. */
export interface StatusUpdate {
  /** Status string to set, if not present the user will appear offline. */
  status: string | undefined;
}

/** Represents identifying information for a stream. */
export interface Stream {
  /** Mode identifies the type of stream. */
  mode: number;
  /** Subject is the primary identifier, if any. */
  channel_id: string;
  /** Subcontext is a secondary identifier, if any. */
  clan_id: string;
  /** The label is an arbitrary identifying string, if the stream has one. */
  label: string;
}

/** A data message delivered over a stream. */
export interface StreamData {
  /** The stream this data message relates to. */
  stream:
    | Stream
    | undefined;
  /** The sender, if any. */
  sender:
    | UserPresence
    | undefined;
  /** Arbitrary contents of the data message. */
  data: string;
  /** True if this data was delivered reliably, false otherwise. */
  reliable: boolean;
}

/** A set of joins and leaves on a particular stream. */
export interface StreamPresenceEvent {
  /** The stream this event relates to. */
  stream:
    | Stream
    | undefined;
  /** Presences joining the stream as part of this event, if any. */
  joins: UserPresence[];
  /** Presences leaving the stream as part of this event, if any. */
  leaves: UserPresence[];
}

/** A user session associated to a stream, usually through a list operation or a join/leave event. */
export interface UserPresence {
  /** The user this presence belongs to. */
  user_id: string;
  /** A unique session ID identifying the particular connection, because the user may have many. */
  session_id: string;
  /** The username for display purposes. */
  username: string;
  /** Whether this presence generates persistent data/messages, if applicable for the stream type. */
  persistence: boolean;
  /** A user-set status message for this stream, if applicable. */
  status: string | undefined;
}

/** A custom status presence */
export interface CustomStatusEvent {
  /** the clan id */
  clan_id: string;
  /** the user id */
  user_id: string;
  /** username */
  username: string;
  /** the status */
  status: string;
}

export interface AddUsers {
  /** User IDs to follow. */
  user_id: string;
  /** Avatar to follow. */
  avatar: string;
  /** Username to follow. */
  username: string;
}

/** A event when user is added to channel */
export interface UserChannelAdded {
  /** the channel id */
  channel_id: string;
  /** the user */
  users: AddUsers[];
  /** the custom status */
  status: string;
  /** the clan id */
  clan_id: string;
  /** the channel type */
  channel_type: number;
}

/**  */
export interface UserChannelRemoved {
  /** the channel id */
  channel_id: string;
  /** the user */
  user_ids: string[];
}

/**  */
export interface UserClanRemoved {
  /** the clan id */
  clan_id: string;
  /** the user */
  user_ids: string[];
}

/** clan updated event */
export interface ClanUpdatedEvent {
  /** the clan id */
  clan_id: string;
  /** the clan name */
  clan_name: string;
  /** the clan logo */
  clan_logo: string;
}

/** clan profile updated event */
export interface ClanProfileUpdatedEvent {
  /** the user id */
  user_id: string;
  /** the clan_nick */
  clan_nick: string;
  /** the avatar */
  clan_avatar: string;
  /** the clan_id */
  clan_id: string;
}

/** user profile updated event */
export interface UserProfileUpdatedEvent {
  /** the user id */
  user_id: string;
  /** the display_name */
  display_name: string;
  /** the avatar */
  avatar: string;
  /** the about_me */
  about_me: string;
  /** the channel_id */
  channel_id: string;
  /** the clan_id */
  clan_id: string;
}

/** A event when user is added to channel */
export interface UserProfileRedis {
  /** User IDs to follow. */
  user_id: string;
  /** Username to follow. */
  username: string;
  /** Avatar to follow. */
  avatar: string;
  /** Display name */
  display_name: string;
  /** FCM token */
  fcm_tokens: FCMTokens[];
}

export interface FCMTokens {
  /** deviceID to follow. */
  device_id: string;
  /** tokenID to follow. */
  token_id: string;
}

export interface ClanNameExistedEvent {
  /** clan name */
  clan_name: string;
  /** is exist */
  exist: boolean;
}

export interface NotificationChannelSettingEvent {
  channel_id: string;
  notification_user_channel: NotificationUserChannel | undefined;
}

/** Notification channel */
export interface NotificationUserChannel {
  /** Notification id */
  id: string;
  /**  */
  notification_setting_type: number;
  /**  */
  time_mute:
    | Date
    | undefined;
  /**  */
  active: number;
}

/** Notification channel */
export interface NotificationCategorySettingEvent {
  category_id: string;
  notification_user_channel: NotificationUserChannel | undefined;
}

/** Notification setting record */
export interface NotificationClanSettingEvent {
  clan_id: string;
  notification_setting: NotificationSetting | undefined;
}

/** Notification setting record */
export interface NotificationSetting {
  /** Notification id */
  id: string;
  /** Notification title */
  notification_setting_type: number;
}

/** Notification channel */
export interface NotifiReactMessageEvent {
  /** channel id */
  channel_id: string;
  /** notification message */
  notifi_react_message: NotifiReactMessage | undefined;
}

/** Notification channel */
export interface NotifiReactMessage {
  /** Notification id */
  id: string;
  /**  */
  user_id: string;
  /**  */
  channel_id: string;
}

function createBaseEnvelope(): Envelope {
  return {
    cid: "",
    channel: undefined,
    clan_join: undefined,
    channel_join: undefined,
    channel_leave: undefined,
    channel_message: undefined,
    channel_message_ack: undefined,
    channel_message_send: undefined,
    channel_message_update: undefined,
    channel_message_remove: undefined,
    channel_presence_event: undefined,
    error: undefined,
    notifications: undefined,
    rpc: undefined,
    status: undefined,
    status_follow: undefined,
    status_presence_event: undefined,
    status_unfollow: undefined,
    status_update: undefined,
    stream_data: undefined,
    stream_presence_event: undefined,
    ping: undefined,
    pong: undefined,
    message_typing_event: undefined,
    last_seen_message_event: undefined,
    message_reaction_event: undefined,
    voice_joined_event: undefined,
    voice_leaved_event: undefined,
    voice_started_event: undefined,
    voice_ended_event: undefined,
    channel_created_event: undefined,
    channel_deleted_event: undefined,
    channel_updated_event: undefined,
    last_pin_message_event: undefined,
    custom_status_event: undefined,
    user_channel_added_event: undefined,
    user_channel_removed_event: undefined,
    user_clan_removed_event: undefined,
    clan_updated_event: undefined,
    clan_profile_updated_event: undefined,
    clan_name_existed_event: undefined,
    user_profile_updated_event: undefined,
    emojis_listed_event: undefined,
    sticker_listed_event: undefined,
    channel_desc_list_event: undefined,
    hashtag_dm_list_event: undefined,
    notification_channel_setting_event: undefined,
    notification_category_setting_event: undefined,
    notification_clan_setting_event: undefined,
    notifi_react_message_event: undefined,
    permission_role_channel_list_event: undefined,
  };
}

export const Envelope = {
  encode(message: Envelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cid !== "") {
      writer.uint32(10).string(message.cid);
    }
    if (message.channel !== undefined) {
      Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
    }
    if (message.clan_join !== undefined) {
      ClanJoin.encode(message.clan_join, writer.uint32(26).fork()).ldelim();
    }
    if (message.channel_join !== undefined) {
      ChannelJoin.encode(message.channel_join, writer.uint32(34).fork()).ldelim();
    }
    if (message.channel_leave !== undefined) {
      ChannelLeave.encode(message.channel_leave, writer.uint32(42).fork()).ldelim();
    }
    if (message.channel_message !== undefined) {
      ChannelMessage.encode(message.channel_message, writer.uint32(50).fork()).ldelim();
    }
    if (message.channel_message_ack !== undefined) {
      ChannelMessageAck.encode(message.channel_message_ack, writer.uint32(58).fork()).ldelim();
    }
    if (message.channel_message_send !== undefined) {
      ChannelMessageSend.encode(message.channel_message_send, writer.uint32(66).fork()).ldelim();
    }
    if (message.channel_message_update !== undefined) {
      ChannelMessageUpdate.encode(message.channel_message_update, writer.uint32(74).fork()).ldelim();
    }
    if (message.channel_message_remove !== undefined) {
      ChannelMessageRemove.encode(message.channel_message_remove, writer.uint32(82).fork()).ldelim();
    }
    if (message.channel_presence_event !== undefined) {
      ChannelPresenceEvent.encode(message.channel_presence_event, writer.uint32(90).fork()).ldelim();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(98).fork()).ldelim();
    }
    if (message.notifications !== undefined) {
      Notifications.encode(message.notifications, writer.uint32(106).fork()).ldelim();
    }
    if (message.rpc !== undefined) {
      Rpc.encode(message.rpc, writer.uint32(114).fork()).ldelim();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(122).fork()).ldelim();
    }
    if (message.status_follow !== undefined) {
      StatusFollow.encode(message.status_follow, writer.uint32(130).fork()).ldelim();
    }
    if (message.status_presence_event !== undefined) {
      StatusPresenceEvent.encode(message.status_presence_event, writer.uint32(138).fork()).ldelim();
    }
    if (message.status_unfollow !== undefined) {
      StatusUnfollow.encode(message.status_unfollow, writer.uint32(146).fork()).ldelim();
    }
    if (message.status_update !== undefined) {
      StatusUpdate.encode(message.status_update, writer.uint32(154).fork()).ldelim();
    }
    if (message.stream_data !== undefined) {
      StreamData.encode(message.stream_data, writer.uint32(162).fork()).ldelim();
    }
    if (message.stream_presence_event !== undefined) {
      StreamPresenceEvent.encode(message.stream_presence_event, writer.uint32(170).fork()).ldelim();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(178).fork()).ldelim();
    }
    if (message.pong !== undefined) {
      Pong.encode(message.pong, writer.uint32(186).fork()).ldelim();
    }
    if (message.message_typing_event !== undefined) {
      MessageTypingEvent.encode(message.message_typing_event, writer.uint32(194).fork()).ldelim();
    }
    if (message.last_seen_message_event !== undefined) {
      LastSeenMessageEvent.encode(message.last_seen_message_event, writer.uint32(202).fork()).ldelim();
    }
    if (message.message_reaction_event !== undefined) {
      MessageReaction.encode(message.message_reaction_event, writer.uint32(210).fork()).ldelim();
    }
    if (message.voice_joined_event !== undefined) {
      VoiceJoinedEvent.encode(message.voice_joined_event, writer.uint32(218).fork()).ldelim();
    }
    if (message.voice_leaved_event !== undefined) {
      VoiceLeavedEvent.encode(message.voice_leaved_event, writer.uint32(226).fork()).ldelim();
    }
    if (message.voice_started_event !== undefined) {
      VoiceStartedEvent.encode(message.voice_started_event, writer.uint32(234).fork()).ldelim();
    }
    if (message.voice_ended_event !== undefined) {
      VoiceEndedEvent.encode(message.voice_ended_event, writer.uint32(242).fork()).ldelim();
    }
    if (message.channel_created_event !== undefined) {
      ChannelCreatedEvent.encode(message.channel_created_event, writer.uint32(250).fork()).ldelim();
    }
    if (message.channel_deleted_event !== undefined) {
      ChannelDeletedEvent.encode(message.channel_deleted_event, writer.uint32(258).fork()).ldelim();
    }
    if (message.channel_updated_event !== undefined) {
      ChannelUpdatedEvent.encode(message.channel_updated_event, writer.uint32(266).fork()).ldelim();
    }
    if (message.last_pin_message_event !== undefined) {
      LastPinMessageEvent.encode(message.last_pin_message_event, writer.uint32(274).fork()).ldelim();
    }
    if (message.custom_status_event !== undefined) {
      CustomStatusEvent.encode(message.custom_status_event, writer.uint32(282).fork()).ldelim();
    }
    if (message.user_channel_added_event !== undefined) {
      UserChannelAdded.encode(message.user_channel_added_event, writer.uint32(290).fork()).ldelim();
    }
    if (message.user_channel_removed_event !== undefined) {
      UserChannelRemoved.encode(message.user_channel_removed_event, writer.uint32(298).fork()).ldelim();
    }
    if (message.user_clan_removed_event !== undefined) {
      UserClanRemoved.encode(message.user_clan_removed_event, writer.uint32(306).fork()).ldelim();
    }
    if (message.clan_updated_event !== undefined) {
      ClanUpdatedEvent.encode(message.clan_updated_event, writer.uint32(314).fork()).ldelim();
    }
    if (message.clan_profile_updated_event !== undefined) {
      ClanProfileUpdatedEvent.encode(message.clan_profile_updated_event, writer.uint32(322).fork()).ldelim();
    }
    if (message.clan_name_existed_event !== undefined) {
      ClanNameExistedEvent.encode(message.clan_name_existed_event, writer.uint32(330).fork()).ldelim();
    }
    if (message.user_profile_updated_event !== undefined) {
      UserProfileUpdatedEvent.encode(message.user_profile_updated_event, writer.uint32(338).fork()).ldelim();
    }
    if (message.emojis_listed_event !== undefined) {
      EmojiListedEvent.encode(message.emojis_listed_event, writer.uint32(346).fork()).ldelim();
    }
    if (message.sticker_listed_event !== undefined) {
      StrickerListedEvent.encode(message.sticker_listed_event, writer.uint32(354).fork()).ldelim();
    }
    if (message.channel_desc_list_event !== undefined) {
      ChannelDescListEvent.encode(message.channel_desc_list_event, writer.uint32(362).fork()).ldelim();
    }
    if (message.hashtag_dm_list_event !== undefined) {
      HashtagDmListEvent.encode(message.hashtag_dm_list_event, writer.uint32(370).fork()).ldelim();
    }
    if (message.notification_channel_setting_event !== undefined) {
      NotificationChannelSettingEvent.encode(message.notification_channel_setting_event, writer.uint32(378).fork())
        .ldelim();
    }
    if (message.notification_category_setting_event !== undefined) {
      NotificationCategorySettingEvent.encode(message.notification_category_setting_event, writer.uint32(386).fork())
        .ldelim();
    }
    if (message.notification_clan_setting_event !== undefined) {
      NotificationClanSettingEvent.encode(message.notification_clan_setting_event, writer.uint32(394).fork()).ldelim();
    }
    if (message.notifi_react_message_event !== undefined) {
      NotifiReactMessageEvent.encode(message.notifi_react_message_event, writer.uint32(402).fork()).ldelim();
    }
    if (message.permission_role_channel_list_event !== undefined) {
      PermissionRoleChannelListEvent.encode(message.permission_role_channel_list_event, writer.uint32(410).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel = Channel.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_join = ClanJoin.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_join = ChannelJoin.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_leave = ChannelLeave.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_message = ChannelMessage.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.channel_message_ack = ChannelMessageAck.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.channel_message_send = ChannelMessageSend.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channel_message_update = ChannelMessageUpdate.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.channel_message_remove = ChannelMessageRemove.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.channel_presence_event = ChannelPresenceEvent.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.notifications = Notifications.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.rpc = Rpc.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.status_follow = StatusFollow.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.status_presence_event = StatusPresenceEvent.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.status_unfollow = StatusUnfollow.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.status_update = StatusUpdate.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.stream_data = StreamData.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.stream_presence_event = StreamPresenceEvent.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.pong = Pong.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.message_typing_event = MessageTypingEvent.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.last_seen_message_event = LastSeenMessageEvent.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.message_reaction_event = MessageReaction.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.voice_joined_event = VoiceJoinedEvent.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.voice_leaved_event = VoiceLeavedEvent.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.voice_started_event = VoiceStartedEvent.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.voice_ended_event = VoiceEndedEvent.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.channel_created_event = ChannelCreatedEvent.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.channel_deleted_event = ChannelDeletedEvent.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.channel_updated_event = ChannelUpdatedEvent.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.last_pin_message_event = LastPinMessageEvent.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.custom_status_event = CustomStatusEvent.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.user_channel_added_event = UserChannelAdded.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.user_channel_removed_event = UserChannelRemoved.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.user_clan_removed_event = UserClanRemoved.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.clan_updated_event = ClanUpdatedEvent.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.clan_profile_updated_event = ClanProfileUpdatedEvent.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.clan_name_existed_event = ClanNameExistedEvent.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.user_profile_updated_event = UserProfileUpdatedEvent.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.emojis_listed_event = EmojiListedEvent.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.sticker_listed_event = StrickerListedEvent.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.channel_desc_list_event = ChannelDescListEvent.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.hashtag_dm_list_event = HashtagDmListEvent.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.notification_channel_setting_event = NotificationChannelSettingEvent.decode(reader, reader.uint32());
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.notification_category_setting_event = NotificationCategorySettingEvent.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.notification_clan_setting_event = NotificationClanSettingEvent.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.notifi_react_message_event = NotifiReactMessageEvent.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.permission_role_channel_list_event = PermissionRoleChannelListEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Envelope {
    return {
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined,
      clan_join: isSet(object.clan_join) ? ClanJoin.fromJSON(object.clan_join) : undefined,
      channel_join: isSet(object.channel_join) ? ChannelJoin.fromJSON(object.channel_join) : undefined,
      channel_leave: isSet(object.channel_leave) ? ChannelLeave.fromJSON(object.channel_leave) : undefined,
      channel_message: isSet(object.channel_message) ? ChannelMessage.fromJSON(object.channel_message) : undefined,
      channel_message_ack: isSet(object.channel_message_ack)
        ? ChannelMessageAck.fromJSON(object.channel_message_ack)
        : undefined,
      channel_message_send: isSet(object.channel_message_send)
        ? ChannelMessageSend.fromJSON(object.channel_message_send)
        : undefined,
      channel_message_update: isSet(object.channel_message_update)
        ? ChannelMessageUpdate.fromJSON(object.channel_message_update)
        : undefined,
      channel_message_remove: isSet(object.channel_message_remove)
        ? ChannelMessageRemove.fromJSON(object.channel_message_remove)
        : undefined,
      channel_presence_event: isSet(object.channel_presence_event)
        ? ChannelPresenceEvent.fromJSON(object.channel_presence_event)
        : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      notifications: isSet(object.notifications) ? Notifications.fromJSON(object.notifications) : undefined,
      rpc: isSet(object.rpc) ? Rpc.fromJSON(object.rpc) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      status_follow: isSet(object.status_follow) ? StatusFollow.fromJSON(object.status_follow) : undefined,
      status_presence_event: isSet(object.status_presence_event)
        ? StatusPresenceEvent.fromJSON(object.status_presence_event)
        : undefined,
      status_unfollow: isSet(object.status_unfollow) ? StatusUnfollow.fromJSON(object.status_unfollow) : undefined,
      status_update: isSet(object.status_update) ? StatusUpdate.fromJSON(object.status_update) : undefined,
      stream_data: isSet(object.stream_data) ? StreamData.fromJSON(object.stream_data) : undefined,
      stream_presence_event: isSet(object.stream_presence_event)
        ? StreamPresenceEvent.fromJSON(object.stream_presence_event)
        : undefined,
      ping: isSet(object.ping) ? Ping.fromJSON(object.ping) : undefined,
      pong: isSet(object.pong) ? Pong.fromJSON(object.pong) : undefined,
      message_typing_event: isSet(object.message_typing_event)
        ? MessageTypingEvent.fromJSON(object.message_typing_event)
        : undefined,
      last_seen_message_event: isSet(object.last_seen_message_event)
        ? LastSeenMessageEvent.fromJSON(object.last_seen_message_event)
        : undefined,
      message_reaction_event: isSet(object.message_reaction_event)
        ? MessageReaction.fromJSON(object.message_reaction_event)
        : undefined,
      voice_joined_event: isSet(object.voice_joined_event)
        ? VoiceJoinedEvent.fromJSON(object.voice_joined_event)
        : undefined,
      voice_leaved_event: isSet(object.voice_leaved_event)
        ? VoiceLeavedEvent.fromJSON(object.voice_leaved_event)
        : undefined,
      voice_started_event: isSet(object.voice_started_event)
        ? VoiceStartedEvent.fromJSON(object.voice_started_event)
        : undefined,
      voice_ended_event: isSet(object.voice_ended_event)
        ? VoiceEndedEvent.fromJSON(object.voice_ended_event)
        : undefined,
      channel_created_event: isSet(object.channel_created_event)
        ? ChannelCreatedEvent.fromJSON(object.channel_created_event)
        : undefined,
      channel_deleted_event: isSet(object.channel_deleted_event)
        ? ChannelDeletedEvent.fromJSON(object.channel_deleted_event)
        : undefined,
      channel_updated_event: isSet(object.channel_updated_event)
        ? ChannelUpdatedEvent.fromJSON(object.channel_updated_event)
        : undefined,
      last_pin_message_event: isSet(object.last_pin_message_event)
        ? LastPinMessageEvent.fromJSON(object.last_pin_message_event)
        : undefined,
      custom_status_event: isSet(object.custom_status_event)
        ? CustomStatusEvent.fromJSON(object.custom_status_event)
        : undefined,
      user_channel_added_event: isSet(object.user_channel_added_event)
        ? UserChannelAdded.fromJSON(object.user_channel_added_event)
        : undefined,
      user_channel_removed_event: isSet(object.user_channel_removed_event)
        ? UserChannelRemoved.fromJSON(object.user_channel_removed_event)
        : undefined,
      user_clan_removed_event: isSet(object.user_clan_removed_event)
        ? UserClanRemoved.fromJSON(object.user_clan_removed_event)
        : undefined,
      clan_updated_event: isSet(object.clan_updated_event)
        ? ClanUpdatedEvent.fromJSON(object.clan_updated_event)
        : undefined,
      clan_profile_updated_event: isSet(object.clan_profile_updated_event)
        ? ClanProfileUpdatedEvent.fromJSON(object.clan_profile_updated_event)
        : undefined,
      clan_name_existed_event: isSet(object.clan_name_existed_event)
        ? ClanNameExistedEvent.fromJSON(object.clan_name_existed_event)
        : undefined,
      user_profile_updated_event: isSet(object.user_profile_updated_event)
        ? UserProfileUpdatedEvent.fromJSON(object.user_profile_updated_event)
        : undefined,
      emojis_listed_event: isSet(object.emojis_listed_event)
        ? EmojiListedEvent.fromJSON(object.emojis_listed_event)
        : undefined,
      sticker_listed_event: isSet(object.sticker_listed_event)
        ? StrickerListedEvent.fromJSON(object.sticker_listed_event)
        : undefined,
      channel_desc_list_event: isSet(object.channel_desc_list_event)
        ? ChannelDescListEvent.fromJSON(object.channel_desc_list_event)
        : undefined,
      hashtag_dm_list_event: isSet(object.hashtag_dm_list_event)
        ? HashtagDmListEvent.fromJSON(object.hashtag_dm_list_event)
        : undefined,
      notification_channel_setting_event: isSet(object.notification_channel_setting_event)
        ? NotificationChannelSettingEvent.fromJSON(object.notification_channel_setting_event)
        : undefined,
      notification_category_setting_event: isSet(object.notification_category_setting_event)
        ? NotificationCategorySettingEvent.fromJSON(object.notification_category_setting_event)
        : undefined,
      notification_clan_setting_event: isSet(object.notification_clan_setting_event)
        ? NotificationClanSettingEvent.fromJSON(object.notification_clan_setting_event)
        : undefined,
      notifi_react_message_event: isSet(object.notifi_react_message_event)
        ? NotifiReactMessageEvent.fromJSON(object.notifi_react_message_event)
        : undefined,
      permission_role_channel_list_event: isSet(object.permission_role_channel_list_event)
        ? PermissionRoleChannelListEvent.fromJSON(object.permission_role_channel_list_event)
        : undefined,
    };
  },

  toJSON(message: Envelope): unknown {
    const obj: any = {};
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.channel !== undefined) {
      obj.channel = Channel.toJSON(message.channel);
    }
    if (message.clan_join !== undefined) {
      obj.clan_join = ClanJoin.toJSON(message.clan_join);
    }
    if (message.channel_join !== undefined) {
      obj.channel_join = ChannelJoin.toJSON(message.channel_join);
    }
    if (message.channel_leave !== undefined) {
      obj.channel_leave = ChannelLeave.toJSON(message.channel_leave);
    }
    if (message.channel_message !== undefined) {
      obj.channel_message = ChannelMessage.toJSON(message.channel_message);
    }
    if (message.channel_message_ack !== undefined) {
      obj.channel_message_ack = ChannelMessageAck.toJSON(message.channel_message_ack);
    }
    if (message.channel_message_send !== undefined) {
      obj.channel_message_send = ChannelMessageSend.toJSON(message.channel_message_send);
    }
    if (message.channel_message_update !== undefined) {
      obj.channel_message_update = ChannelMessageUpdate.toJSON(message.channel_message_update);
    }
    if (message.channel_message_remove !== undefined) {
      obj.channel_message_remove = ChannelMessageRemove.toJSON(message.channel_message_remove);
    }
    if (message.channel_presence_event !== undefined) {
      obj.channel_presence_event = ChannelPresenceEvent.toJSON(message.channel_presence_event);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.notifications !== undefined) {
      obj.notifications = Notifications.toJSON(message.notifications);
    }
    if (message.rpc !== undefined) {
      obj.rpc = Rpc.toJSON(message.rpc);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.status_follow !== undefined) {
      obj.status_follow = StatusFollow.toJSON(message.status_follow);
    }
    if (message.status_presence_event !== undefined) {
      obj.status_presence_event = StatusPresenceEvent.toJSON(message.status_presence_event);
    }
    if (message.status_unfollow !== undefined) {
      obj.status_unfollow = StatusUnfollow.toJSON(message.status_unfollow);
    }
    if (message.status_update !== undefined) {
      obj.status_update = StatusUpdate.toJSON(message.status_update);
    }
    if (message.stream_data !== undefined) {
      obj.stream_data = StreamData.toJSON(message.stream_data);
    }
    if (message.stream_presence_event !== undefined) {
      obj.stream_presence_event = StreamPresenceEvent.toJSON(message.stream_presence_event);
    }
    if (message.ping !== undefined) {
      obj.ping = Ping.toJSON(message.ping);
    }
    if (message.pong !== undefined) {
      obj.pong = Pong.toJSON(message.pong);
    }
    if (message.message_typing_event !== undefined) {
      obj.message_typing_event = MessageTypingEvent.toJSON(message.message_typing_event);
    }
    if (message.last_seen_message_event !== undefined) {
      obj.last_seen_message_event = LastSeenMessageEvent.toJSON(message.last_seen_message_event);
    }
    if (message.message_reaction_event !== undefined) {
      obj.message_reaction_event = MessageReaction.toJSON(message.message_reaction_event);
    }
    if (message.voice_joined_event !== undefined) {
      obj.voice_joined_event = VoiceJoinedEvent.toJSON(message.voice_joined_event);
    }
    if (message.voice_leaved_event !== undefined) {
      obj.voice_leaved_event = VoiceLeavedEvent.toJSON(message.voice_leaved_event);
    }
    if (message.voice_started_event !== undefined) {
      obj.voice_started_event = VoiceStartedEvent.toJSON(message.voice_started_event);
    }
    if (message.voice_ended_event !== undefined) {
      obj.voice_ended_event = VoiceEndedEvent.toJSON(message.voice_ended_event);
    }
    if (message.channel_created_event !== undefined) {
      obj.channel_created_event = ChannelCreatedEvent.toJSON(message.channel_created_event);
    }
    if (message.channel_deleted_event !== undefined) {
      obj.channel_deleted_event = ChannelDeletedEvent.toJSON(message.channel_deleted_event);
    }
    if (message.channel_updated_event !== undefined) {
      obj.channel_updated_event = ChannelUpdatedEvent.toJSON(message.channel_updated_event);
    }
    if (message.last_pin_message_event !== undefined) {
      obj.last_pin_message_event = LastPinMessageEvent.toJSON(message.last_pin_message_event);
    }
    if (message.custom_status_event !== undefined) {
      obj.custom_status_event = CustomStatusEvent.toJSON(message.custom_status_event);
    }
    if (message.user_channel_added_event !== undefined) {
      obj.user_channel_added_event = UserChannelAdded.toJSON(message.user_channel_added_event);
    }
    if (message.user_channel_removed_event !== undefined) {
      obj.user_channel_removed_event = UserChannelRemoved.toJSON(message.user_channel_removed_event);
    }
    if (message.user_clan_removed_event !== undefined) {
      obj.user_clan_removed_event = UserClanRemoved.toJSON(message.user_clan_removed_event);
    }
    if (message.clan_updated_event !== undefined) {
      obj.clan_updated_event = ClanUpdatedEvent.toJSON(message.clan_updated_event);
    }
    if (message.clan_profile_updated_event !== undefined) {
      obj.clan_profile_updated_event = ClanProfileUpdatedEvent.toJSON(message.clan_profile_updated_event);
    }
    if (message.clan_name_existed_event !== undefined) {
      obj.clan_name_existed_event = ClanNameExistedEvent.toJSON(message.clan_name_existed_event);
    }
    if (message.user_profile_updated_event !== undefined) {
      obj.user_profile_updated_event = UserProfileUpdatedEvent.toJSON(message.user_profile_updated_event);
    }
    if (message.emojis_listed_event !== undefined) {
      obj.emojis_listed_event = EmojiListedEvent.toJSON(message.emojis_listed_event);
    }
    if (message.sticker_listed_event !== undefined) {
      obj.sticker_listed_event = StrickerListedEvent.toJSON(message.sticker_listed_event);
    }
    if (message.channel_desc_list_event !== undefined) {
      obj.channel_desc_list_event = ChannelDescListEvent.toJSON(message.channel_desc_list_event);
    }
    if (message.hashtag_dm_list_event !== undefined) {
      obj.hashtag_dm_list_event = HashtagDmListEvent.toJSON(message.hashtag_dm_list_event);
    }
    if (message.notification_channel_setting_event !== undefined) {
      obj.notification_channel_setting_event = NotificationChannelSettingEvent.toJSON(
        message.notification_channel_setting_event,
      );
    }
    if (message.notification_category_setting_event !== undefined) {
      obj.notification_category_setting_event = NotificationCategorySettingEvent.toJSON(
        message.notification_category_setting_event,
      );
    }
    if (message.notification_clan_setting_event !== undefined) {
      obj.notification_clan_setting_event = NotificationClanSettingEvent.toJSON(
        message.notification_clan_setting_event,
      );
    }
    if (message.notifi_react_message_event !== undefined) {
      obj.notifi_react_message_event = NotifiReactMessageEvent.toJSON(message.notifi_react_message_event);
    }
    if (message.permission_role_channel_list_event !== undefined) {
      obj.permission_role_channel_list_event = PermissionRoleChannelListEvent.toJSON(
        message.permission_role_channel_list_event,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Envelope>, I>>(base?: I): Envelope {
    return Envelope.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Envelope>, I>>(object: I): Envelope {
    const message = createBaseEnvelope();
    message.cid = object.cid ?? "";
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? Channel.fromPartial(object.channel)
      : undefined;
    message.clan_join = (object.clan_join !== undefined && object.clan_join !== null)
      ? ClanJoin.fromPartial(object.clan_join)
      : undefined;
    message.channel_join = (object.channel_join !== undefined && object.channel_join !== null)
      ? ChannelJoin.fromPartial(object.channel_join)
      : undefined;
    message.channel_leave = (object.channel_leave !== undefined && object.channel_leave !== null)
      ? ChannelLeave.fromPartial(object.channel_leave)
      : undefined;
    message.channel_message = (object.channel_message !== undefined && object.channel_message !== null)
      ? ChannelMessage.fromPartial(object.channel_message)
      : undefined;
    message.channel_message_ack = (object.channel_message_ack !== undefined && object.channel_message_ack !== null)
      ? ChannelMessageAck.fromPartial(object.channel_message_ack)
      : undefined;
    message.channel_message_send = (object.channel_message_send !== undefined && object.channel_message_send !== null)
      ? ChannelMessageSend.fromPartial(object.channel_message_send)
      : undefined;
    message.channel_message_update =
      (object.channel_message_update !== undefined && object.channel_message_update !== null)
        ? ChannelMessageUpdate.fromPartial(object.channel_message_update)
        : undefined;
    message.channel_message_remove =
      (object.channel_message_remove !== undefined && object.channel_message_remove !== null)
        ? ChannelMessageRemove.fromPartial(object.channel_message_remove)
        : undefined;
    message.channel_presence_event =
      (object.channel_presence_event !== undefined && object.channel_presence_event !== null)
        ? ChannelPresenceEvent.fromPartial(object.channel_presence_event)
        : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.notifications = (object.notifications !== undefined && object.notifications !== null)
      ? Notifications.fromPartial(object.notifications)
      : undefined;
    message.rpc = (object.rpc !== undefined && object.rpc !== null) ? Rpc.fromPartial(object.rpc) : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.status_follow = (object.status_follow !== undefined && object.status_follow !== null)
      ? StatusFollow.fromPartial(object.status_follow)
      : undefined;
    message.status_presence_event =
      (object.status_presence_event !== undefined && object.status_presence_event !== null)
        ? StatusPresenceEvent.fromPartial(object.status_presence_event)
        : undefined;
    message.status_unfollow = (object.status_unfollow !== undefined && object.status_unfollow !== null)
      ? StatusUnfollow.fromPartial(object.status_unfollow)
      : undefined;
    message.status_update = (object.status_update !== undefined && object.status_update !== null)
      ? StatusUpdate.fromPartial(object.status_update)
      : undefined;
    message.stream_data = (object.stream_data !== undefined && object.stream_data !== null)
      ? StreamData.fromPartial(object.stream_data)
      : undefined;
    message.stream_presence_event =
      (object.stream_presence_event !== undefined && object.stream_presence_event !== null)
        ? StreamPresenceEvent.fromPartial(object.stream_presence_event)
        : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    message.pong = (object.pong !== undefined && object.pong !== null) ? Pong.fromPartial(object.pong) : undefined;
    message.message_typing_event = (object.message_typing_event !== undefined && object.message_typing_event !== null)
      ? MessageTypingEvent.fromPartial(object.message_typing_event)
      : undefined;
    message.last_seen_message_event =
      (object.last_seen_message_event !== undefined && object.last_seen_message_event !== null)
        ? LastSeenMessageEvent.fromPartial(object.last_seen_message_event)
        : undefined;
    message.message_reaction_event =
      (object.message_reaction_event !== undefined && object.message_reaction_event !== null)
        ? MessageReaction.fromPartial(object.message_reaction_event)
        : undefined;
    message.voice_joined_event = (object.voice_joined_event !== undefined && object.voice_joined_event !== null)
      ? VoiceJoinedEvent.fromPartial(object.voice_joined_event)
      : undefined;
    message.voice_leaved_event = (object.voice_leaved_event !== undefined && object.voice_leaved_event !== null)
      ? VoiceLeavedEvent.fromPartial(object.voice_leaved_event)
      : undefined;
    message.voice_started_event = (object.voice_started_event !== undefined && object.voice_started_event !== null)
      ? VoiceStartedEvent.fromPartial(object.voice_started_event)
      : undefined;
    message.voice_ended_event = (object.voice_ended_event !== undefined && object.voice_ended_event !== null)
      ? VoiceEndedEvent.fromPartial(object.voice_ended_event)
      : undefined;
    message.channel_created_event =
      (object.channel_created_event !== undefined && object.channel_created_event !== null)
        ? ChannelCreatedEvent.fromPartial(object.channel_created_event)
        : undefined;
    message.channel_deleted_event =
      (object.channel_deleted_event !== undefined && object.channel_deleted_event !== null)
        ? ChannelDeletedEvent.fromPartial(object.channel_deleted_event)
        : undefined;
    message.channel_updated_event =
      (object.channel_updated_event !== undefined && object.channel_updated_event !== null)
        ? ChannelUpdatedEvent.fromPartial(object.channel_updated_event)
        : undefined;
    message.last_pin_message_event =
      (object.last_pin_message_event !== undefined && object.last_pin_message_event !== null)
        ? LastPinMessageEvent.fromPartial(object.last_pin_message_event)
        : undefined;
    message.custom_status_event = (object.custom_status_event !== undefined && object.custom_status_event !== null)
      ? CustomStatusEvent.fromPartial(object.custom_status_event)
      : undefined;
    message.user_channel_added_event =
      (object.user_channel_added_event !== undefined && object.user_channel_added_event !== null)
        ? UserChannelAdded.fromPartial(object.user_channel_added_event)
        : undefined;
    message.user_channel_removed_event =
      (object.user_channel_removed_event !== undefined && object.user_channel_removed_event !== null)
        ? UserChannelRemoved.fromPartial(object.user_channel_removed_event)
        : undefined;
    message.user_clan_removed_event =
      (object.user_clan_removed_event !== undefined && object.user_clan_removed_event !== null)
        ? UserClanRemoved.fromPartial(object.user_clan_removed_event)
        : undefined;
    message.clan_updated_event = (object.clan_updated_event !== undefined && object.clan_updated_event !== null)
      ? ClanUpdatedEvent.fromPartial(object.clan_updated_event)
      : undefined;
    message.clan_profile_updated_event =
      (object.clan_profile_updated_event !== undefined && object.clan_profile_updated_event !== null)
        ? ClanProfileUpdatedEvent.fromPartial(object.clan_profile_updated_event)
        : undefined;
    message.clan_name_existed_event =
      (object.clan_name_existed_event !== undefined && object.clan_name_existed_event !== null)
        ? ClanNameExistedEvent.fromPartial(object.clan_name_existed_event)
        : undefined;
    message.user_profile_updated_event =
      (object.user_profile_updated_event !== undefined && object.user_profile_updated_event !== null)
        ? UserProfileUpdatedEvent.fromPartial(object.user_profile_updated_event)
        : undefined;
    message.emojis_listed_event = (object.emojis_listed_event !== undefined && object.emojis_listed_event !== null)
      ? EmojiListedEvent.fromPartial(object.emojis_listed_event)
      : undefined;
    message.sticker_listed_event = (object.sticker_listed_event !== undefined && object.sticker_listed_event !== null)
      ? StrickerListedEvent.fromPartial(object.sticker_listed_event)
      : undefined;
    message.channel_desc_list_event =
      (object.channel_desc_list_event !== undefined && object.channel_desc_list_event !== null)
        ? ChannelDescListEvent.fromPartial(object.channel_desc_list_event)
        : undefined;
    message.hashtag_dm_list_event =
      (object.hashtag_dm_list_event !== undefined && object.hashtag_dm_list_event !== null)
        ? HashtagDmListEvent.fromPartial(object.hashtag_dm_list_event)
        : undefined;
    message.notification_channel_setting_event =
      (object.notification_channel_setting_event !== undefined && object.notification_channel_setting_event !== null)
        ? NotificationChannelSettingEvent.fromPartial(object.notification_channel_setting_event)
        : undefined;
    message.notification_category_setting_event =
      (object.notification_category_setting_event !== undefined && object.notification_category_setting_event !== null)
        ? NotificationCategorySettingEvent.fromPartial(object.notification_category_setting_event)
        : undefined;
    message.notification_clan_setting_event =
      (object.notification_clan_setting_event !== undefined && object.notification_clan_setting_event !== null)
        ? NotificationClanSettingEvent.fromPartial(object.notification_clan_setting_event)
        : undefined;
    message.notifi_react_message_event =
      (object.notifi_react_message_event !== undefined && object.notifi_react_message_event !== null)
        ? NotifiReactMessageEvent.fromPartial(object.notifi_react_message_event)
        : undefined;
    message.permission_role_channel_list_event =
      (object.permission_role_channel_list_event !== undefined && object.permission_role_channel_list_event !== null)
        ? PermissionRoleChannelListEvent.fromPartial(object.permission_role_channel_list_event)
        : undefined;
    return message;
  },
};

function createBasePermissionRoleChannelListEvent(): PermissionRoleChannelListEvent {
  return { role_id: "", channel_id: "", permission_role_channel: [] };
}

export const PermissionRoleChannelListEvent = {
  encode(message: PermissionRoleChannelListEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role_id !== "") {
      writer.uint32(10).string(message.role_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    for (const v of message.permission_role_channel) {
      PermissionRoleChannel.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionRoleChannelListEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionRoleChannelListEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.permission_role_channel.push(PermissionRoleChannel.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionRoleChannelListEvent {
    return {
      role_id: isSet(object.role_id) ? globalThis.String(object.role_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      permission_role_channel: globalThis.Array.isArray(object?.permission_role_channel)
        ? object.permission_role_channel.map((e: any) => PermissionRoleChannel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PermissionRoleChannelListEvent): unknown {
    const obj: any = {};
    if (message.role_id !== "") {
      obj.role_id = message.role_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.permission_role_channel?.length) {
      obj.permission_role_channel = message.permission_role_channel.map((e) => PermissionRoleChannel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionRoleChannelListEvent>, I>>(base?: I): PermissionRoleChannelListEvent {
    return PermissionRoleChannelListEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionRoleChannelListEvent>, I>>(
    object: I,
  ): PermissionRoleChannelListEvent {
    const message = createBasePermissionRoleChannelListEvent();
    message.role_id = object.role_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.permission_role_channel =
      object.permission_role_channel?.map((e) => PermissionRoleChannel.fromPartial(e)) || [];
    return message;
  },
};

function createBasePermissionRoleChannel(): PermissionRoleChannel {
  return { permission_id: "", active: false };
}

export const PermissionRoleChannel = {
  encode(message: PermissionRoleChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permission_id !== "") {
      writer.uint32(10).string(message.permission_id);
    }
    if (message.active !== false) {
      writer.uint32(16).bool(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionRoleChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionRoleChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permission_id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.active = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionRoleChannel {
    return {
      permission_id: isSet(object.permission_id) ? globalThis.String(object.permission_id) : "",
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
    };
  },

  toJSON(message: PermissionRoleChannel): unknown {
    const obj: any = {};
    if (message.permission_id !== "") {
      obj.permission_id = message.permission_id;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionRoleChannel>, I>>(base?: I): PermissionRoleChannel {
    return PermissionRoleChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionRoleChannel>, I>>(object: I): PermissionRoleChannel {
    const message = createBasePermissionRoleChannel();
    message.permission_id = object.permission_id ?? "";
    message.active = object.active ?? false;
    return message;
  },
};

function createBaseHashtagDmListEvent(): HashtagDmListEvent {
  return { user_id: [], limit: undefined, hashtag_dm: [] };
}

export const HashtagDmListEvent = {
  encode(message: HashtagDmListEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_id) {
      writer.uint32(10).string(v!);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.hashtag_dm) {
      HashtagDm.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashtagDmListEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtagDmListEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hashtag_dm.push(HashtagDm.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashtagDmListEvent {
    return {
      user_id: globalThis.Array.isArray(object?.user_id) ? object.user_id.map((e: any) => globalThis.String(e)) : [],
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      hashtag_dm: globalThis.Array.isArray(object?.hashtag_dm)
        ? object.hashtag_dm.map((e: any) => HashtagDm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HashtagDmListEvent): unknown {
    const obj: any = {};
    if (message.user_id?.length) {
      obj.user_id = message.user_id;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.hashtag_dm?.length) {
      obj.hashtag_dm = message.hashtag_dm.map((e) => HashtagDm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashtagDmListEvent>, I>>(base?: I): HashtagDmListEvent {
    return HashtagDmListEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashtagDmListEvent>, I>>(object: I): HashtagDmListEvent {
    const message = createBaseHashtagDmListEvent();
    message.user_id = object.user_id?.map((e) => e) || [];
    message.limit = object.limit ?? undefined;
    message.hashtag_dm = object.hashtag_dm?.map((e) => HashtagDm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHashtagDm(): HashtagDm {
  return {
    channel_id: "",
    channel_label: "",
    clan_id: "",
    clan_name: "",
    meeting_code: "",
    type: 0,
    channel_private: 0,
    parrent_id: "",
  };
}

export const HashtagDm = {
  encode(message: HashtagDm, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(18).string(message.channel_label);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(34).string(message.clan_name);
    }
    if (message.meeting_code !== "") {
      writer.uint32(42).string(message.meeting_code);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.channel_private !== 0) {
      writer.uint32(56).int32(message.channel_private);
    }
    if (message.parrent_id !== "") {
      writer.uint32(66).string(message.parrent_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashtagDm {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtagDm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashtagDm {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
    };
  },

  toJSON(message: HashtagDm): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashtagDm>, I>>(base?: I): HashtagDm {
    return HashtagDm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashtagDm>, I>>(object: I): HashtagDm {
    const message = createBaseHashtagDm();
    message.channel_id = object.channel_id ?? "";
    message.channel_label = object.channel_label ?? "";
    message.clan_id = object.clan_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.meeting_code = object.meeting_code ?? "";
    message.type = object.type ?? 0;
    message.channel_private = object.channel_private ?? 0;
    message.parrent_id = object.parrent_id ?? "";
    return message;
  },
};

function createBaseChannelDescListEvent(): ChannelDescListEvent {
  return { channeldesc: [] };
}

export const ChannelDescListEvent = {
  encode(message: ChannelDescListEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.channeldesc) {
      ChannelDescription.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDescListEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDescListEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channeldesc.push(ChannelDescription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDescListEvent {
    return {
      channeldesc: globalThis.Array.isArray(object?.channeldesc)
        ? object.channeldesc.map((e: any) => ChannelDescription.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChannelDescListEvent): unknown {
    const obj: any = {};
    if (message.channeldesc?.length) {
      obj.channeldesc = message.channeldesc.map((e) => ChannelDescription.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDescListEvent>, I>>(base?: I): ChannelDescListEvent {
    return ChannelDescListEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDescListEvent>, I>>(object: I): ChannelDescListEvent {
    const message = createBaseChannelDescListEvent();
    message.channeldesc = object.channeldesc?.map((e) => ChannelDescription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannelDescription(): ChannelDescription {
  return {
    clan_id: "",
    channel_id: "",
    type: undefined,
    channel_label: "",
    channel_private: 0,
    meeting_code: "",
    clan_name: "",
    parrent_id: "",
  };
}

export const ChannelDescription = {
  encode(message: ChannelDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.type !== undefined) {
      Int32Value.encode({ value: message.type! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.channel_label !== "") {
      writer.uint32(34).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(40).int32(message.channel_private);
    }
    if (message.meeting_code !== "") {
      writer.uint32(50).string(message.meeting_code);
    }
    if (message.clan_name !== "") {
      writer.uint32(58).string(message.clan_name);
    }
    if (message.parrent_id !== "") {
      writer.uint32(66).string(message.parrent_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.meeting_code = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDescription {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      type: isSet(object.type) ? Number(object.type) : undefined,
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      meeting_code: isSet(object.meeting_code) ? globalThis.String(object.meeting_code) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
    };
  },

  toJSON(message: ChannelDescription): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.meeting_code !== "") {
      obj.meeting_code = message.meeting_code;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDescription>, I>>(base?: I): ChannelDescription {
    return ChannelDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDescription>, I>>(object: I): ChannelDescription {
    const message = createBaseChannelDescription();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.type = object.type ?? undefined;
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.meeting_code = object.meeting_code ?? "";
    message.clan_name = object.clan_name ?? "";
    message.parrent_id = object.parrent_id ?? "";
    return message;
  },
};

function createBaseStrickerListedEvent(): StrickerListedEvent {
  return { clan_id: "", stickers: [] };
}

export const StrickerListedEvent = {
  encode(message: StrickerListedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    for (const v of message.stickers) {
      ClanSticker.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StrickerListedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrickerListedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stickers.push(ClanSticker.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrickerListedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      stickers: globalThis.Array.isArray(object?.stickers)
        ? object.stickers.map((e: any) => ClanSticker.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StrickerListedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.stickers?.length) {
      obj.stickers = message.stickers.map((e) => ClanSticker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StrickerListedEvent>, I>>(base?: I): StrickerListedEvent {
    return StrickerListedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StrickerListedEvent>, I>>(object: I): StrickerListedEvent {
    const message = createBaseStrickerListedEvent();
    message.clan_id = object.clan_id ?? "";
    message.stickers = object.stickers?.map((e) => ClanSticker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClanSticker(): ClanSticker {
  return { id: "", source: "", shortname: "", category: "", creator_id: "", create_time: undefined, clan_id: "" };
}

export const ClanSticker = {
  encode(message: ClanSticker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.shortname !== "") {
      writer.uint32(26).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.creator_id !== "") {
      writer.uint32(42).string(message.creator_id);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.clan_id !== "") {
      writer.uint32(58).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanSticker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanSticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanSticker {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanSticker): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanSticker>, I>>(base?: I): ClanSticker {
    return ClanSticker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanSticker>, I>>(object: I): ClanSticker {
    const message = createBaseClanSticker();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.creator_id = object.creator_id ?? "";
    message.create_time = object.create_time ?? undefined;
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseClanEmoji(): ClanEmoji {
  return { id: "", src: "", shortname: "", category: "", creator_id: "" };
}

export const ClanEmoji = {
  encode(message: ClanEmoji, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.src !== "") {
      writer.uint32(18).string(message.src);
    }
    if (message.shortname !== "") {
      writer.uint32(26).string(message.shortname);
    }
    if (message.category !== "") {
      writer.uint32(34).string(message.category);
    }
    if (message.creator_id !== "") {
      writer.uint32(42).string(message.creator_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanEmoji {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanEmoji();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.src = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shortname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanEmoji {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      src: isSet(object.src) ? globalThis.String(object.src) : "",
      shortname: isSet(object.shortname) ? globalThis.String(object.shortname) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
    };
  },

  toJSON(message: ClanEmoji): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.src !== "") {
      obj.src = message.src;
    }
    if (message.shortname !== "") {
      obj.shortname = message.shortname;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanEmoji>, I>>(base?: I): ClanEmoji {
    return ClanEmoji.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanEmoji>, I>>(object: I): ClanEmoji {
    const message = createBaseClanEmoji();
    message.id = object.id ?? "";
    message.src = object.src ?? "";
    message.shortname = object.shortname ?? "";
    message.category = object.category ?? "";
    message.creator_id = object.creator_id ?? "";
    return message;
  },
};

function createBaseEmojiListedEvent(): EmojiListedEvent {
  return { clan_id: "", emoji_list: [] };
}

export const EmojiListedEvent = {
  encode(message: EmojiListedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    for (const v of message.emoji_list) {
      ClanEmoji.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmojiListedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmojiListedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.emoji_list.push(ClanEmoji.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmojiListedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      emoji_list: globalThis.Array.isArray(object?.emoji_list)
        ? object.emoji_list.map((e: any) => ClanEmoji.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EmojiListedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.emoji_list?.length) {
      obj.emoji_list = message.emoji_list.map((e) => ClanEmoji.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmojiListedEvent>, I>>(base?: I): EmojiListedEvent {
    return EmojiListedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmojiListedEvent>, I>>(object: I): EmojiListedEvent {
    const message = createBaseEmojiListedEvent();
    message.clan_id = object.clan_id ?? "";
    message.emoji_list = object.emoji_list?.map((e) => ClanEmoji.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannel(): Channel {
  return { id: "", presences: [], self: undefined, chanel_label: "", clan_logo: "", category_name: "" };
}

export const Channel = {
  encode(message: Channel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.presences) {
      UserPresence.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.self !== undefined) {
      UserPresence.encode(message.self, writer.uint32(26).fork()).ldelim();
    }
    if (message.chanel_label !== "") {
      writer.uint32(34).string(message.chanel_label);
    }
    if (message.clan_logo !== "") {
      writer.uint32(42).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(50).string(message.category_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Channel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.presences.push(UserPresence.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.self = UserPresence.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chanel_label = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.category_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      presences: globalThis.Array.isArray(object?.presences)
        ? object.presences.map((e: any) => UserPresence.fromJSON(e))
        : [],
      self: isSet(object.self) ? UserPresence.fromJSON(object.self) : undefined,
      chanel_label: isSet(object.chanel_label) ? globalThis.String(object.chanel_label) : "",
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.presences?.length) {
      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));
    }
    if (message.self !== undefined) {
      obj.self = UserPresence.toJSON(message.self);
    }
    if (message.chanel_label !== "") {
      obj.chanel_label = message.chanel_label;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Channel>, I>>(base?: I): Channel {
    return Channel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel>, I>>(object: I): Channel {
    const message = createBaseChannel();
    message.id = object.id ?? "";
    message.presences = object.presences?.map((e) => UserPresence.fromPartial(e)) || [];
    message.self = (object.self !== undefined && object.self !== null)
      ? UserPresence.fromPartial(object.self)
      : undefined;
    message.chanel_label = object.chanel_label ?? "";
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    return message;
  },
};

function createBaseClanJoin(): ClanJoin {
  return { clan_id: "" };
}

export const ClanJoin = {
  encode(message: ClanJoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanJoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanJoin {
    return { clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "" };
  },

  toJSON(message: ClanJoin): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanJoin>, I>>(base?: I): ClanJoin {
    return ClanJoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanJoin>, I>>(object: I): ClanJoin {
    const message = createBaseClanJoin();
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseChannelJoin(): ChannelJoin {
  return { clan_id: "", channel_id: "", channel_type: 0 };
}

export const ChannelJoin = {
  encode(message: ChannelJoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(24).int32(message.channel_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelJoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelJoin {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
    };
  },

  toJSON(message: ChannelJoin): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelJoin>, I>>(base?: I): ChannelJoin {
    return ChannelJoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelJoin>, I>>(object: I): ChannelJoin {
    const message = createBaseChannelJoin();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_type = object.channel_type ?? 0;
    return message;
  },
};

function createBaseChannelLeave(): ChannelLeave {
  return { clan_id: "", channel_id: "", channel_type: 0 };
}

export const ChannelLeave = {
  encode(message: ChannelLeave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(24).int32(message.channel_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelLeave {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelLeave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelLeave {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
    };
  },

  toJSON(message: ChannelLeave): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelLeave>, I>>(base?: I): ChannelLeave {
    return ChannelLeave.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelLeave>, I>>(object: I): ChannelLeave {
    const message = createBaseChannelLeave();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_type = object.channel_type ?? 0;
    return message;
  },
};

function createBaseChannelMessageAck(): ChannelMessageAck {
  return {
    channel_id: "",
    message_id: "",
    code: undefined,
    username: "",
    create_time: undefined,
    update_time: undefined,
    persistent: undefined,
    clan_logo: "",
    category_name: "",
  };
}

export const ChannelMessageAck = {
  encode(message: ChannelMessageAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(18).string(message.message_id);
    }
    if (message.code !== undefined) {
      Int32Value.encode({ value: message.code! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(42).fork()).ldelim();
    }
    if (message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.persistent !== undefined) {
      BoolValue.encode({ value: message.persistent! }, writer.uint32(58).fork()).ldelim();
    }
    if (message.clan_logo !== "") {
      writer.uint32(66).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(74).string(message.category_name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.code = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.persistent = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.category_name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageAck {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      code: isSet(object.code) ? Number(object.code) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      create_time: isSet(object.create_time) ? fromJsonTimestamp(object.create_time) : undefined,
      update_time: isSet(object.update_time) ? fromJsonTimestamp(object.update_time) : undefined,
      persistent: isSet(object.persistent) ? Boolean(object.persistent) : undefined,
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
    };
  },

  toJSON(message: ChannelMessageAck): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.create_time !== undefined) {
      obj.create_time = message.create_time.toISOString();
    }
    if (message.update_time !== undefined) {
      obj.update_time = message.update_time.toISOString();
    }
    if (message.persistent !== undefined) {
      obj.persistent = message.persistent;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageAck>, I>>(base?: I): ChannelMessageAck {
    return ChannelMessageAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageAck>, I>>(object: I): ChannelMessageAck {
    const message = createBaseChannelMessageAck();
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.code = object.code ?? undefined;
    message.username = object.username ?? "";
    message.create_time = object.create_time ?? undefined;
    message.update_time = object.update_time ?? undefined;
    message.persistent = object.persistent ?? undefined;
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    return message;
  },
};

function createBaseChannelMessageSend(): ChannelMessageSend {
  return {
    clan_id: "",
    channel_id: "",
    content: "",
    mentions: [],
    attachments: [],
    references: [],
    mode: 0,
    anonymous_message: false,
    mention_everyone: false,
    avatar: "",
  };
}

export const ChannelMessageSend = {
  encode(message: ChannelMessageSend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    for (const v of message.mentions) {
      MessageMention.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.attachments) {
      MessageAttachment.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.references) {
      MessageRef.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.mode !== 0) {
      writer.uint32(56).int32(message.mode);
    }
    if (message.anonymous_message !== false) {
      writer.uint32(64).bool(message.anonymous_message);
    }
    if (message.mention_everyone !== false) {
      writer.uint32(72).bool(message.mention_everyone);
    }
    if (message.avatar !== "") {
      writer.uint32(82).string(message.avatar);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageSend {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mentions.push(MessageMention.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.references.push(MessageRef.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.anonymous_message = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mention_everyone = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.avatar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageSend {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      mentions: globalThis.Array.isArray(object?.mentions)
        ? object.mentions.map((e: any) => MessageMention.fromJSON(e))
        : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => MessageAttachment.fromJSON(e))
        : [],
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => MessageRef.fromJSON(e))
        : [],
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      anonymous_message: isSet(object.anonymous_message) ? globalThis.Boolean(object.anonymous_message) : false,
      mention_everyone: isSet(object.mention_everyone) ? globalThis.Boolean(object.mention_everyone) : false,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
    };
  },

  toJSON(message: ChannelMessageSend): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.mentions?.length) {
      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => MessageRef.toJSON(e));
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.anonymous_message !== false) {
      obj.anonymous_message = message.anonymous_message;
    }
    if (message.mention_everyone !== false) {
      obj.mention_everyone = message.mention_everyone;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageSend>, I>>(base?: I): ChannelMessageSend {
    return ChannelMessageSend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageSend>, I>>(object: I): ChannelMessageSend {
    const message = createBaseChannelMessageSend();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.content = object.content ?? "";
    message.mentions = object.mentions?.map((e) => MessageMention.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => MessageAttachment.fromPartial(e)) || [];
    message.references = object.references?.map((e) => MessageRef.fromPartial(e)) || [];
    message.mode = object.mode ?? 0;
    message.anonymous_message = object.anonymous_message ?? false;
    message.mention_everyone = object.mention_everyone ?? false;
    message.avatar = object.avatar ?? "";
    return message;
  },
};

function createBaseChannelMessageUpdate(): ChannelMessageUpdate {
  return {
    clan_id: "",
    channel_id: "",
    message_id: "",
    content: "",
    mentions: [],
    attachments: [],
    mode: 0,
    hide_editted: false,
  };
}

export const ChannelMessageUpdate = {
  encode(message: ChannelMessageUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(26).string(message.message_id);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    for (const v of message.mentions) {
      MessageMention.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.attachments) {
      MessageAttachment.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.mode !== 0) {
      writer.uint32(56).int32(message.mode);
    }
    if (message.hide_editted !== false) {
      writer.uint32(64).bool(message.hide_editted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mentions.push(MessageMention.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.attachments.push(MessageAttachment.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.hide_editted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageUpdate {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      mentions: globalThis.Array.isArray(object?.mentions)
        ? object.mentions.map((e: any) => MessageMention.fromJSON(e))
        : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => MessageAttachment.fromJSON(e))
        : [],
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      hide_editted: isSet(object.hide_editted) ? globalThis.Boolean(object.hide_editted) : false,
    };
  },

  toJSON(message: ChannelMessageUpdate): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.mentions?.length) {
      obj.mentions = message.mentions.map((e) => MessageMention.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => MessageAttachment.toJSON(e));
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.hide_editted !== false) {
      obj.hide_editted = message.hide_editted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageUpdate>, I>>(base?: I): ChannelMessageUpdate {
    return ChannelMessageUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageUpdate>, I>>(object: I): ChannelMessageUpdate {
    const message = createBaseChannelMessageUpdate();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.content = object.content ?? "";
    message.mentions = object.mentions?.map((e) => MessageMention.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => MessageAttachment.fromPartial(e)) || [];
    message.mode = object.mode ?? 0;
    message.hide_editted = object.hide_editted ?? false;
    return message;
  },
};

function createBaseChannelMessageRemove(): ChannelMessageRemove {
  return { clan_id: "", channel_id: "", message_id: "", mode: 0 };
}

export const ChannelMessageRemove = {
  encode(message: ChannelMessageRemove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(26).string(message.message_id);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelMessageRemove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMessageRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMessageRemove {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: ChannelMessageRemove): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMessageRemove>, I>>(base?: I): ChannelMessageRemove {
    return ChannelMessageRemove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMessageRemove>, I>>(object: I): ChannelMessageRemove {
    const message = createBaseChannelMessageRemove();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseChannelPresenceEvent(): ChannelPresenceEvent {
  return { channel_id: "", joins: [], leaves: [], clan_logo: "", category_name: "", mode: 0 };
}

export const ChannelPresenceEvent = {
  encode(message: ChannelPresenceEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    for (const v of message.joins) {
      UserPresence.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.leaves) {
      UserPresence.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.clan_logo !== "") {
      writer.uint32(34).string(message.clan_logo);
    }
    if (message.category_name !== "") {
      writer.uint32(42).string(message.category_name);
    }
    if (message.mode !== 0) {
      writer.uint32(48).int32(message.mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelPresenceEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelPresenceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.joins.push(UserPresence.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.leaves.push(UserPresence.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category_name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.mode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelPresenceEvent {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      joins: globalThis.Array.isArray(object?.joins) ? object.joins.map((e: any) => UserPresence.fromJSON(e)) : [],
      leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e: any) => UserPresence.fromJSON(e)) : [],
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
      category_name: isSet(object.category_name) ? globalThis.String(object.category_name) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: ChannelPresenceEvent): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.joins?.length) {
      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    if (message.category_name !== "") {
      obj.category_name = message.category_name;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelPresenceEvent>, I>>(base?: I): ChannelPresenceEvent {
    return ChannelPresenceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelPresenceEvent>, I>>(object: I): ChannelPresenceEvent {
    const message = createBaseChannelPresenceEvent();
    message.channel_id = object.channel_id ?? "";
    message.joins = object.joins?.map((e) => UserPresence.fromPartial(e)) || [];
    message.leaves = object.leaves?.map((e) => UserPresence.fromPartial(e)) || [];
    message.clan_logo = object.clan_logo ?? "";
    message.category_name = object.category_name ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { code: 0, message: "", context: {} };
}

export const Error = {
  encode(message: Error, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.context).forEach(([key, value]) => {
      Error_ContextEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Error_ContextEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.context[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      context: isObject(object.context)
        ? Object.entries(object.context).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.context) {
      const entries = Object.entries(message.context);
      if (entries.length > 0) {
        obj.context = {};
        entries.forEach(([k, v]) => {
          obj.context[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.context = Object.entries(object.context ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseError_ContextEntry(): Error_ContextEntry {
  return { key: "", value: "" };
}

export const Error_ContextEntry = {
  encode(message: Error_ContextEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error_ContextEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError_ContextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error_ContextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Error_ContextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error_ContextEntry>, I>>(base?: I): Error_ContextEntry {
    return Error_ContextEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error_ContextEntry>, I>>(object: I): Error_ContextEntry {
    const message = createBaseError_ContextEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNotifications(): Notifications {
  return { notifications: [] };
}

export const Notifications = {
  encode(message: Notifications, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Notifications {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifications();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Notification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notifications {
    return {
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => Notification.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Notifications): unknown {
    const obj: any = {};
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notifications>, I>>(base?: I): Notifications {
    return Notifications.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notifications>, I>>(object: I): Notifications {
    const message = createBaseNotifications();
    message.notifications = object.notifications?.map((e) => Notification.fromPartial(e)) || [];
    return message;
  },
};

function createBasePing(): Ping {
  return {};
}

export const Ping = {
  encode(_: Ping, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ping {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Ping {
    return {};
  },

  toJSON(_: Ping): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Ping>, I>>(base?: I): Ping {
    return Ping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ping>, I>>(_: I): Ping {
    const message = createBasePing();
    return message;
  },
};

function createBasePong(): Pong {
  return {};
}

export const Pong = {
  encode(_: Pong, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pong {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Pong {
    return {};
  },

  toJSON(_: Pong): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Pong>, I>>(base?: I): Pong {
    return Pong.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pong>, I>>(_: I): Pong {
    const message = createBasePong();
    return message;
  },
};

function createBaseStatus(): Status {
  return { presences: [] };
}

export const Status = {
  encode(message: Status, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.presences) {
      UserPresence.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Status {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.presences.push(UserPresence.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      presences: globalThis.Array.isArray(object?.presences)
        ? object.presences.map((e: any) => UserPresence.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.presences?.length) {
      obj.presences = message.presences.map((e) => UserPresence.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.presences = object.presences?.map((e) => UserPresence.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStatusFollow(): StatusFollow {
  return { user_ids: [], usernames: [] };
}

export const StatusFollow = {
  encode(message: StatusFollow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusFollow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusFollow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusFollow {
    return {
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StatusFollow): unknown {
    const obj: any = {};
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusFollow>, I>>(base?: I): StatusFollow {
    return StatusFollow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusFollow>, I>>(object: I): StatusFollow {
    const message = createBaseStatusFollow();
    message.user_ids = object.user_ids?.map((e) => e) || [];
    message.usernames = object.usernames?.map((e) => e) || [];
    return message;
  },
};

function createBaseStatusPresenceEvent(): StatusPresenceEvent {
  return { joins: [], leaves: [] };
}

export const StatusPresenceEvent = {
  encode(message: StatusPresenceEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.joins) {
      UserPresence.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.leaves) {
      UserPresence.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusPresenceEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusPresenceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.joins.push(UserPresence.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.leaves.push(UserPresence.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusPresenceEvent {
    return {
      joins: globalThis.Array.isArray(object?.joins) ? object.joins.map((e: any) => UserPresence.fromJSON(e)) : [],
      leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e: any) => UserPresence.fromJSON(e)) : [],
    };
  },

  toJSON(message: StatusPresenceEvent): unknown {
    const obj: any = {};
    if (message.joins?.length) {
      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusPresenceEvent>, I>>(base?: I): StatusPresenceEvent {
    return StatusPresenceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusPresenceEvent>, I>>(object: I): StatusPresenceEvent {
    const message = createBaseStatusPresenceEvent();
    message.joins = object.joins?.map((e) => UserPresence.fromPartial(e)) || [];
    message.leaves = object.leaves?.map((e) => UserPresence.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLastPinMessageEvent(): LastPinMessageEvent {
  return { clan_id: "", channel_id: "", message_id: "", mode: 0, user_id: "", timestamp: "", operation: 0 };
}

export const LastPinMessageEvent = {
  encode(message: LastPinMessageEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(26).string(message.message_id);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.user_id !== "") {
      writer.uint32(42).string(message.user_id);
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    if (message.operation !== 0) {
      writer.uint32(56).int32(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LastPinMessageEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastPinMessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.operation = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastPinMessageEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      operation: isSet(object.operation) ? globalThis.Number(object.operation) : 0,
    };
  },

  toJSON(message: LastPinMessageEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.operation !== 0) {
      obj.operation = Math.round(message.operation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LastPinMessageEvent>, I>>(base?: I): LastPinMessageEvent {
    return LastPinMessageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LastPinMessageEvent>, I>>(object: I): LastPinMessageEvent {
    const message = createBaseLastPinMessageEvent();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.mode = object.mode ?? 0;
    message.user_id = object.user_id ?? "";
    message.timestamp = object.timestamp ?? "";
    message.operation = object.operation ?? 0;
    return message;
  },
};

function createBaseLastSeenMessageEvent(): LastSeenMessageEvent {
  return { channel_id: "", message_id: "", mode: 0, timestamp: "" };
}

export const LastSeenMessageEvent = {
  encode(message: LastSeenMessageEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.message_id !== "") {
      writer.uint32(18).string(message.message_id);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LastSeenMessageEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastSeenMessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message_id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastSeenMessageEvent {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      message_id: isSet(object.message_id) ? globalThis.String(object.message_id) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: LastSeenMessageEvent): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.message_id !== "") {
      obj.message_id = message.message_id;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LastSeenMessageEvent>, I>>(base?: I): LastSeenMessageEvent {
    return LastSeenMessageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LastSeenMessageEvent>, I>>(object: I): LastSeenMessageEvent {
    const message = createBaseLastSeenMessageEvent();
    message.channel_id = object.channel_id ?? "";
    message.message_id = object.message_id ?? "";
    message.mode = object.mode ?? 0;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseMessageTypingEvent(): MessageTypingEvent {
  return { clan_id: "", channel_id: "", sender_id: "", mode: 0 };
}

export const MessageTypingEvent = {
  encode(message: MessageTypingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.sender_id !== "") {
      writer.uint32(26).string(message.sender_id);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageTypingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageTypingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender_id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageTypingEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      sender_id: isSet(object.sender_id) ? globalThis.String(object.sender_id) : "",
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
    };
  },

  toJSON(message: MessageTypingEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.sender_id !== "") {
      obj.sender_id = message.sender_id;
    }
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageTypingEvent>, I>>(base?: I): MessageTypingEvent {
    return MessageTypingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageTypingEvent>, I>>(object: I): MessageTypingEvent {
    const message = createBaseMessageTypingEvent();
    message.clan_id = object.clan_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.sender_id = object.sender_id ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseVoiceLeavedEvent(): VoiceLeavedEvent {
  return { id: "", clan_id: "", voice_channel_id: "", voice_user_id: "" };
}

export const VoiceLeavedEvent = {
  encode(message: VoiceLeavedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.voice_channel_id !== "") {
      writer.uint32(26).string(message.voice_channel_id);
    }
    if (message.voice_user_id !== "") {
      writer.uint32(34).string(message.voice_user_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceLeavedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceLeavedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.voice_channel_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.voice_user_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceLeavedEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      voice_channel_id: isSet(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : "",
      voice_user_id: isSet(object.voice_user_id) ? globalThis.String(object.voice_user_id) : "",
    };
  },

  toJSON(message: VoiceLeavedEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.voice_channel_id !== "") {
      obj.voice_channel_id = message.voice_channel_id;
    }
    if (message.voice_user_id !== "") {
      obj.voice_user_id = message.voice_user_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceLeavedEvent>, I>>(base?: I): VoiceLeavedEvent {
    return VoiceLeavedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceLeavedEvent>, I>>(object: I): VoiceLeavedEvent {
    const message = createBaseVoiceLeavedEvent();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.voice_channel_id = object.voice_channel_id ?? "";
    message.voice_user_id = object.voice_user_id ?? "";
    return message;
  },
};

function createBaseVoiceJoinedEvent(): VoiceJoinedEvent {
  return {
    clan_id: "",
    clan_name: "",
    id: "",
    participant: "",
    user_id: "",
    voice_channel_label: "",
    voice_channel_id: "",
    last_screenshot: "",
  };
}

export const VoiceJoinedEvent = {
  encode(message: VoiceJoinedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(18).string(message.clan_name);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.participant !== "") {
      writer.uint32(34).string(message.participant);
    }
    if (message.user_id !== "") {
      writer.uint32(42).string(message.user_id);
    }
    if (message.voice_channel_label !== "") {
      writer.uint32(50).string(message.voice_channel_label);
    }
    if (message.voice_channel_id !== "") {
      writer.uint32(58).string(message.voice_channel_id);
    }
    if (message.last_screenshot !== "") {
      writer.uint32(66).string(message.last_screenshot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceJoinedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceJoinedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.voice_channel_label = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.voice_channel_id = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.last_screenshot = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceJoinedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      voice_channel_label: isSet(object.voice_channel_label) ? globalThis.String(object.voice_channel_label) : "",
      voice_channel_id: isSet(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : "",
      last_screenshot: isSet(object.last_screenshot) ? globalThis.String(object.last_screenshot) : "",
    };
  },

  toJSON(message: VoiceJoinedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.voice_channel_label !== "") {
      obj.voice_channel_label = message.voice_channel_label;
    }
    if (message.voice_channel_id !== "") {
      obj.voice_channel_id = message.voice_channel_id;
    }
    if (message.last_screenshot !== "") {
      obj.last_screenshot = message.last_screenshot;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceJoinedEvent>, I>>(base?: I): VoiceJoinedEvent {
    return VoiceJoinedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceJoinedEvent>, I>>(object: I): VoiceJoinedEvent {
    const message = createBaseVoiceJoinedEvent();
    message.clan_id = object.clan_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.id = object.id ?? "";
    message.participant = object.participant ?? "";
    message.user_id = object.user_id ?? "";
    message.voice_channel_label = object.voice_channel_label ?? "";
    message.voice_channel_id = object.voice_channel_id ?? "";
    message.last_screenshot = object.last_screenshot ?? "";
    return message;
  },
};

function createBaseVoiceStartedEvent(): VoiceStartedEvent {
  return { id: "", clan_id: "", voice_channel_id: "" };
}

export const VoiceStartedEvent = {
  encode(message: VoiceStartedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.voice_channel_id !== "") {
      writer.uint32(26).string(message.voice_channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceStartedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.voice_channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceStartedEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      voice_channel_id: isSet(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : "",
    };
  },

  toJSON(message: VoiceStartedEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.voice_channel_id !== "") {
      obj.voice_channel_id = message.voice_channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceStartedEvent>, I>>(base?: I): VoiceStartedEvent {
    return VoiceStartedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceStartedEvent>, I>>(object: I): VoiceStartedEvent {
    const message = createBaseVoiceStartedEvent();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.voice_channel_id = object.voice_channel_id ?? "";
    return message;
  },
};

function createBaseVoiceEndedEvent(): VoiceEndedEvent {
  return { id: "", clan_id: "", voice_channel_id: "" };
}

export const VoiceEndedEvent = {
  encode(message: VoiceEndedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clan_id !== "") {
      writer.uint32(18).string(message.clan_id);
    }
    if (message.voice_channel_id !== "") {
      writer.uint32(26).string(message.voice_channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VoiceEndedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoiceEndedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.voice_channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VoiceEndedEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      voice_channel_id: isSet(object.voice_channel_id) ? globalThis.String(object.voice_channel_id) : "",
    };
  },

  toJSON(message: VoiceEndedEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.voice_channel_id !== "") {
      obj.voice_channel_id = message.voice_channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VoiceEndedEvent>, I>>(base?: I): VoiceEndedEvent {
    return VoiceEndedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoiceEndedEvent>, I>>(object: I): VoiceEndedEvent {
    const message = createBaseVoiceEndedEvent();
    message.id = object.id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.voice_channel_id = object.voice_channel_id ?? "";
    return message;
  },
};

function createBaseChannelCreatedEvent(): ChannelCreatedEvent {
  return {
    clan_id: "",
    category_id: "",
    creator_id: "",
    parrent_id: "",
    channel_id: "",
    channel_label: "",
    channel_private: 0,
    channel_type: undefined,
    status: 0,
  };
}

export const ChannelCreatedEvent = {
  encode(message: ChannelCreatedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.category_id !== "") {
      writer.uint32(18).string(message.category_id);
    }
    if (message.creator_id !== "") {
      writer.uint32(26).string(message.creator_id);
    }
    if (message.parrent_id !== "") {
      writer.uint32(34).string(message.parrent_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(50).string(message.channel_label);
    }
    if (message.channel_private !== 0) {
      writer.uint32(56).int32(message.channel_private);
    }
    if (message.channel_type !== undefined) {
      Int32Value.encode({ value: message.channel_type! }, writer.uint32(66).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelCreatedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelCreatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.channel_private = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelCreatedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_private: isSet(object.channel_private) ? globalThis.Number(object.channel_private) : 0,
      channel_type: isSet(object.channel_type) ? Number(object.channel_type) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: ChannelCreatedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_private !== 0) {
      obj.channel_private = Math.round(message.channel_private);
    }
    if (message.channel_type !== undefined) {
      obj.channel_type = message.channel_type;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelCreatedEvent>, I>>(base?: I): ChannelCreatedEvent {
    return ChannelCreatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelCreatedEvent>, I>>(object: I): ChannelCreatedEvent {
    const message = createBaseChannelCreatedEvent();
    message.clan_id = object.clan_id ?? "";
    message.category_id = object.category_id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.parrent_id = object.parrent_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_label = object.channel_label ?? "";
    message.channel_private = object.channel_private ?? 0;
    message.channel_type = object.channel_type ?? undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseChannelDeletedEvent(): ChannelDeletedEvent {
  return { clan_id: "", category_id: "", parrent_id: "", channel_id: "", deletor: "" };
}

export const ChannelDeletedEvent = {
  encode(message: ChannelDeletedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.category_id !== "") {
      writer.uint32(18).string(message.category_id);
    }
    if (message.parrent_id !== "") {
      writer.uint32(26).string(message.parrent_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(34).string(message.channel_id);
    }
    if (message.deletor !== "") {
      writer.uint32(42).string(message.deletor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelDeletedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelDeletedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deletor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelDeletedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      deletor: isSet(object.deletor) ? globalThis.String(object.deletor) : "",
    };
  },

  toJSON(message: ChannelDeletedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.deletor !== "") {
      obj.deletor = message.deletor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelDeletedEvent>, I>>(base?: I): ChannelDeletedEvent {
    return ChannelDeletedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelDeletedEvent>, I>>(object: I): ChannelDeletedEvent {
    const message = createBaseChannelDeletedEvent();
    message.clan_id = object.clan_id ?? "";
    message.category_id = object.category_id ?? "";
    message.parrent_id = object.parrent_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.deletor = object.deletor ?? "";
    return message;
  },
};

function createBaseChannelUpdatedEvent(): ChannelUpdatedEvent {
  return {
    clan_id: "",
    category_id: "",
    creator_id: "",
    parrent_id: "",
    channel_id: "",
    channel_label: "",
    channel_type: undefined,
    status: 0,
  };
}

export const ChannelUpdatedEvent = {
  encode(message: ChannelUpdatedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.category_id !== "") {
      writer.uint32(18).string(message.category_id);
    }
    if (message.creator_id !== "") {
      writer.uint32(26).string(message.creator_id);
    }
    if (message.parrent_id !== "") {
      writer.uint32(34).string(message.parrent_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.channel_label !== "") {
      writer.uint32(50).string(message.channel_label);
    }
    if (message.channel_type !== undefined) {
      Int32Value.encode({ value: message.channel_type! }, writer.uint32(58).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChannelUpdatedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelUpdatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parrent_id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.channel_label = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.channel_type = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelUpdatedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      creator_id: isSet(object.creator_id) ? globalThis.String(object.creator_id) : "",
      parrent_id: isSet(object.parrent_id) ? globalThis.String(object.parrent_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      channel_label: isSet(object.channel_label) ? globalThis.String(object.channel_label) : "",
      channel_type: isSet(object.channel_type) ? Number(object.channel_type) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: ChannelUpdatedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.creator_id !== "") {
      obj.creator_id = message.creator_id;
    }
    if (message.parrent_id !== "") {
      obj.parrent_id = message.parrent_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.channel_label !== "") {
      obj.channel_label = message.channel_label;
    }
    if (message.channel_type !== undefined) {
      obj.channel_type = message.channel_type;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelUpdatedEvent>, I>>(base?: I): ChannelUpdatedEvent {
    return ChannelUpdatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelUpdatedEvent>, I>>(object: I): ChannelUpdatedEvent {
    const message = createBaseChannelUpdatedEvent();
    message.clan_id = object.clan_id ?? "";
    message.category_id = object.category_id ?? "";
    message.creator_id = object.creator_id ?? "";
    message.parrent_id = object.parrent_id ?? "";
    message.channel_id = object.channel_id ?? "";
    message.channel_label = object.channel_label ?? "";
    message.channel_type = object.channel_type ?? undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseStatusUnfollow(): StatusUnfollow {
  return { user_ids: [] };
}

export const StatusUnfollow = {
  encode(message: StatusUnfollow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.user_ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusUnfollow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUnfollow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUnfollow {
    return {
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StatusUnfollow): unknown {
    const obj: any = {};
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusUnfollow>, I>>(base?: I): StatusUnfollow {
    return StatusUnfollow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusUnfollow>, I>>(object: I): StatusUnfollow {
    const message = createBaseStatusUnfollow();
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseStatusUpdate(): StatusUpdate {
  return { status: undefined };
}

export const StatusUpdate = {
  encode(message: StatusUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined) {
      StringValue.encode({ value: message.status! }, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusUpdate {
    return { status: isSet(object.status) ? String(object.status) : undefined };
  },

  toJSON(message: StatusUpdate): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusUpdate>, I>>(base?: I): StatusUpdate {
    return StatusUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusUpdate>, I>>(object: I): StatusUpdate {
    const message = createBaseStatusUpdate();
    message.status = object.status ?? undefined;
    return message;
  },
};

function createBaseStream(): Stream {
  return { mode: 0, channel_id: "", clan_id: "", label: "" };
}

export const Stream = {
  encode(message: Stream, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.channel_id !== "") {
      writer.uint32(18).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(26).string(message.clan_id);
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Stream {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream {
    return {
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: Stream): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stream>, I>>(base?: I): Stream {
    return Stream.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stream>, I>>(object: I): Stream {
    const message = createBaseStream();
    message.mode = object.mode ?? 0;
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseStreamData(): StreamData {
  return { stream: undefined, sender: undefined, data: "", reliable: false };
}

export const StreamData = {
  encode(message: StreamData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stream !== undefined) {
      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();
    }
    if (message.sender !== undefined) {
      UserPresence.encode(message.sender, writer.uint32(18).fork()).ldelim();
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    if (message.reliable !== false) {
      writer.uint32(32).bool(message.reliable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stream = Stream.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sender = UserPresence.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reliable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamData {
    return {
      stream: isSet(object.stream) ? Stream.fromJSON(object.stream) : undefined,
      sender: isSet(object.sender) ? UserPresence.fromJSON(object.sender) : undefined,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      reliable: isSet(object.reliable) ? globalThis.Boolean(object.reliable) : false,
    };
  },

  toJSON(message: StreamData): unknown {
    const obj: any = {};
    if (message.stream !== undefined) {
      obj.stream = Stream.toJSON(message.stream);
    }
    if (message.sender !== undefined) {
      obj.sender = UserPresence.toJSON(message.sender);
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.reliable !== false) {
      obj.reliable = message.reliable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamData>, I>>(base?: I): StreamData {
    return StreamData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamData>, I>>(object: I): StreamData {
    const message = createBaseStreamData();
    message.stream = (object.stream !== undefined && object.stream !== null)
      ? Stream.fromPartial(object.stream)
      : undefined;
    message.sender = (object.sender !== undefined && object.sender !== null)
      ? UserPresence.fromPartial(object.sender)
      : undefined;
    message.data = object.data ?? "";
    message.reliable = object.reliable ?? false;
    return message;
  },
};

function createBaseStreamPresenceEvent(): StreamPresenceEvent {
  return { stream: undefined, joins: [], leaves: [] };
}

export const StreamPresenceEvent = {
  encode(message: StreamPresenceEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stream !== undefined) {
      Stream.encode(message.stream, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.joins) {
      UserPresence.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.leaves) {
      UserPresence.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPresenceEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPresenceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stream = Stream.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.joins.push(UserPresence.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.leaves.push(UserPresence.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamPresenceEvent {
    return {
      stream: isSet(object.stream) ? Stream.fromJSON(object.stream) : undefined,
      joins: globalThis.Array.isArray(object?.joins) ? object.joins.map((e: any) => UserPresence.fromJSON(e)) : [],
      leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e: any) => UserPresence.fromJSON(e)) : [],
    };
  },

  toJSON(message: StreamPresenceEvent): unknown {
    const obj: any = {};
    if (message.stream !== undefined) {
      obj.stream = Stream.toJSON(message.stream);
    }
    if (message.joins?.length) {
      obj.joins = message.joins.map((e) => UserPresence.toJSON(e));
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => UserPresence.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamPresenceEvent>, I>>(base?: I): StreamPresenceEvent {
    return StreamPresenceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamPresenceEvent>, I>>(object: I): StreamPresenceEvent {
    const message = createBaseStreamPresenceEvent();
    message.stream = (object.stream !== undefined && object.stream !== null)
      ? Stream.fromPartial(object.stream)
      : undefined;
    message.joins = object.joins?.map((e) => UserPresence.fromPartial(e)) || [];
    message.leaves = object.leaves?.map((e) => UserPresence.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserPresence(): UserPresence {
  return { user_id: "", session_id: "", username: "", persistence: false, status: undefined };
}

export const UserPresence = {
  encode(message: UserPresence, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.session_id !== "") {
      writer.uint32(18).string(message.session_id);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.persistence !== false) {
      writer.uint32(32).bool(message.persistence);
    }
    if (message.status !== undefined) {
      StringValue.encode({ value: message.status! }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserPresence {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPresence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.session_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.persistence = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPresence {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      session_id: isSet(object.session_id) ? globalThis.String(object.session_id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      persistence: isSet(object.persistence) ? globalThis.Boolean(object.persistence) : false,
      status: isSet(object.status) ? String(object.status) : undefined,
    };
  },

  toJSON(message: UserPresence): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.session_id !== "") {
      obj.session_id = message.session_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.persistence !== false) {
      obj.persistence = message.persistence;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPresence>, I>>(base?: I): UserPresence {
    return UserPresence.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPresence>, I>>(object: I): UserPresence {
    const message = createBaseUserPresence();
    message.user_id = object.user_id ?? "";
    message.session_id = object.session_id ?? "";
    message.username = object.username ?? "";
    message.persistence = object.persistence ?? false;
    message.status = object.status ?? undefined;
    return message;
  },
};

function createBaseCustomStatusEvent(): CustomStatusEvent {
  return { clan_id: "", user_id: "", username: "", status: "" };
}

export const CustomStatusEvent = {
  encode(message: CustomStatusEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CustomStatusEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomStatusEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomStatusEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: CustomStatusEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomStatusEvent>, I>>(base?: I): CustomStatusEvent {
    return CustomStatusEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomStatusEvent>, I>>(object: I): CustomStatusEvent {
    const message = createBaseCustomStatusEvent();
    message.clan_id = object.clan_id ?? "";
    message.user_id = object.user_id ?? "";
    message.username = object.username ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseAddUsers(): AddUsers {
  return { user_id: "", avatar: "", username: "" };
}

export const AddUsers = {
  encode(message: AddUsers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.avatar !== "") {
      writer.uint32(18).string(message.avatar);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddUsers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUsers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddUsers {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: AddUsers): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUsers>, I>>(base?: I): AddUsers {
    return AddUsers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddUsers>, I>>(object: I): AddUsers {
    const message = createBaseAddUsers();
    message.user_id = object.user_id ?? "";
    message.avatar = object.avatar ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseUserChannelAdded(): UserChannelAdded {
  return { channel_id: "", users: [], status: "", clan_id: "", channel_type: 0 };
}

export const UserChannelAdded = {
  encode(message: UserChannelAdded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    for (const v of message.users) {
      AddUsers.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    if (message.channel_type !== 0) {
      writer.uint32(40).int32(message.channel_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserChannelAdded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserChannelAdded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.users.push(AddUsers.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channel_type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserChannelAdded {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => AddUsers.fromJSON(e)) : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      channel_type: isSet(object.channel_type) ? globalThis.Number(object.channel_type) : 0,
    };
  },

  toJSON(message: UserChannelAdded): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => AddUsers.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.channel_type !== 0) {
      obj.channel_type = Math.round(message.channel_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserChannelAdded>, I>>(base?: I): UserChannelAdded {
    return UserChannelAdded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserChannelAdded>, I>>(object: I): UserChannelAdded {
    const message = createBaseUserChannelAdded();
    message.channel_id = object.channel_id ?? "";
    message.users = object.users?.map((e) => AddUsers.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.clan_id = object.clan_id ?? "";
    message.channel_type = object.channel_type ?? 0;
    return message;
  },
};

function createBaseUserChannelRemoved(): UserChannelRemoved {
  return { channel_id: "", user_ids: [] };
}

export const UserChannelRemoved = {
  encode(message: UserChannelRemoved, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserChannelRemoved {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserChannelRemoved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserChannelRemoved {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UserChannelRemoved): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserChannelRemoved>, I>>(base?: I): UserChannelRemoved {
    return UserChannelRemoved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserChannelRemoved>, I>>(object: I): UserChannelRemoved {
    const message = createBaseUserChannelRemoved();
    message.channel_id = object.channel_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserClanRemoved(): UserClanRemoved {
  return { clan_id: "", user_ids: [] };
}

export const UserClanRemoved = {
  encode(message: UserClanRemoved, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserClanRemoved {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserClanRemoved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserClanRemoved {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      user_ids: globalThis.Array.isArray(object?.user_ids) ? object.user_ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UserClanRemoved): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.user_ids?.length) {
      obj.user_ids = message.user_ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserClanRemoved>, I>>(base?: I): UserClanRemoved {
    return UserClanRemoved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserClanRemoved>, I>>(object: I): UserClanRemoved {
    const message = createBaseUserClanRemoved();
    message.clan_id = object.clan_id ?? "";
    message.user_ids = object.user_ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseClanUpdatedEvent(): ClanUpdatedEvent {
  return { clan_id: "", clan_name: "", clan_logo: "" };
}

export const ClanUpdatedEvent = {
  encode(message: ClanUpdatedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.clan_name !== "") {
      writer.uint32(18).string(message.clan_name);
    }
    if (message.clan_logo !== "") {
      writer.uint32(26).string(message.clan_logo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanUpdatedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanUpdatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_logo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanUpdatedEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      clan_logo: isSet(object.clan_logo) ? globalThis.String(object.clan_logo) : "",
    };
  },

  toJSON(message: ClanUpdatedEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.clan_logo !== "") {
      obj.clan_logo = message.clan_logo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanUpdatedEvent>, I>>(base?: I): ClanUpdatedEvent {
    return ClanUpdatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanUpdatedEvent>, I>>(object: I): ClanUpdatedEvent {
    const message = createBaseClanUpdatedEvent();
    message.clan_id = object.clan_id ?? "";
    message.clan_name = object.clan_name ?? "";
    message.clan_logo = object.clan_logo ?? "";
    return message;
  },
};

function createBaseClanProfileUpdatedEvent(): ClanProfileUpdatedEvent {
  return { user_id: "", clan_nick: "", clan_avatar: "", clan_id: "" };
}

export const ClanProfileUpdatedEvent = {
  encode(message: ClanProfileUpdatedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.clan_nick !== "") {
      writer.uint32(18).string(message.clan_nick);
    }
    if (message.clan_avatar !== "") {
      writer.uint32(26).string(message.clan_avatar);
    }
    if (message.clan_id !== "") {
      writer.uint32(34).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanProfileUpdatedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanProfileUpdatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clan_nick = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clan_avatar = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanProfileUpdatedEvent {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      clan_nick: isSet(object.clan_nick) ? globalThis.String(object.clan_nick) : "",
      clan_avatar: isSet(object.clan_avatar) ? globalThis.String(object.clan_avatar) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: ClanProfileUpdatedEvent): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.clan_nick !== "") {
      obj.clan_nick = message.clan_nick;
    }
    if (message.clan_avatar !== "") {
      obj.clan_avatar = message.clan_avatar;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanProfileUpdatedEvent>, I>>(base?: I): ClanProfileUpdatedEvent {
    return ClanProfileUpdatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanProfileUpdatedEvent>, I>>(object: I): ClanProfileUpdatedEvent {
    const message = createBaseClanProfileUpdatedEvent();
    message.user_id = object.user_id ?? "";
    message.clan_nick = object.clan_nick ?? "";
    message.clan_avatar = object.clan_avatar ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseUserProfileUpdatedEvent(): UserProfileUpdatedEvent {
  return { user_id: "", display_name: "", avatar: "", about_me: "", channel_id: "", clan_id: "" };
}

export const UserProfileUpdatedEvent = {
  encode(message: UserProfileUpdatedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.display_name !== "") {
      writer.uint32(18).string(message.display_name);
    }
    if (message.avatar !== "") {
      writer.uint32(26).string(message.avatar);
    }
    if (message.about_me !== "") {
      writer.uint32(34).string(message.about_me);
    }
    if (message.channel_id !== "") {
      writer.uint32(42).string(message.channel_id);
    }
    if (message.clan_id !== "") {
      writer.uint32(50).string(message.clan_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserProfileUpdatedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileUpdatedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.about_me = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clan_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileUpdatedEvent {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      about_me: isSet(object.about_me) ? globalThis.String(object.about_me) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
    };
  },

  toJSON(message: UserProfileUpdatedEvent): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.about_me !== "") {
      obj.about_me = message.about_me;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileUpdatedEvent>, I>>(base?: I): UserProfileUpdatedEvent {
    return UserProfileUpdatedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileUpdatedEvent>, I>>(object: I): UserProfileUpdatedEvent {
    const message = createBaseUserProfileUpdatedEvent();
    message.user_id = object.user_id ?? "";
    message.display_name = object.display_name ?? "";
    message.avatar = object.avatar ?? "";
    message.about_me = object.about_me ?? "";
    message.channel_id = object.channel_id ?? "";
    message.clan_id = object.clan_id ?? "";
    return message;
  },
};

function createBaseUserProfileRedis(): UserProfileRedis {
  return { user_id: "", username: "", avatar: "", display_name: "", fcm_tokens: [] };
}

export const UserProfileRedis = {
  encode(message: UserProfileRedis, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user_id !== "") {
      writer.uint32(10).string(message.user_id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.avatar !== "") {
      writer.uint32(26).string(message.avatar);
    }
    if (message.display_name !== "") {
      writer.uint32(34).string(message.display_name);
    }
    for (const v of message.fcm_tokens) {
      FCMTokens.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserProfileRedis {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfileRedis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.display_name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fcm_tokens.push(FCMTokens.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfileRedis {
    return {
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      display_name: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      fcm_tokens: globalThis.Array.isArray(object?.fcm_tokens)
        ? object.fcm_tokens.map((e: any) => FCMTokens.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserProfileRedis): unknown {
    const obj: any = {};
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.display_name !== "") {
      obj.display_name = message.display_name;
    }
    if (message.fcm_tokens?.length) {
      obj.fcm_tokens = message.fcm_tokens.map((e) => FCMTokens.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfileRedis>, I>>(base?: I): UserProfileRedis {
    return UserProfileRedis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfileRedis>, I>>(object: I): UserProfileRedis {
    const message = createBaseUserProfileRedis();
    message.user_id = object.user_id ?? "";
    message.username = object.username ?? "";
    message.avatar = object.avatar ?? "";
    message.display_name = object.display_name ?? "";
    message.fcm_tokens = object.fcm_tokens?.map((e) => FCMTokens.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFCMTokens(): FCMTokens {
  return { device_id: "", token_id: "" };
}

export const FCMTokens = {
  encode(message: FCMTokens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.device_id !== "") {
      writer.uint32(10).string(message.device_id);
    }
    if (message.token_id !== "") {
      writer.uint32(18).string(message.token_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FCMTokens {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFCMTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.device_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FCMTokens {
    return {
      device_id: isSet(object.device_id) ? globalThis.String(object.device_id) : "",
      token_id: isSet(object.token_id) ? globalThis.String(object.token_id) : "",
    };
  },

  toJSON(message: FCMTokens): unknown {
    const obj: any = {};
    if (message.device_id !== "") {
      obj.device_id = message.device_id;
    }
    if (message.token_id !== "") {
      obj.token_id = message.token_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FCMTokens>, I>>(base?: I): FCMTokens {
    return FCMTokens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FCMTokens>, I>>(object: I): FCMTokens {
    const message = createBaseFCMTokens();
    message.device_id = object.device_id ?? "";
    message.token_id = object.token_id ?? "";
    return message;
  },
};

function createBaseClanNameExistedEvent(): ClanNameExistedEvent {
  return { clan_name: "", exist: false };
}

export const ClanNameExistedEvent = {
  encode(message: ClanNameExistedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_name !== "") {
      writer.uint32(10).string(message.clan_name);
    }
    if (message.exist !== false) {
      writer.uint32(16).bool(message.exist);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClanNameExistedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClanNameExistedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.exist = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClanNameExistedEvent {
    return {
      clan_name: isSet(object.clan_name) ? globalThis.String(object.clan_name) : "",
      exist: isSet(object.exist) ? globalThis.Boolean(object.exist) : false,
    };
  },

  toJSON(message: ClanNameExistedEvent): unknown {
    const obj: any = {};
    if (message.clan_name !== "") {
      obj.clan_name = message.clan_name;
    }
    if (message.exist !== false) {
      obj.exist = message.exist;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClanNameExistedEvent>, I>>(base?: I): ClanNameExistedEvent {
    return ClanNameExistedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClanNameExistedEvent>, I>>(object: I): ClanNameExistedEvent {
    const message = createBaseClanNameExistedEvent();
    message.clan_name = object.clan_name ?? "";
    message.exist = object.exist ?? false;
    return message;
  },
};

function createBaseNotificationChannelSettingEvent(): NotificationChannelSettingEvent {
  return { channel_id: "", notification_user_channel: undefined };
}

export const NotificationChannelSettingEvent = {
  encode(message: NotificationChannelSettingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.notification_user_channel !== undefined) {
      NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationChannelSettingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannelSettingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannelSettingEvent {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      notification_user_channel: isSet(object.notification_user_channel)
        ? NotificationUserChannel.fromJSON(object.notification_user_channel)
        : undefined,
    };
  },

  toJSON(message: NotificationChannelSettingEvent): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.notification_user_channel !== undefined) {
      obj.notification_user_channel = NotificationUserChannel.toJSON(message.notification_user_channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationChannelSettingEvent>, I>>(base?: I): NotificationChannelSettingEvent {
    return NotificationChannelSettingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationChannelSettingEvent>, I>>(
    object: I,
  ): NotificationChannelSettingEvent {
    const message = createBaseNotificationChannelSettingEvent();
    message.channel_id = object.channel_id ?? "";
    message.notification_user_channel =
      (object.notification_user_channel !== undefined && object.notification_user_channel !== null)
        ? NotificationUserChannel.fromPartial(object.notification_user_channel)
        : undefined;
    return message;
  },
};

function createBaseNotificationUserChannel(): NotificationUserChannel {
  return { id: "", notification_setting_type: 0, time_mute: undefined, active: 0 };
}

export const NotificationUserChannel = {
  encode(message: NotificationUserChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.notification_setting_type !== 0) {
      writer.uint32(16).int32(message.notification_setting_type);
    }
    if (message.time_mute !== undefined) {
      Timestamp.encode(toTimestamp(message.time_mute), writer.uint32(26).fork()).ldelim();
    }
    if (message.active !== 0) {
      writer.uint32(32).int32(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationUserChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationUserChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_setting_type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.time_mute = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.active = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationUserChannel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      notification_setting_type: isSet(object.notification_setting_type)
        ? globalThis.Number(object.notification_setting_type)
        : 0,
      time_mute: isSet(object.time_mute) ? fromJsonTimestamp(object.time_mute) : undefined,
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
    };
  },

  toJSON(message: NotificationUserChannel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.notification_setting_type !== 0) {
      obj.notification_setting_type = Math.round(message.notification_setting_type);
    }
    if (message.time_mute !== undefined) {
      obj.time_mute = message.time_mute.toISOString();
    }
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationUserChannel>, I>>(base?: I): NotificationUserChannel {
    return NotificationUserChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationUserChannel>, I>>(object: I): NotificationUserChannel {
    const message = createBaseNotificationUserChannel();
    message.id = object.id ?? "";
    message.notification_setting_type = object.notification_setting_type ?? 0;
    message.time_mute = object.time_mute ?? undefined;
    message.active = object.active ?? 0;
    return message;
  },
};

function createBaseNotificationCategorySettingEvent(): NotificationCategorySettingEvent {
  return { category_id: "", notification_user_channel: undefined };
}

export const NotificationCategorySettingEvent = {
  encode(message: NotificationCategorySettingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category_id !== "") {
      writer.uint32(10).string(message.category_id);
    }
    if (message.notification_user_channel !== undefined) {
      NotificationUserChannel.encode(message.notification_user_channel, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationCategorySettingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationCategorySettingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.category_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notification_user_channel = NotificationUserChannel.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationCategorySettingEvent {
    return {
      category_id: isSet(object.category_id) ? globalThis.String(object.category_id) : "",
      notification_user_channel: isSet(object.notification_user_channel)
        ? NotificationUserChannel.fromJSON(object.notification_user_channel)
        : undefined,
    };
  },

  toJSON(message: NotificationCategorySettingEvent): unknown {
    const obj: any = {};
    if (message.category_id !== "") {
      obj.category_id = message.category_id;
    }
    if (message.notification_user_channel !== undefined) {
      obj.notification_user_channel = NotificationUserChannel.toJSON(message.notification_user_channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationCategorySettingEvent>, I>>(
    base?: I,
  ): NotificationCategorySettingEvent {
    return NotificationCategorySettingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationCategorySettingEvent>, I>>(
    object: I,
  ): NotificationCategorySettingEvent {
    const message = createBaseNotificationCategorySettingEvent();
    message.category_id = object.category_id ?? "";
    message.notification_user_channel =
      (object.notification_user_channel !== undefined && object.notification_user_channel !== null)
        ? NotificationUserChannel.fromPartial(object.notification_user_channel)
        : undefined;
    return message;
  },
};

function createBaseNotificationClanSettingEvent(): NotificationClanSettingEvent {
  return { clan_id: "", notification_setting: undefined };
}

export const NotificationClanSettingEvent = {
  encode(message: NotificationClanSettingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clan_id !== "") {
      writer.uint32(10).string(message.clan_id);
    }
    if (message.notification_setting !== undefined) {
      NotificationSetting.encode(message.notification_setting, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationClanSettingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationClanSettingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clan_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notification_setting = NotificationSetting.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationClanSettingEvent {
    return {
      clan_id: isSet(object.clan_id) ? globalThis.String(object.clan_id) : "",
      notification_setting: isSet(object.notification_setting)
        ? NotificationSetting.fromJSON(object.notification_setting)
        : undefined,
    };
  },

  toJSON(message: NotificationClanSettingEvent): unknown {
    const obj: any = {};
    if (message.clan_id !== "") {
      obj.clan_id = message.clan_id;
    }
    if (message.notification_setting !== undefined) {
      obj.notification_setting = NotificationSetting.toJSON(message.notification_setting);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationClanSettingEvent>, I>>(base?: I): NotificationClanSettingEvent {
    return NotificationClanSettingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationClanSettingEvent>, I>>(object: I): NotificationClanSettingEvent {
    const message = createBaseNotificationClanSettingEvent();
    message.clan_id = object.clan_id ?? "";
    message.notification_setting = (object.notification_setting !== undefined && object.notification_setting !== null)
      ? NotificationSetting.fromPartial(object.notification_setting)
      : undefined;
    return message;
  },
};

function createBaseNotificationSetting(): NotificationSetting {
  return { id: "", notification_setting_type: 0 };
}

export const NotificationSetting = {
  encode(message: NotificationSetting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.notification_setting_type !== 0) {
      writer.uint32(16).int32(message.notification_setting_type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotificationSetting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.notification_setting_type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationSetting {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      notification_setting_type: isSet(object.notification_setting_type)
        ? globalThis.Number(object.notification_setting_type)
        : 0,
    };
  },

  toJSON(message: NotificationSetting): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.notification_setting_type !== 0) {
      obj.notification_setting_type = Math.round(message.notification_setting_type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationSetting>, I>>(base?: I): NotificationSetting {
    return NotificationSetting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationSetting>, I>>(object: I): NotificationSetting {
    const message = createBaseNotificationSetting();
    message.id = object.id ?? "";
    message.notification_setting_type = object.notification_setting_type ?? 0;
    return message;
  },
};

function createBaseNotifiReactMessageEvent(): NotifiReactMessageEvent {
  return { channel_id: "", notifi_react_message: undefined };
}

export const NotifiReactMessageEvent = {
  encode(message: NotifiReactMessageEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel_id !== "") {
      writer.uint32(10).string(message.channel_id);
    }
    if (message.notifi_react_message !== undefined) {
      NotifiReactMessage.encode(message.notifi_react_message, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotifiReactMessageEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifiReactMessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel_id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notifi_react_message = NotifiReactMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifiReactMessageEvent {
    return {
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
      notifi_react_message: isSet(object.notifi_react_message)
        ? NotifiReactMessage.fromJSON(object.notifi_react_message)
        : undefined,
    };
  },

  toJSON(message: NotifiReactMessageEvent): unknown {
    const obj: any = {};
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    if (message.notifi_react_message !== undefined) {
      obj.notifi_react_message = NotifiReactMessage.toJSON(message.notifi_react_message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifiReactMessageEvent>, I>>(base?: I): NotifiReactMessageEvent {
    return NotifiReactMessageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifiReactMessageEvent>, I>>(object: I): NotifiReactMessageEvent {
    const message = createBaseNotifiReactMessageEvent();
    message.channel_id = object.channel_id ?? "";
    message.notifi_react_message = (object.notifi_react_message !== undefined && object.notifi_react_message !== null)
      ? NotifiReactMessage.fromPartial(object.notifi_react_message)
      : undefined;
    return message;
  },
};

function createBaseNotifiReactMessage(): NotifiReactMessage {
  return { id: "", user_id: "", channel_id: "" };
}

export const NotifiReactMessage = {
  encode(message: NotifiReactMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user_id !== "") {
      writer.uint32(18).string(message.user_id);
    }
    if (message.channel_id !== "") {
      writer.uint32(26).string(message.channel_id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NotifiReactMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifiReactMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channel_id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifiReactMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user_id: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      channel_id: isSet(object.channel_id) ? globalThis.String(object.channel_id) : "",
    };
  },

  toJSON(message: NotifiReactMessage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user_id !== "") {
      obj.user_id = message.user_id;
    }
    if (message.channel_id !== "") {
      obj.channel_id = message.channel_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotifiReactMessage>, I>>(base?: I): NotifiReactMessage {
    return NotifiReactMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotifiReactMessage>, I>>(object: I): NotifiReactMessage {
    const message = createBaseNotifiReactMessage();
    message.id = object.id ?? "";
    message.user_id = object.user_id ?? "";
    message.channel_id = object.channel_id ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
