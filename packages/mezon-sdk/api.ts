// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { ApiSession } from 'packages/mezon-js/dist/api.gen';
import { buildFetchOptions } from './utils';
import { encode } from 'js-base64';

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface ApiAuthenticateLogoutRequest {
  //Refresh token to invalidate.
  refresh_token?: string;
  //Session token to log out.
  token?: string;
}

/** Authenticate against the server with a refresh token. */
export interface ApiAuthenticateRefreshRequest {
  //Refresh token.
  refresh_token?: string;
}

/**  */
export interface ApiAuthenticateRequest {
  //Optional custom properties to update with this call. If not set, properties are left as they are on the server.
  custom?: Record<string, string>;
  //Optional default properties to update with this call. If not set, properties are left as they are on the server.
  default?: Record<string, string>;
  //Identity ID. Must be between eight and 128 characters (inclusive). Must be an alphanumeric string with only underscores and hyphens allowed.
  id?: string;
}

/** The request to update the status of a message. */
export interface ApiUpdateMessageRequest {
  //The time the message was consumed by the identity.
  consume_time?: string;
  //The identifier of the messages.
  id?: string;
  //The time the message was read at the client.
  read_time?: string;
}


export class MezonApi {

  constructor(readonly apiKey: string, readonly basePath: string, readonly timeoutMs: number) {}

  /** A healthcheck which load balancers can use to check the service. */
  mezonHealthcheck(bearerToken: string,
      options: any = {}): Promise<any> {
    
    const urlPath = "/healthcheck";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** A readycheck which load balancers can use to check the service. */
  mezonReadycheck(bearerToken: string,
      options: any = {}): Promise<any> {
    
    const urlPath = "/readycheck";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Authenticate against the server. */
  mezonAuthenticate(basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiAuthenticateRequest,
      options: any = {}): Promise<ApiSession> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v1/authenticate";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  mezonAuthenticateLogout(bearerToken: string,
      body:ApiAuthenticateLogoutRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v1/authenticate/logout";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  mezonAuthenticateRefresh(basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiAuthenticateRefreshRequest,
      options: any = {}): Promise<ApiSession> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v1/authenticate/refresh";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Deletes a message for an identity. */
  mezonDeleteMessage(bearerToken: string,
      id:string,
      options: any = {}): Promise<any> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v1/message/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Updates a message for an identity. */
  mezonUpdateMessage(bearerToken: string,
      id:string,
      body:ApiUpdateMessageRequest,
      options: any = {}): Promise<any> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v1/message/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  buildFullUrl(basePath: string, fragment: string, queryParams: Map<string, any>) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
        if (v instanceof Array) {
            fullPath += v.reduce((prev: any, curr: any) => {
            return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
        } else {
            if (v != null) {
                fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
            }
        }
    }

    return fullPath;
  }
};