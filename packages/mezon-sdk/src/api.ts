// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import {
  ApiAuthenticateRequest,
  ApiChannelDescList,
  ApiChannelDescription,
  ApiClanDescList,
  ApiCreateChannelDescRequest,
  ApiQuickMenuAccessList,
  ApiQuickMenuAccessRequest,
  ApiRoleListEventResponse,
  ApiSession,
  ApiVoiceChannelUserList,
  MezonUpdateRoleBody,
} from "./interfaces";
import { buildFetchOptions } from "./utils";
import { encode } from "js-base64";
import { RateLimiter } from "./mezon-client/manager/rate-limit_manager";
import * as tsproto from "./api/api";

const GLOBAL_LIMITER = new RateLimiter(1024);
type ProtoDecoder<T> = (bytes: Uint8Array) => T;
export class MezonApi {
  constructor(
    readonly apiKey: string,
    readonly basePath: string,
    readonly timeoutMs: number,
  ) {}

  private rateLimitFetch(
    fullUrl: string,
    fetchOptions: RequestInit,
  ): Promise<Response> {
    return GLOBAL_LIMITER.schedule(async () => {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), this.timeoutMs);

      try {
        return await fetch(fullUrl, {
          ...fetchOptions,
          signal: controller.signal,
        });
      } catch (e: any) {
        if (e?.name === "AbortError") throw new Error("Request timed out.");
        throw e;
      } finally {
        clearTimeout(t);
      }
    });
  }

  private async handleResponse<T = any>(
    response: Response,
    opts?: {
      decode?: ProtoDecoder<T>;
      emptyAs?: T;
    },
  ): Promise<T> {
    if (response.status === 204) {
      return (opts?.emptyAs ?? ({} as any)) as T;
    }

    const ct = (response.headers.get("content-type") || "").toLowerCase();
    const looksBinary =
      ct.includes("application/x-protobuf") ||
      ct.includes("application/protobuf") ||
      ct.includes("application/octet-stream");

    if (opts?.decode) {
      const buffer = await response.arrayBuffer();
      return opts.decode(new Uint8Array(buffer));
    }

    if (looksBinary) {
      throw new Error(
        `Binary/protobuf response detected (content-type: "${ct}") but no decoder was provided for this endpoint.`,
      );
    }

    return (await response.json()) as T;
  }

  /** Authenticate a app with a token against the server. (JSON) */
  async mezonAuthenticate(
    basicAuthUsername: string,
    basicAuthPassword: string,
    body: ApiAuthenticateRequest,
    options: any = {},
  ): Promise<ApiSession> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }

    const urlPath = "/v2/apps/authenticate/token";
    const queryParams = new Map<string, any>();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions(
      "POST",
      options,
      JSON.stringify(body || {}),
    );

    if (basicAuthUsername) {
      fetchOptions.headers["Authorization"] =
        "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
    }
    fetchOptions.headers["Accept"] = "application/x-protobuf";

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiSession>(res, {
      emptyAs: {} as ApiSession,
      decode: (bytes) =>
        tsproto.Session.decode(bytes) as ApiSession,
    });
  }

  /** Create a new channel with the current user as the owner. */
  async createChannelDesc(
    bearerToken: string,
    body: ApiCreateChannelDescRequest,
    options: any = {},
  ): Promise<ApiChannelDescription> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }

    const urlPath = "/mezon.api.Mezon/CreateChannelDesc";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.CreateChannelDescRequest.encode(
      tsproto.CreateChannelDescRequest.fromPartial(body),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiChannelDescription>(res, {
      emptyAs: {} as ApiChannelDescription,
      decode: (bytes) =>
        tsproto.ChannelDescription.decode(bytes) as ApiChannelDescription,
    });
  }

  /** List clans */
  async listClanDescs(
    bearerToken: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiClanDescList> {
    const urlPath = "/mezon.api.Mezon/ListClanDescs";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.ListClanDescRequest.encode(
      tsproto.ListClanDescRequest.fromPartial({ limit, state, cursor }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiClanDescList>(res, {
      emptyAs: {} as ApiClanDescList,
      decode: (bytes) => tsproto.ClanDescList.decode(bytes) as ApiClanDescList,
    });
  }

  /** List channels detail */
  async listChannelDetail(
    bearerToken: string,
    channelId: string,
    options: any = {},
  ): Promise<ApiChannelDescription> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined.",
      );
    }

    const urlPath = "/mezon.api.Mezon/ListChannelDetail";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.ListChannelDetailRequest.encode(
      tsproto.ListChannelDetailRequest.fromPartial({ channel_id: channelId }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiChannelDescription>(res, {
      emptyAs: {} as ApiChannelDescription,
      decode: (bytes) =>
        tsproto.ChannelDescription.decode(bytes) as ApiChannelDescription,
    });
  }

  buildFullUrl(
    basePath: string,
    fragment: string,
    queryParams: Map<string, any>,
  ) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
      if (v instanceof Array) {
        fullPath += v.reduce((prev: any, curr: any) => {
          return (
            prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&"
          );
        }, "");
      } else {
        if (v != null) {
          fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
        }
      }
    }

    return fullPath;
  }

  /** List user channels */
  async listChannelDescs(
    bearerToken: string,
    channelType?: number,
    clanId?: string,
    limit?: number,
    state?: number,
    cursor?: string,
    isMobile?: boolean,
    options: any = {},
  ): Promise<ApiChannelDescList> {
    const urlPath = "/mezon.api.Mezon/ListChannelDescs";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.ListChannelDescsRequest.encode(
      tsproto.ListChannelDescsRequest.fromPartial({
        limit,
        state,
        cursor,
        clan_id: clanId,
        channel_type: channelType,
        is_mobile: isMobile,
      }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiChannelDescList>(res, {
      emptyAs: {} as ApiChannelDescList,
      decode: (bytes) =>
        tsproto.ChannelDescList.decode(bytes) as ApiChannelDescList,
    });
  }

  /** List all users that are part of a channel. */
  async listChannelVoiceUsers(
    bearerToken: string,
    clanId?: string,
    limit?: number,
    options = {}
  ): Promise<ApiVoiceChannelUserList> {
    const urlPath = "/mezon.api.Mezon/ListChannelVoiceUsers";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.ListChannelUsersRequest.encode(
      tsproto.ListChannelUsersRequest.fromPartial({
        clan_id: clanId,
        limit: limit,
      }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiVoiceChannelUserList>(res, {
      emptyAs: {} as ApiVoiceChannelUserList,
      decode: (bytes) =>
        tsproto.VoiceChannelUserList.decode(bytes) as ApiVoiceChannelUserList,
    });
  }

  /** Update fields in a given role */
  async updateRole(
    bearerToken: string,
    roleId: string,
    body: MezonUpdateRoleBody,
    options: any = {},
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined.",
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }

    const urlPath = "/mezon.api.Mezon/UpdateRole";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.UpdateRoleRequest.encode(
      tsproto.UpdateRoleRequest.fromPartial({ ...body, role_id: roleId }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<any>(res, { emptyAs: {} as any });
  }

  /** ListRoles */
  async listRoles(
    bearerToken: string,
    clanId?: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {},
  ): Promise<ApiRoleListEventResponse> {
    const urlPath = "/mezon.api.Mezon/ListRoles";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.RoleListEventRequest.encode(
      tsproto.RoleListEventRequest.fromPartial({
        clan_id: clanId,
        limit,
        state,
        cursor,
      }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiRoleListEventResponse>(res, {
      emptyAs: {} as ApiRoleListEventResponse,
      decode: (bytes) =>
        tsproto.RoleListEventResponse.decode(bytes) as ApiRoleListEventResponse,
    });
  }

  /** AddQuickMenuAccess */
  async addQuickMenuAccess(
    bearerToken: string,
    body: ApiQuickMenuAccessRequest,
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }

    const urlPath = "/mezon.api.Mezon/AddQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.QuickMenuAccess.encode(
      tsproto.QuickMenuAccess.fromPartial(body),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<any>(res, { emptyAs: {} as any });
  }

  /** DeleteQuickMenuAccess */
  async deleteQuickMenuAccess(
    bearerToken: string,
    id?: string,
    clanId?: string,
    botId?: string,
    menuName?: string,
    background?: string,
    actionMsg?: string,
    options: any = {},
  ): Promise<any> {
    const urlPath = "/mezon.api.Mezon/DeleteQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.QuickMenuAccess.encode(
      tsproto.QuickMenuAccess.fromPartial({
        id,
        clan_id: clanId,
        bot_id: botId,
        menu_name: menuName,
        background,
        action_msg: actionMsg,
      }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<any>(res, { emptyAs: {} as any });
  }

  /** ListQuickMenuAccess */
  async listQuickMenuAccess(
    bearerToken: string,
    botId?: string,
    channelId?: string,
    menuType?: number,
    options: any = {},
  ): Promise<ApiQuickMenuAccessList> {
    const urlPath = "/mezon.api.Mezon/ListQuickMenuAccess";
    const queryParams = new Map<string, any>();

    const encodedBody = tsproto.ListQuickMenuAccessRequest.encode(
      tsproto.ListQuickMenuAccessRequest.fromPartial({
        bot_id: botId,
        channel_id: channelId,
        menu_type: menuType,
      }),
    ).finish();

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, "");
    fetchOptions.body = encodedBody;

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(fullUrl, fetchOptions);
    return this.handleResponse<ApiQuickMenuAccessList>(res, {
      emptyAs: {} as ApiQuickMenuAccessList,
      decode: (bytes) =>
        tsproto.QuickMenuAccessList.decode(bytes) as ApiQuickMenuAccessList,
    });
  }

  async playMedia(
    bearerToken: string,
    body: {
      room_name: string;
      participant_identity: string;
      participant_name: string;
      url: string;
      name: string;
    },
    options: any = {},
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined.",
      );
    }

    const urlPath = "https://stn.mezon.ai/api/playmedia";

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fetchOptions = buildFetchOptions("POST", options, bodyJson);

    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    const res = await this.rateLimitFetch(urlPath, fetchOptions);
    return await this.handleResponse(res);
  }
}
