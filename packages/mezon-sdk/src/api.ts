// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { ApiAuthenticateLogoutRequest, ApiAuthenticateRefreshRequest, ApiAuthenticateRequest, ApiChannelDescription, ApiClanDescList, ApiCreateChannelDescRequest, ApiQuickMenuAccessRequest, ApiRegisterStreamingChannelRequest, ApiSession, ApiUpdateMessageRequest, MezonUpdateRoleBody, TokenSentEvent } from "./interfaces";
import { buildFetchOptions } from './utils';
import { encode } from 'js-base64';
import { RateLimiter } from "./mezon-client/manager/rate-limit_manager"

const GLOBAL_LIMITER = new RateLimiter(1024);
export class MezonApi {

  constructor(readonly apiKey: string, readonly basePath: string, readonly timeoutMs: number) {}

  private rateLimitFetch(fullUrl: string, fetchOptions: RequestInit): Promise<Response> {
    return GLOBAL_LIMITER.schedule(async () => {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), this.timeoutMs);

      try {
        return await fetch(fullUrl, { ...fetchOptions, signal: controller.signal });
      } catch (e: any) {
        if (e?.name === "AbortError") throw new Error("Request timed out.");
        throw e;
      } finally {
        clearTimeout(t);
      }
    });
  }

  private async handleResponse<T = any>(response: Response): Promise<T> {
    if (response.status === 204) {
      return response as unknown as T;
    }

    if (response.status >= 200 && response.status < 300) {
      return response.json() as Promise<T>;
    }
    throw response;
  }

  /** A healthcheck which load balancers can use to check the service. */
  mezonHealthcheck(bearerToken: string,
      options: any = {}): Promise<any> {
    
    const urlPath = "/healthcheck";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** A readycheck which load balancers can use to check the service. */
  mezonReadycheck(bearerToken: string,
      options: any = {}): Promise<any> {
    
    const urlPath = "/readycheck";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** Authenticate a app with a token against the server. */
  mezonAuthenticate(basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiAuthenticateRequest,
      options: any = {}): Promise<ApiSession> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/authenticate/token";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse<ApiSession>(res)
    );
  }

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  mezonAuthenticateLogout(bearerToken: string,
      body:ApiAuthenticateLogoutRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/authenticate/logout";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

    /** Create a new channel with the current user as the owner. */
    createChannelDesc(bearerToken: string,
      body:ApiCreateChannelDescRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }
    
    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
}

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  mezonAuthenticateRefresh(basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiAuthenticateRefreshRequest,
      options: any = {}): Promise<ApiSession> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/authenticate/refresh";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** Deletes a message for an identity. */
  mezonDeleteMessage(bearerToken: string,
      id:string,
      options: any = {}): Promise<any> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/message/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** Updates a message for an identity. */
  mezonUpdateMessage(bearerToken: string,
      id:string,
      body:ApiUpdateMessageRequest,
      options: any = {}): Promise<any> {
    
    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/apps/message/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** List clans */
  listClanDescs(bearerToken: string,
    limit?:number,
    state?:number,
    cursor?:string,
    options: any = {}): Promise<ApiClanDescList> {
  
    const urlPath = "/v2/clandesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** List channels detail */
  listChannelDetail(
    bearerToken: string,
    channelId: string,
    options: any = {}
  ): Promise<ApiChannelDescription> {
    if (channelId === null || channelId === undefined) {
      throw new Error(
        "'channelId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/channeldesc/{channelId}".replace(
      "{channelId}",
      encodeURIComponent(String(channelId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  buildFullUrl(basePath: string, fragment: string, queryParams: Map<string, any>) {
    let fullPath = basePath + fragment + "?";

    for (let [k, v] of queryParams) {
        if (v instanceof Array) {
            fullPath += v.reduce((prev: any, curr: any) => {
            return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
        } else {
            if (v != null) {
                fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
            }
        }
    }

    return fullPath;
  }

  /** List channels */
  listChannelDescs(
    bearerToken: string,
    channel_type: number,
    clan_id?: string,
    limit?: number,
    state?: number,
    cursor?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/channeldesc";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);
    queryParams.set("channel_type", channel_type);
    if (clan_id) {
      queryParams.set("clan_id", clan_id);
    }

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

    /** List all users that are part of a channel. */
  listChannelVoiceUsers(
      bearerToken: string,
      clanId?: string,
      channelId?: string,
      channelType?: number,
      limit?: number,
      state?: number,
      cursor?: string,
      options: any = {}
    ): Promise<any> {
      const urlPath = "/v2/channelvoice";
      const queryParams = new Map<string, any>();
      queryParams.set("clan_id", clanId);
      queryParams.set("channel_id", channelId);
      queryParams.set("channel_type", channelType);
      queryParams.set("limit", limit);
      queryParams.set("state", state);
      queryParams.set("cursor", cursor);
  
      let bodyJson: string = "";
  
      const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
      const fetchOptions = buildFetchOptions("GET", options, bodyJson);
      if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
  
      return Promise.race([
        fetch(fullUrl, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
    }

  /** Register streaming in channel ( for bot - get streaming key) */
  registerStreamingChannel(bearerToken: string,
      body:ApiRegisterStreamingChannelRequest,
      options: any = {}): Promise<any> {
    
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/streaming-channels";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  async sendToken(
    bearerToken: string,
    body: TokenSentEvent,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/sendtoken";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  updateRole(
    bearerToken: string,
    roleId: string,
    body: MezonUpdateRoleBody,
    options: any = {}
  ): Promise<any> {
    if (roleId === null || roleId === undefined) {
      throw new Error(
        "'roleId' is a required parameter but is null or undefined."
      );
    }
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/roles/{roleId}".replace(
      "{roleId}",
      encodeURIComponent(String(roleId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  listRoles(
    bearerToken: string,
    clanId?: string,
    limit?: string,
    state?: string,
    cursor?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/roles";
    const queryParams = new Map<string, any>();
    queryParams.set("clan_id", clanId);
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  getListFriends(
    bearerToken: string,
    limit = 1000,
    state?: string,
    cursor?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  requestFriend(
    bearerToken: string,
    usernames: string,
    ids?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("usernames", usernames);
    if (ids) {
      queryParams.set("ids", ids);
    }

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** list transaction detail */
  listTransactionDetail(
    bearerToken: string,
    transId: string,
    options: any = {}
  ): Promise<any> {
    if (transId === null || transId === undefined) {
      throw new Error(
        "'transId' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/transaction/{transId}".replace(
      "{transId}",
      encodeURIComponent(String(transId))
    );
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /**  */
  addQuickMenuAccess(
    bearerToken: string,
    body: ApiQuickMenuAccessRequest,
    options: any = {}
  ): Promise<any> {
    if (body === null || body === undefined) {
      throw new Error(
        "'body' is a required parameter but is null or undefined."
      );
    }
    const urlPath = "/v2/quickmenuaccess";
    const queryParams = new Map<string, any>();

    let bodyJson: string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  /** deleteQuickMenuAccess */
  deleteQuickMenuAccess(
    bearerToken: string,
    botId?: string,
    options: any = {}
  ): Promise<any> {
    const urlPath = "/v2/quickmenuaccess";
    const queryParams = new Map<string, any>();

    queryParams.set("bot_id", botId);

    let bodyJson: string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return this.rateLimitFetch(fullUrl, fetchOptions).then((res) =>
      this.handleResponse(res)
    );
  }

  playMedia(
      bearerToken: string,
      body: {
        room_name: string;
        participant_identity: string;
        participant_name: string;
        url: string;
        name: string;
      },
      options: any = {}
    ): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error(
          "'body' is a required parameter but is null or undefined."
        );
      }

      const urlPath = "https://stn.mezon.ai/api/playmedia";

      let bodyJson: string = "";
      bodyJson = JSON.stringify(body || {});

      const fetchOptions = buildFetchOptions("POST", options, bodyJson);

      if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
      }
      return Promise.race([
        fetch(urlPath, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, this.timeoutMs, "Request timed out.")
        ),
      ]);
  }
  
}
